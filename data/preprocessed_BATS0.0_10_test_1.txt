[{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix a bug in MathUtils . equals ( double  double  int ). ", "B_clean_title": ["fix", "bug", "mathutil", "math", "util", "equal", "doubl", "doubl", "int"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix MathUtils . equals ( double  double  int ). ", "B_clean_title": ["fix", "mathutil", "math", "util", "equal", "doubl", "doubl", "int"]},
{"A_title": "Inconsistent interpretation of ambiguous time during DSTThe inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now it always returns the earlier instant (summer time) during an overlap.", "A_clean_title": ["inconsist", "interpret", "ambigu", "time", "dure", "dstthe", "dst", "inconsist", "appear", "timezon", "europ", "london", "these", "three", "datetim", "date", "time", "object", "all", "repres", "same", "moment", "time", "even", "they", "are", "ambigu", "now", "it", "alway", "return", "earlier", "instant", "summer", "time", "dure", "overlap"], "B_title": "fixed typo .. ", "B_clean_title": ["fix", "typo"]},
{"A_title": "Inconsistent interpretation of ambiguous time during DSTThe inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now it always returns the earlier instant (summer time) during an overlap.", "A_clean_title": ["inconsist", "interpret", "ambigu", "time", "dure", "dstthe", "dst", "inconsist", "appear", "timezon", "europ", "london", "these", "three", "datetim", "date", "time", "object", "all", "repres", "same", "moment", "time", "even", "they", "are", "ambigu", "now", "it", "alway", "return", "earlier", "instant", "summer", "time", "dure", "overlap"], "B_title": "Added transition marker. ", "B_clean_title": ["ad", "transit", "marker"]},
{"A_title": "Inconsistent interpretation of ambiguous time during DSTThe inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now it always returns the earlier instant (summer time) during an overlap.", "A_clean_title": ["inconsist", "interpret", "ambigu", "time", "dure", "dstthe", "dst", "inconsist", "appear", "timezon", "europ", "london", "these", "three", "datetim", "date", "time", "object", "all", "repres", "same", "moment", "time", "even", "they", "are", "ambigu", "now", "it", "alway", "return", "earlier", "instant", "summer", "time", "dure", "overlap"], "B_title": "fixed typo .. ", "B_clean_title": ["fix", "typo"]},
{"A_title": "addDays(0) changes value of MutableDateTimeUpon DST transition from summer to winter time zone adding the amount of zero days to a mutable date time object changes the value of the object. The methods addMonths and addYears show the same problem; addSeconds addMinutes and addHours are ok.  I have tested with version 2.3. However if I repeat the test with Joda 1.5.2 the invocation of addDays(0) does not change the dates value.", "A_clean_title": ["addday", "add", "day", "chang", "valu", "mutabledatetimeupon", "mutabl", "date", "time", "upon", "dst", "transit", "summer", "winter", "time", "zone", "ad", "amount", "zero", "day", "mutabl", "date", "time", "object", "chang", "valu", "object", "method", "addmonth", "add", "month", "addyear", "add", "year", "show", "same", "problem", "addsecond", "add", "second", "addminut", "add", "minut", "addhour", "add", "hour", "are", "ok", "have", "test", "version", "howev", "repeat", "test", "joda", "invoc", "addday", "add", "day", "not", "chang", "date", "valu"], "B_title": "Adding zero no longer changes the offset during DST overlap", "B_clean_title": ["ad", "zero", "no", "longer", "chang", "offset", "dure", "dst", "overlap"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Removed deprecated methods.", "B_clean_title": ["remov", "deprec", "method"]},
{"A_title": "FastMath.cosh sinh do not support the same range of values as the Math counterpartsAs reported by Jeff Hain: cosh(double) and sinh(double): Math.cosh(709.783) = 8.991046692770538E307 FastMath.cosh(709.783) = Infinity Math.sinh(709.783) = 8.991046692770538E307 FastMath.sinh(709.783) = Infinity ===> This is due to using exp( x )/2 for values of |x| above 20: the result sometimes should not overflow but exp( x ) does so we end up with some infinity. ===> for values of |x| >= StrictMath.log(Double.MAX_VALUE) exp will overflow so you need to use that instead: for x positive: double t = exp(x*0.5); return (0.5*t)*t; for x negative: double t = exp(-x*0.5); return (-0.5*t)*t;", "A_clean_title": ["fastmath", "cosh", "fast", "math", "sinh", "not", "support", "same", "rang", "valu", "as", "math", "counterpartsa", "counterpart", "as", "report", "by", "jeff", "hain", "cosh", "doubl", "sinh", "doubl", "math", "cosh", "709", "783", "991046692770538e307", "fastmath", "cosh", "fast", "math", "709", "783", "infin", "math", "sinh", "709", "783", "991046692770538e307", "fastmath", "sinh", "fast", "math", "709", "783", "infin", "thi", "due", "exp", "valu", "|x|", "abov", "20", "result", "sometim", "not", "overflow", "but", "exp", "so", "we", "end", "up", "some", "infin", "valu", "|x|", "strictmath", "log", "strict", "math", "doubl", "max", "valu", "exp", "will", "overflow", "so", "you", "need", "use", "that", "instead", "posit", "doubl", "exp", "return", "neg", "doubl", "exp", "return"], "B_title": "Avoid overflow on the whole range covered by the equivalent functions in the standard Math class.", "B_clean_title": ["avoid", "overflow", "whole", "rang", "cover", "by", "equival", "function", "standard", "math", "class"]},
{"A_title": "Errors creating/parsing dates with specific time zones.The results are out of 572 time zones 130 fail and 30 throw exceptions.  The failures are the most interesting. When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka. When I take that id and create a date time with it its time zone id is America/Adak. It is like there are multiple list of time zones in Joda time and they are out of sync.", "A_clean_title": ["error", "creat", "pars", "date", "specif", "time", "zone", "result", "are", "out", "572", "time", "zone", "130", "fail", "30", "throw", "except", "failur", "are", "most", "interest", "when", "queri", "datetimezon", "date", "time", "zone", "get", "it", "time", "zone", "id", "will", "get", "time", "zone", "like", "america", "atka", "when", "take", "that", "id", "creat", "date", "time", "it", "it", "time", "zone", "id", "america", "adak", "it", "like", "there", "are", "multipl", "list", "time", "zone", "joda", "time", "they", "are", "out", "sync"], "B_title": "Fix zone id parsing for ids like America/Dawson_Creek 3427389", "B_clean_title": ["fix", "zone", "id", "pars", "id", "like", "creek", "america", "dawson", "3427389"]},
{"A_title": "Fraction.comparTo returns 0 for some differente fractionsIf two different fractions evaluate to the same double due to limited precision the compareTo methode returns 0 as if they were identical.  // value is roughly PI - 3.07e-18 Fraction pi1 = new Fraction(1068966896 340262731);  // value is roughly PI + 1.936e-17 Fraction pi2 = new Fraction( 411557987 131002976);  System.out.println(pi1.doubleValue() - pi2.doubleValue()); // exactly 0.0 due to limited IEEE754 precision System.out.println(pi1.compareTo(pi2)); // display 0 instead of a negative value", "A_clean_title": ["fraction", "comparto", "compar", "return", "some", "different", "fractionsif", "fraction", "two", "differ", "fraction", "evalu", "same", "doubl", "due", "limit", "precis", "compareto", "compar", "method", "return", "as", "they", "were", "ident", "valu", "roughli", "pi", "18", "07e", "fraction", "pi1", "new", "fraction", "1068966896", "340262731", "valu", "roughli", "pi", "17", "936e", "fraction", "pi2", "new", "fraction", "411557987", "131002976", "system", "out", "println", "pi1", "doublevalu", "doubl", "valu", "pi2", "doublevalu", "doubl", "valu", "exactli", "due", "limit", "ieee754", "precis", "system", "out", "println", "pi1", "compareto", "compar", "pi2", "display", "instead", "neg", "valu"], "B_title": "Fixed a comparison error when two different fractions evaluate to the same double due to limited precision. Jira: MATH-252", "B_clean_title": ["fix", "comparison", "error", "when", "two", "differ", "fraction", "evalu", "same", "doubl", "due", "limit", "precis", "jira", "math", "252"]},
{"A_title": "class Dfp toDouble method return -inf whan Dfp value is 0 zeroI found a bug in the toDouble() method of the Dfp class. If the Dfps value is 0 zero the toDouble() method returns a  negative infini. This is because the double value returned has an exposant equal to 0xFFF  and a significand is equal to 0. In the IEEE754 this is a -inf. To be equal to zero the exposant and the significand must be equal to zero. A simple test case is : ---------------------------------------------- import org.apache.commons.math.dfp.DfpField; public class test  /**  @param args  */ public static void main(String args)   DfpField field = new DfpField(100); System.out.println(toDouble value of getZero() =+field.getZero().toDouble()+ ntoDouble value of newDfp(0.0) =+ field.newDfp(0.0).toDouble());    May be the simplest way to fix it is to test the zero equality at the begin of the toDouble() method to be able to return the correctly signed zero ?", "A_clean_title": ["class", "dfp", "todoubl", "doubl", "method", "return", "inf", "whan", "dfp", "valu", "zeroi", "zero", "found", "bug", "todoubl", "doubl", "method", "dfp", "class", "dfp", "valu", "zero", "todoubl", "doubl", "method", "return", "neg", "infini", "thi", "becaus", "doubl", "valu", "return", "ha", "expos", "equal", "0xfff", "0x", "fff", "significand", "equal", "ieee754", "thi", "inf", "equal", "zero", "expos", "significand", "must", "equal", "zero", "simpl", "test", "case", "import", "org", "apach", "common", "math", "dfp", "dfpfield", "dfp", "field", "public", "class", "test", "param", "arg", "public", "static", "void", "main", "string", "arg", "dfpfield", "dfp", "field", "field", "new", "dfpfield", "dfp", "field", "100", "system", "out", "println", "todoubl", "doubl", "valu", "getzero", "get", "zero", "=+field", "getzero", "get", "zero", "todoubl", "doubl", "ntodoubl", "nto", "doubl", "valu", "newdfp", "new", "dfp", "field", "newdfp", "new", "dfp", "todoubl", "doubl", "may", "simplest", "way", "fix", "it", "test", "zero", "equal", "at", "begin", "todoubl", "doubl", "method", "abl", "return", "correctli", "sign", "zero"], "B_title": "Fixed conversion problems to/from 0 in Decimal Floating Point (Dfp) class.", "B_clean_title": ["fix", "convers", "problem", "decim", "float", "point", "dfp", "class"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fixed creation of generic array.", "B_clean_title": ["fix", "creation", "gener", "array"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here"], "B_title": "Complex division by zero:  z / 0 = INF if z is not ZERO  0 / 0 = NaN", "B_clean_title": ["complex", "divis", "by", "zero", "inf", "not", "zero", "nan", "na"]},
{"A_title": "Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environmentsThe thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapps use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.", "A_clean_title": ["use", "threadloc", "thread", "local", "tostringstyl", "string", "style", "hashcodebuild", "hash", "code", "builder", "trigger", "memori", "leak", "contain", "environmentsth", "environ", "thread", "local", "org", "apach", "common", "lang3", "builder", "tostringstyl", "string", "style", "creat", "but", "never", "remov", "no", "api", "provid", "remov", "it", "webapp", "use", "lang", "trigger", "load", "thi", "class", "refer", "chain", "will", "creat", "that", "will", "caus", "memori", "leak", "web", "applic", "reload", "see", "http", "markmail", "org", "thread", "uetw2fdrsqgbh2cv", "more", "info"], "B_title": "Clear ThreadLocal for HashCodeBuilder as well", "B_clean_title": ["clear", "threadloc", "thread", "local", "hashcodebuild", "hash", "code", "builder", "as", "well"]}]