[{"A_title": "StringEscapeUtils.escapeJava(String) escapes / charactersCommons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes / characters which is not a valid escapable character in Java strings.  I havent tried the other Java escape/unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off in that / should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase      public void testEscapeJavaWithSlash()           final String input = String with a slash (/) in it;                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes / characters          * which are not a valid character to escape in a Java string.            */         assertEquals( expected actual );      ", "A_clean_title": ["stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "characterscommon", "charact", "common", "lang", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "now", "escap", "charact", "which", "not", "valid", "escap", "charact", "java", "string", "havent", "tri", "other", "java", "escap", "unescap", "method", "see", "they", "have", "similar", "problem", "or", "that", "onli", "java", "escap", "charact", "are", "escap", "by", "escapejava", "escap", "java", "string", "thi", "bug", "may", "have", "appear", "as", "unintend", "side", "effect", "fix", "lang", "363", "also", "javadoc", "escapejava", "escap", "java", "now", "littl", "off", "that", "now", "includ", "sentenc", "describ", "differ", "between", "java", "javascript", "string", "respect", "escap", "rule", "follow", "junit3", "unit3", "test", "demonstr", "bug", "import", "junit", "framework", "testcas", "test", "case", "import", "org", "apach", "common", "lang", "stringescapeutil", "string", "escap", "util", "public", "class", "stringescapeutilstest", "string", "escap", "util", "test", "extend", "testcas", "test", "case", "public", "void", "testescapejavawithslash", "test", "escap", "java", "slash", "final", "string", "input", "string", "slash", "it", "final", "string", "expect", "input", "final", "string", "actual", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "input", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "charact", "which", "are", "not", "valid", "charact", "escap", "java", "string", "assertequ", "assert", "equal", "expect", "actual"], "B_title": "don  t escape single quote when escaping backslash. ", "B_clean_title": ["don", "escap", "singl", "quot", "when", "escap", "backslash"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle isDigits ( string ) with patch 1 - Lang - 58 - Hercules . fixed. ", "B_clean_title": ["handl", "isdigit", "digit", "string", "patch", "lang", "58", "hercul", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix parse error. ", "B_clean_title": ["fix", "pars", "error"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "try StringUtils . isDigit. I had left it harwired to null .. ", "B_clean_title": ["tri", "stringutil", "string", "util", "isdigit", "digit", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix regex processing. I had left it harwired to null .. ", "B_clean_title": ["fix", "regex", "process", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "don  t throw NumberFormatException if decPos < decPos. I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["don", "throw", "numberformatexcept", "number", "format", "except", "decpo", "dec", "po", "decpo", "dec", "po", "had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. start with - -. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "start"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a missing patch. I had left it harwired to null .. don  t check isEmpty ( str )  because it seems we  re trying to understand why. ", "B_clean_title": ["add", "miss", "patch", "had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "becaus", "it", "seem", "we", "re", "tri", "understand", "whi"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t check isEmpty ( str ) in StringUtils. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "remove exp = null ; fix for patched code. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["remov", "exp", "null", "fix", "patch", "code", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. Add an error if the string is blank .. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["allow", "null", "string", "input", "add", "error", "string", "blank", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add the missing throw exception. I had left it harwired to null .. ", "B_clean_title": ["add", "miss", "throw", "except", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove exp = null in numberUtils. I had left it harwired to null .. ", "B_clean_title": ["remov", "exp", "null", "numberutil", "number", "util", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix NPE. don  t check isEmpty ( str ) in StringUtils. ", "B_clean_title": ["fix", "npe", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. isEmpty ( str ) fixed NHY - 1342  fixed NHY - 1342. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "isempti", "empti", "str", "fix", "nhi", "1342", "fix", "nhi", "1342"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fixed String . isBlank ( ). Add a patch for formatting numbers in Avro settings. I had left it harwired to null .. ", "B_clean_title": ["fix", "string", "isblank", "blank", "add", "patch", "format", "number", "avro", "set", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fix a numeric type request. I had left it harwired to null .. ", "B_clean_title": ["fix", "numer", "type", "request", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. I had left it harwired to null .. ", "B_clean_title": ["allow", "null", "string", "input", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. remove fix. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "remov", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. I had left it harwired to null .. ", "B_clean_title": ["allow", "null", "string", "input", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t check isEmpty ( str ) in StringUtils. Add an error if a blank string is not a valid number. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util", "add", "error", "blank", "string", "not", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused method. I had left it harwired to null .. ", "B_clean_title": ["remov", "old", "unus", "method", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow string to be parsed as a literal int. I had left it harwired to null .. ", "B_clean_title": ["allow", "string", "pars", "as", "liter", "int", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. add null check. add isDigit to StringUtils. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "null", "check", "add", "isdigit", "digit", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fixed String . isBlank ( ). I had left it harwired to null .. ", "B_clean_title": ["fix", "string", "isblank", "blank", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Allow null to be passed. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "allow", "null", "pass"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. add null check. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "null", "check"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. ", "B_clean_title": ["had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an error if the string is blank .. I had left it harwired to null .. ", "B_clean_title": ["add", "error", "string", "blank", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Add string isEmpty ( ) to isAllZeros ( ). ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "string", "isempti", "empti", "isallzero", "all", "zero"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an exception if the string is null. I had left it harwired to null .. ", "B_clean_title": ["add", "except", "string", "null", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "add patch for isDigit. I had left it harwired to null .. ", "B_clean_title": ["add", "patch", "isdigit", "digit", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a missing patch. I had left it harwired to null .. Add a throw statement so that it can be cleaned up by the patcher .. ", "B_clean_title": ["add", "miss", "patch", "had", "left", "it", "harwir", "null", "add", "throw", "statement", "so", "that", "it", "clean", "up", "by", "patcher"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. isDigits method patched. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "isdigit", "digit", "method", "patch"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused method. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["remov", "old", "unus", "method", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an error if the string is blank .. don  t throw NPE at end of definition file. I had left it harwired to null .. ", "B_clean_title": ["add", "error", "string", "blank", "don", "throw", "npe", "at", "end", "definit", "file", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t throw NumberFormatException on isBlank ( string ). ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "throw", "numberformatexcept", "number", "format", "except", "isblank", "blank", "string"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a throw if it is not a valid number. I had left it harwired to null .. ", "B_clean_title": ["add", "throw", "it", "not", "valid", "number", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused patch. Allow null to be passed in for numberUtils . createBigInteger ( ). start with - -. ", "B_clean_title": ["remov", "old", "unus", "patch", "allow", "null", "pass", "numberutil", "number", "util", "createbiginteg", "creat", "big", "integ", "start"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. @ patch_1228 for StringUtils . isDigit. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "patch", "1228", "stringutil", "string", "util", "isdigit", "digit"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix 143 potential value error. fixed NHYD fixed. I had left it harwired to null .. ", "B_clean_title": ["fix", "143", "potenti", "valu", "error", "fix", "nhyd", "fix", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fix null string handling. I had left it harwired to null .. ", "B_clean_title": ["fix", "null", "string", "handl", "had", "left", "it", "harwir", "null"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor result. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "result"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix false alarm in JKali patch. ", "B_clean_title": ["fix", "fals", "alarm", "jkali", "kali", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix a bug in JMutRepair where abs ( u ) > v. ", "B_clean_title": ["fix", "bug", "jmutrepair", "mut", "repair", "where", "ab"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix # 1796. remove patch for 1 . 7 . 0 - > 1 . 7 . 0. ", "B_clean_title": ["fix", "1796", "remov", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor patch. Fix string comparison in Fraction . equals ( ). ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "patch", "fix", "string", "comparison", "fraction", "equal"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "remove patch for 1 . 6. Fix string comparison between 0 . 1 and 1 . 2. ", "B_clean_title": ["remov", "patch", "fix", "string", "comparison", "between"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "fix a numeric equality bug in Fraction. remove patch for 1 . 6. ", "B_clean_title": ["fix", "numer", "equal", "bug", "fraction", "remov", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "remove 582  as it is not applicable. fixed a small bug. ", "B_clean_title": ["remov", "582", "as", "it", "not", "applic", "fix", "small", "bug"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction patch. Fix string comparison in Fraction . equals ( ). ", "B_clean_title": ["fix", "fraction", "patch", "fix", "string", "comparison", "fraction", "equal"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Add missing toProperString. Fix accidental conversion of inf to int. ", "B_clean_title": ["add", "miss", "toproperstr", "proper", "string", "fix", "accident", "convers", "inf", "int"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder copy ( ) . ", "B_clean_title": ["strbuilder", "str", "builder", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "add missing backslash. ", "B_clean_title": ["add", "miss", "backslash"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity .. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( size + 1 ) for appendFixedWidthPadRight. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "size", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) now uses char  as the indexing array is. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "now", "use", "char", "as", "index", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses char instead of char because it is not compatible. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "instead", "char", "becaus", "it", "not", "compat"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t create arrayCopy ( ) .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "creat", "arraycopi", "array", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( changed ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "chang"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build .. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add empty buffer for appendFixedWidthPadRight. ", "B_clean_title": ["add", "empti", "buffer", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix an issue with the appendFixedWidthPadRight method where the object is null .. ", "B_clean_title": ["fix", "issu", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "method", "where", "object", "null"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added expanded array structure. ", "B_clean_title": ["ad", "expand", "array", "structur"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should reset the StringBuilder and not use the array when creating the string. ", "B_clean_title": ["strbuilder", "str", "builder", "reset", "stringbuild", "string", "builder", "not", "use", "array", "when", "creat", "string"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Reset nullText if we have text .. ", "B_clean_title": ["reset", "nulltext", "null", "text", "we", "have", "text"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix an issue with null string builders .. ", "B_clean_title": ["fix", "issu", "null", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix nullText setting .. ", "B_clean_title": ["fix", "nulltext", "null", "text", "set"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses char  instead of char   for the append of. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "instead", "char", "append"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Reset line endings. ", "B_clean_title": ["reset", "line", "end"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix NPE in StrBuilder . appendFixedWidthPadRight. ", "B_clean_title": ["fix", "npe", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add empty array if we can  t append string with spaces .. ", "B_clean_title": ["add", "empti", "array", "we", "append", "string", "space"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add null check in StrBuilder. ", "B_clean_title": ["add", "null", "check", "strbuilder", "str", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set the nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses buffer . length - > string . length. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "buffer", "length", "string", "length"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set the nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix buffer issue. ", "B_clean_title": ["fix", "buffer", "issu"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix ensureCapacity ( ) for string builders. ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity .. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t overwrite existing buffer .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "overwrit", "exist", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( initially empty ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "initi", "empti"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses stringBuilder  but string is not expanding the buffer ;. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "stringbuild", "string", "builder", "but", "string", "not", "expand", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( initially empty ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "initi", "empti"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more space for string builders. ", "B_clean_title": ["add", "more", "space", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should reset the array if we add null text  otherwise it will throw an NPE. ", "B_clean_title": ["strbuilder", "str", "builder", "reset", "array", "we", "add", "null", "text", "otherwis", "it", "will", "throw", "npe"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use the newLine setting for each builder object. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "newlin", "new", "line", "set", "each", "builder", "object"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add null string if possible. ", "B_clean_title": ["add", "null", "string", "possibl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix lost ensureCapacity .. ", "B_clean_title": ["fix", "lost", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the bug in StrBuilder . appendFixedWidthPadRight. ", "B_clean_title": ["fix", "bug", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Added a test to see if the dataset is not sufficiently large and not too large .. ", "B_clean_title": ["ad", "test", "see", "dataset", "not", "suffici", "larg", "not", "too", "larg"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Add missing column to drop from tableau if it is too large. ", "B_clean_title": ["add", "miss", "column", "drop", "tableau", "it", "too", "larg"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a bug in MultiDirectional .. ", "B_clean_title": ["fix", "bug", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "removed incorrect patch. ", "B_clean_title": ["remov", "incorrect", "patch"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Add a return statement so the contract can be used .. ", "B_clean_title": ["add", "return", "statement", "so", "contract", "use"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "added a missing if / else. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "Missing in previous patch. ", "B_clean_title": ["miss", "previou", "patch"]}]