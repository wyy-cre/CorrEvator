[{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Set nullText before deleting characters. remove startIndex. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "set", "nulltext", "null", "text", "befor", "delet", "charact", "remov", "startindex", "start", "index", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Fix NPE triggered by nullText .. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "fix", "npe", "trigger", "by", "nulltext", "null", "text", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Fix StrBuilder . length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "fix", "strbuilder", "str", "builder", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. remove startIndex. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "remov", "startindex", "start", "index", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Fix buffer handling. ", "B_clean_title": ["add", "miss", "append", "patch", "fix", "buffer", "handl"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "set nullText to null on delete ( ). Add missing append ( ) patch. Fix buffer handling. ", "B_clean_title": ["set", "nulltext", "null", "text", "null", "delet", "add", "miss", "append", "patch", "fix", "buffer", "handl"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. set nullText if it is not null. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "set", "nulltext", "null", "text", "it", "not", "null", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . deleteFirst ( ) now uses char  instead of char   .. StrBuilder . length - strLen = size ; patched. ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "deletefirst", "delet", "first", "now", "use", "char", "instead", "char", "strbuilder", "str", "builder", "length", "strlen", "str", "len", "size", "patch"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . deleteFirst ( ) uses buffer . length - > string . length ( ). StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "deletefirst", "delet", "first", "use", "buffer", "length", "string", "length", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Add more ensureCapacity .. StrBuilder . length - strLen = size ; patched. ", "B_clean_title": ["add", "miss", "append", "patch", "add", "more", "ensurecapac", "ensur", "capac", "strbuilder", "str", "builder", "length", "strlen", "str", "len", "size", "patch"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . length - strLen = size ; patched. ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "length", "strlen", "str", "len", "size", "patch"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Fix StrBuilder . length ( ). ", "B_clean_title": ["fix", "strbuilder", "str", "builder", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Set nullText before deleting characters. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "set", "nulltext", "null", "text", "befor", "delet", "charact", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "Brent solver returns the wrong value if either bracket endpoint is rootThe solve(final UnivariateRealFunction f final double min final double max final double initial) function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max.", "A_clean_title": ["brent", "solver", "return", "wrong", "valu", "either", "bracket", "endpoint", "rootth", "root", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "function", "return", "ymin", "min", "or", "ymax", "max", "min", "or", "max", "are", "deem", "root", "respect", "instead", "min", "or", "max"], "B_title": "Fix the bit between the two functions. ", "B_clean_title": ["fix", "bit", "between", "two", "function"]},
{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "Added missing throw in patch192. added missing throwing check. ", "B_clean_title": ["ad", "miss", "throw", "patch192", "ad", "miss", "throw", "check"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Added test to check for same point vector. ", "B_clean_title": ["ad", "test", "check", "same", "point", "vector"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "added test for point equals and otherPoint. ", "B_clean_title": ["ad", "test", "point", "equal", "otherpoint", "other", "point"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Fix typo in KMeansPlusPlusClusterer . java. ", "B_clean_title": ["fix", "typo", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "java"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "fixed bug in point comparison. ", "B_clean_title": ["fix", "bug", "point", "comparison"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Fix NPE in Line . intersection ( ). ", "B_clean_title": ["fix", "npe", "line", "intersect"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix CMAESOptimizer  s min max value .. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "min", "max", "valu"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "cmAESOptimizer now uses the max iterations. ", "B_clean_title": ["cmaesoptim", "cm", "ae", "optim", "now", "use", "max", "iter"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix CategoryPlot  s renderers. Fix bug. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "bug", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend  s location .. ", "B_clean_title": ["remov", "null", "check", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "legend", "locat"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "remov", "redund", "code", "fix", "issu", "domain", "axi", "not", "be", "chang", "by", "end", "categor", "axe", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Extend CategoryPlot to remove listener from the existing renderer. Fix issue with the axes configuration for the year century .. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "extend", "categoryplot", "categori", "plot", "remov", "listen", "exist", "render", "fix", "issu", "axe", "configur", "year", "centuri", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Remove fireChangeEvent ( ) from CategoryPlot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "remov", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove redundant code. Fix # 183. Fix issues with the categs spines plot. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "183", "fix", "issu", "categ", "spine", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Remove null check in place. ", "B_clean_title": ["remov", "redund", "code", "remov", "redund", "call", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "definit", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with the axes function not being re - added. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "axe", "function", "not", "be", "re", "ad", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix issue with defects4J_Chart_1 .. Remove some trailing whitespace. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "issu", "defects4j", "chart", "remov", "some", "trail", "whitespac"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix issue with domain axis selection. Remove null check. ", "B_clean_title": ["remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix # 1862. Fix bug. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "1862", "fix", "bug", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1336. Fix # 1862. Fix category axis. Fix category axes. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1336", "fix", "1862", "fix", "categori", "axi", "fix", "categori", "axe", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix a problem with the axes. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "problem", "axe", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with the legend  s X axis .. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "legend", "axi", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix a potential NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "potenti", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Added fix for NPE in CategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "ad", "fix", "npe", "categoryitemrender", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Fix bug. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1349", "fix", "bug", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix fireChangeEvent. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "firechangeev", "fire", "chang", "event", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix # 183. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "183", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix label positionning. ", "B_clean_title": ["remov", "redund", "code", "fix", "label", "posit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix issue with the legend  s X axis .. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "issu", "legend", "axi", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a potential NPE in CategoryPlot. Fix NPE in CategoryPlot. Fix category axes. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "potenti", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "fix", "categori", "axe", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Fix PR # 1674. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "pr", "1674", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Remove null check. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "local", "variabl", "warn", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axis location .. Fix NPE in chart 1. ", "B_clean_title": ["fix", "categori", "axi", "locat", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1349", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix change in CategoryPlot. Add urlText to category items renderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "chang", "categoryplot", "categori", "plot", "add", "urltext", "url", "text", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix bug. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "1862", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 183. Fix issue with defects4J_Chart_1 .. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "183", "fix", "issu", "defects4j", "chart", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix null label in CategoryPlot. Require index < 0 .. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "fix", "null", "label", "categoryplot", "categori", "plot", "requir", "index", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix issue with first plot using patch. Remove null check in place. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "issu", "first", "plot", "patch", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix CategoryPlot  s renderers. Fix issue with data set selection. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "issu", "data", "set", "select", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix fireChangeEvent. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove null check. ", "B_clean_title": ["remov", "redund", "code", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Added patch for domain axis generation. Fix category gridline position .. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "ad", "patch", "domain", "axi", "gener", "fix", "categori", "gridlin", "posit", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with chart 1 .. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "chart", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix local testing. Remove spurious return value. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "local", "test", "remov", "spuriou", "return", "valu"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix category axes. Fix # 1718. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "categori", "axe", "fix", "1718", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. remove 1677 from range axes. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "1677", "rang", "axe", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Added datasetChanged ( ) method to CategoryPlot. Remove redundant code. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "method", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix issue with  GenProg_Defects4J_Chart_1 . Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "redund", "code", "fix", "issu", "genprog", "defects4j", "chart", "gen", "prog", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "added datasetChanged ( ) to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant line. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "line", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "definit", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Added datasetChanged ( ) method to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "method", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove some trailing whitespace. ", "B_clean_title": ["remov", "redund", "code", "remov", "some", "trail", "whitespac"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with  CategoryPlot  axis. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "issu", "categoryplot", "categori", "plot", "axi", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with wrong param. Remove some trailing whitespace. ", "B_clean_title": ["fix", "issu", "wrong", "param", "remov", "some", "trail", "whitespac"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Fix build. Remove redundant code. Fix bug. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "fix", "build", "remov", "redund", "code", "fix", "bug", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix fireChangeEvent. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. remove 1677 from category plot. Remove some redundant lines. ", "B_clean_title": ["fix", "1862", "remov", "1677", "categori", "plot", "remov", "some", "redund", "line"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Fix local variable warning. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "local", "variabl", "warn", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 183. Fix category plot not listening to the existing renderer. Fix category axis fire. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "183", "fix", "categori", "plot", "not", "listen", "exist", "render", "fix", "categori", "axi", "fire", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with  add domain axis  method. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "add", "domain", "axi", "method", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not used .. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "some", "line", "that", "were", "not", "use"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix pull request. Fix newline. Fix NPE in chart 1. ", "B_clean_title": ["fix", "pull", "request", "fix", "newlin", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with CategoryPlot . setDataset ( int  CategoryDataset ). Fix NPE in chart 1. ", "B_clean_title": ["fix", "issu", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "int", "categorydataset", "categori", "dataset", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1336. Fix # 1862. Fix CategoryPlot  s renderer. Fix bug. Fix issue with wrong dataset index. ", "B_clean_title": ["fix", "1336", "fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "bug", "fix", "issu", "wrong", "dataset", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix issue with chart 1 .. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "issu", "chart", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Remove redundant code. Fix NPE in CategoryPlot. Fix category chart demo .. ", "B_clean_title": ["fix", "1349", "remov", "redund", "code", "fix", "npe", "categoryplot", "categori", "plot", "fix", "categori", "chart", "demo"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Fix # 1862. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "1862", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. remove 1674 from category plot. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "remov", "1674", "categori", "plot", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with the axes configuration for today  s CategoryPlot. Remove unused variable. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "axe", "configur", "today", "categoryplot", "categori", "plot", "remov", "unus", "variabl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "local", "variabl", "warn", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove 1679 from CategoryPlot. Fix label positionning. ", "B_clean_title": ["remov", "redund", "code", "remov", "1679", "categoryplot", "categori", "plot", "fix", "label", "posit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a potential NPE in CategoryPlot. Fix # 1862. Fix bug. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "potenti", "npe", "categoryplot", "categori", "plot", "fix", "1862", "fix", "bug", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix # 183. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "183", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "1862", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "throw exception if index is negative. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["throw", "except", "index", "neg", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix 1349. Fix legend generation. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1349", "fix", "legend", "gener", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix bug. Remove urlText = null in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "bug", "remov", "urltext", "url", "text", "null", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove unused variable .. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "unus", "variabl", "fix", "issu", "domain", "axi", "select", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Added throw exception if index < 0. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "ad", "throw", "except", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). ", "B_clean_title": ["remov", "null", "check", "place", "fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1796. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1796"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix chart otp .. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "chart", "otp", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. @@ 1355 removed redundant call. ", "B_clean_title": ["remov", "null", "check", "place", "1355", "remov", "redund", "call"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix pull request. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix minor axes disappearing on histogram select. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "minor", "axe", "disappear", "histogram", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix CategoryPlot not clearing the foreground domain marker map when it is not null .. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "categoryplot", "categori", "plot", "not", "clear", "foreground", "domain", "marker", "map", "when", "it", "not", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Remove null check in place. ", "B_clean_title": ["fix", "1349", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Removed redundant code. ", "B_clean_title": ["remov", "null", "check", "place", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with wrong data set range axis mapping. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "wrong", "data", "set", "rang", "axi", "map"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. Fix Eclipse. ", "B_clean_title": ["fix", "npe", "fix", "eclips"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix pull request. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. Fix NPE in CategoryPlot. ", "B_clean_title": ["fix", "npe", "fix", "npe", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Throw an exception if orientation is null. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "throw", "except", "orient", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix category datasets. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "categori", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove null check in place. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix category plot background for phones. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "categori", "plot", "background", "phone"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Add category dataset patch. ", "B_clean_title": ["remov", "null", "check", "place", "add", "categori", "dataset", "patch"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with chart 1. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix issue with wrong fireChangeEvent. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "issu", "wrong", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data renderer NPE. Fix range zero baseline paint. ", "B_clean_title": ["fix", "categori", "data", "render", "npe", "fix", "rang", "zero", "baselin", "paint"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with new category plot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "new", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix range zero baseline paint. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "rang", "zero", "baselin", "paint"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. remove deprecated call to fireChangeEvent ( ). ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "remov", "deprec", "call", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with chart 1. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix crosshair dataset index. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "crosshair", "dataset", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with wrong fireChangeEvent. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "wrong", "firechangeev", "fire", "chang", "event"]}]