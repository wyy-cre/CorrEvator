[{"A_title": "Fraction percentageValue rare overflowThe percentageValue() method of the Fraction class works by first multiplying the Fraction by 100 then converting the Fraction to a double. This causes overflows when the numerator is greater than Integer.MAX_VALUE/100 even when the value of the fraction is far below this value. The patch changes the method to first convert to a double value and then multiply this value by 100 - the result should be the same but with less overflows. An addition to the test for the method that covers this bug is also included.", "A_clean_title": ["fraction", "percentagevalu", "percentag", "valu", "rare", "overflowth", "overflow", "percentagevalu", "percentag", "valu", "method", "fraction", "class", "work", "by", "first", "multipli", "fraction", "by", "100", "then", "convert", "fraction", "doubl", "thi", "caus", "overflow", "when", "numer", "greater", "than", "integ", "max", "valu", "100", "even", "when", "valu", "fraction", "far", "below", "thi", "valu", "patch", "chang", "method", "first", "convert", "doubl", "valu", "then", "multipli", "thi", "valu", "by", "100", "result", "same", "but", "less", "overflow", "addit", "test", "method", "that", "cover", "thi", "bug", "also", "includ"], "B_title": "Added Fraction copy of Fraction . percentageValue ( ). ", "B_clean_title": ["ad", "fraction", "copi", "fraction", "percentagevalu", "percentag", "valu"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix NumberFormatException. ", "B_clean_title": ["fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);     ", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Fix getOwnPct return type. ", "B_clean_title": ["fix", "getownpct", "get", "own", "pct", "return", "type"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);     ", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Add missing import .. Fix getFrequency ( Object ) to return 1  not 2. ", "B_clean_title": ["add", "miss", "import", "fix", "getfrequ", "get", "frequenc", "object", "return", "not"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor in Fraction copy. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "fraction", "copi"]},
{"A_title": "HarmonicFitter.ParameterGuesser sometimes fails to return sensible valuesThe inner class ParameterGuesser in HarmonicFitter (package o.a.c.m.optimization.fitting) fails to compute a usable guess for the amplitude parameter.", "A_clean_title": ["harmonicfitt", "parameterguess", "harmon", "fitter", "paramet", "guesser", "sometim", "fail", "return", "sensibl", "valuesth", "valu", "inner", "class", "parameterguess", "paramet", "guesser", "harmonicfitt", "harmon", "fitter", "packag", "optim", "fit", "fail", "comput", "usabl", "guess", "amplitud", "paramet"], "B_title": "Add a throw if the pair of arguments are not compatible with 1 . 0 .. ", "B_clean_title": ["add", "throw", "pair", "argument", "are", "not", "compat"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Using the copy of SimplexTableau  it is better for testing. ", "B_clean_title": ["copi", "simplextableau", "simplex", "tableau", "it", "better", "test"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Updated patch1 - Math - 33 - Hercules . fixed. ", "B_clean_title": ["updat", "patch1", "math", "33", "hercul", "fix"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Fix missing import. reduce maxUlps to epsilon. ", "B_clean_title": ["fix", "miss", "import", "reduc", "maxulp", "max", "ulp", "epsilon"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "Using the best function to reduce the total number of tests for a fixed situation .. Fix the patch. ", "B_clean_title": ["best", "function", "reduc", "total", "number", "test", "fix", "situat", "fix", "patch"]},
{"A_title": "Fraction percentageValue rare overflowThe percentageValue() method of the Fraction class works by first multiplying the Fraction by 100 then converting the Fraction to a double. This causes overflows when the numerator is greater than Integer.MAX_VALUE/100 even when the value of the fraction is far below this value. The patch changes the method to first convert to a double value and then multiply this value by 100 - the result should be the same but with less overflows. An addition to the test for the method that covers this bug is also included.", "A_clean_title": ["fraction", "percentagevalu", "percentag", "valu", "rare", "overflowth", "overflow", "percentagevalu", "percentag", "valu", "method", "fraction", "class", "work", "by", "first", "multipli", "fraction", "by", "100", "then", "convert", "fraction", "doubl", "thi", "caus", "overflow", "when", "numer", "greater", "than", "integ", "max", "valu", "100", "even", "when", "valu", "fraction", "far", "below", "thi", "valu", "patch", "chang", "method", "first", "convert", "doubl", "valu", "then", "multipli", "thi", "valu", "by", "100", "result", "same", "but", "less", "overflow", "addit", "test", "method", "that", "cover", "thi", "bug", "also", "includ"], "B_title": "Avoid overflow.", "B_clean_title": ["avoid", "overflow"]},
{"A_title": "HarmonicFitter.ParameterGuesser sometimes fails to return sensible valuesThe inner class ParameterGuesser in HarmonicFitter (package o.a.c.m.optimization.fitting) fails to compute a usable guess for the amplitude parameter.", "A_clean_title": ["harmonicfitt", "parameterguess", "harmon", "fitter", "paramet", "guesser", "sometim", "fail", "return", "sensibl", "valuesth", "valu", "inner", "class", "parameterguess", "paramet", "guesser", "harmonicfitt", "harmon", "fitter", "packag", "optim", "fit", "fail", "comput", "usabl", "guess", "amplitud", "paramet"], "B_title": "Generate an exception when the parameter guessing procedure cannot perform correctly (in rare ill-conditioned cases).", "B_clean_title": ["gener", "except", "when", "paramet", "guess", "procedur", "not", "perform", "correctli", "rare", "ill", "condit", "case"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "use epsilon criteria when deciding to drop columns after phase 1.", "B_clean_title": ["use", "epsilon", "criteria", "when", "decid", "drop", "column", "after", "phase"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "The best point is sometimes not the last one evaluated.", "B_clean_title": ["best", "point", "sometim", "not", "last", "one", "evalu"]}]