[{"A_title": "ODE integrator goes past specified end of integration rangeEnd of integration range in ODE solving is handled as an event. In some cases numerical accuracy in events detection leads to error in events location. The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range.    public void testMissedEvent() throws IntegratorException DerivativeException            final double t0 = 1878250320.0000029;           final double t =  1878250379.9999986;           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations()                           public int getDimension()                  return 1;                                       public void computeDerivatives(double t double y double yDot)                 throws DerivativeException                  yDot0 = y0 * 1.0e-6;                      ;          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0 100.0                                                                                1.0e-10 1.0e-10);          double y =  1.0 ;         integrator.setInitialStepSize(60.0);         double finalT = integrator.integrate(ode t0 y t y);         Assert.assertEquals(t finalT 1.0e-6);     ", "A_clean_title": ["ode", "integr", "goe", "past", "specifi", "end", "integr", "rangeend", "rang", "end", "integr", "rang", "ode", "solv", "handl", "as", "event", "some", "case", "numer", "accuraci", "event", "detect", "lead", "error", "event", "locat", "follow", "test", "case", "show", "end", "event", "not", "handl", "properli", "integr", "that", "cover", "60", "rang", "fact", "cover", "160", "rang", "more", "than", "twice", "specifi", "rang", "public", "void", "testmissedev", "test", "miss", "event", "throw", "integratorexcept", "integr", "except", "derivativeexcept", "deriv", "except", "final", "doubl", "t0", "1878250320", "0000029", "final", "doubl", "1878250379", "9999986", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "ode", "new", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "public", "int", "getdimens", "get", "dimens", "return", "public", "void", "computederiv", "comput", "deriv", "doubl", "doubl", "doubl", "ydot", "dot", "throw", "derivativeexcept", "deriv", "except", "ydot0", "dot0", "y0", "0e", "dormandprince853integr", "dormand", "prince853integr", "integr", "new", "dormandprince853integr", "dormand", "prince853integr", "100", "10", "0e", "10", "0e", "doubl", "integr", "setinitialsteps", "set", "initi", "step", "size", "60", "doubl", "finalt", "final", "integr", "integr", "ode", "t0", "assert", "assertequ", "assert", "equal", "finalt", "final", "0e"], "B_title": "Fix mixed line ending condition. improve var. Fix g0Positive = false where the end of a line was not triggering the g0 value. ", "B_clean_title": ["fix", "mix", "line", "end", "condit", "improv", "var", "fix", "g0posit", "fals", "where", "end", "line", "wa", "not", "trigger", "g0", "valu"]},
{"A_title": "ODE integrator goes past specified end of integration rangeEnd of integration range in ODE solving is handled as an event. In some cases numerical accuracy in events detection leads to error in events location. The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range.    public void testMissedEvent() throws IntegratorException DerivativeException            final double t0 = 1878250320.0000029;           final double t =  1878250379.9999986;           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations()                           public int getDimension()                  return 1;                                       public void computeDerivatives(double t double y double yDot)                 throws DerivativeException                  yDot0 = y0 * 1.0e-6;                      ;          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0 100.0                                                                                1.0e-10 1.0e-10);          double y =  1.0 ;         integrator.setInitialStepSize(60.0);         double finalT = integrator.integrate(ode t0 y t y);         Assert.assertEquals(t finalT 1.0e-6);     ", "A_clean_title": ["ode", "integr", "goe", "past", "specifi", "end", "integr", "rangeend", "rang", "end", "integr", "rang", "ode", "solv", "handl", "as", "event", "some", "case", "numer", "accuraci", "event", "detect", "lead", "error", "event", "locat", "follow", "test", "case", "show", "end", "event", "not", "handl", "properli", "integr", "that", "cover", "60", "rang", "fact", "cover", "160", "rang", "more", "than", "twice", "specifi", "rang", "public", "void", "testmissedev", "test", "miss", "event", "throw", "integratorexcept", "integr", "except", "derivativeexcept", "deriv", "except", "final", "doubl", "t0", "1878250320", "0000029", "final", "doubl", "1878250379", "9999986", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "ode", "new", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "public", "int", "getdimens", "get", "dimens", "return", "public", "void", "computederiv", "comput", "deriv", "doubl", "doubl", "doubl", "ydot", "dot", "throw", "derivativeexcept", "deriv", "except", "ydot0", "dot0", "y0", "0e", "dormandprince853integr", "dormand", "prince853integr", "integr", "new", "dormandprince853integr", "dormand", "prince853integr", "100", "10", "0e", "10", "0e", "doubl", "integr", "setinitialsteps", "set", "initi", "step", "size", "60", "doubl", "finalt", "final", "integr", "integr", "ode", "t0", "assert", "assertequ", "assert", "equal", "finalt", "final", "0e"], "B_title": "Add pendingEvent to var1 line. Re - initialize interpolatedTime. ", "B_clean_title": ["add", "pendingev", "pend", "event", "var1", "line", "re", "initi", "interpolatedtim", "interpol", "time"]},
{"A_title": "ODE integrator goes past specified end of integration rangeEnd of integration range in ODE solving is handled as an event. In some cases numerical accuracy in events detection leads to error in events location. The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range.    public void testMissedEvent() throws IntegratorException DerivativeException            final double t0 = 1878250320.0000029;           final double t =  1878250379.9999986;           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations()                           public int getDimension()                  return 1;                                       public void computeDerivatives(double t double y double yDot)                 throws DerivativeException                  yDot0 = y0 * 1.0e-6;                      ;          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0 100.0                                                                                1.0e-10 1.0e-10);          double y =  1.0 ;         integrator.setInitialStepSize(60.0);         double finalT = integrator.integrate(ode t0 y t y);         Assert.assertEquals(t finalT 1.0e-6);     ", "A_clean_title": ["ode", "integr", "goe", "past", "specifi", "end", "integr", "rangeend", "rang", "end", "integr", "rang", "ode", "solv", "handl", "as", "event", "some", "case", "numer", "accuraci", "event", "detect", "lead", "error", "event", "locat", "follow", "test", "case", "show", "end", "event", "not", "handl", "properli", "integr", "that", "cover", "60", "rang", "fact", "cover", "160", "rang", "more", "than", "twice", "specifi", "rang", "public", "void", "testmissedev", "test", "miss", "event", "throw", "integratorexcept", "integr", "except", "derivativeexcept", "deriv", "except", "final", "doubl", "t0", "1878250320", "0000029", "final", "doubl", "1878250379", "9999986", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "ode", "new", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "public", "int", "getdimens", "get", "dimens", "return", "public", "void", "computederiv", "comput", "deriv", "doubl", "doubl", "doubl", "ydot", "dot", "throw", "derivativeexcept", "deriv", "except", "ydot0", "dot0", "y0", "0e", "dormandprince853integr", "dormand", "prince853integr", "integr", "new", "dormandprince853integr", "dormand", "prince853integr", "100", "10", "0e", "10", "0e", "doubl", "integr", "setinitialsteps", "set", "initi", "step", "size", "60", "doubl", "finalt", "final", "integr", "integr", "ode", "t0", "assert", "assertequ", "assert", "equal", "finalt", "final", "0e"], "B_title": "Revert  fix pending event . Fix g ( t  y ). ", "B_clean_title": ["revert", "fix", "pend", "event", "fix"]},
{"A_title": "ODE integrator goes past specified end of integration rangeEnd of integration range in ODE solving is handled as an event. In some cases numerical accuracy in events detection leads to error in events location. The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range.    public void testMissedEvent() throws IntegratorException DerivativeException            final double t0 = 1878250320.0000029;           final double t =  1878250379.9999986;           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations()                           public int getDimension()                  return 1;                                       public void computeDerivatives(double t double y double yDot)                 throws DerivativeException                  yDot0 = y0 * 1.0e-6;                      ;          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0 100.0                                                                                1.0e-10 1.0e-10);          double y =  1.0 ;         integrator.setInitialStepSize(60.0);         double finalT = integrator.integrate(ode t0 y t y);         Assert.assertEquals(t finalT 1.0e-6);     ", "A_clean_title": ["ode", "integr", "goe", "past", "specifi", "end", "integr", "rangeend", "rang", "end", "integr", "rang", "ode", "solv", "handl", "as", "event", "some", "case", "numer", "accuraci", "event", "detect", "lead", "error", "event", "locat", "follow", "test", "case", "show", "end", "event", "not", "handl", "properli", "integr", "that", "cover", "60", "rang", "fact", "cover", "160", "rang", "more", "than", "twice", "specifi", "rang", "public", "void", "testmissedev", "test", "miss", "event", "throw", "integratorexcept", "integr", "except", "derivativeexcept", "deriv", "except", "final", "doubl", "t0", "1878250320", "0000029", "final", "doubl", "1878250379", "9999986", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "ode", "new", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "public", "int", "getdimens", "get", "dimens", "return", "public", "void", "computederiv", "comput", "deriv", "doubl", "doubl", "doubl", "ydot", "dot", "throw", "derivativeexcept", "deriv", "except", "ydot0", "dot0", "y0", "0e", "dormandprince853integr", "dormand", "prince853integr", "integr", "new", "dormandprince853integr", "dormand", "prince853integr", "100", "10", "0e", "10", "0e", "doubl", "integr", "setinitialsteps", "set", "initi", "step", "size", "60", "doubl", "finalt", "final", "integr", "integr", "ode", "t0", "assert", "assertequ", "assert", "equal", "finalt", "final", "0e"], "B_title": "improve var. put back previous derivative state into interpolatedState. ", "B_clean_title": ["improv", "var", "put", "back", "previou", "deriv", "state", "into", "interpolatedst", "interpol", "state"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the format definition for the next // line. Fix format description not found in message striper. ", "B_clean_title": ["fix", "format", "definit", "next", "line", "fix", "format", "descript", "not", "found", "messag", "striper"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix compile error. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "compil", "error", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "missing return statement. Fix an issue with the pattern  s pattern after it has been read .. ", "B_clean_title": ["miss", "return", "statement", "fix", "issu", "pattern", "pattern", "after", "it", "ha", "been", "read"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "missing patch. Fix the format definition of  QUOTE . ", "B_clean_title": ["miss", "patch", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "fix lost ParsePosition. ", "B_clean_title": ["fix", "lost", "parseposit", "pars", "posit"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "don  t apply message format twice. Fix the format definition of  QUOTE . ", "B_clean_title": ["don", "appli", "messag", "format", "twice", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix NPE for @ ArjaDefects4J_Lang_43. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "npe", "arjadefects4j", "lang", "43", "arja", "defects4j", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix mails. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "mail", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix NPE. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "npe", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the format definition for the next // line. ", "B_clean_title": ["fix", "format", "definit", "next", "line"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the format definition so that it doesn  t become an error in the code. Fix the over - aggressive loop. ", "B_clean_title": ["fix", "format", "definit", "so", "that", "it", "doesn", "becom", "error", "code", "fix", "over", "aggress", "loop"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the format definition of  QUOTE . Reset the registry object as well. ", "B_clean_title": ["fix", "format", "definit", "quot", "reset", "registri", "object", "as", "well"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "don  t apply message format twice. Fix the format definition for the next // line. ", "B_clean_title": ["don", "appli", "messag", "format", "twice", "fix", "format", "definit", "next", "line"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "fix lost toPattern ; changed to match superclass. ", "B_clean_title": ["fix", "lost", "topattern", "pattern", "chang", "match", "superclass"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix # 141. don  t apply the pattern if it wasn  t defined in the superclass .. ", "B_clean_title": ["fix", "141", "don", "appli", "pattern", "it", "wasn", "defin", "superclass"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix an issue with missing backslash. ", "B_clean_title": ["fix", "issu", "miss", "backslash"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "fix missing patch. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "miss", "patch", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix registry field. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "registri", "field", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "setting registry. Fix the format definition of  QUOTE . ", "B_clean_title": ["set", "registri", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix cruise ( this . registry = registry ). Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "cruis", "thi", "registri", "registri", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the pattern for the second time. ", "B_clean_title": ["fix", "pattern", "second", "time"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Reset the index of the message format definition so it parses. ", "B_clean_title": ["reset", "index", "messag", "format", "definit", "so", "it", "pars"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix NPE for @ ArjaDefects4J_Lang_43. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "npe", "arjadefects4j", "lang", "43", "arja", "defects4j", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "missing patch. Fix the format definition for the next // line. ", "B_clean_title": ["miss", "patch", "fix", "format", "definit", "next", "line"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix NPE. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "npe", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "don  t apply message formats if registry is null. Fix the format definition of  QUOTE . ", "B_clean_title": ["don", "appli", "messag", "format", "registri", "null", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "don  t apply message formats if registry is null. Fix the format definition of  QUOTE . Fix the bug. ", "B_clean_title": ["don", "appli", "messag", "format", "registri", "null", "fix", "format", "definit", "quot", "fix", "bug"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix NPE. Fix the format definition of  QUOTE . ", "B_clean_title": ["fix", "npe", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "fix lost ParsePosition. Fix the bug. ", "B_clean_title": ["fix", "lost", "parseposit", "pars", "posit", "fix", "bug"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Remove unused call to toPattern if registry is null. Fix the format definition of  QUOTE . ", "B_clean_title": ["remov", "unus", "call", "topattern", "pattern", "registri", "null", "fix", "format", "definit", "quot"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the format definition for the next // line. validate format count after patch. ", "B_clean_title": ["fix", "format", "definit", "next", "line", "valid", "format", "count", "after", "patch"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "don  t apply the pattern if it wasn  t defined in the superclass .. ", "B_clean_title": ["don", "appli", "pattern", "it", "wasn", "defin", "superclass"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix the format definition for the next // line. Fix message format change. ", "B_clean_title": ["fix", "format", "definit", "next", "line", "fix", "messag", "format", "chang"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from patch. Add a throw if it is not a blank string. ", "B_clean_title": ["get", "fix", "patch", "add", "throw", "it", "not", "blank", "string"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null to be passed in number utils. get fix from pull request. ", "B_clean_title": ["allow", "null", "pass", "number", "util", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add the patch for the exponentiation of certain characters. get fix from pull request. ", "B_clean_title": ["add", "patch", "exponenti", "certain", "charact", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add missing patch. get fix from pull request. ", "B_clean_title": ["add", "miss", "patch", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from patch. remove exp. ", "B_clean_title": ["get", "fix", "patch", "remov", "exp"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix NPE in Arja_Defects4J_Lang_16. revert patch. get fix from patch. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "16", "revert", "patch", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fixed a small bug. get fix from patch. ", "B_clean_title": ["fix", "small", "bug", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add an exception if the string is null. get fix from pull request. ", "B_clean_title": ["add", "except", "string", "null", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null string input. get fix from patch. ", "B_clean_title": ["allow", "null", "string", "input", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix NPE in number utils .. get fix from pull request. ", "B_clean_title": ["fix", "npe", "number", "util", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from patch. Fix exp parsing in Arja_Defects4J_Lang_16. ", "B_clean_title": ["get", "fix", "patch", "fix", "exp", "pars", "arja", "defects4j", "lang", "16"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fix null string handling. get fix from pull request. remove exp. ", "B_clean_title": ["fix", "null", "string", "handl", "get", "fix", "pull", "request", "remov", "exp"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add missing patch. fixed syntax error in ArjaDefects4J_Lang_16. get fix from patch. ", "B_clean_title": ["add", "miss", "patch", "fix", "syntax", "error", "arjadefects4j", "lang", "16", "arja", "defects4j", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix a 13e032 error in Arja  s NumberUtils. fixed a typo in the code. ", "B_clean_title": ["fix", "13e032", "error", "arja", "numberutil", "number", "util", "fix", "typo", "code"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from patch. ", "B_clean_title": ["get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "try string cast. get fix from patch. ", "B_clean_title": ["tri", "string", "cast", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null string input. get fix from patch. ", "B_clean_title": ["allow", "null", "string", "input", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix a NumberFormatException if the string length is not > = expPos. get fix from pull request. ", "B_clean_title": ["fix", "numberformatexcept", "number", "format", "except", "string", "length", "not", "exppo", "exp", "po", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fix null string handling. Fix a minor issue with NumberUtils . createFloat ( str ). get fix from pull request. ", "B_clean_title": ["fix", "null", "string", "handl", "fix", "minor", "issu", "numberutil", "number", "util", "createfloat", "creat", "float", "str", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fixed NPE in Arja_Defects4J_Lang_16. Fix typo in data .. get fix from pull request. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "16", "fix", "typo", "data", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix NumberFormatException. get fix from pull request. ", "B_clean_title": ["fix", "numberformatexcept", "number", "format", "except", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null string input. fixed a bug in NumberUtils. get fix from patch. ", "B_clean_title": ["allow", "null", "string", "input", "fix", "bug", "numberutil", "number", "util", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "removed patch for numberUtils. get fix from pull request. ", "B_clean_title": ["remov", "patch", "numberutil", "number", "util", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Remove patch from last commit. Fix a bug in NumberUtils. get fix from pull request. ", "B_clean_title": ["remov", "patch", "last", "commit", "fix", "bug", "numberutil", "number", "util", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix NPE in Arja_Defects4J_Lang_16. get fix from pull request. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "16", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from pull request. try Integer . decode ( str ) instead of String . create ( str ). ", "B_clean_title": ["get", "fix", "pull", "request", "tri", "integ", "decod", "str", "instead", "string", "creat", "str"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "throw exception if str is null. get fix from pull request. Fix StringUtils . isNaN ( str ). ", "B_clean_title": ["throw", "except", "str", "null", "get", "fix", "pull", "request", "fix", "stringutil", "string", "util", "isnan", "na", "str"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix NPE in Arja_Defects4J_Lang_16. get fix from patch. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "16", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "A blank string is not a valid number. Revert  remove  from  fix. get fix from pull request. ", "B_clean_title": ["blank", "string", "not", "valid", "number", "revert", "remov", "fix", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "throw exception if str is null. get fix from pull request. add patch for eequality. ", "B_clean_title": ["throw", "except", "str", "null", "get", "fix", "pull", "request", "add", "patch", "eequal"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from patch. Handle null string input from NumberUtils. ", "B_clean_title": ["get", "fix", "patch", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "throw exception if str is null. get fix from pull request. ", "B_clean_title": ["throw", "except", "str", "null", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null string input. fixed a bug in the code style. get fix from patch. ", "B_clean_title": ["allow", "null", "string", "input", "fix", "bug", "code", "style", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add null check. get fix from pull request. ", "B_clean_title": ["add", "null", "check", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "throw exception if str is null. get fix from patch. ", "B_clean_title": ["throw", "except", "str", "null", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add number exception patch. get fix from pull request. Add a throw if it is not a blank string. ", "B_clean_title": ["add", "number", "except", "patch", "get", "fix", "pull", "request", "add", "throw", "it", "not", "blank", "string"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null to be parsed as a number. Fix potential NPE in NumberUtils. get fix from patch. ", "B_clean_title": ["allow", "null", "pars", "as", "number", "fix", "potenti", "npe", "numberutil", "number", "util", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null string input. Revert  fix merge conflict . get fix from pull request. ", "B_clean_title": ["allow", "null", "string", "input", "revert", "fix", "merg", "conflict", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "A blank string is not a valid number. get fix from pull request. ", "B_clean_title": ["blank", "string", "not", "valid", "number", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Revert  remove  from  fix. Fix accidentely removed patch for string literals. get fix from pull request. ", "B_clean_title": ["revert", "remov", "fix", "fix", "accident", "remov", "patch", "string", "liter", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fixed NPE in Arja_Defects4J_Lang_16. get fix from pull request. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "16", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "A blank string is not a valid number. don  t check isEmpty ( ) in NumberUtils. get fix from patch. remove exp. ", "B_clean_title": ["blank", "string", "not", "valid", "number", "don", "check", "isempti", "empti", "numberutil", "number", "util", "get", "fix", "patch", "remov", "exp"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add number exception patch. get fix from pull request. Fix NPE in NumberUtils. ", "B_clean_title": ["add", "number", "except", "patch", "get", "fix", "pull", "request", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fixed a bug in NumberUtils. get fix from pull request. Fix StringUtils . isNaN ( str ) .. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "get", "fix", "pull", "request", "fix", "stringutil", "string", "util", "isnan", "na", "str"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix this. get fix from patch. ", "B_clean_title": ["fix", "thi", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add the patch for number utils. Fix a minor issue with NumberUtils . createFloat ( str ). get fix from patch. ", "B_clean_title": ["add", "patch", "number", "util", "fix", "minor", "issu", "numberutil", "number", "util", "createfloat", "creat", "float", "str", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from pull request. don  t ignore numbers with spaces. ", "B_clean_title": ["get", "fix", "pull", "request", "don", "ignor", "number", "space"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "adding patch for  ---- . get fix from patch. don  t ignore signs in - - fixes NPE. ", "B_clean_title": ["ad", "patch", "get", "fix", "patch", "don", "ignor", "sign", "fix", "npe"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fixed a bug in NumberUtils. Fix potential NPE in NumberUtils. get fix from pull request. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "fix", "potenti", "npe", "numberutil", "number", "util", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Revert  update to latest compatibility . get fix from pull request. ", "B_clean_title": ["revert", "updat", "latest", "compat", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "get fix from pull request. remove null check in ArjaDefects4J_Lang_16. ", "B_clean_title": ["get", "fix", "pull", "request", "remov", "null", "check", "arjadefects4j", "lang", "16", "arja", "defects4j"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix typo in reference manual. get fix from patch. ", "B_clean_title": ["fix", "typo", "refer", "manual", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Allow null string input. get fix from patch. ", "B_clean_title": ["allow", "null", "string", "input", "get", "fix", "patch"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Remove unused patch. get fix from pull request. ", "B_clean_title": ["remov", "unus", "patch", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix null pointer check in ArjaDefects4J_Lang_16. get fix from pull request. ", "B_clean_title": ["fix", "null", "pointer", "check", "arjadefects4j", "lang", "16", "arja", "defects4j", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix 1474 patch for number utils. get fix from pull request. Handle null string input from NumberUtils. ", "B_clean_title": ["fix", "1474", "patch", "number", "util", "get", "fix", "pull", "request", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Add number exception patch. get fix from pull request. ", "B_clean_title": ["add", "number", "except", "patch", "get", "fix", "pull", "request"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "fixed NPE in Arja_Defects4J_Lang_16. fixed a bug in NumberUtils. get fix from patch. Add a throw if it is not a blank string. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "16", "fix", "bug", "numberutil", "number", "util", "get", "fix", "patch", "add", "throw", "it", "not", "blank", "string"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "Fix a bug in NumberUtils. get fix from pull request. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "get", "fix", "pull", "request"]}]