[{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fixed incorrect patch HD. ", "B_clean_title": ["fix", "incorrect", "patch", "hd"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix NPE in UniformRealDistribution . density ( double ). Updated reference to patched code. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "npe", "uniformrealdistribut", "uniform", "real", "distribut", "densiti", "doubl", "updat", "refer", "patch", "code"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_412 .. updated FDistribution . log ( ). updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "412", "updat", "fdistribut", "distribut", "log", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated guidance for real distributions. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "guidanc", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch .. Updated reference to patch 1389 in UniformRealDistribution. Throw an exception if denominatorDegreesOfFreedom < 0. fixed FDistribution . getSupportLowerBound. ", "B_clean_title": ["ad", "miss", "patch", "updat", "refer", "patch", "1389", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "fix", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. updated FDistribution with patch 1 . 5. Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patch_959 .. ", "B_clean_title": ["ad", "miss", "patch", "updat", "fdistribut", "distribut", "patch", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "959"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patched code. Fix FDistribution . exp ( x < 0 ). updated FDistribution with patched lower bound. ", "B_clean_title": ["updat", "refer", "patch", "code", "fix", "fdistribut", "distribut", "exp", "updat", "fdistribut", "distribut", "patch", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_984 .. Fix FDistribution . density ( double ). updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "984", "fix", "fdistribut", "distribut", "densiti", "doubl", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix a bug in UniformRealDistribution. Updated reference to patch w015. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "refer", "patch", "w015"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patched code. Remove a redundant line. updated FDistribution with better error handling. ", "B_clean_title": ["updat", "refer", "patch", "code", "remov", "redund", "line", "updat", "fdistribut", "distribut", "better", "error", "handl"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "fixed EMC. updated FDistribution with patched upper bounds. Updated reference to patched code. ", "B_clean_title": ["fix", "emc", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "refer", "patch", "code"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. updated FDistribution with patched upper bounds. Updated reference to patch 1306 .. ", "B_clean_title": ["ad", "miss", "patch", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "refer", "patch", "1306"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. updated FDistribution with patched upper bounds. Fix a bug in UniformRealDistribution where the first argument is not greater than the second .. Updated reference to patch w015. ", "B_clean_title": ["ad", "miss", "patch", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "where", "first", "argument", "not", "greater", "than", "second", "updat", "refer", "patch", "w015"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added a throw if the denominatorDegreesOfFreedom was not greater than the numeratorDegreesOf. updated FDistribution with patch 1255. Updated reference to patched code. ", "B_clean_title": ["ad", "throw", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than", "numeratordegreesof", "numer", "degre", "updat", "fdistribut", "distribut", "patch", "1255", "updat", "refer", "patch", "code"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_525 .. Updated FDistribution . getSupportLowerBound ( ). fixed FDistribution . isSupportLowerBoundInclusive ( ). ", "B_clean_title": ["updat", "refer", "patch", "525", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Add missing patch. Updated reference to patch_631 .. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "add", "miss", "patch", "updat", "refer", "patch", "631"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix a bug in UniformRealDistribution. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_934 .. Throw an exception if denominatorDegreesOfFreedom < 0. updated FDistribution with patched lower bound. ", "B_clean_title": ["updat", "refer", "patch", "934", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "updat", "fdistribut", "distribut", "patch", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Throw an exception if denominatorDegreesOfFreedom < 0. updated FDistribution with patch_961. Fix a bug in UniformRealDistribution. ", "B_clean_title": ["throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "updat", "fdistribut", "distribut", "patch", "961", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch 1436 .. Add support lowerBound to FDistribution . density ( ). updated FDistribution with patch 1436. ", "B_clean_title": ["updat", "refer", "patch", "1436", "add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "densiti", "updat", "fdistribut", "distribut", "patch", "1436"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch in UniformRealDistribution. Throw an exception if denominatorDegreesOfFreedom < 0. updated FDistribution with patched lower bound. Fix FDistribution . isSupportLowerBoundInclusive ( ). ", "B_clean_title": ["updat", "refer", "patch", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. updated FDistribution with patched lower bound. Updated reference to patch 1366 in UniformRealDistribution. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "updat", "refer", "patch", "1366", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix a bug in UniformRealDistribution. Updated FDistribution . getSupportLowerBound ( ). ", "B_clean_title": ["fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. updated FDistribution with patch 1445. Updated reference to patch 1445. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "updat", "fdistribut", "distribut", "patch", "1445", "updat", "refer", "patch", "1445"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch w015. Fix FDistribution . log ( ). updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "w015", "fix", "fdistribut", "distribut", "log", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_519 in UniformRealDistribution. updated FDistribution with patched lower bound. Fix FDistribution . isSupportLowerBoundInclusive ( ). ", "B_clean_title": ["updat", "refer", "patch", "519", "uniformrealdistribut", "uniform", "real", "distribut", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Added missing patch. Fix NPE in UniformRealDistribution . getSupportUpperBound. Updated reference to patch 1421. Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. fixed a bug in FDistribution . getSupportLowerBound. ", "B_clean_title": ["ad", "miss", "patch", "fix", "npe", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "1421", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Allow < = > lognxm to be defined for FDistribution . density ( ) .. fixed a bug in FDistribution . getSupportLowerBound. Added missing patch. Fix NPE in UniformRealDistribution . getSupportUpperBound. Updated reference to patch 1471 .. ", "B_clean_title": ["allow", "lognxm", "defin", "fdistribut", "distribut", "densiti", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "ad", "miss", "patch", "fix", "npe", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "1471"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. updated FDistribution with patched lower bound. Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patched real distribution. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "updat", "fdistribut", "distribut", "patch", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . log ( x ) .. fixed a bug in FDistribution . getSupportLowerBound. Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patch_698 .. ", "B_clean_title": ["fix", "fdistribut", "distribut", "log", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "698"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. fixed a bug in FDistribution . getSupportLowerBound. Updated reference to patch 1334 .. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "updat", "refer", "patch", "1334"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add support for lowerBound in FDistribution. fixed FDistribution . getSupportLowerBound. Added missing patch. Updated reference to patch 1386 in UniformRealDistribution. ", "B_clean_title": ["add", "support", "lowerbound", "lower", "bound", "fdistribut", "distribut", "fix", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "ad", "miss", "patch", "updat", "refer", "patch", "1386", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch_589 in UniformRealDistribution. Add qa = 0 to numeratorDegreesOfFreedom logn. updated FDistribution with patched upper bounds. ", "B_clean_title": ["updat", "refer", "patch", "589", "uniformrealdistribut", "uniform", "real", "distribut", "add", "qa", "numeratordegreesoffreedom", "numer", "degre", "freedom", "logn", "updat", "fdistribut", "distribut", "patch", "upper", "bound"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated FDistribution . getSupportLowerBound ( ). Fix a bug in UniformRealDistribution . getSupportUpperBound. Updated reference to patched real distribution. ", "B_clean_title": ["updat", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "fix", "bug", "uniformrealdistribut", "uniform", "real", "distribut", "getsupportupperbound", "get", "support", "upper", "bound", "updat", "refer", "patch", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add qa = 0 to numeratorDegreesOfFreedom logn. updated FDistribution with patched upper bounds. Fix FDistribution . isSupportLowerBoundInclusive ( ). Updated reference to patch_604 .. ", "B_clean_title": ["add", "qa", "numeratordegreesoffreedom", "numer", "degre", "freedom", "logn", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "fix", "fdistribut", "distribut", "issupportlowerboundinclus", "support", "lower", "bound", "inclus", "updat", "refer", "patch", "604"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . log ( x ) .. fixed a bug in FDistribution . getSupportLowerBound. Updated reference to patched real distribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "log", "fix", "bug", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "updat", "refer", "patch", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add the mu value to FDistribution . log ( ) .. updated FDistribution with patched upper bounds. Updated guidance for real distributions. ", "B_clean_title": ["add", "mu", "valu", "fdistribut", "distribut", "log", "updat", "fdistribut", "distribut", "patch", "upper", "bound", "updat", "guidanc", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Fix FDistribution . density ( double ). ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "fix", "fdistribut", "distribut", "densiti", "doubl"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerator and denominator are not greater than the numerator. Fix FDistribution . getSupportLowerBound ( ). Updated reference to patch_692 .. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "denomin", "are", "not", "greater", "than", "numer", "fix", "fdistribut", "distribut", "getsupportlowerbound", "get", "support", "lower", "bound", "updat", "refer", "patch", "692"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerator is not greater than the denominator. Fix up upperBound inclusiveness in UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "not", "greater", "than", "denomin", "fix", "up", "upperbound", "upper", "bound", "inclus", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated reference to patch 850 for compatibility with older OSGi versions .. Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. ", "B_clean_title": ["updat", "refer", "patch", "850", "compat", "older", "osgi", "os", "gi", "version", "throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add numerical variance to FDistribution . density ( double ). Updated copyright on UniformRealDistribution. ", "B_clean_title": ["add", "numer", "varianc", "fdistribut", "distribut", "densiti", "doubl", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ). Updated copyright on UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add numerical variance to FDistribution . density ( ). fixed NPE in FDistribution. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["add", "numer", "varianc", "fdistribut", "distribut", "densiti", "fix", "npe", "fdistribut", "distribut", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix logx being > = 0 .. Fix UniformRealDistribution patch. ", "B_clean_title": ["fix", "logx", "be", "fix", "uniformrealdistribut", "uniform", "real", "distribut", "patch"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerator is not greater than the denominator. Updated patch for 1 . 3 . 5. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "not", "greater", "than", "denomin", "updat", "patch", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Throw an exception if the numeratorDegreesOfFreedom > = 0. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "throw", "except", "numeratordegreesoffreedom", "numer", "degre", "freedom"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Fix FDistribution . density ( double ) where the numerical variance was not calculated .. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "varianc", "wa", "not", "calcul"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Fix FDistribution . density ( double ) where the numerical variance was not calculated .. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["fix", "fdistribut", "distribut", "densiti", "doubl", "where", "numer", "varianc", "wa", "not", "calcul", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Add numerical variance to FDistribution . density ( ). Updated copyright on UniformRealDistribution. ", "B_clean_title": ["add", "numer", "varianc", "fdistribut", "distribut", "densiti", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Throw an exception if the denominatorDegreesOfFreedom was not greater than 0 .. Updated patch for 1 . 6 . 2. Updated copyright on UniformRealDistribution. ", "B_clean_title": ["throw", "except", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "wa", "not", "greater", "than", "updat", "patch", "updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut"]},
{"A_title": "Fix and then deprecate isSupportXxxInclusive in RealDistribution interfaceThe conclusion from 1 was never implemented. We should deprecate these properties from the RealDistribution interface but since removal will have to wait until 4.0 we should agree on a precise definition and fix the code to match it in the mean time. The definition that I propose is that isSupportXxxInclusive means that when the density function is applied to the upper or lower bound of support returned by getSupportXxxBound a finite (i.e. not infinite) not NaN value is returned. 1 http://markmail.org/message/dxuxh7eybl7xejde", "A_clean_title": ["fix", "then", "deprec", "issupportxxxinclus", "support", "xxx", "inclus", "realdistribut", "real", "distribut", "interfaceth", "interfac", "conclus", "wa", "never", "implement", "we", "deprec", "these", "properti", "realdistribut", "real", "distribut", "interfac", "but", "sinc", "remov", "will", "have", "wait", "until", "we", "agre", "precis", "definit", "fix", "code", "match", "it", "mean", "time", "definit", "that", "propos", "that", "issupportxxxinclus", "support", "xxx", "inclus", "mean", "that", "when", "densiti", "function", "appli", "upper", "or", "lower", "bound", "support", "return", "by", "getsupportxxxbound", "get", "support", "xxx", "bound", "finit", "not", "infinit", "not", "nan", "na", "valu", "return", "http", "markmail", "org", "messag", "dxuxh7eybl7xejd"], "B_title": "Updated copyright on UniformRealDistribution. Fix logx being > = 0. ", "B_clean_title": ["updat", "copyright", "uniformrealdistribut", "uniform", "real", "distribut", "fix", "logx", "be"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix bug in equals. ", "B_clean_title": ["fix", "bug", "equal"]},
{"A_title": "NaN in equals methodsIn MathUtils some equals methods will return true if both argument are NaN. Unless Im mistaken this contradicts the IEEE standard. If nobody objects Im going to make the changes.", "A_clean_title": ["nan", "na", "equal", "methodsin", "method", "mathutil", "math", "util", "some", "equal", "method", "will", "return", "true", "both", "argument", "are", "nan", "na", "unless", "im", "mistaken", "thi", "contradict", "ieee", "standard", "nobodi", "object", "im", "go", "make", "chang"], "B_title": "Fix bug in MathUtils . equals. ", "B_clean_title": ["fix", "bug", "mathutil", "math", "util", "equal"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix bug in DiscreteDistribution . java. ", "B_clean_title": ["fix", "bug", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample from patch collection. ", "B_clean_title": ["remov", "sampl", "patch", "collect"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix MWE - 7764. Updated definition of DiscreteDistribution. ", "B_clean_title": ["fix", "mwe", "7764", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add high precision array to ND array .. Fix the bug in MathArrays . set ( double ). Remove unused code. ", "B_clean_title": ["add", "high", "precis", "array", "nd", "array", "fix", "bug", "matharray", "math", "array", "set", "doubl", "remov", "unus", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Remove a redundant error reported by UnStrictlyPositiveException .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. Add z = 1 . 0 / 120 . 0 in GenProg_Defects4. Fix the for loop. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut", "add", "120", "genprog", "defects4", "gen", "prog", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated DiscreteDistribution . sample ( ). Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["updat", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int newSize. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "int", "newsiz", "new", "size", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove erroneous fallthrough in DiscreteDistribution . sample ( ). ", "B_clean_title": ["remov", "erron", "fallthrough", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. Added missing int. ", "B_clean_title": ["remov", "redund", "empti", "line", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add zb value to infinite array length .. Fix MWE - 7764. Remove unused sample method. ", "B_clean_title": ["add", "zb", "valu", "infinit", "array", "length", "fix", "mwe", "7764", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Put the sample on the right side. ", "B_clean_title": ["put", "sampl", "right", "side"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["updat", "sampl", "method", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for LOGNORMALIZE_NAN. Remove a redundant error reported by UnStrictlyPositiveException .. ", "B_clean_title": ["ad", "patch", "lognorm", "nan", "remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Removed unused code. Added missing int. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "code", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Add missing int newSize. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method. Added missing patch. Fix NPE. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method", "ad", "miss", "patch", "fix", "npe"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Updated definition of sample ( ) .. Added patch for MathArrays. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "sampl", "ad", "patch", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for the infinite array implementation .. Add missing int newSize. Removed some necessary code. ", "B_clean_title": ["add", "patch", "infinit", "array", "implement", "add", "miss", "int", "newsiz", "new", "size", "remov", "some", "necessari", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Keep going until I figure out the source of the numerical inaccuracies .. ", "B_clean_title": ["keep", "go", "until", "figur", "out", "sourc", "numer", "inaccuraci"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed some necessary code. Add missing patch .. Fix MWE - 7764. ", "B_clean_title": ["remov", "some", "necessari", "code", "add", "miss", "patch", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Updated DiscreteDistribution . sample ( ). Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["ad", "miss", "patch", "updat", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the bug in MathArrays . set ( double ). Remove unused sample method. ", "B_clean_title": ["fix", "bug", "matharray", "math", "array", "set", "doubl", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for MathArrays . normalizeArray ( double  double  double ). Remove unused sample value. ", "B_clean_title": ["add", "patch", "matharray", "math", "array", "normalizearray", "normal", "array", "doubl", "doubl", "doubl", "remov", "unus", "sampl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Remove a couple incorrect lines. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. Added patch for isInfinite. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Added missing int. Fix NPE in MathArrays . java. Remove unused code. ", "B_clean_title": ["ad", "miss", "patch", "ad", "miss", "int", "fix", "npe", "matharray", "math", "array", "java", "remov", "unus", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Put back DiscreteDistribution . sample ( ). Add missing int newSize. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "put", "back", "discretedistribut", "discret", "distribut", "sampl", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. Added missing patch. Added missing int. ", "B_clean_title": ["remov", "oversampl", "ad", "miss", "patch", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. Add one more test. ", "B_clean_title": ["remov", "oversampl", "add", "one", "more", "test"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant error reported by UnStrictlyPositiveException .. Added throw exception if it is not infinite  patched. Added patch for isInfinite / isNaN in MathArrays. Fix MWE - 7764. ", "B_clean_title": ["remov", "redund", "error", "report", "by", "unstrictlypositiveexcept", "un", "strictli", "posit", "except", "ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "isnan", "na", "matharray", "math", "array", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove 10 + 186 from DiscreteDistribution .. Added patch for isInfinite. Fix MWE - 7764. ", "B_clean_title": ["remov", "10", "186", "discretedistribut", "discret", "distribut", "ad", "patch", "isinfinit", "infinit", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of sample ( ) .. Add missing int newSize. ", "B_clean_title": ["updat", "definit", "sampl", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added throw exception if it is not infinite  patched. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "throw", "except", "it", "not", "infinit", "patch", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a redundant line. Added patch for isInfinite. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add 0 . 0 to fix infinities in MathArrays. Added missing int. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "fix", "infin", "matharray", "math", "array", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Updated definition of DiscreteDistribution. Add NAN normalization patch. Added patch for isNaN ( ). ", "B_clean_title": ["updat", "sampl", "method", "updat", "definit", "discretedistribut", "discret", "distribut", "add", "nan", "normal", "patch", "ad", "patch", "isnan", "na"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. StrictlyPositiveException was thrown with too many samples .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "mani", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the for - loop of MathArrays .. Remove a couple incorrect lines. ", "B_clean_title": ["fix", "loop", "matharray", "math", "array", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays . normalizeArray ( ). Added patch for DiscreteDistribution. Removed some necessary code. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "normalizearray", "normal", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "some", "necessari", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Fix the for loop. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added throw exception if it is not infinite  patched. Added patch for isInfinite / isNaN in MathArrays. Fix MWE - 7764. Remove a couple incorrect code. ", "B_clean_title": ["ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "isnan", "na", "matharray", "math", "array", "fix", "mwe", "7764", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method. Add zb and resultHigh to NAN patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method", "add", "zb", "resulthigh", "result", "high", "nan", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing patch. Removed a couple incorrect lines. ", "B_clean_title": ["add", "miss", "patch", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix NPE. Add a missing assignment. Remove sample from patch .. ", "B_clean_title": ["ad", "miss", "patch", "fix", "npe", "add", "miss", "assign", "remov", "sampl", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a couple incorrect code. Added patch for MathArrays. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code", "ad", "patch", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add 0 . 0 to fix the build .. Remove unused sample method .. ", "B_clean_title": ["add", "fix", "build", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect code. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Added missing patch. Remove a couple incorrect lines from the code. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add z / rev .. Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["add", "rev", "ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove unused sample method. Add zb and resultHigh to NAN patch. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "unus", "sampl", "method", "add", "zb", "resulthigh", "result", "high", "nan", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused sample method .. Added missing patch. Fix NPE in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "sampl", "method", "ad", "miss", "patch", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Updated definition of sample ( ) .. Added patch for isInfinite. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "updat", "definit", "sampl", "ad", "patch", "isinfinit", "infinit", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove sample from the patch .. Fix a bug in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "remov", "sampl", "patch", "fix", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added missing patch. Fix for bug 687 build .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "miss", "patch", "fix", "bug", "687", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. StrictlyPositiveException was not strictly positive .. Add zb value to infinite array fix. ", "B_clean_title": ["updat", "sampl", "method", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "add", "zb", "valu", "infinit", "array", "fix"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add zb to fix the build .. Fix NPE in MathArrays. Add a missing assignment. Remove unused variable. ", "B_clean_title": ["add", "zb", "fix", "build", "fix", "npe", "matharray", "math", "array", "add", "miss", "assign", "remov", "unus", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "StrictlyPositiveException was thrown with too few samples. Add the fix in MathArrays . isInfinite ( ) .. Add missing int newSize. ", "B_clean_title": ["strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "few", "sampl", "add", "fix", "matharray", "math", "array", "isinfinit", "infinit", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added patch for isInfinite. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int .. Fix a bug in DiscreteDistribution . get ( i ). Remove a redundant empty line. ", "B_clean_title": ["ad", "miss", "int", "fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Added patch for DiscreteDistribution. Updated definition of sample ( ) .. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Added missing int. Add a missing assignment. Remove unused sample method. ", "B_clean_title": ["ad", "miss", "patch", "ad", "miss", "int", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for MathArrays. Removed some necessary code. ", "B_clean_title": ["add", "patch", "matharray", "math", "array", "remov", "some", "necessari", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a redundant empty line. Add missing int newSize. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "empti", "line", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. Added missing patch. Fix NPE. ", "B_clean_title": ["remov", "redund", "line", "ad", "miss", "patch", "fix", "npe"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated DiscreteDistribution with new patch code. StrictlyPositiveException was not strictly positive. Add zb value to infinite array fix. ", "B_clean_title": ["updat", "discretedistribut", "discret", "distribut", "new", "patch", "code", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "add", "zb", "valu", "infinit", "array", "fix"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect lines from DiscreteDistribution . java. Add missing patch. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Fix NPE in MathArrays .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add NAN to MathArrays  patched. Fix a bug in MathArrays that expanded after the expanded array became too large. Fix a bug in DiscreteDistribution . get ( i ). Remove unused sample method .. ", "B_clean_title": ["add", "nan", "matharray", "math", "array", "patch", "fix", "bug", "matharray", "math", "array", "that", "expand", "after", "expand", "array", "becam", "too", "larg", "fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove sample from patch .. Added missing patch. Added missing int. ", "B_clean_title": ["add", "miss", "assign", "remov", "sampl", "patch", "ad", "miss", "patch", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of sample ( ) .. ", "B_clean_title": ["updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Removed a redundant empty line. Added patch for isInfinite. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "remov", "redund", "empti", "line", "ad", "patch", "isinfinit", "infinit", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite ( ) .. Add missing patch. Updated sample method. StrictlyPositiveException was thrown with too few samples. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "add", "miss", "patch", "updat", "sampl", "method", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "few", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a redundant empty line. Add missing facta variable to fix the build .. ", "B_clean_title": ["add", "miss", "assign", "remov", "redund", "empti", "line", "add", "miss", "facta", "variabl", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. StrictlyPositiveException was not strictly positive .. Add zb and idx = 0 ;. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "add", "zb", "idx"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing patch. Fix a bug in DiscreteDistribution .. ", "B_clean_title": ["add", "miss", "patch", "fix", "bug", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a patch for DiscreteDistribution. Remove a redundant empty line. Added patch for isInfinite. ", "B_clean_title": ["add", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "empti", "line", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect lines from the code. Add missing facta variable to MathArrays . java. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "line", "code", "add", "miss", "facta", "variabl", "matharray", "math", "array", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added missing int .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for GROOVY - 816. Remove a couple incorrect lines. ", "B_clean_title": ["ad", "patch", "groovi", "816", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). Remove a couple incorrect code. Added missing patch. Added missing int. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl", "remov", "coupl", "incorrect", "code", "ad", "miss", "patch", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "miss", "patch", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Missing patch for DiscreteDistribution . sample ( ). ", "B_clean_title": ["add", "miss", "assign", "miss", "patch", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of DiscreteDistribution. ", "B_clean_title": ["updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant empty line. ", "B_clean_title": ["remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing patch for MathArrays . isInfinite ( ) .. Fix a bug in DiscreteDistribution . get ( i ). Remove a redundant line. ", "B_clean_title": ["add", "miss", "patch", "matharray", "math", "array", "isinfinit", "infinit", "fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample int. ", "B_clean_title": ["remov", "unus", "sampl", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Remove a couple incorrect code. Added patch for isInfinite. Fix the for loop. ", "B_clean_title": ["updat", "sampl", "method", "remov", "coupl", "incorrect", "code", "ad", "patch", "isinfinit", "infinit", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove redundant sample method. ", "B_clean_title": ["ad", "miss", "patch", "remov", "redund", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in sample ( ). Add z = 1 . 0 / 120 . 0 in GenProg_Defects4. ", "B_clean_title": ["fix", "bug", "sampl", "add", "120", "genprog", "defects4", "gen", "prog"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove unused sample method. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. ", "B_clean_title": ["remov", "oversampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Removed unused code. Added missing int. ", "B_clean_title": ["updat", "sampl", "method", "remov", "unus", "code", "ad", "miss", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. Added patch for DiscreteDistribution. Remove a redundant line. ", "B_clean_title": ["add", "miss", "patch", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove erroneous loop. Add missing int newSize. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "erron", "loop", "add", "miss", "int", "newsiz", "new", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add z = 1 . 0 / 120 . 0 to fix the build .. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "120", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int index .. Added missing sample implementation. ", "B_clean_title": ["ad", "miss", "int", "index", "ad", "miss", "sampl", "implement"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int .. Remove a couple incorrect code. Added patch for isInfinite. ", "B_clean_title": ["ad", "miss", "int", "remov", "coupl", "incorrect", "code", "ad", "patch", "isinfinit", "infinit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove redundant code. Added throw exception if it is not infinite  patched. Added patch for isInfinite. Fix MWE - 7764. ", "B_clean_title": ["remov", "redund", "code", "ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "fix", "mwe", "7764"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix the for loop. Add a missing assignment. Updated definition of DiscreteDistribution. ", "B_clean_title": ["fix", "loop", "add", "miss", "assign", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a redundant empty line. Added patch for isInfinite. Fix NPE in MathArrays . java. ", "B_clean_title": ["add", "miss", "assign", "remov", "redund", "empti", "line", "ad", "patch", "isinfinit", "infinit", "fix", "npe", "matharray", "math", "array", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix a bit of code style. ", "B_clean_title": ["ad", "miss", "patch", "fix", "bit", "code", "style"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused code. Fix the for loop. ", "B_clean_title": ["remov", "unus", "code", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing exception message. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "miss", "except", "messag", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Fix  Too many decimal places to round to  MathArrays . toString ( ) . ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "fix", "too", "mani", "decim", "place", "round", "matharray", "math", "array", "tostr", "string"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int . MaxValue for MathArrays .. Add a missing assignment. Remove unused sample method .. ", "B_clean_title": ["ad", "miss", "int", "maxvalu", "max", "valu", "matharray", "math", "array", "add", "miss", "assign", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Changed min / max range of DiscreteDistribution .. Remove a couple incorrect code. ", "B_clean_title": ["chang", "min", "max", "rang", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Changed min = Integer . MAX_VALUE for DiscreteDistribution .. Remove a couple incorrect code. ", "B_clean_title": ["chang", "min", "integ", "max", "valu", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the patch for MathArrays. Add missing patch. Add a missing assignment. Updated definition of sample ( ) .. ", "B_clean_title": ["add", "patch", "matharray", "math", "array", "add", "miss", "patch", "add", "miss", "assign", "updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. ", "B_clean_title": ["remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Allow NaN to be thrown in MathArrays. Added patch for DiscreteDistribution. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "allow", "nan", "na", "thrown", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing patch. Fix NPE in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "patch", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. Added patch for MathArrays . normalizeArray ( ). ", "B_clean_title": ["remov", "unus", "sampl", "method", "ad", "patch", "matharray", "math", "array", "normalizearray", "normal", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add z / rev .. Removesampling patch. ", "B_clean_title": ["add", "rev", "removesampl", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove a couple incorrect code. ", "B_clean_title": ["ad", "miss", "patch", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing patch. Removed erroneous fallthrough in DiscreteDistribution . sample ( ) .. ", "B_clean_title": ["add", "miss", "patch", "remov", "erron", "fallthrough", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite. Fix the for loop. Updated sample method. Remove a redundant line. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "fix", "loop", "updat", "sampl", "method", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated probabilities to 0 . 8 . 0. Remove a redundant empty line. ", "B_clean_title": ["updat", "probabl", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add z = 1 . 0 / 120 . 0 in GenProg_Defects4. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "120", "genprog", "defects4", "gen", "prog"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method. Add zb and resultHigh to NAN patch. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "zb", "resulthigh", "result", "high", "nan", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Put the sample on the right place .. Added patch for MathArrays. Add zb patched for now .. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "put", "sampl", "right", "place", "ad", "patch", "matharray", "math", "array", "add", "zb", "patch", "now"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Fix a bug in MathArrays. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "fix", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove unused code. Fix NPE in MathArrays. ", "B_clean_title": ["add", "miss", "assign", "remov", "unus", "code", "fix", "npe", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug in DiscreteDistribution. Remove a couple incorrect lines from DiscreteDistribution . java. ", "B_clean_title": ["fix", "small", "bug", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "line", "discretedistribut", "discret", "distribut", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in MathArrays. Remove unused sample method .. ", "B_clean_title": ["fix", "bug", "matharray", "math", "array", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing sample implementation. Add 0 . 0 to fix the build .. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "sampl", "implement", "add", "fix", "build", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. StrictlyPositiveException was thrown with too small sample size .. Add z = 1 . 0 / 120 . 0 to fix the build .. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "small", "sampl", "size", "add", "120", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in MathArrays . java. Updated definition of DiscreteDistribution. ", "B_clean_title": ["fix", "npe", "matharray", "math", "array", "java", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Updated definition of sample ( ) .. Add missing patch. ", "B_clean_title": ["add", "miss", "assign", "updat", "definit", "sampl", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a patch for DiscreteDistribution. Remove a couple incorrect code. ", "B_clean_title": ["add", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Fix MWE - 7764. Remove a redundant empty line. ", "B_clean_title": ["ad", "miss", "patch", "fix", "mwe", "7764", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing int. Remove 10 + 186 from DiscreteDistribution .. ", "B_clean_title": ["ad", "miss", "int", "remov", "10", "186", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Remove a couple incorrect code. ", "B_clean_title": ["add", "miss", "assign", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect code. Added missing patch .. ", "B_clean_title": ["remov", "coupl", "incorrect", "code", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. ", "B_clean_title": ["remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "fixed a small bug. Fix MWE - 1296 by adding a new empty int. ", "B_clean_title": ["fix", "small", "bug", "fix", "mwe", "1296", "by", "ad", "new", "empti", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in DiscreteDistribution . get ( i ). Remove unused sample method .. Fix PIP. ", "B_clean_title": ["fix", "bug", "discretedistribut", "discret", "distribut", "get", "remov", "unus", "sampl", "method", "fix", "pip"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Add missing sample method. Added missing patch. ", "B_clean_title": ["add", "miss", "assign", "add", "miss", "sampl", "method", "ad", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add z = 1 . 0 / 120 . 0 to fix the build .. Added patch for DiscreteDistribution. StrictlyPositiveException was not strictly positive .. ", "B_clean_title": ["add", "120", "fix", "build", "ad", "patch", "discretedistribut", "discret", "distribut", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. Added missing patch. Fix a bug in MathArrays .. ", "B_clean_title": ["add", "miss", "assign", "ad", "miss", "patch", "fix", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample int. Add the infinite exception message. ", "B_clean_title": ["remov", "unus", "sampl", "int", "add", "infinit", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated sample method. Remove unused sample method .. ", "B_clean_title": ["updat", "sampl", "method", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "StrictlyPositiveException was thrown with too many samples .. Add the missing patch .. ", "B_clean_title": ["strictlypositiveexcept", "strictli", "posit", "except", "wa", "thrown", "too", "mani", "sampl", "add", "miss", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed some necessary code. Fix NPE in MathArrays . java. ", "B_clean_title": ["remov", "some", "necessari", "code", "fix", "npe", "matharray", "math", "array", "java"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Remove a couple incorrect code. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for MathArrays. Added patch for DiscreteDistribution. Updated definition of DiscreteDistribution. ", "B_clean_title": ["ad", "patch", "matharray", "math", "array", "ad", "patch", "discretedistribut", "discret", "distribut", "updat", "definit", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in MathArrays . toArray. Remove a couple incorrect lines. ", "B_clean_title": ["fix", "npe", "matharray", "math", "array", "toarray", "array", "remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix MWE - 7764. Remove redundant code. ", "B_clean_title": ["fix", "mwe", "7764", "remov", "redund", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Updated definition of sample ( ) .. ", "B_clean_title": ["updat", "definit", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing int newSize. Remove a redundant line. ", "B_clean_title": ["add", "miss", "int", "newsiz", "new", "size", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove unused sample method .. Add 0 . 0 to fix the build .. ", "B_clean_title": ["remov", "unus", "sampl", "method", "add", "fix", "build"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a missing assignment. StrictlyPositiveException was not strictly positive .. Fix the for loop. ", "B_clean_title": ["add", "miss", "assign", "strictlypositiveexcept", "strictli", "posit", "except", "wa", "not", "strictli", "posit", "fix", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added throw exception if it is not infinite  patched. Added patch for isInfinite. Fix MWE - 7764. Remove a redundant empty line. ", "B_clean_title": ["ad", "throw", "except", "it", "not", "infinit", "patch", "ad", "patch", "isinfinit", "infinit", "fix", "mwe", "7764", "remov", "redund", "empti", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for isInfinite ( ) .. Updated probabilities. Remove unused sample method. ", "B_clean_title": ["ad", "patch", "isinfinit", "infinit", "updat", "probabl", "remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove a couple incorrect code. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "coupl", "incorrect", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Add missing facta variable .. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "add", "miss", "facta", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing exception message. Remove patch from DiscreteDistribution. ", "B_clean_title": ["ad", "miss", "except", "messag", "remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Fix NaN in MathArrays. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "fix", "nan", "na", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Remove patched code. ", "B_clean_title": ["ad", "miss", "patch", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Fix a merge conflict caused by Double . isNaN ( normalizedSum ) being too high. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "fix", "merg", "conflict", "caus", "by", "doubl", "isnan", "na", "normalizedsum", "normal", "sum", "be", "too", "high"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix minor rounding bug in MathArrays. Remove patch from DiscreteDistribution. ", "B_clean_title": ["fix", "minor", "round", "bug", "matharray", "math", "array", "remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Throw an error if sampleSize <= 0. ", "B_clean_title": ["add", "miss", "except", "messag", "throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. Remove patch. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix POSIX - compliance issue in MathArrays. Remove patched code. ", "B_clean_title": ["fix", "posix", "complianc", "issu", "matharray", "math", "array", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove oversampling .. ", "B_clean_title": ["remov", "oversampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Handle isInfinite / isNaN in MathArrays. Remove accidential modification. ", "B_clean_title": ["handl", "isinfinit", "infinit", "isnan", "na", "matharray", "math", "array", "remov", "accidenti", "modif"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. remove patch. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove patch. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "removed patch from DiscreteDistribution. Remove patch from DiscreteDistribution. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch. Fix an issue with infinities in MathArrays. ", "B_clean_title": ["remov", "patch", "fix", "issu", "infin", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed patch from MathArrays . java. Remove patched code. ", "B_clean_title": ["remov", "patch", "matharray", "math", "array", "java", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patched code. Fix a bug in MathArrays that was accidentally left in the last commit .. ", "B_clean_title": ["remov", "patch", "code", "fix", "bug", "matharray", "math", "array", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a couple incorrect lines. Added a bit more custom error message. ", "B_clean_title": ["remov", "coupl", "incorrect", "line", "ad", "bit", "more", "custom", "error", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added missing patch. Throw an error if sampleSize <= 0. ", "B_clean_title": ["ad", "miss", "patch", "throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix an issue with MathArrays . isInfinite ( ) being thrown as NaN .. throw exception if sampleSize is not positive. ", "B_clean_title": ["fix", "issu", "matharray", "math", "array", "isinfinit", "infinit", "be", "thrown", "as", "nan", "na", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "StrictlyPositiveException for DiscreteDistribution. ", "B_clean_title": ["strictlypositiveexcept", "strictli", "posit", "except", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Added patch for DiscreteDistribution. throw exception if sampleSize is not positive. ", "B_clean_title": ["ad", "patch", "discretedistribut", "discret", "distribut", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patched exception. ", "B_clean_title": ["remov", "patch", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NAN normalization in MathArrays. Remove patch. ", "B_clean_title": ["fix", "nan", "normal", "matharray", "math", "array", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix a bug in MathArrays that would cause NAN normalization to fail. throw exception if sampleSize is not positive. ", "B_clean_title": ["fix", "bug", "matharray", "math", "array", "that", "would", "caus", "nan", "normal", "fail", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove sample from definition. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "sampl", "definit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing exception message. throw exception if sampleSize is not positive. ", "B_clean_title": ["add", "miss", "except", "messag", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch. Fix a bug in MathArrays that could cause NaN values in the same way as MathArray. ", "B_clean_title": ["remov", "patch", "fix", "bug", "matharray", "math", "array", "that", "could", "caus", "nan", "na", "valu", "same", "way", "as", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Handle NaN normalization in MathArrays. throw exception if sampleSize < 0. ", "B_clean_title": ["handl", "nan", "na", "normal", "matharray", "math", "array", "throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add the missing exception message. Fix MathArrays . sum ( double ) to 0. Remove a couple of unused lines. ", "B_clean_title": ["add", "miss", "except", "messag", "fix", "matharray", "math", "array", "sum", "doubl", "remov", "coupl", "unus", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch. Fix a merge conflict in MathArrays .. ", "B_clean_title": ["remov", "patch", "fix", "merg", "conflict", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove sample calls. ", "B_clean_title": ["remov", "sampl", "call"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing exception message. Remove patched code. ", "B_clean_title": ["add", "miss", "except", "messag", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Add missing exception message. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "add", "miss", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove accidently removed code. Fix a numeric equality bug in MathArrays. ", "B_clean_title": ["remov", "accid", "remov", "code", "fix", "numer", "equal", "bug", "matharray", "math", "array"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Throw an error if sampleSize <= 0. ", "B_clean_title": ["throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NAN normalization in MathArrays. Remove patched code. ", "B_clean_title": ["fix", "nan", "normal", "matharray", "math", "array", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add a thrown exception if it is not infinite .. Remove patched code. ", "B_clean_title": ["add", "thrown", "except", "it", "not", "infinit", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Add missing patch. remove patch. ", "B_clean_title": ["add", "miss", "patch", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove 10 + 186 from DiscreteDistribution .. Add missing exception message. ", "B_clean_title": ["remov", "10", "186", "discretedistribut", "discret", "distribut", "add", "miss", "except", "messag"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "removed patch for DiscreteDistribution. Remove overzealous call to sample ( ). ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "remov", "overzeal", "call", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Handle infinities in MathArrays. Remove patched code. ", "B_clean_title": ["handl", "infin", "matharray", "math", "array", "remov", "patch", "code"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove patch from DiscreteDistribution. Added a throw exception if the normalized sum is not greater than the value .. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut", "ad", "throw", "except", "normal", "sum", "not", "greater", "than", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NAN normalization in MathArrays. throw exception if sampleSize is not positive. ", "B_clean_title": ["fix", "nan", "normal", "matharray", "math", "array", "throw", "except", "samples", "sampl", "size", "not", "posit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix RSRepair defects4J_Math_8 .. remove patch. ", "B_clean_title": ["fix", "rsrepair", "rs", "repair", "defects4j", "math", "remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . min = Double . POSITIVE_INFINITY. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "min", "doubl", "posit", "infin"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . weightSum. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "weightsum", "weight", "sum"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample ( ). ", "B_clean_title": ["remov", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused sample method. ", "B_clean_title": ["remov", "unus", "sampl", "method"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in DiscreteDistribution. remove patched double setting constructor. ", "B_clean_title": ["fix", "npe", "discretedistribut", "discret", "distribut", "remov", "patch", "doubl", "set", "constructor"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix NPE in DiscreteDistribution. remove a redundant line. ", "B_clean_title": ["fix", "npe", "discretedistribut", "discret", "distribut", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). remove patched double value. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl", "remov", "patch", "doubl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix for DiscreteDistribution . get ( int ). Throw an error if sampleSize <= 0. ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "get", "int", "throw", "error", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove a redundant line. ", "B_clean_title": ["remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "removed patch for RSRepair_Defects4J_Math_8. remove unused variable. ", "B_clean_title": ["remov", "patch", "rsrepair", "defects4j", "math", "rs", "repair", "remov", "unus", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused local variable. ", "B_clean_title": ["remov", "unus", "local", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. Fix potential segfault in RSRepairDefects4J_Math_8 .. ", "B_clean_title": ["remov", "patch", "fix", "potenti", "segfault", "rsrepairdefects4j", "math", "rs", "repair", "defects4j"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed a redundant empty loop in DiscreteDistribution. ", "B_clean_title": ["remov", "redund", "empti", "loop", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed some declared exceptions. ", "B_clean_title": ["remov", "some", "declar", "except"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch from DiscreteDistribution. ", "B_clean_title": ["remov", "patch", "discretedistribut", "discret", "distribut"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove erroneous unused variable. ", "B_clean_title": ["remov", "erron", "unus", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample from definition. ", "B_clean_title": ["remov", "sampl", "definit"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "replace 1 . 0d with 1 . 0d. Remove a redundant line. ", "B_clean_title": ["replac", "0d", "0d", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sample size is not > = 0. Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["throw", "except", "sampl", "size", "not", "fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Remove erroneous loop. ", "B_clean_title": ["remov", "erron", "loop"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Removed unused sample value. ", "B_clean_title": ["remov", "unus", "sampl", "valu"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "throw exception if sampleSize < 0. ", "B_clean_title": ["throw", "except", "samples", "sampl", "size"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix minor bug in RSRepair_Defects4J_Math_8 .. remove a redundant line. ", "B_clean_title": ["fix", "minor", "bug", "rsrepair", "defects4j", "math", "rs", "repair", "remov", "redund", "line"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused sample int. ", "B_clean_title": ["remov", "unus", "sampl", "int"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "Fix DiscreteDistribution . sample ( ). ", "B_clean_title": ["fix", "discretedistribut", "discret", "distribut", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused sample ( ). ", "B_clean_title": ["remov", "unus", "sampl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove unused local variable. ", "B_clean_title": ["remov", "unus", "local", "variabl"]},
{"A_title": "DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class typeCreating an array with Array.newInstance(singletons.get(0).getClass() sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:  singleons.get(0) is of type T1 an sub-class of T and DiscreteDistribution.sample() returns an object which is of type T but not of type T1.  To reproduce:  List<Pair<ObjectDouble>> list = new ArrayList<Pair<Object Double>>(); list.add(new Pair<Object Double>(new Object()  new Double(0))); list.add(new Pair<Object Double>(new Object()  new Double(1))); new DiscreteDistribution<Object>(list).sample(1);   Attaching a patch.", "A_clean_title": ["discretedistribut", "sampl", "discret", "distribut", "int", "may", "throw", "except", "first", "element", "singleton", "sub", "class", "typecr", "type", "creat", "array", "array", "newinst", "new", "instanc", "singleton", "get", "getclass", "get", "class", "samples", "sampl", "size", "discretedistribut", "sampl", "discret", "distribut", "int", "riski", "except", "will", "thrown", "singleon", "get", "type", "t1", "sub", "class", "discretedistribut", "sampl", "discret", "distribut", "return", "object", "which", "type", "but", "not", "type", "t1", "reproduc", "list", "pair", "objectdoubl", "object", "doubl", "list", "new", "arraylist", "array", "list", "pair", "object", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "list", "add", "new", "pair", "object", "doubl", "new", "object", "new", "doubl", "new", "discretedistribut", "discret", "distribut", "object", "list", "sampl", "attach", "patch"], "B_title": "remove sample from definition. ", "B_clean_title": ["remov", "sampl", "definit"]}]