[{"A_title": "Incomplete reinitialization with some events handlingI get a bug with event handling: I track 2 events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I cant give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests.", "A_clean_title": ["incomplet", "reiniti", "some", "event", "handlingi", "handl", "get", "bug", "event", "handl", "track", "event", "that", "occur", "same", "step", "when", "first", "one", "accept", "it", "reset", "state", "but", "reiniti", "not", "complet", "second", "one", "becom", "unabl", "find", "it", "way", "cant", "give", "my", "context", "which", "rather", "larg", "but", "tri", "patch", "that", "work", "me", "unfortun", "it", "break", "unit", "test"], "B_title": "Fix load / load of confix classes. Fix typo in EventState. ", "B_clean_title": ["fix", "load", "load", "confix", "class", "fix", "typo", "eventst", "event", "state"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Updated chart with the new column doesn  t already exist .. ", "B_clean_title": ["updat", "chart", "new", "column", "doesn", "alreadi", "exist"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Improved method to append XYDataItems. ", "B_clean_title": ["improv", "method", "append", "xydataitem", "xy", "data", "item"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Add some missing imports. Fix bug in addOrUpdate. ", "B_clean_title": ["add", "some", "miss", "import", "fix", "bug", "addorupd", "add", "or", "updat"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in chart. ", "B_clean_title": ["fix", "bug", "chart"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Remove an overwritten throw exception if it is null. Improved method to append XYSeries items. Fix overwritten variable. ", "B_clean_title": ["remov", "overwritten", "throw", "except", "it", "null", "improv", "method", "append", "xyseri", "xy", "seri", "item", "fix", "overwritten", "variabl"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Remove an overwritten check. Improved method to append XYSeries items. ", "B_clean_title": ["remov", "overwritten", "check", "improv", "method", "append", "xyseri", "xy", "seri", "item"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed a bug in Complex . reciprocal ( ). ", "B_clean_title": ["fix", "bug", "complex", "reciproc"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Extend reciprocal to fix max claims. ", "B_clean_title": ["extend", "reciproc", "fix", "max", "claim"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix potential inf special case for complex type in code. ", "B_clean_title": ["fix", "potenti", "inf", "special", "case", "complex", "type", "code"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Revert back to NaN since it  s defined in the old one. Fix toString ( ) of Complex. ", "B_clean_title": ["revert", "back", "nan", "na", "sinc", "it", "defin", "old", "one", "fix", "tostr", "string", "complex"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Added missing 1111. ", "B_clean_title": ["ad", "miss", "1111"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size > = length ( ). ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( len + 1 ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "len", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "reset nullText if it is empty string ( # 1267 ). Fix buffer size too large. ", "B_clean_title": ["reset", "nulltext", "null", "text", "it", "empti", "string", "1267", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "reset nullText on deleteFirst ( ). Fix buffer size > = length ( ). ", "B_clean_title": ["reset", "nulltext", "null", "text", "deletefirst", "delet", "first", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add more ensureCapacity .. Fix buffer size too large. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( size + 4 ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "size", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix ensureCapacity .. Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size increase. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "increas"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add throw inside if / else .. fixed a small bug. ", "B_clean_title": ["add", "throw", "insid", "fix", "small", "bug"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix ensureCapacity .. Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Revert previous patch. ", "B_clean_title": ["revert", "previou", "patch"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder deleteFirst ( ) returns this if the builder is empty .. Fix buffer size too large. ", "B_clean_title": ["strbuilder", "str", "builder", "deletefirst", "delet", "first", "return", "thi", "builder", "empti", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix buffer size increase. ", "B_clean_title": ["fix", "buffer", "size", "increas"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add accidently removed backslash. ", "B_clean_title": ["add", "accid", "remov", "backslash"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( len + 1 ) if we have > 0 length. Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "len", "we", "have", "length", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug in TimeSeries . java. ", "B_clean_title": ["fix", "bug", "timeseri", "time", "seri", "java"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix a bug in chart_9_TimeSeries_t. ", "B_clean_title": ["fix", "bug", "chart", "timeseri", "time", "seri"]},
{"A_title": "One of Variance.evaluate() methods does not work correctlyThe method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double values double weights double mean int begin int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.", "A_clean_title": ["one", "varianc", "evalu", "method", "not", "work", "correctlyth", "correctli", "method", "org", "apach", "common", "math", "stat", "descript", "moment", "varianc", "evalu", "doubl", "valu", "doubl", "weight", "doubl", "mean", "int", "begin", "int", "length", "not", "work", "properli", "look", "loke", "it", "ignor", "length", "paramet", "grab", "whole", "dataset", "similar", "method", "mean", "class", "seem", "work", "did", "not", "check", "other", "method", "take", "part", "array", "they", "may", "have", "same", "problem", "workaround", "had", "shrink", "my", "array", "use", "method", "without", "length"], "B_title": "Added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Added throw exception if search and replace array lengths do not match. revert accidently change. remove a for loop. ", "B_clean_title": ["ad", "throw", "except", "search", "replac", "array", "length", "not", "match", "revert", "accid", "chang", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove accidently leftover from StringUtils. ", "B_clean_title": ["remov", "accid", "leftov", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove unused patch. ", "B_clean_title": ["remov", "unus", "patch"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "throw exception if timeToLive < 0. remove a unused variable. ", "B_clean_title": ["throw", "except", "timetol", "time", "live", "remov", "unus", "variabl"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "revert accidently change for StringUtils. remove a for loop. ", "B_clean_title": ["revert", "accid", "chang", "stringutil", "string", "util", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "revert accidently change. remove a redundant line. ", "B_clean_title": ["revert", "accid", "chang", "remov", "redund", "line"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed unnecessary check for null / non - empty text fields. reset replaceIndex. remove a for loop. fixed NPE and NPE in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "check", "null", "non", "empti", "text", "field", "reset", "replaceindex", "replac", "index", "remov", "loop", "fix", "npe", "npe", "stringutil", "string", "util"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Added missing throw in patch 158 Gaussian dataset. ", "B_clean_title": ["ad", "miss", "throw", "patch", "158", "gaussian", "dataset"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Added correction for typo in case of erroneous data. ", "B_clean_title": ["ad", "correct", "typo", "case", "erron", "data"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix regression in GaussianFitter .. ", "B_clean_title": ["fix", "regress", "gaussianfitt", "gaussian", "fitter"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Add insampling error. Fix Gaussian function parameter length. ", "B_clean_title": ["revert", "accid", "remov", "fit", "add", "insampl", "error", "fix", "gaussian", "function", "paramet", "length"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Remove a couple of points that are not used .. ", "B_clean_title": ["revert", "accid", "remov", "param", "remov", "coupl", "point", "that", "are", "not", "use"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Added a null check. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "param", "ad", "null", "check", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Added throw if observations . length < 4 to GaussianFitter . guess ( ). ", "B_clean_title": ["revert", "accid", "remov", "param", "ad", "throw", "observ", "length", "gaussianfitt", "gaussian", "fitter", "guess"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling error. Add NPE if y is null. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "error", "add", "npe", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add NPE if points are null. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "npe", "point", "are", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Put back previous patch. Reverted accidently removed param. Throw NPE if observations . length < 4. Throw an error if observations is null. ", "B_clean_title": ["put", "back", "previou", "patch", "revert", "accid", "remov", "param", "throw", "npe", "observ", "length", "throw", "error", "observ", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed change from fit ( ) .. Allow null input array to be used for GaussianFitter .. Add missing param for GaussianFitter ( maxYIdx - > X ). ", "B_clean_title": ["revert", "accid", "remov", "chang", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "miss", "param", "gaussianfitt", "gaussian", "fitter", "maxyidx", "max", "idx"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Remove a couple of points that are not used .. Fix GaussianFitter parameter error. ", "B_clean_title": ["revert", "accid", "remov", "param", "remov", "coupl", "point", "that", "are", "not", "use", "fix", "gaussianfitt", "gaussian", "fitter", "paramet", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Remove a couple of points that are not used .. Fix GaussianFitter . sort ( ). ", "B_clean_title": ["add", "back", "miss", "patch", "remov", "coupl", "point", "that", "are", "not", "use", "fix", "gaussianfitt", "gaussian", "fitter", "sort"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Add a patch for GaussianFitter . guess ( ). Add NPE if y is null. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "fit", "add", "patch", "gaussianfitt", "gaussian", "fitter", "guess", "add", "npe", "null", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Added throw exception if observations . length < 4. Add a throw if param  2  is not strictly positive. ", "B_clean_title": ["revert", "accid", "remov", "fit", "ad", "throw", "except", "observ", "length", "add", "throw", "param", "not", "strictli", "posit"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add a throw if observations . length < 3. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "throw", "observ", "length"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling error. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Allow null input array to be used for GaussianFitter .. Add one exception. ", "B_clean_title": ["revert", "accid", "remov", "param", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "one", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Allow null input array to be used for GaussianFitter .. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add NPE if observations is null. Fix GaussianFitter . isBetween ( y  x  y ) .. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "npe", "observ", "null", "fix", "gaussianfitt", "gaussian", "fitter", "isbetween", "between"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling exception. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Allow null input array to be used for GaussianFitter .. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add a dimension mismatch check. Reverted accidently removed param. Add insampling exception. ", "B_clean_title": ["add", "dimens", "mismatch", "check", "revert", "accid", "remov", "param", "add", "insampl", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Remove a couple of points that are not used .. Added a null check. ", "B_clean_title": ["add", "back", "miss", "patch", "remov", "coupl", "point", "that", "are", "not", "use", "ad", "null", "check"]}]