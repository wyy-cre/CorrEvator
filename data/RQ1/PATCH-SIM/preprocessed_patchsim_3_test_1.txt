[{"A_title": "getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)the L_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries. The current implementation in ArrayRealVector has a typo:      public double getLInfNorm()          double max = 0;         for (double a : data)              max += Math.max(max Math.abs(a));                  return max;        the += should just be an =. There is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test not a test for correctness). Worse the implementation in OpenMapRealVector is not even positive semi-definite:          public double getLInfNorm()          double max = 0;         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             max += iter.value();                  return max;        I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():    public double getLInfNorm()      double norm = 0;     Iterator<Entry> it = sparseIterator();     Entry e;     while(it.hasNext() && (e = it.next()) != null)        norm = Math.max(norm Math.abs(e.getValue()));          return norm;      Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future.", "A_clean_title": ["getlinfnorm", "get", "inf", "norm", "use", "wrong", "formula", "both", "arrayrealvector", "array", "real", "vector", "openmaprealvector", "open", "map", "real", "vector", "differ", "way", "infin", "norm", "finit", "dimension", "vector", "just", "max", "absolut", "valu", "it", "entri", "current", "implement", "arrayrealvector", "array", "real", "vector", "ha", "typo", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "doubl", "data", "max", "math", "max", "max", "math", "ab", "return", "max", "just", "there", "sadli", "unit", "test", "assur", "us", "that", "thi", "correct", "behavior", "effect", "regress", "onli", "test", "not", "test", "correct", "wors", "implement", "openmaprealvector", "open", "map", "real", "vector", "not", "even", "posit", "semi", "definit", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "max", "iter", "valu", "return", "max", "would", "suggest", "that", "thi", "method", "move", "up", "abstractrealvector", "abstract", "real", "vector", "superclass", "implement", "sparseiter", "spars", "iter", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "norm", "iter", "entri", "it", "sparseiter", "spars", "iter", "entri", "while", "it", "hasnext", "ha", "next", "it", "next", "null", "norm", "math", "max", "norm", "math", "ab", "getvalu", "get", "valu", "return", "norm", "unit", "test", "neg", "valu", "vector", "would", "help", "check", "thi", "kind", "thing", "futur"], "B_title": "Fix ArrayRealVector . getLInfNorm ( ). Added get ( ) method to OpenMapRealVector. ", "B_clean_title": ["fix", "arrayrealvector", "array", "real", "vector", "getlinfnorm", "get", "inf", "norm", "ad", "get", "method", "openmaprealvector", "open", "map", "real", "vector"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix partial constructor to work with joda - time. ", "B_clean_title": ["fix", "partial", "constructor", "work", "joda", "time"]}]