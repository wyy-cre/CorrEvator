[{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added back missing betas. ", "B_clean_title": ["ad", "back", "miss", "beta"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a bug in the patch collection. ", "B_clean_title": ["fix", "bug", "patch", "collect"]},
{"A_title": "MathRuntimeException with simple ebeMultiply on OpenMapRealVectorThe following piece of code  import org.apache.commons.math.linear.OpenMapRealVector; import org.apache.commons.math.linear.RealVector;  public class DemoBugOpenMapRealVector      public static void main(String args)          final RealVector u = new OpenMapRealVector(3 1E-6);         u.setEntry(0 1.);         u.setEntry(1 0.);         u.setEntry(2 2.);         final RealVector v = new OpenMapRealVector(3 1E-6);         v.setEntry(0 0.);         v.setEntry(1 3.);         v.setEntry(2 0.);         System.out.println(u);         System.out.println(v);         System.out.println(u.ebeMultiply(v));         raises an exception  org.apache.commons.math.linear.OpenMapRealVector@7170a9b6 Exception in thread main org.apache.commons.math.MathRuntimeException 6: map has been modified while iterating at org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373) at org.apache.commons.math.util.OpenIntToDoubleHashMap Iterator.advance(OpenIntToDoubleHashMap.java:564) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:1) at DemoBugOpenMapRealVector.main(DemoBugOpenMapRealVector.java:17)", "A_clean_title": ["mathruntimeexcept", "math", "runtim", "except", "simpl", "ebemultipli", "ebe", "multipli", "openmaprealvectorth", "open", "map", "real", "vector", "follow", "piec", "code", "import", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "import", "org", "apach", "common", "math", "linear", "realvector", "real", "vector", "public", "class", "demobugopenmaprealvector", "demo", "bug", "open", "map", "real", "vector", "public", "static", "void", "main", "string", "arg", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "system", "out", "println", "system", "out", "println", "system", "out", "println", "ebemultipli", "ebe", "multipli", "rais", "except", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "7170a9b6", "except", "thread", "main", "org", "apach", "common", "math", "mathruntimeexcept", "math", "runtim", "except", "map", "ha", "been", "modifi", "while", "iter", "at", "org", "apach", "common", "math", "mathruntimeexcept", "createconcurrentmodificationexcept", "math", "runtim", "except", "creat", "concurr", "modif", "except", "mathruntimeexcept", "java:373", "math", "runtim", "except", "at", "org", "apach", "common", "math", "util", "openinttodoublehashmap", "open", "int", "doubl", "hash", "map", "iter", "advanc", "openinttodoublehashmap", "java:564", "open", "int", "doubl", "hash", "map", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:372", "open", "map", "real", "vector", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:1", "open", "map", "real", "vector", "at", "demobugopenmaprealvector", "main", "demo", "bug", "open", "map", "real", "vector", "demobugopenmaprealvector", "java:17", "demo", "bug", "open", "map", "real", "vector"], "B_title": "Fix bug in ebeDivide ( RealVector ). Fix bug in ebeDivide ( ). Updated patch. Fix bug in ebeMultiply ( ). ", "B_clean_title": ["fix", "bug", "ebedivid", "ebe", "divid", "realvector", "real", "vector", "fix", "bug", "ebedivid", "ebe", "divid", "updat", "patch", "fix", "bug", "ebemultipli", "ebe", "multipli"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "fixed bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Fix swapped diffs in patch. ", "B_clean_title": ["fix", "swap", "diff", "patch"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "added missing copy. ", "B_clean_title": ["ad", "miss", "copi"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Add missing import. Fix test. ", "B_clean_title": ["add", "miss", "import", "fix", "test"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . flipIfWarranted ( ) .. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "flipifwarr", "flip", "warrant"]},
{"A_title": "Bugs in RealVector.ebeMultiply(RealVector) and ebeDivide(RealVector)OpenMapRealVector.ebeMultiply(RealVector) and OpenMapRealVector.ebeDivide(RealVector) return wrong values when one entry of the specified RealVector is nan or infinity. The bug is easy to understand. Here is the current implementation of ebeMultiply      public OpenMapRealVector ebeMultiply(RealVector v)          checkVectorDimensions(v.getDimension());         OpenMapRealVector res = new OpenMapRealVector(this);         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             res.setEntry(iter.key() iter.value() * v.getEntry(iter.key()));                  return res;        The assumption is that for any double x x * 0d == 0d holds which is not true. The bug is easy enough to identify but more complex to solve. The only solution I can come up with is to loop through all entries of v (instead of those entries which correspond to non-zero entries of this). Im afraid about performance losses.", "A_clean_title": ["bug", "realvector", "ebemultipli", "real", "vector", "ebe", "multipli", "realvector", "real", "vector", "ebedivid", "ebe", "divid", "realvector", "real", "vector", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "realvector", "real", "vector", "openmaprealvector", "ebedivid", "open", "map", "real", "vector", "ebe", "divid", "realvector", "real", "vector", "return", "wrong", "valu", "when", "one", "entri", "specifi", "realvector", "real", "vector", "nan", "or", "infin", "bug", "easi", "understand", "here", "current", "implement", "ebemultipli", "ebe", "multipli", "public", "openmaprealvector", "open", "map", "real", "vector", "ebemultipli", "ebe", "multipli", "realvector", "real", "vector", "checkvectordimens", "check", "vector", "dimens", "getdimens", "get", "dimens", "openmaprealvector", "open", "map", "real", "vector", "re", "new", "openmaprealvector", "open", "map", "real", "vector", "thi", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "re", "setentri", "set", "entri", "iter", "key", "iter", "valu", "getentri", "get", "entri", "iter", "key", "return", "re", "assumpt", "that", "ani", "doubl", "0d", "0d", "hold", "which", "not", "true", "bug", "easi", "enough", "identifi", "but", "more", "complex", "solv", "onli", "solut", "come", "up", "loop", "through", "all", "entri", "instead", "those", "entri", "which", "correspond", "non", "zero", "entri", "thi", "im", "afraid", "about", "perform", "loss"], "B_title": "  - modified OpenMapRealVector.ebeMultiply() and ebeDivide() to handle special cases  0d * NaN 0d * Infinity 0d / 0d and 0d / NaN.   - added implementation of isNaN() and isInfinite() to SparseRealVectorTest.SparseRealVectorTestImpl in order to allow for testing of OpenMapRealVector.ebeMultiply() and ebeDivide() with mixed types.", "B_clean_title": ["modifi", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "ebedivid", "ebe", "divid", "handl", "special", "case", "0d", "nan", "na", "0d", "infin", "0d", "0d", "0d", "nan", "na", "ad", "implement", "isnan", "na", "isinfinit", "infinit", "sparserealvectortest", "sparserealvectortestimpl", "spars", "real", "vector", "test", "spars", "real", "vector", "test", "impl", "order", "allow", "test", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "ebedivid", "ebe", "divid", "mix", "type"]},
{"A_title": "Ensure there is a max/min valid offsetDateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.", "A_clean_title": ["ensur", "there", "max", "min", "valid", "offsetdatetimezon", "offset", "date", "time", "zone", "not", "appli", "max", "min", "valu", "offset", "howev", "pars", "method", "limit", "23:59", "make", "23:59:59", "999", "maximum"], "B_title": "Ensure there is a max/min valid offset in DateTimeZone", "B_clean_title": ["ensur", "there", "max", "min", "valid", "offset", "datetimezon", "date", "time", "zone"]}]