[{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added missing throws. ", "B_clean_title": ["ad", "miss", "throw"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated imports. Added missing closing parenthesis .. ", "B_clean_title": ["updat", "import", "ad", "miss", "close", "parenthesi"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  --  from NumberUtils . startsWith ( )  it was restricting our. ", "B_clean_title": ["remov", "unnecessari", "numberutil", "number", "util", "startswith", "start", "it", "wa", "restrict", "our"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix 0x mistake in patch. ", "B_clean_title": ["fix", "0x", "mistak", "patch"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "Fixing rat phase. ", "B_clean_title": ["fix", "rat", "phase"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Add null check. ", "B_clean_title": ["add", "null", "check"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing return statement. ", "B_clean_title": ["ad", "miss", "return", "statement"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness functionIf you give large values as lower/upper bounds (for example -Double.MAX_VALUE as a lower bound) the optimizer can call the fitness function with parameters set to NaN.  My guess is this is due to FitnessFunction.encode/decode generating NaN when normalizing/denormalizing parameters.  For example if the difference between the lower and upper bound is greater than Double.MAX_VALUE encode could divide infinity by infinity.", "A_clean_title": ["wide", "bound", "cmaesoptim", "cmae", "optim", "result", "nan", "na", "paramet", "pass", "fit", "functionif", "function", "you", "give", "larg", "valu", "as", "lower", "upper", "bound", "exampl", "doubl", "max", "valu", "as", "lower", "bound", "optim", "call", "fit", "function", "paramet", "set", "nan", "na", "my", "guess", "thi", "due", "fitnessfunct", "fit", "function", "encod", "decod", "gener", "nan", "na", "when", "normal", "denorm", "paramet", "exampl", "differ", "between", "lower", "upper", "bound", "greater", "than", "doubl", "max", "valu", "encod", "could", "divid", "infin", "by", "infin"], "B_title": "Early detection that overflow will occur in the variables normalization procedure (encode method). Warning mentioned in the documentation.", "B_clean_title": ["earli", "detect", "that", "overflow", "will", "occur", "variabl", "normal", "procedur", "encod", "method", "warn", "mention", "document"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add additional heuristic for rare cases in pivotRow selection.", "B_clean_title": ["add", "addit", "heurist", "rare", "case", "pivotrow", "pivot", "row", "select"]}]