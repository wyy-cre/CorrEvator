[{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow L with an exponent or decimal point. ", "B_clean_title": ["allow", "expon", "or", "decim", "point"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "KMeansPlusPlusClusterer copy constructor. ", "B_clean_title": ["kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "copi", "constructor"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added fix. added fix. ", "B_clean_title": ["ad", "fix", "ad", "fix"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added null check in subLine copy. ", "B_clean_title": ["ad", "null", "check", "sublin", "sub", "line", "copi"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Add null check in patch2. ", "B_clean_title": ["add", "null", "check", "patch2"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here"], "B_title": "Add fix from MATH - 657. Fix typo in MATH - 657. ", "B_clean_title": ["add", "fix", "math", "657", "fix", "typo", "math", "657"]},
{"A_title": "Days#daysBetween throw exception for MonthDay with 29 FebruaryIs there a way to avoid this happening? I understand fiddling around with the leap year youre bound to get issues.", "A_clean_title": ["day", "daysbetween", "day", "between", "throw", "except", "monthday", "month", "day", "29", "februaryi", "februari", "there", "way", "avoid", "thi", "happen", "understand", "fiddl", "around", "leap", "year", "your", "bound", "get", "issu"], "B_title": "Days.daysBetween fails for MonthDay", "B_clean_title": ["day", "daysbetween", "day", "between", "fail", "monthday", "month", "day"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fixed missing repair of a point that lies outside the boundaries. Thanks to Frank Hessen for the report and for pinpointing the cause of the problem.", "B_clean_title": ["fix", "miss", "repair", "point", "that", "lie", "outsid", "boundari", "thank", "frank", "hessen", "report", "pinpoint", "caus", "problem"]},
{"A_title": "Dfp Dfp.multiply(int x) does not comply with the general contract FieldElement.multiply(int n)In class org.apache.commons.math3.Dfp  the method multiply(int n) is limited to 0 <= n <= 9999. This is not consistent with the general contract of FieldElement.multiply(int n) where there should be no limitation on the values of n.", "A_clean_title": ["dfp", "dfp", "multipli", "int", "not", "compli", "gener", "contract", "fieldel", "multipli", "field", "element", "int", "class", "org", "apach", "common", "math3", "dfp", "method", "multipli", "int", "limit", "9999", "thi", "not", "consist", "gener", "contract", "fieldel", "multipli", "field", "element", "int", "where", "there", "no", "limit", "valu"], "B_title": "Allow unlimited input values for Dfp#multiply.", "B_clean_title": ["allow", "unlimit", "input", "valu", "dfp", "multipli"]}]