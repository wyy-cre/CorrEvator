[{"A_title": "StopWatch: suspend() acts as split() if followed by stop()In my opinion it is a bug that suspend() acts as split() if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause where time counter doesnt continue. So a following stop()-call shouldnt increase the time counter should it?", "A_clean_title": ["stopwatch", "stop", "watch", "suspend", "act", "as", "split", "follow", "by", "stop", "my", "opinion", "it", "bug", "that", "suspend", "act", "as", "split", "follow", "by", "stop", "see", "below", "stopwatch", "stop", "watch", "sw", "new", "stopwatch", "stop", "watch", "sw", "start", "thread", "sleep", "1000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "2000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "sw", "resum", "thread", "sleep", "3000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "4000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "5000", "sw", "stop", "time", "but", "time", "not", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "suspend", "resum", "like", "paus", "where", "time", "counter", "doesnt", "continu", "so", "follow", "stop", "call", "shouldnt", "increas", "time", "counter", "it"], "B_title": "Fixed bug in StopWatch . stopTime. ", "B_clean_title": ["fix", "bug", "stopwatch", "stop", "watch", "stoptim", "stop", "time"]},
{"A_title": "HypergeometricDistribution.sample suffers from integer overflowHi I have an application which broke when ported from commons math 2.2 to 3.2. It looks like the HypergeometricDistribution.sample() method doesnt work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50.  import org.apache.commons.math3.distribution.HypergeometricDistribution;  public class Foo    public static void main(String args)      HypergeometricDistribution a = new HypergeometricDistribution(         43130568 42976365 50);     System.out.printf(%d %d%n a.getSupportLowerBound() a.getSupportUpperBound()); // Prints 0 50     System.out.printf(%d%na.sample());                                             // Prints -50       In the debugger I traced it as far as an integer overflow in HypergeometricDistribution.getNumericalMean() – instead of doing  return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();   it could do:  return getSampleSize() * ((double) getNumberOfSuccesses() / (double) getPopulationSize());   This seemed to fix it based on a quick test.", "A_clean_title": ["hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "suffer", "integ", "overflowhi", "overflow", "hi", "have", "applic", "which", "broke", "when", "port", "common", "math", "it", "look", "like", "hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "method", "doesnt", "work", "as", "well", "as", "it", "use", "larg", "integ", "valu", "exampl", "code", "below", "return", "sampl", "between", "50", "but", "usual", "return", "50", "import", "org", "apach", "common", "math3", "distribut", "hypergeometricdistribut", "hypergeometr", "distribut", "public", "class", "foo", "public", "static", "void", "main", "string", "arg", "hypergeometricdistribut", "hypergeometr", "distribut", "new", "hypergeometricdistribut", "hypergeometr", "distribut", "43130568", "42976365", "50", "system", "out", "printf", "getsupportlowerbound", "get", "support", "lower", "bound", "getsupportupperbound", "get", "support", "upper", "bound", "print", "50", "system", "out", "printf", "na", "sampl", "print", "50", "debugg", "trace", "it", "as", "far", "as", "integ", "overflow", "hypergeometricdistribut", "getnumericalmean", "hypergeometr", "distribut", "get", "numer", "mean", "instead", "do", "return", "doubl", "getsamples", "get", "sampl", "size", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "it", "could", "return", "getsamples", "get", "sampl", "size", "doubl", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "thi", "seem", "fix", "it", "base", "quick", "test"], "B_title": "Remove extraneous whitespace. ", "B_clean_title": ["remov", "extran", "whitespac"]},
{"A_title": "FastMath.max(50.0f -50.0f) => -50.0f; should be +50.0fFastMath.max(50.0f -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case testMinMaxFloat() because that has a bug too - it tests doubles not floats.", "A_clean_title": ["fastmath", "max", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0ffastmath", "max", "0f", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0f", "thi", "becaus", "wrong", "variabl", "return", "bug", "wa", "not", "detect", "by", "test", "case", "testminmaxfloat", "test", "min", "max", "float", "becaus", "that", "ha", "bug", "too", "it", "test", "doubl", "not", "float"], "B_title": "Fix float . max ( a  b ). ", "B_clean_title": ["fix", "float", "max"]},
{"A_title": "RegulaFalsiSolver failureThe following unit test:  @Test public void testBug()      final UnivariateRealFunction f = new UnivariateRealFunction()              @Override             public double value(double x)                  return Math.exp(x) - Math.pow(Math.PI 3.0);                      ;      UnivariateRealSolver solver = new RegulaFalsiSolver();     double root = solver.solve(100 f 1 10);    fails with  illegal state: maximal count (100) exceeded: evaluations   Using PegasusSolver the answer is found after 17 evaluations.", "A_clean_title": ["regulafalsisolv", "regula", "falsi", "solver", "failureth", "failur", "follow", "unit", "test", "test", "public", "void", "testbug", "test", "bug", "final", "univariaterealfunct", "univari", "real", "function", "new", "univariaterealfunct", "univari", "real", "function", "overrid", "public", "doubl", "valu", "doubl", "return", "math", "exp", "math", "pow", "math", "pi", "univariaterealsolv", "univari", "real", "solver", "solver", "new", "regulafalsisolv", "regula", "falsi", "solver", "doubl", "root", "solver", "solv", "100", "10", "fail", "illeg", "state", "maxim", "count", "100", "exceed", "evalu", "pegasussolv", "pegasu", "solver", "answer", "found", "after", "17", "evalu"], "B_title": "Fix renegation of base secant solver .. ", "B_clean_title": ["fix", "reneg", "base", "secant", "solver"]},
{"A_title": "RegulaFalsiSolver failureThe following unit test:  @Test public void testBug()      final UnivariateRealFunction f = new UnivariateRealFunction()              @Override             public double value(double x)                  return Math.exp(x) - Math.pow(Math.PI 3.0);                      ;      UnivariateRealSolver solver = new RegulaFalsiSolver();     double root = solver.solve(100 f 1 10);    fails with  illegal state: maximal count (100) exceeded: evaluations   Using PegasusSolver the answer is found after 17 evaluations.", "A_clean_title": ["regulafalsisolv", "regula", "falsi", "solver", "failureth", "failur", "follow", "unit", "test", "test", "public", "void", "testbug", "test", "bug", "final", "univariaterealfunct", "univari", "real", "function", "new", "univariaterealfunct", "univari", "real", "function", "overrid", "public", "doubl", "valu", "doubl", "return", "math", "exp", "math", "pow", "math", "pi", "univariaterealsolv", "univari", "real", "solver", "solver", "new", "regulafalsisolv", "regula", "falsi", "solver", "doubl", "root", "solver", "solv", "100", "10", "fail", "illeg", "state", "maxim", "count", "100", "exceed", "evalu", "pegasussolv", "pegasu", "solver", "answer", "found", "after", "17", "evalu"], "B_title": "Fix the case for renegation in BaseSecantSolver. ", "B_clean_title": ["fix", "case", "reneg", "basesecantsolv", "base", "secant", "solver"]},
{"A_title": "RegulaFalsiSolver failureThe following unit test:  @Test public void testBug()      final UnivariateRealFunction f = new UnivariateRealFunction()              @Override             public double value(double x)                  return Math.exp(x) - Math.pow(Math.PI 3.0);                      ;      UnivariateRealSolver solver = new RegulaFalsiSolver();     double root = solver.solve(100 f 1 10);    fails with  illegal state: maximal count (100) exceeded: evaluations   Using PegasusSolver the answer is found after 17 evaluations.", "A_clean_title": ["regulafalsisolv", "regula", "falsi", "solver", "failureth", "failur", "follow", "unit", "test", "test", "public", "void", "testbug", "test", "bug", "final", "univariaterealfunct", "univari", "real", "function", "new", "univariaterealfunct", "univari", "real", "function", "overrid", "public", "doubl", "valu", "doubl", "return", "math", "exp", "math", "pow", "math", "pi", "univariaterealsolv", "univari", "real", "solver", "solver", "new", "regulafalsisolv", "regula", "falsi", "solver", "doubl", "root", "solver", "solv", "100", "10", "fail", "illeg", "state", "maxim", "count", "100", "exceed", "evalu", "pegasussolv", "pegasu", "solver", "answer", "found", "after", "17", "evalu"], "B_title": "Fix a bug in the patch .. ", "B_clean_title": ["fix", "bug", "patch"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix the bug in Hercules . fixed. Fix the bug in Hercules .. ", "B_clean_title": ["fix", "bug", "hercul", "fix", "fix", "bug", "hercul"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix an NPE in StrBuilder . toString ( ). ", "B_clean_title": ["fix", "npe", "strbuilder", "str", "builder", "tostr", "string"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Improved the garbage collection profile of TwoDimTableau .. ", "B_clean_title": ["improv", "garbag", "collect", "profil", "twodimtableau", "two", "dim", "tableau"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Fixed epsilon. ", "B_clean_title": ["fix", "epsilon"]}]