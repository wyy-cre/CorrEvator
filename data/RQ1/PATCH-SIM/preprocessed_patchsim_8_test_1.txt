[{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "long not int ( not long ). ", "B_clean_title": ["long", "not", "int", "not", "long"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "Fix warning. ", "B_clean_title": ["fix", "warn"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix post - release build. ", "B_clean_title": ["fix", "post", "releas", "build"]},
{"A_title": "DateUtils.isSameLocalTime does not work correctHi I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)", "A_clean_title": ["dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "not", "work", "correcthi", "correct", "hi", "think", "found", "bug", "dateutil", "date", "util", "class", "method", "issamelocaltim", "same", "local", "time", "exampl", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297364400000l", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297321200000l", "assert", "assertfals", "assert", "fals", "dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "thi", "becaus", "method", "compar", "cal1", "get", "calendar", "hour", "cal2", "get", "calendar", "hour", "but", "think", "it", "ha", "cal1", "get", "calendar", "hour", "day", "cal2", "get", "calendar", "hour", "day"], "B_title": "Fixed fall through in DateUtils . java. ", "B_clean_title": ["fix", "fall", "through", "dateutil", "date", "util", "java"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "(second take). Best point must be returned.", "B_clean_title": ["second", "take", "best", "point", "must", "return"]},
{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fix DateTimeFormatter.parseInto() where it obtains the default year", "B_clean_title": ["fix", "datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "where", "it", "obtain", "default", "year"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Use modified Lentz-Thompson algorithm for continued fraction evaluation.", "B_clean_title": ["use", "modifi", "lentz", "thompson", "algorithm", "continu", "fraction", "evalu"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "Patch applied to fix the overflow issue.", "B_clean_title": ["patch", "appli", "fix", "overflow", "issu"]},
{"A_title": "DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hourDateTimeZone.forOffsetHoursMinutes(hm) cannot handle negative offset < 1 hour like -0:30 due to argument range checking. I used forOffsetMillis() instead.  This should probably be mentioned in the documentation or negative minutes be accepted.", "A_clean_title": ["datetimezon", "foroffsethoursminut", "date", "time", "zone", "offset", "hour", "minut", "not", "handl", "neg", "offset", "hourdatetimezon", "foroffsethoursminut", "hour", "date", "time", "zone", "offset", "hour", "minut", "hm", "not", "handl", "neg", "offset", "hour", "like", "0:30", "due", "argument", "rang", "check", "use", "foroffsetmilli", "offset", "milli", "instead", "thi", "probabl", "mention", "document", "or", "neg", "minut", "accept"], "B_title": "Fix to allow offsets from -00:01 to -00:59", "B_clean_title": ["fix", "allow", "offset", "00:01", "00:59"]},
{"A_title": "CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval 01.  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "bound", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "when", "fit", "bound", "cmaesoptim", "cmae", "optim", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "thi", "becaus", "it", "intern", "map", "fit", "paramet", "rang", "into", "interv", "01", "unit", "least", "precis", "ulp", "between", "float", "point", "number", "much", "smaller", "near", "zero", "than", "near", "one", "thu", "fit", "have", "much", "better", "resolut", "near", "lower", "bound", "which", "map", "zero", "than", "upper", "bound", "which", "map", "one", "will", "attach", "exampl", "program", "demonstr"], "B_title": "Modified encode and decode methods. Unit test testFitAccuracyDependsOnBoundary now passes and is thus enabled. Unit test testConstrainedRosen had to be modified in order to not fail with the new code (starting point is set closer to the solution).", "B_clean_title": ["modifi", "encod", "decod", "method", "unit", "test", "testfitaccuracydependsonboundari", "test", "fit", "accuraci", "depend", "boundari", "now", "pass", "thu", "enabl", "unit", "test", "testconstrainedrosen", "test", "constrain", "rosen", "had", "modifi", "order", "not", "fail", "new", "code", "start", "point", "set", "closer", "solut"]}]