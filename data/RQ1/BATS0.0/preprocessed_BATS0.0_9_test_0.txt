[{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Stop appending extra characters .. ", "B_clean_title": ["stop", "append", "extra", "charact"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Don  t compare string builders to buffer length - trailing space .. ", "B_clean_title": ["don", "compar", "string", "builder", "buffer", "length", "trail", "space"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "StrBuilder . indexOf ( String ) uses reflection to improve matching of substrings. Add more ensureCapacity ( ) for string builder. ", "B_clean_title": ["strbuilder", "str", "builder", "indexof", "index", "string", "use", "reflect", "improv", "match", "substr", "add", "more", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "StrBuilder . indexOf ( String ) uses reflection to improve matching of substrings. Add ensureCapacity ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "indexof", "index", "string", "use", "reflect", "improv", "match", "substr", "add", "ensurecapac", "ensur", "capac"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "StrBuilder . indexOf ( String ) uses buffer . length - > string . length. Add more ensureCapacity ( ) .. ", "B_clean_title": ["strbuilder", "str", "builder", "indexof", "index", "string", "use", "buffer", "length", "string", "length", "add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "StrBuilder . indexOf ( String ) uses buffer . length - > string . length. Add more ensureCapacity .. ", "B_clean_title": ["strbuilder", "str", "builder", "indexof", "index", "string", "use", "buffer", "length", "string", "length", "add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Set nullText before deleting characters. remove startIndex. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "set", "nulltext", "null", "text", "befor", "delet", "charact", "remov", "startindex", "start", "index", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Fix NPE triggered by nullText .. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "fix", "npe", "trigger", "by", "nulltext", "null", "text", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Fix StrBuilder . length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "fix", "strbuilder", "str", "builder", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . deleteFirst ( ) can delete empty strings if buffer . length == 0. ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "deletefirst", "delet", "first", "delet", "empti", "string", "buffer", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Add patch for StringBuilder . appendNull ( ). StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "add", "patch", "stringbuild", "string", "builder", "appendnul", "append", "null", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. remove startIndex. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "remov", "startindex", "start", "index", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Fix buffer handling. ", "B_clean_title": ["add", "miss", "append", "patch", "fix", "buffer", "handl"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Add more ensureCapacity .. StrBuilder . length ( ) now uses size - > int. ", "B_clean_title": ["add", "miss", "append", "patch", "add", "more", "ensurecapac", "ensur", "capac", "strbuilder", "str", "builder", "length", "now", "use", "size", "int"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "set nullText to null on delete ( ). Add missing append ( ) patch. Fix buffer handling. ", "B_clean_title": ["set", "nulltext", "null", "text", "null", "delet", "add", "miss", "append", "patch", "fix", "buffer", "handl"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. set nullText if it is not null. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "set", "nulltext", "null", "text", "it", "not", "null", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . deleteFirst ( ) now uses char  instead of char   .. StrBuilder . length - strLen = size ; patched. ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "deletefirst", "delet", "first", "now", "use", "char", "instead", "char", "strbuilder", "str", "builder", "length", "strlen", "str", "len", "size", "patch"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . deleteFirst ( ) uses buffer . length - > string . length ( ). StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "deletefirst", "delet", "first", "use", "buffer", "length", "string", "length", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Add more ensureCapacity .. StrBuilder . length - strLen = size ; patched. ", "B_clean_title": ["add", "miss", "append", "patch", "add", "more", "ensurecapac", "ensur", "capac", "strbuilder", "str", "builder", "length", "strlen", "str", "len", "size", "patch"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. StrBuilder . length - strLen = size ; patched. ", "B_clean_title": ["add", "miss", "append", "patch", "strbuilder", "str", "builder", "length", "strlen", "str", "len", "size", "patch"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Fix StrBuilder . length ( ). ", "B_clean_title": ["fix", "strbuilder", "str", "builder", "length"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Add missing append ( ) patch. Set nullText before deleting characters. StrBuilder patched length ( ). ", "B_clean_title": ["add", "miss", "append", "patch", "set", "nulltext", "null", "text", "befor", "delet", "charact", "strbuilder", "str", "builder", "patch", "length"]},
{"A_title": "Brent solver returns the wrong value if either bracket endpoint is rootThe solve(final UnivariateRealFunction f final double min final double max final double initial) function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max.", "A_clean_title": ["brent", "solver", "return", "wrong", "valu", "either", "bracket", "endpoint", "rootth", "root", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "function", "return", "ymin", "min", "or", "ymax", "max", "min", "or", "max", "are", "deem", "root", "respect", "instead", "min", "or", "max"], "B_title": "Fix the bit between the two functions. ", "B_clean_title": ["fix", "bit", "between", "two", "function"]},
{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "Added a null check. Allow null to be added to the arrayUtils constructor. adding @@. ", "B_clean_title": ["ad", "null", "check", "allow", "null", "ad", "arrayutil", "array", "util", "constructor", "ad"]},
{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "Added missing throw in patch192. added missing throwing check. ", "B_clean_title": ["ad", "miss", "throw", "patch192", "ad", "miss", "throw", "check"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "allow trailing comma in NumberUtils. ", "B_clean_title": ["allow", "trail", "comma", "numberutil", "number", "util"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Fix compiler warning. ", "B_clean_title": ["fix", "compil", "warn"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Added missing semicolon. ", "B_clean_title": ["ad", "miss", "semicolon"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Added test to check for same point vector. ", "B_clean_title": ["ad", "test", "check", "same", "point", "vector"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "added test for point equals and otherPoint. ", "B_clean_title": ["ad", "test", "point", "equal", "otherpoint", "other", "point"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Fix typo in KMeansPlusPlusClusterer . java. ", "B_clean_title": ["fix", "typo", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "java"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "fixed bug in point comparison. ", "B_clean_title": ["fix", "bug", "point", "comparison"]},
{"A_title": "Fix case-insensitive string handlingString.to*Case() is locale-sensitive this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.", "A_clean_title": ["fix", "case", "insensit", "string", "handlingstr", "handl", "string", "case", "local", "sensit", "thi", "usual", "not", "intend", "case", "insensit", "comparis", "pleas", "see", "common", "bug", "detail"], "B_title": "fixed StringUtils . containsIgnoreCase ( ). ", "B_clean_title": ["fix", "stringutil", "string", "util", "containsignorecas", "contain", "ignor", "case"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Fix NPE in Line . intersection ( ). ", "B_clean_title": ["fix", "npe", "line", "intersect"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix CMAESOptimizer  s min max value .. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "min", "max", "valu"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "remove maxiterations as it is not compatible with Java 8. ", "B_clean_title": ["remov", "maxiter", "as", "it", "not", "compat", "java"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix inline with OE. ", "B_clean_title": ["fix", "inlin", "oe"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix double - precision opengl operation. ", "B_clean_title": ["fix", "doubl", "precis", "opengl", "oper"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Use 16000 as lambda. ", "B_clean_title": ["use", "16000", "as", "lambda"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "revert change to hercules fixed bug. remove superfluous call to null inputSigma. ", "B_clean_title": ["revert", "chang", "hercul", "fix", "bug", "remov", "superflu", "call", "null", "inputsigma", "input", "sigma"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix direct msampling to benefit from diagD = diag ( x  i ). ", "B_clean_title": ["fix", "direct", "msampl", "benefit", "diagd", "diag", "diag"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Update the CMAESOptimizer  s lambda function to the same value as the input array  with. ", "B_clean_title": ["updat", "cmaesoptim", "cmae", "optim", "lambda", "function", "same", "valu", "as", "input", "array"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix CMAESOptimizer log101 .. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "log101"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Remove erroneous loop. ", "B_clean_title": ["remov", "erron", "loop"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "CACHE_DIRECT_MODE = 100 ; LPS - 77383 Remove interm. ", "B_clean_title": ["cach", "direct", "mode", "100", "lp", "77383", "remov", "interm"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Remove intermittent inverse of x. ", "B_clean_title": ["remov", "intermitt", "invers"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix CMAESOptimizer  s fix. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "fix"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix CMAESOptimizer  s value range .. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "valu", "rang"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "CACHE_NON_CONSTANTS_TO_LOGICAL - 1216. ", "B_clean_title": ["cach", "non", "constant", "logic", "1216"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fix CMAESOptimizer  s line ending. ", "B_clean_title": ["fix", "cmaesoptim", "cmae", "optim", "line", "end"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "cmAESOptimizer now uses the max iterations. ", "B_clean_title": ["cmaesoptim", "cm", "ae", "optim", "now", "use", "max", "iter"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Improved nullability in CategoryItemRenderer. ", "B_clean_title": ["improv", "nullabl", "categoryitemrender", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix CategoryItemRenderer to handle non - null datasets. ", "B_clean_title": ["fix", "categoryitemrender", "categori", "item", "render", "handl", "non", "null", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null pointer check in Kali_Defects4J_Chart_1 .. ", "B_clean_title": ["fix", "null", "pointer", "check", "kali", "defects4j", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null pointer check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "null", "pointer", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix CategoryItemRenderer . getDataset ( ) to return the first result. ", "B_clean_title": ["fix", "categoryitemrender", "categori", "item", "render", "getdataset", "get", "dataset", "return", "first", "result"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null pointer check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "null", "pointer", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability assertion in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "nullabl", "assert", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix legend item legend generation. ", "B_clean_title": ["fix", "legend", "item", "legend", "gener"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability note in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "nullabl", "note", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null checking in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability note in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "nullabl", "note", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category item label generator on initial refresh .. ", "B_clean_title": ["fix", "categori", "item", "label", "gener", "initi", "refresh"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant return statement. ", "B_clean_title": ["remov", "redund", "return", "statement"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove unnecessary check for null dataset. ", "B_clean_title": ["remov", "unnecessari", "check", "null", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category item renderer to reset the counts as well. ", "B_clean_title": ["fix", "categori", "item", "render", "reset", "count", "as", "well"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category item renderer to save row count in case of data series changes. ", "B_clean_title": ["fix", "categori", "item", "render", "save", "row", "count", "case", "data", "seri", "chang"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix background annotations for category items. ", "B_clean_title": ["fix", "background", "annot", "categori", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Allow null dataset in chart. ", "B_clean_title": ["allow", "null", "dataset", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix x axis issue. Fix NPE in CategoryPlot. Fix NPE in chart impl. ", "B_clean_title": ["fix", "axi", "issu", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart", "impl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix bug. ", "B_clean_title": ["remov", "null", "check", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix category plot backgrounds. Remove fireChangeEvent ( ) from CategoryPlot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "categori", "plot", "background", "remov", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix fireChangeEvent. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "1862", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Fix CategoryPlot  s renderer. Fix bug. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix CategoryPlot  s renderers. Fix bug. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "bug", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend  s location .. ", "B_clean_title": ["remov", "null", "check", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "legend", "locat"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "remov", "redund", "code", "fix", "issu", "domain", "axi", "not", "be", "chang", "by", "end", "categor", "axe", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Fix # 183. Remove a couple of unused files. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1862", "fix", "183", "remov", "coupl", "unus", "file"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Extend CategoryPlot to remove listener from the existing renderer. Fix issue with the axes configuration for the year century .. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "extend", "categoryplot", "categori", "plot", "remov", "listen", "exist", "render", "fix", "issu", "axe", "configur", "year", "centuri", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix option selection on CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "option", "select", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Remove fireChangeEvent ( ) from CategoryPlot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "remov", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix label positionning. Fix pull request. Fix # 1664. ", "B_clean_title": ["fix", "label", "posit", "fix", "pull", "request", "fix", "1664"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix a bug in CategoryPlot. Remove redundant code. Fix bug. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Added patch to defects4J_Chart_1. Fix # 1862. remove 1677 from category plot. ", "B_clean_title": ["ad", "patch", "defects4j", "chart", "fix", "1862", "remov", "1677", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add urlText to category items renderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. ", "B_clean_title": ["add", "urltext", "url", "text", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix label positionning. Fix # 1862. Remove redundant code. remove 1673 from category plot. ", "B_clean_title": ["fix", "label", "posit", "fix", "1862", "remov", "redund", "code", "remov", "1673", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Added missing patch. Remove redundant code. Fix issue with wrong range axis size. ", "B_clean_title": ["fix", "npe", "chart", "ad", "miss", "patch", "remov", "redund", "code", "fix", "issu", "wrong", "rang", "axi", "size"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove redundant code. Fix # 183. Fix issues with the categs spines plot. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "183", "fix", "issu", "categ", "spine", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Remove null check in place. ", "B_clean_title": ["remov", "redund", "code", "remov", "redund", "call", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. Remove unused variable. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "bug", "remov", "unus", "variabl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "definit", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed redundant call to setRenderer ( ). Fix bug. ", "B_clean_title": ["remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "call", "setrender", "set", "render", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add barBase and line to result. Fix NPE in CategoryPlot. Remove redundant code. Fix minor eclipse compile warning. ", "B_clean_title": ["add", "barbas", "bar", "base", "line", "result", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "minor", "eclips", "compil", "warn"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. Fix a bug in CategoryPlot. Remove redundant code. Fix issue with  add domain axis  method. ", "B_clean_title": ["remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "add", "domain", "axi", "method"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with the axes function not being re - added. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "axe", "function", "not", "be", "re", "ad", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Improved null pointer check in CategoryItemRenderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. ", "B_clean_title": ["improv", "null", "pointer", "check", "categoryitemrender", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix bug. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "fix", "bug", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix # 1862. throw exception if index is negative. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1862", "throw", "except", "index", "neg"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix issue with defects4J_Chart_1 .. Remove some trailing whitespace. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "issu", "defects4j", "chart", "remov", "some", "trail", "whitespac"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis not being changed by the user. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "domain", "axi", "not", "be", "chang", "by", "user"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix # 1862. Fix bug. ", "B_clean_title": ["remov", "null", "check", "fix", "1862", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix issue with domain axis selection. Remove null check. ", "B_clean_title": ["remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix # 1862. Fix bug. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "1862", "fix", "bug", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1336. Fix # 1862. Fix category axis. Fix category axes. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1336", "fix", "1862", "fix", "categori", "axi", "fix", "categori", "axe", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove potential NPE in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. ", "B_clean_title": ["remov", "potenti", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1796. remove 1675 from category plot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1796", "remov", "1675", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add urlText to category items renderer patch. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set range zero baseline stroke. ", "B_clean_title": ["add", "urltext", "url", "text", "categori", "item", "render", "patch", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "rang", "zero", "baselin", "stroke"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Remove redundant code. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Remove redundant code. Fix issue with defects 4J calendar plugin. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1862", "remov", "redund", "code", "fix", "issu", "defect", "4j", "calendar", "plugin"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 183. Remove redundant code. ", "B_clean_title": ["fix", "npe", "chart", "fix", "183", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove some redundant lines. Fix # 1862. ", "B_clean_title": ["remov", "some", "redund", "line", "fix", "1862"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix bug. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix a problem with the axes. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "problem", "axe", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with the legend  s X axis .. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "legend", "axi", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix year for data set domain axis. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "year", "data", "set", "domain", "axi", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. remove 1679 from category plot. ", "B_clean_title": ["fix", "npe", "chart", "remov", "1679", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix a potential NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "potenti", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "definit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix # 183. Remove redundant code. Fix issue with  add domain axis  method. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "183", "remov", "redund", "code", "fix", "issu", "add", "domain", "axi", "method"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix issue with data set range zero baseline stroke. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "fix", "issu", "data", "set", "rang", "zero", "baselin", "stroke"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Added fix for NPE in CategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "ad", "fix", "npe", "categoryitemrender", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Fix bug. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1349", "fix", "bug", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix # 1862. Fix issue with wrong parameter name. ", "B_clean_title": ["remov", "null", "check", "fix", "1862", "fix", "issu", "wrong", "paramet", "name"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove 1355 from CategoryPlot. Remove redundant code. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "1355", "categoryplot", "categori", "plot", "remov", "redund", "code", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix fireChangeEvent. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "firechangeev", "fire", "chang", "event", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix # 183. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "183", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with defects plot 1. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "defect", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix label positionning. ", "B_clean_title": ["remov", "redund", "code", "fix", "label", "posit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix issue with the legend  s X axis .. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "issu", "legend", "axi", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["remov", "redund", "code", "remov", "redund", "call", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a potential NPE in CategoryPlot. Fix NPE in CategoryPlot. Fix category axes. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "potenti", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "fix", "categori", "axe", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Fix PR # 1674. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "pr", "1674", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Remove null check. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix legend generation. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "legend", "gener"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "local", "variabl", "warn", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axis location .. Fix NPE in chart 1. ", "B_clean_title": ["fix", "categori", "axi", "locat", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1349", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix # 1359. Remove redundant code. Fix NPE in CategoryPlot. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "1359", "remov", "redund", "code", "fix", "npe", "categoryplot", "categori", "plot", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1660. Remove 1672 from CategoryPlot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1660", "remov", "1672", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix pull request. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1862. Fix issue with same dataset .. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "fix", "issu", "same", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove unused variable .. Fix bug. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "unus", "variabl", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix change in CategoryPlot. Add urlText to category items renderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "chang", "categoryplot", "categori", "plot", "add", "urltext", "url", "text", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix bug. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "1862", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 183. Fix issue with defects4J_Chart_1 .. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "183", "fix", "issu", "defects4j", "chart", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix null label in CategoryPlot. Require index < 0 .. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1862", "fix", "null", "label", "categoryplot", "categori", "plot", "requir", "index", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix issue with first plot using patch. Remove null check in place. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "issu", "first", "plot", "patch", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix CategoryPlot  s renderers. Fix issue with data set selection. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "issu", "data", "set", "select", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix fireChangeEvent. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove null check. ", "B_clean_title": ["remov", "redund", "code", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix CategoryPlot  s renderers. Fix issue with the axes configuration for the year century .. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "issu", "axe", "configur", "year", "centuri", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix bug. ", "B_clean_title": ["remov", "null", "check", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "remov", "redund", "code", "fix", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col", "col"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add urlText to category item renderer. Fix NPE in CategoryPlot. Remove redundant code. Fix bug. ", "B_clean_title": ["add", "urltext", "url", "text", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Remove redundant call. Fix null label in CategoryPlot. Require index < 0 .. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "remov", "redund", "call", "fix", "null", "label", "categoryplot", "categori", "plot", "requir", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Added patch for domain axis generation. Fix category gridline position .. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "ad", "patch", "domain", "axi", "gener", "fix", "categori", "gridlin", "posit", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with chart 1 .. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "chart", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix a bug in CategoryPlot. Fix option selection for CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "bug", "categoryplot", "categori", "plot", "fix", "option", "select", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix build. Remove redundant code. Fix fireChangeEvent. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "build", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Fix local testing. Remove spurious return value. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "fix", "local", "test", "remov", "spuriou", "return", "valu"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed redundant call to setRenderer ( ). Fix issue with the legend  s X axis .. ", "B_clean_title": ["remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "call", "setrender", "set", "render", "fix", "issu", "legend", "axi"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix getDataset ( ). Fix # 1862. Remove redundant code. remove 1674 from category plot. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "getdataset", "get", "dataset", "fix", "1862", "remov", "redund", "code", "remov", "1674", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix category axes. Fix # 1718. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "categori", "axe", "fix", "1718", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 183. Remove redundant code. Fix issue with chart 1 .. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "183", "remov", "redund", "code", "fix", "issu", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. Fix category plot index calculation .. ", "B_clean_title": ["remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "bug", "fix", "categori", "plot", "index", "calcul"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix bug in CategoryPlot. Remove redundant code. Fix issue with  add domain axis  method. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "bug", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "add", "domain", "axi", "method"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix # 1862. Remove redundant code. added notify listener. ", "B_clean_title": ["remov", "null", "check", "fix", "1862", "remov", "redund", "code", "ad", "notifi", "listen"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix fire sale. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "fire", "sale"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. remove 1677 from range axes. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "1677", "rang", "axe", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Added datasetChanged ( ) method to CategoryPlot. Remove redundant code. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "method", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix NPE in CategoryPlot. Fix # 1864. ", "B_clean_title": ["remov", "null", "check", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1864"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix issue with  GenProg_Defects4J_Chart_1 . Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "redund", "code", "fix", "issu", "genprog", "defects4j", "chart", "gen", "prog", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix bug. ", "B_clean_title": ["remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "call", "remov", "redund", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend  s X axis .. ", "B_clean_title": ["remov", "null", "check", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "legend", "axi"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "added datasetChanged ( ) to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant line. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "line", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "1862", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 1862. Fix issue with domain axis selection. ", "B_clean_title": ["fix", "npe", "chart", "fix", "1862", "fix", "issu", "domain", "axi", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data range selection. Fix 1349. ", "B_clean_title": ["fix", "categori", "data", "rang", "select", "fix", "1349"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "definit", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Removed redundant call to setRenderer ( ). Fix pull request. ", "B_clean_title": ["remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "call", "setrender", "set", "render", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Remove redundant code. Fix fireChangeEvent. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix legend generation. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "legend", "gener"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. Remove redundant fireChangeEvent ( ) call. ", "B_clean_title": ["remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "remov", "redund", "firechangeev", "fire", "chang", "event", "call"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check. Fix crosshair renderers. ", "B_clean_title": ["remov", "null", "check", "fix", "crosshair", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix legend. Fix NPE in CategoryPlot. Fix change in CategoryPlot. ", "B_clean_title": ["fix", "legend", "fix", "npe", "categoryplot", "categori", "plot", "fix", "chang", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Added datasetChanged ( ) method to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "method", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove some trailing whitespace. ", "B_clean_title": ["remov", "redund", "code", "remov", "some", "trail", "whitespac"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 183. Remove redundant code. Fix issue with  add domain axis  method. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "183", "remov", "redund", "code", "fix", "issu", "add", "domain", "axi", "method"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with  CategoryPlot  axis. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "issu", "categoryplot", "categori", "plot", "axi", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with wrong param. Remove some trailing whitespace. ", "B_clean_title": ["fix", "issu", "wrong", "param", "remov", "some", "trail", "whitespac"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1213. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1213"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Fix build. Remove redundant code. Fix bug. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "fix", "build", "remov", "redund", "code", "fix", "bug", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix fireChangeEvent. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "firechangeev", "fire", "chang", "event", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "domain", "axi", "not", "be", "chang", "by", "end", "categor", "axe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. remove 1677 from category plot. Remove some redundant lines. ", "B_clean_title": ["fix", "1862", "remov", "1677", "categori", "plot", "remov", "some", "redund", "line"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Fix local variable warning. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "local", "variabl", "warn", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 183. Fix category plot not listening to the existing renderer. Fix category axis fire. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["fix", "183", "fix", "categori", "plot", "not", "listen", "exist", "render", "fix", "categori", "axi", "fire", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Remove fireChangeEvent ( ) from CategoryPlot. ", "B_clean_title": ["fix", "npe", "chart", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "remov", "firechangeev", "fire", "chang", "event", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. ", "B_clean_title": ["remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with  add domain axis  method. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "add", "domain", "axi", "method", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not used .. ", "B_clean_title": ["fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "some", "line", "that", "were", "not", "use"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix pull request. Fix newline. Fix NPE in chart 1. ", "B_clean_title": ["fix", "pull", "request", "fix", "newlin", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with CategoryPlot . setDataset ( int  CategoryDataset ). Fix NPE in chart 1. ", "B_clean_title": ["fix", "issu", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "int", "categorydataset", "categori", "dataset", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix NPE in CategoryPlot . setDataset ( ). Fix # 183. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "183"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix null label in CategoryPlot. Require index < 0 .. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "null", "label", "categoryplot", "categori", "plot", "requir", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1336. Fix # 1862. Fix CategoryPlot  s renderer. Fix bug. Fix issue with wrong dataset index. ", "B_clean_title": ["fix", "1336", "fix", "1862", "fix", "categoryplot", "categori", "plot", "render", "fix", "bug", "fix", "issu", "wrong", "dataset", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix issue with chart 1 .. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "issu", "chart", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Remove redundant code. Fix NPE in CategoryPlot. Fix category chart demo .. ", "B_clean_title": ["fix", "1349", "remov", "redund", "code", "fix", "npe", "categoryplot", "categori", "plot", "fix", "categori", "chart", "demo"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot . setDataset ( ). Fix # 1862. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "1862", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. remove 1674 from category plot. Remove null check. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "remov", "1674", "categori", "plot", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with the axes configuration for today  s CategoryPlot. Remove unused variable. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "axe", "configur", "today", "categoryplot", "categori", "plot", "remov", "unus", "variabl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not left unlinked  fixed opengl opengl opengl opengl opengl opengl opengl opengl. ", "B_clean_title": ["remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "remov", "some", "line", "that", "were", "not", "left", "unlink", "fix", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl", "opengl"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add urlText to category item renderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. ", "B_clean_title": ["add", "urltext", "url", "text", "categori", "item", "render", "fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "issu", "data", "set", "definit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "local", "variabl", "warn", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Remove 1679 from CategoryPlot. Fix label positionning. ", "B_clean_title": ["remov", "redund", "code", "remov", "1679", "categoryplot", "categori", "plot", "fix", "label", "posit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a potential NPE in CategoryPlot. Fix # 1862. Fix bug. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "potenti", "npe", "categoryplot", "categori", "plot", "fix", "1862", "fix", "bug", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Remove redundant code. Fix category axis location .. ", "B_clean_title": ["fix", "npe", "chart", "remov", "redund", "code", "fix", "categori", "axi", "locat"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix # 183. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "183", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "1862", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "throw exception if index is negative. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["throw", "except", "index", "neg", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "1862", "remov", "redund", "code", "fix", "issu", "domain", "axi", "select", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix category axis registration. Remove null check. ", "B_clean_title": ["fix", "1862", "fix", "categori", "axi", "registr", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix pull request. Remove urlText from AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "remov", "redund", "code", "fix", "pull", "request", "remov", "urltext", "url", "text", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Fix NPE in chart 1. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1862. Remove redundant code. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1862", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 183. Fix # 1673. ", "B_clean_title": ["fix", "npe", "chart", "fix", "183", "fix", "1673"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. throw exception if index is negative. Remove null check. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "throw", "except", "index", "neg", "remov", "null", "check"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix 1349. Fix legend generation. Fix NPE in chart 1. ", "B_clean_title": ["fix", "1349", "fix", "legend", "gener", "fix", "npe", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove redundant code. Fix bug. Remove urlText = null in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "redund", "code", "fix", "bug", "remov", "urltext", "url", "text", "null", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove unused variable .. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "remov", "unus", "variabl", "fix", "issu", "domain", "axi", "select", "remov", "null", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in chart 1. Fix # 183. Remove redundant code. Fix legend generation. ", "B_clean_title": ["fix", "npe", "chart", "fix", "183", "remov", "redund", "code", "fix", "legend", "gener"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Added throw exception if index < 0. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "ad", "throw", "except", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data renderer NPE. Fix # 1862. ", "B_clean_title": ["fix", "categori", "data", "render", "npe", "fix", "1862"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). ", "B_clean_title": ["remov", "null", "check", "place", "fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix NPE in CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "npe", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "remove deprecated fireChangeEvent. Remove null check in place. ", "B_clean_title": ["remov", "deprec", "firechangeev", "fire", "chang", "event", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1796. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1796"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. ", "B_clean_title": ["fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Add a note that the datasets are no longer used .. ", "B_clean_title": ["remov", "null", "check", "place", "add", "note", "that", "dataset", "are", "no", "longer", "use"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix chart otp .. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "chart", "otp", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data renderer NPE. Fix previous patch. ", "B_clean_title": ["fix", "categori", "data", "render", "npe", "fix", "previou", "patch"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix # 1349. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1349"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. @@ 1355 removed redundant call. ", "B_clean_title": ["remov", "null", "check", "place", "1355", "remov", "redund", "call"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix pull request. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category plot annoyances. Fix issue with wrong fireChangeEvent. Remove null check in place. ", "B_clean_title": ["fix", "categori", "plot", "annoy", "fix", "issu", "wrong", "firechangeev", "fire", "chang", "event", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "@@ 1355 removed redundant call. Fix category data renderer NPE. ", "B_clean_title": ["1355", "remov", "redund", "call", "fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove redundant code. Fix Eclipse. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "redund", "code", "fix", "eclips", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with chart  s foreground domain marker removal. Fix crosshair index for chart 1 .. Fix category data renderer NPE. ", "B_clean_title": ["fix", "issu", "chart", "foreground", "domain", "marker", "remov", "fix", "crosshair", "index", "chart", "fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix pull request. Remove null check in place. ", "B_clean_title": ["fix", "pull", "request", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix pull request. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "@@ 1355 removed dataset . addChangeListener ( ). Fix issue with previous pull request .. Fix category data renderer NPE. ", "B_clean_title": ["1355", "remov", "dataset", "addchangelisten", "add", "chang", "listen", "fix", "issu", "previou", "pull", "request", "fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix minor axes disappearing on histogram select. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "minor", "axe", "disappear", "histogram", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. added datasetChanged ( ) line. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "ad", "datasetchang", "dataset", "chang", "line"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix # 1349. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1349"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null dataset crash. ", "B_clean_title": ["fix", "null", "dataset", "crash"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1862. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1862"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix CategoryPlot not clearing the foreground domain marker map when it is not null .. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "categoryplot", "categori", "plot", "not", "clear", "foreground", "domain", "marker", "map", "when", "it", "not", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with not - so - deprecated API in CategoryPlot. Fix category data renderer NPE. ", "B_clean_title": ["fix", "issu", "not", "so", "deprec", "api", "categoryplot", "categori", "plot", "fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with new domain crosshair plot. Remove null check in place. ", "B_clean_title": ["fix", "issu", "new", "domain", "crosshair", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix chart 1 .. Fix rangeGridlineStroke option not being used .. Fix pull from previous commit  fixes # 1862. Fix bug. ", "B_clean_title": ["fix", "chart", "fix", "rangegridlinestrok", "rang", "gridlin", "stroke", "option", "not", "be", "use", "fix", "pull", "previou", "commit", "fix", "1862", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Avoid NPE in CategoryPlot. Remove null check in place. ", "B_clean_title": ["avoid", "npe", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "remove wrong fireChangeEvent. Remove null check in place. ", "B_clean_title": ["remov", "wrong", "firechangeev", "fire", "chang", "event", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axis location for 1 . 6 . x. Fix NPE. ", "B_clean_title": ["fix", "categori", "axi", "locat", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Added datasetChanged ( ) to CategoryPlot. Remove a line if dataset is null. ", "B_clean_title": ["fix", "1862", "ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot", "remov", "line", "dataset", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axes. Fix NPE. ", "B_clean_title": ["fix", "categori", "axe", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1862. Fix category plot background for phones. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1862", "fix", "categori", "plot", "background", "phone"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "remove redundant code. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "redund", "code", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix category plot annoyances. Removed redundant line. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "categori", "plot", "annoy", "remov", "redund", "line"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null column count in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "null", "column", "count", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix for Persian and Urdu language maps # 2019. Fix category plot background for phones. ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "2019", "fix", "categori", "plot", "background", "phone"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix # 1862. Fix # 1358. Fix crosshair dataset index issue. Fix # 183. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1862", "fix", "1358", "fix", "crosshair", "dataset", "index", "issu", "fix", "183"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Added throw exception if orientation is null. Remove redundant clearDomainMarkers method. ", "B_clean_title": ["remov", "null", "check", "place", "ad", "throw", "except", "orient", "null", "remov", "redund", "cleardomainmark", "clear", "domain", "marker", "method"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Removed redundant line. Remove null check in place. ", "B_clean_title": ["remov", "redund", "line", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Remove null check in place. ", "B_clean_title": ["fix", "1349", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). Remove null check in place. ", "B_clean_title": ["fix", "1862", "fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1796. Remove null check in place. ", "B_clean_title": ["fix", "1796", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with previous call. Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "previou", "call", "fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category renderer index calculation .. Remove null check in place. ", "B_clean_title": ["fix", "categori", "render", "index", "calcul", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Added patch for addValue ( ). Remove null check in place. ", "B_clean_title": ["ad", "patch", "addvalu", "add", "valu", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix - add listener to existing renderer. Remove null check in place. ", "B_clean_title": ["fix", "add", "listen", "exist", "render", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Removed redundant code. ", "B_clean_title": ["remov", "null", "check", "place", "remov", "redund", "code"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with wrong data set range axis mapping. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "wrong", "data", "set", "rang", "axi", "map"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 183. Fix pull from previous commit  fixes # 1227. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "183", "fix", "pull", "previou", "commit", "fix", "1227"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1796. Remove null check in place. ", "B_clean_title": ["fix", "1796", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix addChangeListener. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "addchangelisten", "add", "chang", "listen"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. Fix Eclipse. ", "B_clean_title": ["fix", "npe", "fix", "eclips"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axis selection bug. Remove null check in place. ", "B_clean_title": ["fix", "categori", "axi", "select", "bug", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). Remove null check in place. ", "B_clean_title": ["fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add listener to CategoryPlot. Remove null check in place. ", "B_clean_title": ["add", "listen", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix parent month / year axes NPE. added datasetChanged ( ) to CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "parent", "month", "year", "axe", "npe", "ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix pull request. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix pull request. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. Fix NPE in CategoryPlot. ", "B_clean_title": ["fix", "npe", "fix", "npe", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. Add category dataset patch. ", "B_clean_title": ["fix", "npe", "add", "categori", "dataset", "patch"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix 1355. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1355"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix rangeGridlineStroke. Fix NPE. ", "B_clean_title": ["fix", "rangegridlinestrok", "rang", "gridlin", "stroke", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. remove redundant code. Fix issue with wrong fireChangeEvent. ", "B_clean_title": ["remov", "null", "check", "place", "remov", "redund", "code", "fix", "issu", "wrong", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Throw an exception if orientation is null. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "throw", "except", "orient", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix problem with reconfigurable range axes. Fix NPE. ", "B_clean_title": ["fix", "problem", "reconfigur", "rang", "axe", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Updated self . orientation to use VERTICAL .. Fix crosshair dataset index .. Remove null check in place. ", "B_clean_title": ["updat", "self", "orient", "use", "vertic", "fix", "crosshair", "dataset", "index", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "added datasetChanged ( ) to getDataset ( index ). Remove null check in place. ", "B_clean_title": ["ad", "datasetchang", "dataset", "chang", "getdataset", "get", "dataset", "index", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix 1349. Remove null check in place. ", "B_clean_title": ["fix", "1349", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. @@ 1355 removed dataset . addChangeListener ( ). Fix minor issue with CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "place", "1355", "remov", "dataset", "addchangelisten", "add", "chang", "listen", "fix", "minor", "issu", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data renderer NPE. ", "B_clean_title": ["fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category plot annoyances. Fix category data renderer NPE. ", "B_clean_title": ["fix", "categori", "plot", "annoy", "fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "@@ 1355 removed redundant call. Fix - add listener to existing renderer. Remove null check in place. ", "B_clean_title": ["1355", "remov", "redund", "call", "fix", "add", "listen", "exist", "render", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix build. reset rangeCrosshairValue after each renderer is added. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "build", "reset", "rangecrosshairvalu", "rang", "crosshair", "valu", "after", "each", "render", "ad"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. @@ 1355 removed redundant call. ", "B_clean_title": ["fix", "npe", "1355", "remov", "redund", "call"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix # 183. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "183"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix crosshair dataset index issue. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "crosshair", "dataset", "index", "issu"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category plot annoyances. Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "categori", "plot", "annoy", "fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove null check in place. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1336. @@ 1356 don  t add a listener to the dataset. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1336", "1356", "don", "add", "listen", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a minor issue with chart 1 .. Remove null check in place. ", "B_clean_title": ["fix", "minor", "issu", "chart", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1349. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1349"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Added datasetChanged ( ) to CategoryPlot. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix for Persian and Urdu language maps # 2019. remove deprecated call to fireChangeEvent ( ). ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "2019", "remov", "deprec", "call", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix chart 1 .. Fix category axes. Remove null check in place. ", "B_clean_title": ["fix", "chart", "fix", "categori", "axe", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix issue with CategoryPlot . setDataset ( ). Fix Eclipse. Fix NPE. ", "B_clean_title": ["fix", "issu", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "eclips", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1433. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "getlegenditem", "get", "legend", "item", "fix", "1433"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix pull request. Remove null check in place. ", "B_clean_title": ["fix", "pull", "request", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Removed redundant line. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "redund", "line", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Add a listener to CategoryPlot. Fix # 183. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "add", "listen", "categoryplot", "categori", "plot", "fix", "183"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Remove over - aggressive dataset listener. ", "B_clean_title": ["remov", "null", "check", "place", "remov", "over", "aggress", "dataset", "listen"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1336. @@ 1356 don  t add a listener to the dataset. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1336", "1356", "don", "add", "listen", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix category datasets. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "categori", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix NPE in CategoryPlot. Remove null check in place. ", "B_clean_title": ["fix", "1862", "fix", "npe", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "remove redundant code. Fix category data renderer NPE. ", "B_clean_title": ["remov", "redund", "code", "fix", "categori", "data", "render", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Remove redundant code. Fix category datasets. ", "B_clean_title": ["remov", "null", "check", "place", "remov", "redund", "code", "fix", "categori", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1796. Remove null check in place. ", "B_clean_title": ["fix", "1796", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1796. Fix bug. ", "B_clean_title": ["fix", "1796", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix minor axes disappearing on histogram select. Remove null check in place. ", "B_clean_title": ["fix", "minor", "axe", "disappear", "histogram", "select", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix problem with resampling. Remove null check in place. ", "B_clean_title": ["fix", "problem", "resampl", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1349. Fix category plot weight changes. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1349", "fix", "categori", "plot", "weight", "chang"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix bug. ", "B_clean_title": ["fix", "1862", "fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix pull request. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "pull", "request", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix rangeGridlineStroke option not being used .. Fix getLegendItems ( ). ", "B_clean_title": ["fix", "rangegridlinestrok", "rang", "gridlin", "stroke", "option", "not", "be", "use", "fix", "getlegenditem", "get", "legend", "item"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix crosshair dataset index .. Remove null check in place. ", "B_clean_title": ["fix", "crosshair", "dataset", "index", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix pull request. Fix issue with range crosshair. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "pull", "request", "fix", "issu", "rang", "crosshair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a bug in CategoryPlot. Remove null check in place. ", "B_clean_title": ["fix", "bug", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. Fix a bug in CategoryPlot. ", "B_clean_title": ["fix", "npe", "fix", "bug", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1796. Fix # 1337. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1796", "fix", "1337"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axes. Remove null check in place. ", "B_clean_title": ["fix", "categori", "axe", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axes selection. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "categori", "axe", "select", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix category plot background for phones. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "categori", "plot", "background", "phone"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Add category dataset patch. ", "B_clean_title": ["remov", "null", "check", "place", "add", "categori", "dataset", "patch"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1349. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1349"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with chart 1. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix category axes. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "categori", "axe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix a bug in CategoryPlot. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "bug", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix issue with wrong fireChangeEvent. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "issu", "wrong", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data renderer NPE. Fix range zero baseline paint. ", "B_clean_title": ["fix", "categori", "data", "render", "npe", "fix", "rang", "zero", "baselin", "paint"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with new category plot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "new", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "@@ 1355 removed redundant call. Fix NPE. ", "B_clean_title": ["1355", "remov", "redund", "call", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix category mouse positionning. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "categori", "mous", "posit"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix rangeGridlineStroke. Fix category axis selection bug. Remove null check in place. ", "B_clean_title": ["fix", "rangegridlinestrok", "rang", "gridlin", "stroke", "fix", "categori", "axi", "select", "bug", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in CategoryPlot. Remove null check in place. ", "B_clean_title": ["fix", "npe", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fixed a bug with CategoryPlot . setDataset ( int  CategoryDataset ). ", "B_clean_title": ["remov", "null", "check", "place", "fix", "bug", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "int", "categorydataset", "categori", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Add category dataset patch. Fix category plot background for phones. ", "B_clean_title": ["remov", "null", "check", "place", "add", "categori", "dataset", "patch", "fix", "categori", "plot", "background", "phone"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with CategoryPlot . setDataset ( ). Fix minor issue with CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "categoryplot", "categori", "plot", "setdataset", "set", "dataset", "fix", "minor", "issu", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix problem with reconfigurable range axes. Fix category data renderer bug. ", "B_clean_title": ["fix", "problem", "reconfigur", "rang", "axe", "fix", "categori", "data", "render", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1349. Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). Fix NPE. ", "B_clean_title": ["fix", "1349", "fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean", "fix", "npe"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "remove redundant code. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["remov", "redund", "code", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Avoid NPE in CategoryPlot. Remove null check in place. ", "B_clean_title": ["avoid", "npe", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Remove null check in place. ", "B_clean_title": ["fix", "1862", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category plot range axis positioning. Remove null check in place. ", "B_clean_title": ["fix", "categori", "plot", "rang", "axi", "posit", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix range zero baseline paint. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "rang", "zero", "baselin", "paint"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix pull request. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "pull", "request"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix pull from previous commit  fixes # 1265. Remove null check in place. ", "B_clean_title": ["fix", "1862", "fix", "pull", "previou", "commit", "fix", "1265", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. remove deprecated call to fireChangeEvent ( ). ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "remov", "deprec", "call", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE. throw exception if index < 0. ", "B_clean_title": ["fix", "npe", "throw", "except", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix # 1887. Fix minor axes disappearing on histogram select. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "1887", "fix", "minor", "axe", "disappear", "histogram", "select"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix Eclipse. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "eclips", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Added throw exception if orientation is null. ", "B_clean_title": ["remov", "null", "check", "place", "ad", "throw", "except", "orient", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with chart 1. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "chart"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add category dataset patch. Fix category plot background for phones. Added datasetChanged ( ) to CategoryPlot. Remove a line if dataset is null. ", "B_clean_title": ["add", "categori", "dataset", "patch", "fix", "categori", "plot", "background", "phone", "ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot", "remov", "line", "dataset", "null"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix category plot annoyances. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "categori", "plot", "annoy"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1862. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "1862", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix crosshair dataset index. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "crosshair", "dataset", "index"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in AbstractCategoryItemRenderer. Fix # 1796. @@ 1356 don  t add a listener to the dataset. ", "B_clean_title": ["fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render", "fix", "1796", "1356", "don", "add", "listen", "dataset"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 183. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "183", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix chart 1 .. Fix minor bug in CategoryPlot. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "chart", "fix", "minor", "bug", "categoryplot", "categori", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in place. Fix issue with wrong fireChangeEvent. ", "B_clean_title": ["remov", "null", "check", "place", "fix", "issu", "wrong", "firechangeev", "fire", "chang", "event"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 1336. Remove null check in place. ", "B_clean_title": ["fix", "1336", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix a minor issue with CategoryPlot . setRenderer ( int  CategoryItemRenderer  boolean ). Added datasetChanged ( ) to CategoryPlot. Remove null check in place. ", "B_clean_title": ["fix", "minor", "issu", "categoryplot", "categori", "plot", "setrender", "set", "render", "int", "categoryitemrender", "categori", "item", "render", "boolean", "ad", "datasetchang", "dataset", "chang", "categoryplot", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix # 183. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "183", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix rangeGridlineStroke. Removed redundant line. Remove null check in place. ", "B_clean_title": ["fix", "rangegridlinestrok", "rang", "gridlin", "stroke", "remov", "redund", "line", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix chart 1 .. Remove null check in place. ", "B_clean_title": ["fix", "chart", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Add background annotations to defects plot. ", "B_clean_title": ["add", "background", "annot", "defect", "plot"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Set default background paint on category plot. Remove null check in place. ", "B_clean_title": ["set", "default", "background", "paint", "categori", "plot", "remov", "null", "check", "place"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix minor issue with CategoryPlot. Fix NPE in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "minor", "issu", "categoryplot", "categori", "plot", "fix", "npe", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category axes. Fix category space rendering in RSRepair_Defects4J_Chart_1 .. ", "B_clean_title": ["fix", "categori", "axe", "fix", "categori", "space", "render", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "@@ fix colspan error. Fix RSRepair_Defects4J_Chart_1 .. ", "B_clean_title": ["fix", "colspan", "error", "fix", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix RSRepair_Defects4J_Chart_1 .. @@ removed return result from last fix. ", "B_clean_title": ["fix", "rsrepair", "defects4j", "chart", "rs", "repair", "remov", "return", "result", "last", "fix"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix possible NPE in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["fix", "possibl", "npe", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix NPE in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix minor bug. @@ removed patched line. ", "B_clean_title": ["fix", "minor", "bug", "remov", "patch", "line"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["remov", "null", "check", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix bug in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["fix", "bug", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category space for rect in RSRepair_Defects4J_Chart_1 .. ", "B_clean_title": ["fix", "categori", "space", "rect", "rsrepair", "defects4j", "chart", "rs", "repair"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category data after last fix. ", "B_clean_title": ["fix", "categori", "data", "after", "last", "fix"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix category plot plot. @@ - Remove break line. ", "B_clean_title": ["fix", "categori", "plot", "plot", "remov", "break", "line"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Remove null check in RSRepair_Defects4J_Chart_1. ", "B_clean_title": ["remov", "null", "check", "rsrepair", "defects4j", "chart", "rs", "repair"]}]