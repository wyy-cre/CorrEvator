[{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fix a bug in the linear tableau test .. ", "B_clean_title": ["fix", "bug", "linear", "tableau", "test"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fix a bug in the tableau test .. ", "B_clean_title": ["fix", "bug", "tableau", "test"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "removed test code. ", "B_clean_title": ["remov", "test", "code"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "added check for erroneous division. ", "B_clean_title": ["ad", "check", "erron", "divis"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fix warning. Fix a bug in the similarity function. ", "B_clean_title": ["fix", "warn", "fix", "bug", "similar", "function"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fixed a bug in the linear search results. ", "B_clean_title": ["fix", "bug", "linear", "search", "result"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "added fixed case for tableau sizes. ", "B_clean_title": ["ad", "fix", "case", "tableau", "size"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from str ; if it was < - 1. ", "B_clean_title": ["remov", "exppo", "exp", "po", "str", "it", "wa"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string .. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos. ", "B_clean_title": ["remov", "exppo", "exp", "po"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix copy ( ). ", "B_clean_title": ["fix", "copi"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix typo in first line of text file. ", "B_clean_title": ["fix", "typo", "first", "line", "text", "file"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix parse error. ", "B_clean_title": ["fix", "pars", "error"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Added throw exception if string is null. removed expPos from mant string. ", "B_clean_title": ["ad", "throw", "except", "string", "null", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. fix a typo in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "typo", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Allow null string input. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "allow", "null", "string", "input"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "formatting null values as null values are not accepted. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["format", "null", "valu", "as", "null", "valu", "are", "not", "accept", "remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fixed NPE in StringUtils. ", "B_clean_title": ["fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed ninth - month issue. removed expPos from mant string. fixed a bug in NumberUtils. ", "B_clean_title": ["fix", "ninth", "month", "issu", "remov", "exppo", "exp", "po", "mant", "string", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in NumberUtils. removed expPos from mant string. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the extraneous space. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "extran", "space"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Fix Eclipse warning. fixed a bug in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "eclips", "warn", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. try string to create double from string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "tri", "string", "creat", "doubl", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the unnecessary dec string. try string to create double from string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "unnecessari", "dec", "string", "tri", "string", "creat", "doubl", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "27", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. don  t put patched exception in place. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "don", "put", "patch", "except", "place"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed BigDecimal class name. ", "B_clean_title": ["fix", "bigdecim", "big", "decim", "class", "name"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed erroneous legacy patch. ", "B_clean_title": ["remov", "erron", "legaci", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "throw exception if str is null. removed expPos from mant string. ", "B_clean_title": ["throw", "except", "str", "null", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in StringUtils. removed expPos from mant string. ", "B_clean_title": ["fix", "bug", "stringutil", "string", "util", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. try string to create double from string. remove wrong symbol. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "tri", "string", "creat", "doubl", "string", "remov", "wrong", "symbol"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Handle null string input. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "handl", "null", "string", "input"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "avoid NPE. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. fix a typo in NumberUtils. ", "B_clean_title": ["avoid", "npe", "remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j", "fix", "typo", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "A blank string is not a valid number. removed expPos from mant string. ", "B_clean_title": ["blank", "string", "not", "valid", "number", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fix null string handling. removed expPos from mant string. ", "B_clean_title": ["fix", "null", "string", "handl", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Fix number parsing in Arja_Defects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "number", "pars", "arja", "defects4j", "lang", "27"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Add a patch for formatting numbers in Avro settings. removed expPos from mant string. remove expPos. ", "B_clean_title": ["add", "patch", "format", "number", "avro", "set", "remov", "exppo", "exp", "po", "mant", "string", "remov", "exppo", "exp", "po"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "throw exception if str is null. removed expPos from mant string. convert numeric to double for compatibility with 1 . 5. ", "B_clean_title": ["throw", "except", "str", "null", "remov", "exppo", "exp", "po", "mant", "string", "convert", "numer", "doubl", "compat"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed NPE in NumberUtils. removed expPos from mant string. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove unnecessary default value. removed expPos from mant string. ", "B_clean_title": ["remov", "unnecessari", "default", "valu", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Add the missing patch. removed expPos from mant string. ", "B_clean_title": ["add", "miss", "patch", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fixed syntax error in previous patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "syntax", "error", "previou", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "avoid NPE. removed expPos from mant string. ", "B_clean_title": ["avoid", "npe", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. try Integer . decode ( str ) instead of String . create ( str ). ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "tri", "integ", "decod", "str", "instead", "string", "creat", "str"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove unused patch. removed expPos from mant string. ", "B_clean_title": ["remov", "unus", "patch", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. Handle null string input. adding mant variable to prevent compiler from giving an error message. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "handl", "null", "string", "input", "ad", "mant", "variabl", "prevent", "compil", "give", "error", "messag"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fix a minor typo in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "minor", "typo", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not needed. fixed a bug in NumberUtils. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "need", "fix", "bug", "numberutil", "number", "util", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. remove the unnecessary dec string. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "remov", "unnecessari", "dec", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. ", "B_clean_title": ["fix", "npe", "arja", "defects4j", "lang", "27", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove expPos. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "exppo", "exp", "po"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Handle parseDouble for StringUtils .. ", "B_clean_title": ["handl", "parsedoubl", "pars", "doubl", "stringutil", "string", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. Allow trailing comma in Strings. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "allow", "trail", "comma", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arjadefects4j", "lang", "27", "arja", "defects4j"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the unnecessary dec string. Remove exp pos from definition of Double. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "unnecessari", "dec", "string", "remov", "exp", "po", "definit", "doubl"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "avoid NPE. fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. fixed NPE in Arja_Defects4J_Lang_27. ", "B_clean_title": ["avoid", "npe", "fix", "npe", "arja", "defects4j", "lang", "27", "remov", "exppo", "exp", "po", "mant", "string", "fix", "npe", "arja", "defects4j", "lang", "27"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Allow null string input. removed expPos from mant string. ", "B_clean_title": ["allow", "null", "string", "input", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in NumberUtils. removed expPos from mant string. fixed syntax error in previous patch. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "remov", "exppo", "exp", "po", "mant", "string", "fix", "syntax", "error", "previou", "patch"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "fixed a bug in NumberUtils. removed unnecessary check for integer precision thing. Remove expPos from mant string  because we  re about to replace it with the exp. try string to create double from numeric value. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "remov", "unnecessari", "check", "integ", "precis", "thing", "remov", "exppo", "exp", "po", "mant", "string", "becaus", "we", "re", "about", "replac", "it", "exp", "tri", "string", "creat", "doubl", "numer", "valu"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Allow null exponent string to be parsed as a string. removed expPos from mant string. ", "B_clean_title": ["allow", "null", "expon", "string", "pars", "as", "string", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. remove the extraneous space. fix a merge conflict in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "remov", "extran", "space", "fix", "merg", "conflict", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed exp fix. ", "B_clean_title": ["remov", "exp", "fix"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. Allow null string input. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "allow", "null", "string", "input"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Fix lost backslash. Fix a bug in NumberUtils. ", "B_clean_title": ["fix", "lost", "backslash", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Add null check. removed expPos from mant string. ", "B_clean_title": ["add", "null", "check", "remov", "exppo", "exp", "po", "mant", "string"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Remove expPos from mant string  as it  s not accessible from native code. fixed a bug in NumberUtils. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "as", "it", "not", "access", "nativ", "code", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "removed expPos from mant string. Fixed ment = string .. ", "B_clean_title": ["remov", "exppo", "exp", "po", "mant", "string", "fix", "ment", "string"]},
{"A_title": "LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to itLevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.", "A_clean_title": ["levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "ignor", "vectorialconvergencecheck", "vectori", "converg", "checker", "paramet", "pass", "itlevenbergmarquardtoptim", "it", "levenberg", "marquardt", "optim", "ignor", "vectorialconvergencecheck", "vectori", "converg", "checker", "paramet", "pass", "it", "thi", "make", "it", "hard", "specifi", "custom", "stop", "criteria", "optim"], "B_title": "Fix a regression in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "regress", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)the L_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries. The current implementation in ArrayRealVector has a typo:      public double getLInfNorm()          double max = 0;         for (double a : data)              max += Math.max(max Math.abs(a));                  return max;        the += should just be an =. There is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test not a test for correctness). Worse the implementation in OpenMapRealVector is not even positive semi-definite:          public double getLInfNorm()          double max = 0;         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             max += iter.value();                  return max;        I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():    public double getLInfNorm()      double norm = 0;     Iterator<Entry> it = sparseIterator();     Entry e;     while(it.hasNext() && (e = it.next()) != null)        norm = Math.max(norm Math.abs(e.getValue()));          return norm;      Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future.", "A_clean_title": ["getlinfnorm", "get", "inf", "norm", "use", "wrong", "formula", "both", "arrayrealvector", "array", "real", "vector", "openmaprealvector", "open", "map", "real", "vector", "differ", "way", "infin", "norm", "finit", "dimension", "vector", "just", "max", "absolut", "valu", "it", "entri", "current", "implement", "arrayrealvector", "array", "real", "vector", "ha", "typo", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "doubl", "data", "max", "math", "max", "max", "math", "ab", "return", "max", "just", "there", "sadli", "unit", "test", "assur", "us", "that", "thi", "correct", "behavior", "effect", "regress", "onli", "test", "not", "test", "correct", "wors", "implement", "openmaprealvector", "open", "map", "real", "vector", "not", "even", "posit", "semi", "definit", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "max", "iter", "valu", "return", "max", "would", "suggest", "that", "thi", "method", "move", "up", "abstractrealvector", "abstract", "real", "vector", "superclass", "implement", "sparseiter", "spars", "iter", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "norm", "iter", "entri", "it", "sparseiter", "spars", "iter", "entri", "while", "it", "hasnext", "ha", "next", "it", "next", "null", "norm", "math", "max", "norm", "math", "ab", "getvalu", "get", "valu", "return", "norm", "unit", "test", "neg", "valu", "vector", "would", "help", "check", "thi", "kind", "thing", "futur"], "B_title": "Fix ArrayRealVector . getLInfNorm ( ). ", "B_clean_title": ["fix", "arrayrealvector", "array", "real", "vector", "getlinfnorm", "get", "inf", "norm"]},
{"A_title": "PearsonsCorrelation.getCorrelationPValues() precision limited by machine epsilonSimilar to the issue described in MATH-201 using PearsonsCorrelation.getCorrelationPValues() with many treatments results in p-values that are continuous down to 2.2e-16 but that drop to 0 after that. In MATH-201 the problem was described as such: > So in essence the p-value returned by TTestImpl.tTest() is: >  > 1.0 - (cumulativeProbability(t) - cumulativeProbabily(-t)) >  > For large-ish t-statistics cumulativeProbabilty(-t) can get quite small and cumulativeProbabilty(t) can get very close to 1.0. When  > cumulativeProbability(-t) is less than the machine epsilon we get p-values equal to zero because: >  > 1.0 - 1.0 + 0.0 = 0.0 The solution in MATH-201 was to modify the p-value calculation to this: > p = 2.0 * cumulativeProbability(-t) Here the problem is similar.  From PearsonsCorrelation.getCorrelationPValues():   p = 2 * (1 - tDistribution.cumulativeProbability(t)); Directly calculating the p-value using identical code as PearsonsCorrelation.getCorrelationPValues() but with the following change seems to solve the problem:   p = 2 * (tDistribution.cumulativeProbability(-t));", "A_clean_title": ["pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "precis", "limit", "by", "machin", "epsilonsimilar", "epsilon", "similar", "issu", "describ", "math", "201", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "mani", "treatment", "result", "valu", "that", "are", "continu", "down", "16", "2e", "but", "that", "drop", "after", "that", "math", "201", "problem", "wa", "describ", "as", "such", "so", "essenc", "valu", "return", "by", "ttestimpl", "ttest", "test", "impl", "test", "cumulativeprob", "cumul", "probabl", "cumulativeprobabili", "cumul", "probabili", "larg", "ish", "statist", "cumulativeprobabilti", "cumul", "probabilti", "get", "quit", "small", "cumulativeprobabilti", "cumul", "probabilti", "get", "veri", "close", "when", "cumulativeprob", "cumul", "probabl", "less", "than", "machin", "epsilon", "we", "get", "valu", "equal", "zero", "becaus", "solut", "math", "201", "wa", "modifi", "valu", "calcul", "thi", "cumulativeprob", "cumul", "probabl", "here", "problem", "similar", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "tdistribut", "cumulativeprob", "distribut", "cumul", "probabl", "directli", "calcul", "valu", "ident", "code", "as", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "but", "follow", "chang", "seem", "solv", "problem", "tdistribut", "cumulativeprob", "distribut", "cumul", "probabl"], "B_title": "Missing test for HIVE5199 ( I had left it harwired to say ). ", "B_clean_title": ["miss", "test", "hive5199", "had", "left", "it", "harwir", "say"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Set signChangeIndex to 2. ", "B_clean_title": ["set", "signchangeindex", "sign", "chang", "index"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "fix the sign change index so it works. ", "B_clean_title": ["fix", "sign", "chang", "index", "so", "it", "work"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Added missing sign in BracketingNthOrderBrentSolver. ", "B_clean_title": ["ad", "miss", "sign", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Added a fix for the case where the root of the bracketing NthOrderBrent. ", "B_clean_title": ["ad", "fix", "case", "where", "root", "bracket", "nthorderbr", "nth", "order", "brent"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Fix swapped sign exchange error in BracketingNthOrderBrentSolver . java. ", "B_clean_title": ["fix", "swap", "sign", "exchang", "error", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "java"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "moving yA to 0 when we drop the lowest value in the array. Forgot to include verifyInterval in BracketingNthOrderBrentSolver . solve (. Fix EZC from pull request. ", "B_clean_title": ["move", "ya", "when", "we", "drop", "lowest", "valu", "array", "forgot", "includ", "verifyinterv", "verifi", "interv", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "solv", "fix", "ezc", "pull", "request"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - max datetime field. ", "B_clean_title": ["fix", "zero", "max", "datetim", "field"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Added zeroismaxdatetimefield copy. ", "B_clean_title": ["ad", "zeroismaxdatetimefield", "copi"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - max datetime field. ", "B_clean_title": ["fix", "zero", "max", "datetim", "field"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - maxDateTimeField minimization. ", "B_clean_title": ["fix", "zero", "maxdatetimefield", "max", "date", "time", "field", "minim"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed the build .. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add an exception. ", "B_clean_title": ["add", "except"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add an exception. ", "B_clean_title": ["add", "except"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix # 135. ", "B_clean_title": ["fix", "135"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fixed zero - is - max datetime field minimization. ", "B_clean_title": ["fix", "zero", "max", "datetim", "field", "minim"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix incorrect patch180 data. ", "B_clean_title": ["fix", "incorrect", "patch180", "data"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add 0 . 5 for the getMaximumValue ( ) method  but not in the patch. ", "B_clean_title": ["add", "getmaximumvalu", "get", "maximum", "valu", "method", "but", "not", "patch"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Add missing import .. Fixed whitespace in ZeroIsMaxDateTimeField . getMaximumValue ( ReadablePartial instant  int . ", "B_clean_title": ["add", "miss", "import", "fix", "whitespac", "zeroismaxdatetimefield", "zero", "max", "date", "time", "field", "getmaximumvalu", "get", "maximum", "valu", "readableparti", "readabl", "partial", "instant", "int"]},
{"A_title": "Bug on withLaterOffsetAtOverlap methodOn the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).", "A_clean_title": ["bug", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "methodon", "method", "last", "two", "bracket", "we", "see", "that", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "not", "undo", "withearlieroffsetatoverlap", "earlier", "offset", "at", "overlap", "as", "it", "not", "even", "work", "at", "all"], "B_title": "Fix an issue with DateTimeZone . getOffset ( ) where the difference was not an overlap. ", "B_clean_title": ["fix", "issu", "datetimezon", "date", "time", "zone", "getoffset", "get", "offset", "where", "differ", "wa", "not", "overlap"]},
{"A_title": "Bug on withLaterOffsetAtOverlap methodOn the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).", "A_clean_title": ["bug", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "methodon", "method", "last", "two", "bracket", "we", "see", "that", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "not", "undo", "withearlieroffsetatoverlap", "earlier", "offset", "at", "overlap", "as", "it", "not", "even", "work", "at", "all"], "B_title": "Fix bug in time zone ISO 8601 format. ", "B_clean_title": ["fix", "bug", "time", "zone", "iso", "8601", "format"]}]