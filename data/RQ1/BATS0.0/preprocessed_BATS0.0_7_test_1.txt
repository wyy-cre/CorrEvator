[{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added verifyBracketing to BrentSolver. ", "B_clean_title": ["ad", "verifybracket", "verifi", "bracket", "brentsolv", "brent", "solver"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Added back missing betas. ", "B_clean_title": ["ad", "back", "miss", "beta"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Remove unused if (. ", "B_clean_title": ["remov", "unus"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a false reporting of convergence. ", "B_clean_title": ["fix", "fals", "report", "converg"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a false reporting of convergence. ", "B_clean_title": ["fix", "fals", "report", "converg"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Remove a redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "Fix a bug in the patch collection. ", "B_clean_title": ["fix", "bug", "patch", "collect"]},
{"A_title": "MathRuntimeException with simple ebeMultiply on OpenMapRealVectorThe following piece of code  import org.apache.commons.math.linear.OpenMapRealVector; import org.apache.commons.math.linear.RealVector;  public class DemoBugOpenMapRealVector      public static void main(String args)          final RealVector u = new OpenMapRealVector(3 1E-6);         u.setEntry(0 1.);         u.setEntry(1 0.);         u.setEntry(2 2.);         final RealVector v = new OpenMapRealVector(3 1E-6);         v.setEntry(0 0.);         v.setEntry(1 3.);         v.setEntry(2 0.);         System.out.println(u);         System.out.println(v);         System.out.println(u.ebeMultiply(v));         raises an exception  org.apache.commons.math.linear.OpenMapRealVector@7170a9b6 Exception in thread main org.apache.commons.math.MathRuntimeException 6: map has been modified while iterating at org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373) at org.apache.commons.math.util.OpenIntToDoubleHashMap Iterator.advance(OpenIntToDoubleHashMap.java:564) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:1) at DemoBugOpenMapRealVector.main(DemoBugOpenMapRealVector.java:17)", "A_clean_title": ["mathruntimeexcept", "math", "runtim", "except", "simpl", "ebemultipli", "ebe", "multipli", "openmaprealvectorth", "open", "map", "real", "vector", "follow", "piec", "code", "import", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "import", "org", "apach", "common", "math", "linear", "realvector", "real", "vector", "public", "class", "demobugopenmaprealvector", "demo", "bug", "open", "map", "real", "vector", "public", "static", "void", "main", "string", "arg", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "system", "out", "println", "system", "out", "println", "system", "out", "println", "ebemultipli", "ebe", "multipli", "rais", "except", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "7170a9b6", "except", "thread", "main", "org", "apach", "common", "math", "mathruntimeexcept", "math", "runtim", "except", "map", "ha", "been", "modifi", "while", "iter", "at", "org", "apach", "common", "math", "mathruntimeexcept", "createconcurrentmodificationexcept", "math", "runtim", "except", "creat", "concurr", "modif", "except", "mathruntimeexcept", "java:373", "math", "runtim", "except", "at", "org", "apach", "common", "math", "util", "openinttodoublehashmap", "open", "int", "doubl", "hash", "map", "iter", "advanc", "openinttodoublehashmap", "java:564", "open", "int", "doubl", "hash", "map", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:372", "open", "map", "real", "vector", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:1", "open", "map", "real", "vector", "at", "demobugopenmaprealvector", "main", "demo", "bug", "open", "map", "real", "vector", "demobugopenmaprealvector", "java:17", "demo", "bug", "open", "map", "real", "vector"], "B_title": "Fix bug in ebeDivide ( RealVector ). Fix bug in ebeDivide ( ). Updated patch. Fix bug in ebeMultiply ( ). ", "B_clean_title": ["fix", "bug", "ebedivid", "ebe", "divid", "realvector", "real", "vector", "fix", "bug", "ebedivid", "ebe", "divid", "updat", "patch", "fix", "bug", "ebemultipli", "ebe", "multipli"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "Bump the buffer size for the empty string builder .. Removed unnecessary copy of StringUtils. ", "B_clean_title": ["bump", "buffer", "size", "empti", "string", "builder", "remov", "unnecessari", "copi", "stringutil", "string", "util"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "fixed bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "fixed bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Remove redundant code. ", "B_clean_title": ["remov", "redund", "code"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "fix merge issue. ", "B_clean_title": ["fix", "merg", "issu"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Fix swapped diffs in patch. ", "B_clean_title": ["fix", "swap", "diff", "patch"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "added missing copy. ", "B_clean_title": ["ad", "miss", "copi"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "Add missing import. Fix test. ", "B_clean_title": ["add", "miss", "import", "fix", "test"]},
{"A_title": ".withHourOfDay() sets hour inconsistantly on DST transition.When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I cant find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.", "A_clean_title": ["withhourofday", "hour", "day", "set", "hour", "inconsistantli", "dst", "transit", "when", "hour", "day", "set", "ambigu", "hour", "daylight", "standard", "time", "transit", "given", "time", "zone", "result", "inconsist", "differ", "time", "zone", "shoul", "hour", "set", "daylight", "hour", "or", "standard", "hour", "all", "time", "zone", "cant", "find", "anyth", "that", "document", "thi", "behavior", "my", "test", "code", "below", "return", "differ", "result", "differ", "time", "zone", "veri", "last", "assert", "fail", "australia", "time", "zone", "cutov"], "B_title": "Fixed typo in Time - 26 - Hercules .. Fixed bug in Time - 26 - Hercules .. Fixed formatting mistake .. Fixed bug in Time - 26 - Hercules .. Fixed typo in patch1. Fixed formatting mistake in convertLocalToUTC ( long  boolean  boolean  boolean  boolean ). Fixed formatting mistake in convertLocalToUTC ( long  boolean  boolean  boolean ). ", "B_clean_title": ["fix", "typo", "time", "26", "hercul", "fix", "bug", "time", "26", "hercul", "fix", "format", "mistak", "fix", "bug", "time", "26", "hercul", "fix", "typo", "patch1", "fix", "format", "mistak", "convertlocaltoutc", "convert", "local", "utc", "long", "boolean", "boolean", "boolean", "boolean", "fix", "format", "mistak", "convertlocaltoutc", "convert", "local", "utc", "long", "boolean", "boolean", "boolean"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fix array length. ", "B_clean_title": ["fix", "array", "length"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fix the array to work properly. fix the bug. ", "B_clean_title": ["fix", "array", "work", "properli", "fix", "bug"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "BigMatrixImpl copy constructor. Fix error in RealMatrixImpl .. ", "B_clean_title": ["bigmatriximpl", "big", "matrix", "impl", "copi", "constructor", "fix", "error", "realmatriximpl", "real", "matrix", "impl"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fixed erroneous conversion to BigDecimal. Fix initial matrix lengths .. ", "B_clean_title": ["fix", "erron", "convers", "bigdecim", "big", "decim", "fix", "initi", "matrix", "length"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "Fixed erroneous conversion to BigDecimal. Fix initial matrix length. ", "B_clean_title": ["fix", "erron", "convers", "bigdecim", "big", "decim", "fix", "initi", "matrix", "length"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Fix 144 bug. ", "B_clean_title": ["fix", "144", "bug"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Fixed a bug in MultiplePiePlot .. ", "B_clean_title": ["fix", "bug", "multiplepieplot", "multipl", "pie", "plot"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Missing warning. ", "B_clean_title": ["miss", "warn"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "Set the dataset on the pie chart .. ", "B_clean_title": ["set", "dataset", "pie", "chart"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check to Complex . add ( ). ", "B_clean_title": ["add", "isnan", "na", "check", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check to Complex . add ( ). ", "B_clean_title": ["add", "isnan", "na", "check", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add NaN to Complex . add ( ). ", "B_clean_title": ["add", "nan", "na", "complex", "add"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check. ", "B_clean_title": ["add", "isnan", "na", "check"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add one - line ifs. ", "B_clean_title": ["add", "one", "line", "if"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Add the isNaN check in Complex . add ( ). ", "B_clean_title": ["add", "isnan", "na", "check", "complex", "add"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . flipIfWarranted ( ) .. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "flipifwarr", "flip", "warrant"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . flipIfWarranted ( ) .. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "flipifwarr", "flip", "warrant"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . java. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "java"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);                            ", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed a bug in EigenDecompositionImpl . java. ", "B_clean_title": ["fix", "bug", "eigendecompositionimpl", "eigen", "decomposit", "impl", "java"]},
{"A_title": "BSPTree class and recovery of a Euclidean 3D BRepNew to the work here. Thanks for your efforts on this code. I create a BSPTree from a BoundaryRep (Brep) my test Brep is a cube as represented by a float array containing 8 3D points in(xyz) order and an array of indices (12 triplets for the 12 faces of the cube). I construct a BSPMesh() as shown in the code below. I can construct the PolyhedronsSet() but have problems extracting the faces from the BSPTree to reconstruct the BRep. The attached code (BSPMesh2.java) shows that a small change to 1 of the vertex positions causes/corrects the problem. Any ideas?", "A_clean_title": ["bsptree", "bsp", "tree", "class", "recoveri", "euclidean", "3d", "brepnew", "rep", "new", "work", "here", "thank", "your", "effort", "thi", "code", "creat", "bsptree", "bsp", "tree", "boundaryrep", "boundari", "rep", "brep", "my", "test", "brep", "cube", "as", "repres", "by", "float", "array", "contain", "3d", "point", "xyz", "order", "array", "indic", "12", "triplet", "12", "face", "cube", "construct", "bspmesh", "bsp", "mesh", "as", "shown", "code", "below", "construct", "polyhedronsset", "polyhedron", "set", "but", "have", "problem", "extract", "face", "bsptree", "bsp", "tree", "reconstruct", "brep", "rep", "attach", "code", "bspmesh2", "java", "bsp", "mesh2", "show", "that", "small", "chang", "vertex", "posit", "caus", "correct", "problem", "ani", "idea"], "B_title": "removed debug code. ", "B_clean_title": ["remov", "debug", "code"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "I don  t really see a justification for doing a whitespace in a string ( changed by the. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "whitespac", "string", "chang", "by"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "Remove redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "FastDateParser ignores white space. ", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "ignor", "white", "space"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "FastDateParser copy ( ) didn  t ignore whitespace in date parsing. ", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "copi", "didn", "ignor", "whitespac", "date", "pars"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "don  t backslash backslash in regex so it won  t be backslashed. ", "B_clean_title": ["don", "backslash", "backslash", "regex", "so", "it", "won", "backslash"]},
{"A_title": "FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() wont changeThe FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null then it is not made part of the key but the stored object is created using the current default locale. If the Locale is changed subsequently then the wrong locale is applied. Patch for test case to follow.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "assum", "local", "getdefault", "get", "default", "wont", "changeth", "chang", "fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "method", "creat", "hashmap", "hash", "map", "key", "variou", "item", "includ", "local", "local", "null", "then", "it", "not", "made", "part", "key", "but", "store", "object", "creat", "current", "default", "local", "local", "chang", "subsequ", "then", "wrong", "local", "appli", "patch", "test", "case", "follow"], "B_title": "Fix FastDateFormat  s key value if locale is not null. Fix getLocaleKey exception in FastDateFormat. ", "B_clean_title": ["fix", "fastdateformat", "fast", "date", "format", "key", "valu", "local", "not", "null", "fix", "getlocalekey", "get", "local", "key", "except", "fastdateformat", "fast", "date", "format"]},
{"A_title": "NPE in  KMeansPlusPlusClusterer unittestWhen running this unittest I am facing this NPE: java.lang.NullPointerException at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91) This is the unittest: package org.fao.fisheries.chronicles.calcuation.cluster; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.Arrays; import java.util.List; import java.util.Random; import org.apache.commons.math.stat.clustering.Cluster; import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint; import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer; import org.fao.fisheries.chronicles.input.CsvImportProcess; import org.fao.fisheries.chronicles.input.Top200Csv; import org.junit.Test; public class ClusterAnalysisTest  @Test public void testPerformClusterAnalysis2()  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint points = new EuclideanIntegerPoint  new EuclideanIntegerPoint(new int   1959 325100  ) new EuclideanIntegerPoint(new int   1960 373200  ) ; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points) 1 1); assertEquals(1 clusters.size());  ", "A_clean_title": ["npe", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "unittestwhen", "unittest", "when", "run", "thi", "unittest", "am", "face", "thi", "npe", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "assignpointstoclust", "mean", "plu", "plu", "cluster", "assign", "point", "cluster", "kmeanspluspluscluster", "java:91", "mean", "plu", "plu", "cluster", "thi", "unittest", "packag", "org", "fao", "fisheri", "chronicl", "calcuat", "cluster", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "static", "org", "junit", "assert", "asserttru", "assert", "true", "import", "java", "util", "array", "import", "java", "util", "list", "import", "java", "util", "random", "import", "org", "apach", "common", "math", "stat", "cluster", "cluster", "import", "org", "apach", "common", "math", "stat", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "import", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "import", "org", "fao", "fisheri", "chronicl", "input", "csvimportprocess", "csv", "import", "process", "import", "org", "fao", "fisheri", "chronicl", "input", "top200csv", "import", "org", "junit", "test", "public", "class", "clusteranalysistest", "cluster", "analysi", "test", "test", "public", "void", "testperformclusteranalysis2", "test", "perform", "cluster", "analysis2", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "transform", "new", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "random", "1746432956321l", "euclideanintegerpoint", "euclidean", "integ", "point", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1959", "325100", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1960", "373200", "list", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "cluster", "transform", "cluster", "array", "aslist", "as", "list", "point", "assertequ", "assert", "equal", "cluster", "size"], "B_title": "Fix MathUtils . distance ( )  reported by Marin Dzhigarov .. ", "B_clean_title": ["fix", "mathutil", "math", "util", "distanc", "report", "by", "marin", "dzhigarov"]},
{"A_title": "NPE in  KMeansPlusPlusClusterer unittestWhen running this unittest I am facing this NPE: java.lang.NullPointerException at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91) This is the unittest: package org.fao.fisheries.chronicles.calcuation.cluster; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.Arrays; import java.util.List; import java.util.Random; import org.apache.commons.math.stat.clustering.Cluster; import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint; import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer; import org.fao.fisheries.chronicles.input.CsvImportProcess; import org.fao.fisheries.chronicles.input.Top200Csv; import org.junit.Test; public class ClusterAnalysisTest  @Test public void testPerformClusterAnalysis2()  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint points = new EuclideanIntegerPoint  new EuclideanIntegerPoint(new int   1959 325100  ) new EuclideanIntegerPoint(new int   1960 373200  ) ; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points) 1 1); assertEquals(1 clusters.size());  ", "A_clean_title": ["npe", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "unittestwhen", "unittest", "when", "run", "thi", "unittest", "am", "face", "thi", "npe", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "assignpointstoclust", "mean", "plu", "plu", "cluster", "assign", "point", "cluster", "kmeanspluspluscluster", "java:91", "mean", "plu", "plu", "cluster", "thi", "unittest", "packag", "org", "fao", "fisheri", "chronicl", "calcuat", "cluster", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "static", "org", "junit", "assert", "asserttru", "assert", "true", "import", "java", "util", "array", "import", "java", "util", "list", "import", "java", "util", "random", "import", "org", "apach", "common", "math", "stat", "cluster", "cluster", "import", "org", "apach", "common", "math", "stat", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "import", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "import", "org", "fao", "fisheri", "chronicl", "input", "csvimportprocess", "csv", "import", "process", "import", "org", "fao", "fisheri", "chronicl", "input", "top200csv", "import", "org", "junit", "test", "public", "class", "clusteranalysistest", "cluster", "analysi", "test", "test", "public", "void", "testperformclusteranalysis2", "test", "perform", "cluster", "analysis2", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "transform", "new", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "random", "1746432956321l", "euclideanintegerpoint", "euclidean", "integ", "point", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1959", "325100", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1960", "373200", "list", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "cluster", "transform", "cluster", "array", "aslist", "as", "list", "point", "assertequ", "assert", "equal", "cluster", "size"], "B_title": "removed int because it wasn  t working as expected. ", "B_clean_title": ["remov", "int", "becaus", "it", "wasn", "work", "as", "expect"]},
{"A_title": "NPE in DateTimeZoneBuilderWhen a DateTimeZone is build with duplicate-named recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:", "A_clean_title": ["npe", "datetimezonebuilderwhen", "date", "time", "zone", "builder", "when", "datetimezon", "date", "time", "zone", "build", "duplic", "name", "recur", "save", "time", "first", "thread", "all", "goe", "ok", "warn", "messag", "gener", "identifi", "automat", "gener", "precalculatedzon", "creat", "precalcul", "zone", "when", "second", "thread", "same", "npe", "gener", "zoneinfocompil", "verbos", "zone", "info", "compil", "caus", "that", "cverbos", "verbos", "threadloc", "thread", "local", "incorrectli", "initi", "zoneinfocompil", "zone", "info", "compil", "will", "initi", "cverbos", "verbos", "onli", "first", "thread", "not", "subsequ", "one", "npe", "caus", "by", "autobox", "better", "approach", "could", "remov", "initi", "test", "null"], "B_title": "Stops verbose output. ", "B_clean_title": ["stop", "verbos", "output"]},
{"A_title": "Brent solver doesnt throw IllegalArgumentException when initial guess has the wrong signJavadoc for public double solve(final UnivariateRealFunction f final double min final double max final double initial) claims that if the values of the function at the three points have the same sign an IllegalArgumentException is thrown. This case isnt even checked.", "A_clean_title": ["brent", "solver", "doesnt", "throw", "illegalargumentexcept", "illeg", "argument", "except", "when", "initi", "guess", "ha", "wrong", "signjavadoc", "sign", "javadoc", "public", "doubl", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "claim", "that", "valu", "function", "at", "three", "point", "have", "same", "sign", "illegalargumentexcept", "illeg", "argument", "except", "thrown", "thi", "case", "isnt", "even", "check"], "B_title": "Fixed a missing bracketing check of initial interval in Brent solver JIRA: MATH-343", "B_clean_title": ["fix", "miss", "bracket", "check", "initi", "interv", "brent", "solver", "jira", "math", "343"]},
{"A_title": "bug in inverseCumulativeProbability() for Normal Distribution@version  Revision: 617953    Date: 2008-02-02 22:54:00 -0700 (Sat 02 Feb 2008)    */ public class NormalDistributionImpl extends AbstractContinuousDistribution    @version  Revision: 506600    Date: 2007-02-12 12:35:59 -0700 (Mon 12 Feb 2007)    */ public abstract class AbstractContinuousDistribution  This code:         DistributionFactory factory = app.getDistributionFactory();         NormalDistribution normal = factory.createNormalDistribution(01);         double result = normal.inverseCumulativeProbability(0.9772498680518209); gives the exception below. It should return (approx) 2.0000... normal.inverseCumulativeProbability(0.977249868051820); works fine These also give errors: 0.9986501019683698 (should return 3.0000...) 0.9999683287581673 (should return 4.0000...) org.apache.commons.math.MathException: Number of iterations=1 maximum iterations=2147483647 initial=1 lower bound=0 upper bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 final a value=0 final b value=2 f(a)=-0.477 f(b)=0 at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103) at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "A_clean_title": ["bug", "inversecumulativeprob", "invers", "cumul", "probabl", "normal", "distribut", "version", "revis", "617953", "date", "2008", "02", "02", "22:54:00", "0700", "sat", "02", "feb", "2008", "public", "class", "normaldistributionimpl", "normal", "distribut", "impl", "extend", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "version", "revis", "506600", "date", "2007", "02", "12", "12:35:59", "0700", "mon", "12", "feb", "2007", "public", "abstract", "class", "abstractcontinuousdistribut", "abstract", "continu", "distribut", "thi", "code", "distributionfactori", "distribut", "factori", "factori", "app", "getdistributionfactori", "get", "distribut", "factori", "normaldistribut", "normal", "distribut", "normal", "factori", "createnormaldistribut", "creat", "normal", "distribut", "01", "doubl", "result", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "9772498680518209", "give", "except", "below", "it", "return", "approx", "0000", "normal", "inversecumulativeprob", "invers", "cumul", "probabl", "977249868051820", "work", "fine", "these", "also", "give", "error", "9986501019683698", "return", "0000", "9999683287581673", "return", "0000", "org", "apach", "common", "math", "mathexcept", "math", "except", "number", "iterations=1", "maximum", "iterations=2147483647", "initial=1", "lower", "bound=0", "upper", "bound=179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "final", "value=0", "final", "value=2", "477", "=0", "at", "org", "apach", "common", "math", "distribut", "abstractcontinuousdistribut", "inversecumulativeprob", "abstract", "continu", "distribut", "invers", "cumul", "probabl", "abstractcontinuousdistribut", "java:103", "abstract", "continu", "distribut", "at", "org", "apach", "common", "math", "distribut", "normaldistributionimpl", "inversecumulativeprob", "normal", "distribut", "impl", "invers", "cumul", "probabl", "normaldistributionimpl", "java:145", "normal", "distribut", "impl"], "B_title": "fixed a bracketing issue due to inconsistent checks JIRA: MATH-280", "B_clean_title": ["fix", "bracket", "issu", "due", "inconsist", "check", "jira", "math", "280"]},
{"A_title": "MathRuntimeException with simple ebeMultiply on OpenMapRealVectorThe following piece of code  import org.apache.commons.math.linear.OpenMapRealVector; import org.apache.commons.math.linear.RealVector;  public class DemoBugOpenMapRealVector      public static void main(String args)          final RealVector u = new OpenMapRealVector(3 1E-6);         u.setEntry(0 1.);         u.setEntry(1 0.);         u.setEntry(2 2.);         final RealVector v = new OpenMapRealVector(3 1E-6);         v.setEntry(0 0.);         v.setEntry(1 3.);         v.setEntry(2 0.);         System.out.println(u);         System.out.println(v);         System.out.println(u.ebeMultiply(v));         raises an exception  org.apache.commons.math.linear.OpenMapRealVector@7170a9b6 Exception in thread main org.apache.commons.math.MathRuntimeException 6: map has been modified while iterating at org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373) at org.apache.commons.math.util.OpenIntToDoubleHashMap Iterator.advance(OpenIntToDoubleHashMap.java:564) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372) at org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:1) at DemoBugOpenMapRealVector.main(DemoBugOpenMapRealVector.java:17)", "A_clean_title": ["mathruntimeexcept", "math", "runtim", "except", "simpl", "ebemultipli", "ebe", "multipli", "openmaprealvectorth", "open", "map", "real", "vector", "follow", "piec", "code", "import", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "import", "org", "apach", "common", "math", "linear", "realvector", "real", "vector", "public", "class", "demobugopenmaprealvector", "demo", "bug", "open", "map", "real", "vector", "public", "static", "void", "main", "string", "arg", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "final", "realvector", "real", "vector", "new", "openmaprealvector", "open", "map", "real", "vector", "1e", "setentri", "set", "entri", "setentri", "set", "entri", "setentri", "set", "entri", "system", "out", "println", "system", "out", "println", "system", "out", "println", "ebemultipli", "ebe", "multipli", "rais", "except", "org", "apach", "common", "math", "linear", "openmaprealvector", "open", "map", "real", "vector", "7170a9b6", "except", "thread", "main", "org", "apach", "common", "math", "mathruntimeexcept", "math", "runtim", "except", "map", "ha", "been", "modifi", "while", "iter", "at", "org", "apach", "common", "math", "mathruntimeexcept", "createconcurrentmodificationexcept", "math", "runtim", "except", "creat", "concurr", "modif", "except", "mathruntimeexcept", "java:373", "math", "runtim", "except", "at", "org", "apach", "common", "math", "util", "openinttodoublehashmap", "open", "int", "doubl", "hash", "map", "iter", "advanc", "openinttodoublehashmap", "java:564", "open", "int", "doubl", "hash", "map", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:372", "open", "map", "real", "vector", "at", "org", "apach", "common", "math", "linear", "openmaprealvector", "ebemultipli", "open", "map", "real", "vector", "ebe", "multipli", "openmaprealvector", "java:1", "open", "map", "real", "vector", "at", "demobugopenmaprealvector", "main", "demo", "bug", "open", "map", "real", "vector", "demobugopenmaprealvector", "java:17", "demo", "bug", "open", "map", "real", "vector"], "B_title": "Iterate on the original vector not on the copy that is modified.", "B_clean_title": ["iter", "origin", "vector", "not", "copi", "that", "modifi"]},
{"A_title": "StringUtils.join throws NPE when toString returns null for one of objects in collectionTry    StringUtils.join(new Object         new Object()            @Override           public String toString()              return null;                          );   ToString should probably never return null but it does in javax.mail.internet.InternetAddress", "A_clean_title": ["stringutil", "join", "string", "util", "throw", "npe", "when", "tostr", "string", "return", "null", "one", "object", "collectiontri", "collect", "tri", "stringutil", "join", "string", "util", "new", "object", "new", "object", "overrid", "public", "string", "tostr", "string", "return", "null", "tostr", "string", "probabl", "never", "return", "null", "but", "it", "javax", "mail", "internet", "internetaddress", "internet", "address"], "B_title": "Applying Ilyas patch from LANG-703 fixing an NPE when toString returns null", "B_clean_title": ["appli", "ilya", "patch", "lang", "703", "fix", "npe", "when", "tostr", "string", "return", "null"]},
{"A_title": "JCommon 1.0.12 ShapeUtilities.equal(path1path2)The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1 GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "A_clean_title": ["jcommon", "common", "12", "shapeutil", "equal", "shape", "util", "path1path2", "comparison", "two", "generalpath", "gener", "path", "object", "use", "same", "pathiter", "path", "iter", "both", "object", "equal", "generalpath", "gener", "path", "path1", "generalpath", "gener", "path", "path2", "will", "thu", "return", "true", "ani", "pair", "non", "null", "generalpath", "gener", "path", "instanc", "have", "same", "windingrul", "wind", "rule"], "B_title": "source/org/jfree/chart/util/SerialUtilities.java (readShape): Handle SEG_CLOSE for GeneralPath Use correct path for comparison.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "util", "serialutil", "serial", "util", "readshap", "read", "shape", "handl", "seg", "close", "generalpath", "gener", "path", "use", "correct", "path", "comparison"]},
{"A_title": "event state not updated if an unrelated event triggers a RESET_STATE during ODE integrationWhen an ODE solver manages several different event types there are some unwanted side effects. If one event handler asks for a RESET_STATE (for integration state) when its eventOccurred method is called the other event handlers that did not trigger an event in the same step are not updated correctly due to an early return. As a result when the next step is processed with a reset integration state the forgotten event still refer to the start date of the previous state. This implies that when these event handlers will be checked for In some cases the function defining an event g(double t double y) is called with state parameters y that are completely wrong. In one case when the y array should have contained values between -1 and +1 one function call got values up to 1.0e20. The attached file reproduces the problem.", "A_clean_title": ["event", "state", "not", "updat", "unrel", "event", "trigger", "reset", "state", "dure", "ode", "integrationwhen", "integr", "when", "ode", "solver", "manag", "sever", "differ", "event", "type", "there", "are", "some", "unwant", "side", "effect", "one", "event", "handler", "ask", "reset", "state", "integr", "state", "when", "it", "eventoccur", "event", "occur", "method", "call", "other", "event", "handler", "that", "did", "not", "trigger", "event", "same", "step", "are", "not", "updat", "correctli", "due", "earli", "return", "as", "result", "when", "next", "step", "process", "reset", "integr", "state", "forgotten", "event", "still", "refer", "start", "date", "previou", "state", "thi", "impli", "that", "when", "these", "event", "handler", "will", "check", "some", "case", "function", "defin", "event", "doubl", "doubl", "call", "state", "paramet", "that", "are", "complet", "wrong", "one", "case", "when", "array", "have", "contain", "valu", "between", "+1", "one", "function", "call", "got", "valu", "up", "0e20", "attach", "file", "reproduc", "problem"], "B_title": "Fixed missing update in ODE event handlers.", "B_clean_title": ["fix", "miss", "updat", "ode", "event", "handler"]},
{"A_title": ".withHourOfDay() sets hour inconsistantly on DST transition.When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I cant find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.", "A_clean_title": ["withhourofday", "hour", "day", "set", "hour", "inconsistantli", "dst", "transit", "when", "hour", "day", "set", "ambigu", "hour", "daylight", "standard", "time", "transit", "given", "time", "zone", "result", "inconsist", "differ", "time", "zone", "shoul", "hour", "set", "daylight", "hour", "or", "standard", "hour", "all", "time", "zone", "cant", "find", "anyth", "that", "document", "thi", "behavior", "my", "test", "code", "below", "return", "differ", "result", "differ", "time", "zone", "veri", "last", "assert", "fail", "australia", "time", "zone", "cutov"], "B_title": "bugs 310276021824442553453 New method now retains the offset wherever possible during calculations This affects higher methods like withHourOfDay/withMinuteOfHour/withSecondOfMinute/withMillisOfSecond which now do not change offset when called within a DST overlap", "B_clean_title": ["bug", "310276021824442553453", "new", "method", "now", "retain", "offset", "wherev", "possibl", "dure", "calcul", "thi", "affect", "higher", "method", "like", "withhourofday", "withminuteofhour", "withsecondofminut", "withmillisofsecond", "hour", "day", "minut", "hour", "second", "minut", "milli", "second", "which", "now", "not", "chang", "offset", "when", "call", "within", "dst", "overlap"]},
{"A_title": "DateTimeFormatter.parseInto broken when no year in formatIn Joda Time 2.0 the default year was set to 2000 so that Feb 29 could be parsed correctly. However parseInto now overwrites the given instants year with 2000 (or whatever iDefaultYear is set to). The correct behavior would seem to be to use the given instants year instead of iDefaultYear. This does mean that Feb 29 might not be parseable if the instants year is not a leap year but in this case the caller asked for that in a sense.", "A_clean_title": ["datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "broken", "when", "no", "year", "formatin", "format", "joda", "time", "default", "year", "wa", "set", "2000", "so", "that", "feb", "29", "could", "pars", "correctli", "howev", "parseinto", "pars", "into", "now", "overwrit", "given", "instant", "year", "2000", "or", "whatev", "idefaultyear", "default", "year", "set", "correct", "behavior", "would", "seem", "use", "given", "instant", "year", "instead", "idefaultyear", "default", "year", "thi", "mean", "that", "feb", "29", "might", "not", "parseabl", "instant", "year", "not", "leap", "year", "but", "thi", "case", "caller", "ask", "that", "sens"], "B_title": "Fix DateTimeFormatter.parseInto() 3522138", "B_clean_title": ["fix", "datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "3522138"]},
{"A_title": "StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as uD840uDC00 private static final String CharU20000 = uD840uDC00; private static final String CharU20001 = uD840uDC01; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals(-1 CharU20000.indexOf(CharU20001)); But this is broken: assertEquals(false StringUtils.containsAny(CharU20000 CharU20001)); assertEquals(false StringUtils.containsAny(CharU20001 CharU20000)); This is fine: assertEquals(true StringUtils.contains(CharU20000 + CharU20001 CharU20000)); assertEquals(true StringUtils.contains(CharU20000 + CharU20001 CharU20001)); assertEquals(true StringUtils.contains(CharU20000 CharU20000)); assertEquals(false StringUtils.contains(CharU20000 CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/", "A_clean_title": ["stringutil", "string", "util", "method", "not", "handl", "unicod", "0+", "supplementari", "charact", "correctli", "stringutil", "containsani", "string", "util", "contain", "ani", "method", "incorrectli", "match", "unicod", "0+", "supplementari", "charact", "exampl", "defin", "test", "fixtur", "unicod", "charact", "u+20000", "where", "u+20000", "written", "java", "sourc", "as", "ud840udc00", "d840u", "dc00", "privat", "static", "final", "string", "charu20000", "char", "u20000", "ud840udc00", "d840u", "dc00", "privat", "static", "final", "string", "charu20001", "char", "u20001", "ud840udc01", "d840u", "dc01", "you", "see", "unicod", "supplementari", "charact", "correctli", "implement", "jre", "call", "assertequ", "assert", "equal", "charu20000", "indexof", "char", "u20000", "index", "charu20001", "char", "u20001", "but", "thi", "broken", "assertequ", "assert", "equal", "fals", "stringutil", "containsani", "string", "util", "contain", "ani", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "assertequ", "assert", "equal", "fals", "stringutil", "containsani", "string", "util", "contain", "ani", "charu20001", "char", "u20001", "charu20000", "char", "u20000", "thi", "fine", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "charu20000", "char", "u20000", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "charu20001", "char", "u20001", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20000", "char", "u20000", "assertequ", "assert", "equal", "fals", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "becaus", "method", "call", "jre", "perform", "match", "more", "than", "you", "want", "know", "http", "sun", "java", "com", "develop", "technicalarticl", "intl", "supplementari", "technic", "articl"], "B_title": "StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters.", "B_clean_title": ["stringutil", "containsani", "string", "util", "contain", "ani", "method", "incorrectli", "match", "unicod", "0+", "supplementari", "charact"]},
{"A_title": "Basic variable is not found correctly in simplex tableauThe last patch to SimplexTableau caused an automated test suite Im running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code. SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable which is incorrect - the entry should have a value equal to 1.", "A_clean_title": ["basic", "variabl", "not", "found", "correctli", "simplex", "tableauth", "tableau", "last", "patch", "simplextableau", "simplex", "tableau", "caus", "autom", "test", "suit", "im", "run", "at", "work", "go", "down", "new", "code", "path", "uncov", "what", "hope", "last", "bug", "remain", "simplex", "code", "simplextableau", "simplex", "tableau", "wa", "assum", "entri", "tableau", "had", "nonzero", "indic", "basic", "variabl", "which", "incorrect", "entri", "have", "valu", "equal"], "B_title": "Fixed a wrong check for basic variables JIRA: MATH-273", "B_clean_title": ["fix", "wrong", "check", "basic", "variabl", "jira", "math", "273"]},
{"A_title": "RealMatrixImpl#operate gets result vector dimensions wrongorg.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix. Thus line 640 in RealMatrixImpl.java should read double out = new doublenRows; instead of double out = new doublev.length;", "A_clean_title": ["realmatriximpl", "real", "matrix", "impl", "oper", "get", "result", "vector", "dimens", "wrongorg", "apach", "common", "math", "linear", "realmatriximpl", "real", "matrix", "impl", "oper", "tri", "creat", "result", "vector", "that", "alway", "ha", "same", "length", "as", "input", "vector", "thi", "result", "runtim", "except", "matrix", "non", "squar", "it", "alway", "yield", "incorrect", "result", "matrix", "non", "squar", "correct", "behaviour", "would", "cours", "creat", "vector", "same", "length", "as", "row", "dimens", "matrix", "thu", "line", "640", "realmatriximpl", "java", "real", "matrix", "impl", "read", "doubl", "out", "new", "doublenrow", "doublen", "row", "instead", "doubl", "out", "new", "doublev", "length"], "B_title": "fixed dimension error in operate method for RealMatrixImpl and BigMatrixImpl JIRA: MATH-209", "B_clean_title": ["fix", "dimens", "error", "oper", "method", "realmatriximpl", "real", "matrix", "impl", "bigmatriximpl", "big", "matrix", "impl", "jira", "math", "209"]},
{"A_title": "LookupTranslator accepts CharSequence as input but fails to work with implementations other than StringThe core of org.apache.commons.lang3.text.translate is a HashMap<CharSequence CharSequence> lookupMap. From the Javadoc of CharSequence (emphasis mine):  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore in general undefined. Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map. The current implementation causes code such as the following to not work as expected:  CharSequence cs1 = 1 < 2; CharSequence cs2 = CharBuffer.wrap(1 < 2.toCharArray());  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1)); System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));   ... which gives the following results (but should be identical):  1 &lt; 2 1 < 2   The problem at a minimum is that CharBuffer.equals is even documented in the Javadoc that:  A char buffer is not equal to any other type of object. ... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains. An obvious work-around is to instead use something along the lines of either of the following:  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString())); System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));   ... which forces everything back to a String.  However this is not practical when working with large sets of data which would require significant heap allocations and garbage collection concerns.  (As such I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.) Another option that Im considering is to use a custom CharSequence wrapper around a char that implements hashCode() and equals() to work with those implemented on String.  (However this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)", "A_clean_title": ["lookuptransl", "lookup", "translat", "accept", "charsequ", "char", "sequenc", "as", "input", "but", "fail", "work", "implement", "other", "than", "stringth", "string", "core", "org", "apach", "common", "lang3", "text", "translat", "hashmap", "hash", "map", "charsequ", "char", "sequenc", "charsequ", "char", "sequenc", "lookupmap", "lookup", "map", "javadoc", "charsequ", "char", "sequenc", "emphasi", "mine", "thi", "interfac", "not", "refin", "gener", "contract", "equal", "hashcod", "hash", "code", "method", "result", "compar", "two", "object", "that", "implement", "charsequ", "char", "sequenc", "therefor", "gener", "undefin", "each", "object", "may", "implement", "by", "differ", "class", "there", "no", "guarante", "that", "each", "class", "will", "capabl", "test", "it", "instanc", "equal", "those", "other", "it", "therefor", "inappropri", "use", "arbitrari", "charsequ", "char", "sequenc", "instanc", "as", "element", "set", "or", "as", "key", "map", "current", "implement", "caus", "code", "such", "as", "follow", "not", "work", "as", "expect", "charsequ", "char", "sequenc", "cs1", "charsequ", "char", "sequenc", "cs2", "charbuff", "wrap", "char", "buffer", "tochararray", "char", "array", "system", "out", "println", "stringescapeutil", "translat", "string", "escap", "util", "escap", "html4", "cs1", "system", "out", "println", "stringescapeutil", "translat", "string", "escap", "util", "escap", "html4", "cs2", "which", "give", "follow", "result", "but", "ident", "lt", "problem", "at", "minimum", "that", "charbuff", "equal", "char", "buffer", "even", "document", "javadoc", "that", "char", "buffer", "not", "equal", "ani", "other", "type", "object", "so", "lookup", "charbuff", "char", "buffer", "map", "will", "alway", "fail", "when", "compar", "against", "string", "implement", "that", "it", "contain", "obviou", "work", "around", "instead", "use", "someth", "along", "line", "either", "follow", "system", "out", "println", "stringescapeutil", "translat", "string", "escap", "util", "escap", "html4", "cs2", "tostr", "string", "system", "out", "println", "stringescapeutil", "escapehtml4", "string", "escap", "util", "escap", "html4", "cs2", "tostr", "string", "which", "forc", "everyth", "back", "string", "howev", "thi", "not", "practic", "when", "work", "larg", "set", "data", "which", "would", "requir", "signific", "heap", "alloc", "garbag", "collect", "concern", "as", "such", "wa", "actual", "tri", "use", "translat", "method", "that", "output", "writer", "but", "simplifi", "abov", "exampl", "omit", "thi", "anoth", "option", "that", "im", "consid", "use", "custom", "charsequ", "char", "sequenc", "wrapper", "around", "char", "that", "implement", "hashcod", "hash", "code", "equal", "work", "those", "implement", "string", "howev", "thi", "will", "interest", "due", "symmetr", "assumpt", "which", "further", "interest", "that", "string", "equal", "current", "implement", "instanceof", "even", "though", "string", "final"], "B_title": "Allow LookupTranslator to support CharSequence properly; previously it was working only for CharSequences that implemented hashCode and equals(Object). LANG-882", "B_clean_title": ["allow", "lookuptransl", "lookup", "translat", "support", "charsequ", "char", "sequenc", "properli", "previous", "it", "wa", "work", "onli", "charsequ", "char", "sequenc", "that", "implement", "hashcod", "hash", "code", "equal", "object", "lang", "882"]},
{"A_title": "Fix for MultiplePiePlotWhen dataset is passed into constructor for MultiplePiePlot the dataset is not wired to a listener as it would be if setDataset is called.", "A_clean_title": ["fix", "multiplepieplotwhen", "multipl", "pie", "plot", "when", "dataset", "pass", "into", "constructor", "multiplepieplot", "multipl", "pie", "plot", "dataset", "not", "wire", "listen", "as", "it", "would", "setdataset", "set", "dataset", "call"], "B_title": "source/org/jfree/chart/plot/MultiplePiePlot.java (MultiplePiePlot(CategoryDataset)): Call setDataset() to ensure that plot registers as a dataset listener.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "plot", "multiplepieplot", "multipl", "pie", "plot", "multiplepieplot", "multipl", "pie", "plot", "categorydataset", "categori", "dataset", "call", "setdataset", "set", "dataset", "ensur", "that", "plot", "regist", "as", "dataset", "listen"]},
{"A_title": "Complex Add and Subtract handle NaN arguments differently but javadoc contracts are the sameFor both Complex add and subtract the javadoc states that       * If either this or <code>rhs</code> has a NaN value in either part      * @link #NaN is returned; otherwise Inifinite and NaN values are      * returned in the parts of the result according to the rules for      * @link java.lang.Double arithmetic   Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test.  The test should be added to the add implementation (actually restored since this looks like a code merge problem going back to 1.1).", "A_clean_title": ["complex", "add", "subtract", "handl", "nan", "na", "argument", "differ", "but", "javadoc", "contract", "are", "samefor", "same", "both", "complex", "add", "subtract", "javadoc", "state", "that", "either", "thi", "or", "code", "rh", "code", "ha", "nan", "na", "valu", "either", "part", "link", "nan", "na", "return", "otherwis", "inifinit", "nan", "na", "valu", "are", "return", "part", "result", "accord", "rule", "link", "java", "lang", "doubl", "arithmet", "subtract", "includ", "isnan", "na", "test", "return", "complex", "nan", "na", "either", "complex", "argument", "isnan", "na", "but", "add", "omit", "thi", "test", "test", "ad", "add", "implement", "actual", "restor", "sinc", "thi", "look", "like", "code", "merg", "problem", "go", "back"], "B_title": "Fixed add method to match javadoc contract when one or both addends has NaN parts.", "B_clean_title": ["fix", "add", "method", "match", "javadoc", "contract", "when", "one", "or", "both", "addend", "ha", "nan", "na", "part"]},
{"A_title": "FastDateFormats z pattern does not respect timezone of Calendar instances passed to format()The work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3. The problem can be seen by this snippet:  // Always prints timezone name of machines default timezone ignoring TZ // set on calendar even though the printed time itself respects calendars TZ. Calendar myCal = Calendar.getInstance(TimeZone.getTimeZone(US/Central)); System.out.println(FastDateFormat.getInstance(h:mma z).format(myCal));   If you happen to be in US/Central this will print the right thing but just try it with US/Eastern US/Pacific etc.  It will print the time in the correct timezone but the timezone name at the end (the z pattern) will always be the system default timezone.  This is a regression against commons-lang 2.x. Basically when the forced time zone code was removed the TimeZoneNameRule class stopped respecting the Calendar instances timezone and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long). The removal of the forced time zone stuff is surely the right thing to do (it was a mess).  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance but rather to use the TimeZone on the Calendar instance passed into appendTo() just like TimeZoneNumberRule does.  Presumably then for efficiency one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezones display name.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "pattern", "not", "respect", "timezon", "calendar", "instanc", "pass", "format", "work", "lang", "462", "ha", "introduc", "time", "zone", "format", "bug", "fastdateformat", "fast", "date", "format", "common", "lang3", "problem", "seen", "by", "thi", "snippet", "alway", "print", "timezon", "name", "machin", "default", "timezon", "ignor", "tz", "set", "calendar", "even", "though", "print", "time", "itself", "respect", "calendar", "tz", "calendar", "mycal", "my", "cal", "calendar", "getinst", "get", "instanc", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "us", "central", "system", "out", "println", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "mma", "format", "mycal", "my", "cal", "you", "happen", "us", "central", "thi", "will", "print", "right", "thing", "but", "just", "tri", "it", "us", "eastern", "us", "pacif", "etc", "it", "will", "print", "time", "correct", "timezon", "but", "timezon", "name", "at", "end", "pattern", "will", "alway", "system", "default", "timezon", "thi", "regress", "against", "common", "lang", "basic", "when", "forc", "time", "zone", "code", "wa", "remov", "timezonenamerul", "time", "zone", "name", "rule", "class", "stop", "respect", "calendar", "instanc", "timezon", "instead", "now", "alway", "use", "mtimezon", "time", "zone", "fastdateformat", "fast", "date", "format", "instanc", "itself", "which", "onli", "suppos", "use", "when", "format", "timezon", "less", "object", "such", "as", "date", "or", "long", "remov", "forc", "time", "zone", "stuff", "sure", "right", "thing", "it", "wa", "mess", "think", "fix", "chang", "timezonenamerul", "time", "zone", "name", "rule", "inner", "class", "not", "take", "timezon", "time", "zone", "instanc", "but", "rather", "use", "timezon", "time", "zone", "calendar", "instanc", "pass", "into", "appendto", "append", "just", "like", "timezonenumberrul", "time", "zone", "number", "rule", "presum", "then", "effici", "one", "would", "use", "gettimezonedisplay", "get", "time", "zone", "display", "packag", "static", "method", "quickli", "retriev", "requir", "timezon", "display", "name"], "B_title": "FastDateFormats z pattern does not respect timezone of Calendar instances passed to format()", "B_clean_title": ["fastdateformat", "fast", "date", "format", "pattern", "not", "respect", "timezon", "calendar", "instanc", "pass", "format"]},
{"A_title": "ArrayUtils.addAll(T array1 T... array2) does not handle mixed types very wellArrayUtils.addAll(T array1 T... array2) does not handle mixed array types very well. The stack trace for  Number st = ArrayUtils.addAll(new Integer 1  new Long 2L ); starts: java.lang.ArrayStoreException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962) which is not all that obvious. It would be a lot clearer if the method threw an IlegalArgumentException or similar.", "A_clean_title": ["arrayutil", "addal", "array", "util", "add", "all", "array1", "array2", "not", "handl", "mix", "type", "veri", "wellarrayutil", "addal", "well", "array", "util", "add", "all", "array1", "array2", "not", "handl", "mix", "array", "type", "veri", "well", "stack", "trace", "number", "st", "arrayutil", "addal", "array", "util", "add", "all", "new", "integ", "new", "long", "2l", "start", "java", "lang", "arraystoreexcept", "array", "store", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang3", "arrayutil", "addal", "array", "util", "add", "all", "arrayutil", "java:2962", "array", "util", "which", "not", "all", "that", "obviou", "it", "would", "lot", "clearer", "method", "threw", "ilegalargumentexcept", "ileg", "argument", "except", "or", "similar"], "B_title": "- ArrayUtils.addAll(T array1 T... array2) does not handle mixed types very well Also remove unnecessary main() and suite() from test class", "B_clean_title": ["arrayutil", "addal", "array", "util", "add", "all", "array1", "array2", "not", "handl", "mix", "type", "veri", "well", "also", "remov", "unnecessari", "main", "suit", "test", "class"]},
{"A_title": "Special functions not very accurateThe Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy as this is what Id expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.", "A_clean_title": ["special", "function", "not", "veri", "accurateth", "accur", "gamma", "beta", "function", "return", "valu", "doubl", "precis", "but", "default", "epsilon", "set", "10e", "think", "that", "default", "set", "highest", "possibl", "accuraci", "as", "thi", "what", "id", "expect", "return", "by", "doubl", "precis", "routin", "note", "that", "erf", "function", "alreadi", "use", "call", "gamma", "regularizedgammap", "regular", "gamma", "epsilon", "15", "0e"], "B_title": "Increased default epsilon for Gamma Beta function evaluation. JIRA: MATH-166 Reported and patched by Lukas Theussl", "B_clean_title": ["increas", "default", "epsilon", "gamma", "beta", "function", "evalu", "jira", "math", "166", "report", "patch", "by", "luka", "theussl"]},
{"A_title": "wrong result in eigen decompositionSome results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0      public void testMathpbx02()           double mainTridiagonal =            7484.860960227216 18405.28129035345 13855.225609560746          10016.708722343366 559.8117399576674 6750.190788301587              71.21428769782159         ;         double secondaryTridiagonal =           -4175.0885704763661975.79558582419945193.178422374075            1995.28665916917975.34535882933804-234.0808002076056         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =          20654.74489030697441216828.208208485466457         6893.1559126349948206757.083016675340332         5887.79988568855878864.309089923240379         57.992628792736340         ;         RealVector refEigenVectors =          new ArrayRealVector(new double -0.270356342026904 0.852811091326997 0.399639490702077 0.198794657813990 0.019739323307666 0.000106983022327 -0.000001216636321)         new ArrayRealVector(new double 0.179995273578326-0.4028078481530420.7018709935257340.5550582110148880.0680791488982360.000509139115227-0.000007112235617)         new ArrayRealVector(new double -0.399582721284727-0.056629954519333-0.5144064885228270.7111681645185800.2255480812763670.125943999652923-0.004321507456014)         new ArrayRealVector(new double 0.0585157215728210.0102001300577390.063516274916536-0.090696087449378-0.0171484204325970.991318870265707-0.034707338554096)         new ArrayRealVector(new double 0.8552059955375640.327134656629775-0.2653823970605480.2826907290267060.105736068025572-0.0091381266220390.000367751821196)         new ArrayRealVector(new double -0.002913069901144-0.0051775157771010.041906334478672-0.1093159184162580.4361923054567410.0263073156395350.891797507436344)         new ArrayRealVector(new double -0.005738311176435-0.0102076116703780.082662420517928-0.2157338860943680.861606487840411-0.025478530652759-0.451080697503958)         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-3);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-5);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-5);", "A_clean_title": ["wrong", "result", "eigen", "decompositionsom", "decomposit", "some", "result", "comput", "by", "eigendecompositionimpl", "eigen", "decomposit", "impl", "are", "wrong", "follow", "case", "comput", "by", "fortran", "lapack", "fail", "version", "public", "void", "testmathpbx02", "test", "mathpbx02", "doubl", "maintridiagon", "main", "tridiagon", "7484", "860960227216", "18405", "28129035345", "13855", "225609560746", "10016", "708722343366", "559", "8117399576674", "6750", "190788301587", "71", "21428769782159", "doubl", "secondarytridiagon", "secondari", "tridiagon", "4175", "0885704763661975", "79558582419945193", "178422374075", "1995", "28665916917975", "34535882933804", "234", "0808002076056", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "20654", "74489030697441216828", "208208485466457", "6893", "1559126349948206757", "083016675340332", "5887", "79988568855878864", "309089923240379", "57", "992628792736340", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "270356342026904", "852811091326997", "399639490702077", "198794657813990", "019739323307666", "000106983022327", "000001216636321", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "179995273578326", "4028078481530420", "7018709935257340", "5550582110148880", "0680791488982360", "000509139115227", "000007112235617", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "399582721284727", "056629954519333", "5144064885228270", "7111681645185800", "2255480812763670", "125943999652923", "004321507456014", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "0585157215728210", "0102001300577390", "063516274916536", "090696087449378", "0171484204325970", "991318870265707", "034707338554096", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "8552059955375640", "327134656629775", "2653823970605480", "2826907290267060", "105736068025572", "0091381266220390", "000367751821196", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "002913069901144", "0051775157771010", "041906334478672", "1093159184162580", "4361923054567410", "0263073156395350", "891797507436344", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "005738311176435", "0102076116703780", "082662420517928", "2157338860943680", "861606487840411", "025478530652759", "451080697503958", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e"], "B_title": "Fixed an index computation error in eigen decomposition. Once again kudos to Dimitri for debugging this. JIRA: MATH-318", "B_clean_title": ["fix", "index", "comput", "error", "eigen", "decomposit", "onc", "again", "kudo", "dimitri", "debug", "thi", "jira", "math", "318"]},
{"A_title": "BSPTree class and recovery of a Euclidean 3D BRepNew to the work here. Thanks for your efforts on this code. I create a BSPTree from a BoundaryRep (Brep) my test Brep is a cube as represented by a float array containing 8 3D points in(xyz) order and an array of indices (12 triplets for the 12 faces of the cube). I construct a BSPMesh() as shown in the code below. I can construct the PolyhedronsSet() but have problems extracting the faces from the BSPTree to reconstruct the BRep. The attached code (BSPMesh2.java) shows that a small change to 1 of the vertex positions causes/corrects the problem. Any ideas?", "A_clean_title": ["bsptree", "bsp", "tree", "class", "recoveri", "euclidean", "3d", "brepnew", "rep", "new", "work", "here", "thank", "your", "effort", "thi", "code", "creat", "bsptree", "bsp", "tree", "boundaryrep", "boundari", "rep", "brep", "my", "test", "brep", "cube", "as", "repres", "by", "float", "array", "contain", "3d", "point", "xyz", "order", "array", "indic", "12", "triplet", "12", "face", "cube", "construct", "bspmesh", "bsp", "mesh", "as", "shown", "code", "below", "construct", "polyhedronsset", "polyhedron", "set", "but", "have", "problem", "extract", "face", "bsptree", "bsp", "tree", "reconstruct", "brep", "rep", "attach", "code", "bspmesh2", "java", "bsp", "mesh2", "show", "that", "small", "chang", "vertex", "posit", "caus", "correct", "problem", "ani", "idea"], "B_title": "Fixed a wrong assumption on BSP tree attributes.", "B_clean_title": ["fix", "wrong", "assumpt", "bsp", "tree", "attribut"]},
{"A_title": "FastDateParser does not handle white-space properlyThe SimpleDateFormat Javadoc does not treat white-space specially however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properlyth", "properli", "simpledateformat", "simpl", "date", "format", "javadoc", "not", "treat", "white", "space", "special", "howev", "fastdatepars", "fast", "date", "parser", "treat", "singl", "white", "space", "as", "be", "ani", "number", "white", "space", "charact", "thi", "mean", "that", "fdp", "will", "pars", "date", "that", "fail", "when", "pars", "by", "sdp"], "B_title": "FastDateParser does not handle white-space properly", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "white", "space", "properli"]},
{"A_title": "FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() wont changeThe FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null then it is not made part of the key but the stored object is created using the current default locale. If the Locale is changed subsequently then the wrong locale is applied. Patch for test case to follow.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "assum", "local", "getdefault", "get", "default", "wont", "changeth", "chang", "fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "method", "creat", "hashmap", "hash", "map", "key", "variou", "item", "includ", "local", "local", "null", "then", "it", "not", "made", "part", "key", "but", "store", "object", "creat", "current", "default", "local", "local", "chang", "subsequ", "then", "wrong", "local", "appli", "patch", "test", "case", "follow"], "B_title": "Applying Sebbs test and fix from LANG-368 - fixing it so that FastDateFormat getDateInstance and getDateTimeInstance continue to work if Locale.getDefault() changes", "B_clean_title": ["appli", "sebb", "test", "fix", "lang", "368", "fix", "it", "so", "that", "fastdateformat", "fast", "date", "format", "getdateinst", "get", "date", "instanc", "getdatetimeinst", "get", "date", "time", "instanc", "continu", "work", "local", "getdefault", "get", "default", "chang"]},
{"A_title": "Different behaviour of PeriodFormatterWhen the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I cant find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.", "A_clean_title": ["differ", "behaviour", "periodformatterwhen", "period", "formatt", "when", "hour", "day", "set", "ambigu", "hour", "daylight", "standard", "time", "transit", "given", "time", "zone", "result", "inconsist", "differ", "time", "zone", "shoul", "hour", "set", "daylight", "hour", "or", "standard", "hour", "all", "time", "zone", "cant", "find", "anyth", "that", "document", "thi", "behavior", "my", "test", "code", "below", "return", "differ", "result", "differ", "time", "zone", "veri", "last", "assert", "fail", "australia", "time", "zone", "cutov"], "B_title": "Period formatter builder append(PeriodFormatter) did not handle some case 2495455 test from Bjoern Ricks", "B_clean_title": ["period", "formatt", "builder", "append", "periodformatt", "period", "formatt", "did", "not", "handl", "some", "case", "2495455", "test", "bjoern", "rick"]},
{"A_title": "NPE in  KMeansPlusPlusClusterer unittestWhen running this unittest I am facing this NPE: java.lang.NullPointerException at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91) This is the unittest: package org.fao.fisheries.chronicles.calcuation.cluster; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import java.util.Arrays; import java.util.List; import java.util.Random; import org.apache.commons.math.stat.clustering.Cluster; import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint; import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer; import org.fao.fisheries.chronicles.input.CsvImportProcess; import org.fao.fisheries.chronicles.input.Top200Csv; import org.junit.Test; public class ClusterAnalysisTest  @Test public void testPerformClusterAnalysis2()  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint points = new EuclideanIntegerPoint  new EuclideanIntegerPoint(new int   1959 325100  ) new EuclideanIntegerPoint(new int   1960 373200  ) ; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points) 1 1); assertEquals(1 clusters.size());", "A_clean_title": ["npe", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "unittestwhen", "unittest", "when", "run", "thi", "unittest", "am", "face", "thi", "npe", "java", "lang", "nullpointerexcept", "null", "pointer", "except", "at", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "assignpointstoclust", "mean", "plu", "plu", "cluster", "assign", "point", "cluster", "kmeanspluspluscluster", "java:91", "mean", "plu", "plu", "cluster", "thi", "unittest", "packag", "org", "fao", "fisheri", "chronicl", "calcuat", "cluster", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "static", "org", "junit", "assert", "asserttru", "assert", "true", "import", "java", "util", "array", "import", "java", "util", "list", "import", "java", "util", "random", "import", "org", "apach", "common", "math", "stat", "cluster", "cluster", "import", "org", "apach", "common", "math", "stat", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "import", "org", "apach", "common", "math", "stat", "cluster", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "import", "org", "fao", "fisheri", "chronicl", "input", "csvimportprocess", "csv", "import", "process", "import", "org", "fao", "fisheri", "chronicl", "input", "top200csv", "import", "org", "junit", "test", "public", "class", "clusteranalysistest", "cluster", "analysi", "test", "test", "public", "void", "testperformclusteranalysis2", "test", "perform", "cluster", "analysis2", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "transform", "new", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "random", "1746432956321l", "euclideanintegerpoint", "euclidean", "integ", "point", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1959", "325100", "new", "euclideanintegerpoint", "euclidean", "integ", "point", "new", "int", "1960", "373200", "list", "cluster", "euclideanintegerpoint", "euclidean", "integ", "point", "cluster", "transform", "cluster", "array", "aslist", "as", "list", "point", "assertequ", "assert", "equal", "cluster", "size"], "B_title": "Fixed an overflow error in MathUtils.distance that was causing KMeansPlusPlusClusterer to fail with a NullPointerException when component distances between points exceeded Integer.MAXVALUE. JIRA: MATH-305 Reported by Erik van Ingen", "B_clean_title": ["fix", "overflow", "error", "mathutil", "distanc", "math", "util", "that", "wa", "caus", "kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "fail", "nullpointerexcept", "null", "pointer", "except", "when", "compon", "distanc", "between", "point", "exceed", "integ", "maxvalu", "jira", "math", "305", "report", "by", "erik", "van", "ingen"]},
{"A_title": "Ensure there is a max/min valid offsetDateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.", "A_clean_title": ["ensur", "there", "max", "min", "valid", "offsetdatetimezon", "offset", "date", "time", "zone", "not", "appli", "max", "min", "valu", "offset", "howev", "pars", "method", "limit", "23:59", "make", "23:59:59", "999", "maximum"], "B_title": "Ensure there is a max/min valid offset in DateTimeZone", "B_clean_title": ["ensur", "there", "max", "min", "valid", "offset", "datetimezon", "date", "time", "zone"]},
{"A_title": "NPE in DateTimeZoneBuilderWhen a DateTimeZone is build with duplicate-named recurring saving time in a first thread all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:", "A_clean_title": ["npe", "datetimezonebuilderwhen", "date", "time", "zone", "builder", "when", "datetimezon", "date", "time", "zone", "build", "duplic", "name", "recur", "save", "time", "first", "thread", "all", "goe", "ok", "warn", "messag", "gener", "identifi", "automat", "gener", "precalculatedzon", "creat", "precalcul", "zone", "when", "second", "thread", "same", "npe", "gener", "zoneinfocompil", "verbos", "zone", "info", "compil", "caus", "that", "cverbos", "verbos", "threadloc", "thread", "local", "incorrectli", "initi", "zoneinfocompil", "zone", "info", "compil", "will", "initi", "cverbos", "verbos", "onli", "first", "thread", "not", "subsequ", "one", "npe", "caus", "by", "autobox", "better", "approach", "could", "remov", "initi", "test", "null"], "B_title": "Fix ZoneInfoCompiler and DateTimeZoneBuilder multi-threading", "B_clean_title": ["fix", "zoneinfocompil", "zone", "info", "compil", "datetimezonebuild", "date", "time", "zone", "builder", "multi", "thread"]}]