[{"A_title": "ODE integrator goes past specified end of integration rangeEnd of integration range in ODE solving is handled as an event. In some cases numerical accuracy in events detection leads to error in events location. The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range.    public void testMissedEvent() throws IntegratorException DerivativeException            final double t0 = 1878250320.0000029;           final double t =  1878250379.9999986;           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations()                           public int getDimension()                  return 1;                                       public void computeDerivatives(double t double y double yDot)                 throws DerivativeException                  yDot0 = y0 * 1.0e-6;                      ;          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0 100.0                                                                                1.0e-10 1.0e-10);          double y =  1.0 ;         integrator.setInitialStepSize(60.0);         double finalT = integrator.integrate(ode t0 y t y);         Assert.assertEquals(t finalT 1.0e-6);     ", "A_clean_title": ["ode", "integr", "goe", "past", "specifi", "end", "integr", "rangeend", "rang", "end", "integr", "rang", "ode", "solv", "handl", "as", "event", "some", "case", "numer", "accuraci", "event", "detect", "lead", "error", "event", "locat", "follow", "test", "case", "show", "end", "event", "not", "handl", "properli", "integr", "that", "cover", "60", "rang", "fact", "cover", "160", "rang", "more", "than", "twice", "specifi", "rang", "public", "void", "testmissedev", "test", "miss", "event", "throw", "integratorexcept", "integr", "except", "derivativeexcept", "deriv", "except", "final", "doubl", "t0", "1878250320", "0000029", "final", "doubl", "1878250379", "9999986", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "ode", "new", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "public", "int", "getdimens", "get", "dimens", "return", "public", "void", "computederiv", "comput", "deriv", "doubl", "doubl", "doubl", "ydot", "dot", "throw", "derivativeexcept", "deriv", "except", "ydot0", "dot0", "y0", "0e", "dormandprince853integr", "dormand", "prince853integr", "integr", "new", "dormandprince853integr", "dormand", "prince853integr", "100", "10", "0e", "10", "0e", "doubl", "integr", "setinitialsteps", "set", "initi", "step", "size", "60", "doubl", "finalt", "final", "integr", "integr", "ode", "t0", "assert", "assertequ", "assert", "equal", "finalt", "final", "0e"], "B_title": "Fix the artificial 0 size step for EmbeddedRungeKuttaIntegator .. Fix the nonstiff test .. ", "B_clean_title": ["fix", "artifici", "size", "step", "embeddedrungekuttainteg", "embed", "rung", "kutta", "integ", "fix", "nonstiff", "test"]},
{"A_title": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situationsIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example the following unit test fails:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;      // more commonly constructed with: cal = new GregorianCalendar(2009 9 16 8 42 16)     // for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);       FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));      However this unit test passes:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));   ", "A_clean_title": ["dateformatutil", "format", "date", "format", "util", "not", "correctli", "chang", "calendar", "timezon", "time", "zone", "certain", "situationsif", "situat", "calendar", "object", "construct", "certain", "way", "call", "calendar", "settimezon", "set", "time", "zone", "not", "correctli", "chang", "calendar", "field", "call", "calenar", "gettim", "get", "time", "seem", "fix", "thi", "problem", "while", "thi", "probabl", "bug", "jdk", "it", "would", "nice", "dateformatutil", "date", "format", "util", "wa", "smart", "enough", "detect", "resolv", "thi", "problem", "exampl", "follow", "unit", "test", "fail", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "more", "commonli", "construct", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "2009", "16", "42", "16", "unit", "test", "work", "ani", "time", "zone", "construct", "gmt", "rather", "than", "default", "local", "time", "zone", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal", "howev", "thi", "unit", "test", "pass", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "cal", "gettim", "get", "time", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal"], "B_title": "Reset timeZone on parse ( ) .. ", "B_clean_title": ["reset", "timezon", "time", "zone", "pars"]},
{"A_title": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situationsIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example the following unit test fails:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;      // more commonly constructed with: cal = new GregorianCalendar(2009 9 16 8 42 16)     // for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);       FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));      However this unit test passes:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));   ", "A_clean_title": ["dateformatutil", "format", "date", "format", "util", "not", "correctli", "chang", "calendar", "timezon", "time", "zone", "certain", "situationsif", "situat", "calendar", "object", "construct", "certain", "way", "call", "calendar", "settimezon", "set", "time", "zone", "not", "correctli", "chang", "calendar", "field", "call", "calenar", "gettim", "get", "time", "seem", "fix", "thi", "problem", "while", "thi", "probabl", "bug", "jdk", "it", "would", "nice", "dateformatutil", "date", "format", "util", "wa", "smart", "enough", "detect", "resolv", "thi", "problem", "exampl", "follow", "unit", "test", "fail", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "more", "commonli", "construct", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "2009", "16", "42", "16", "unit", "test", "work", "ani", "time", "zone", "construct", "gmt", "rather", "than", "default", "local", "time", "zone", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal", "howev", "thi", "unit", "test", "pass", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "cal", "gettim", "get", "time", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal"], "B_title": "Fixed formatting of date with timeZone. ", "B_clean_title": ["fix", "format", "date", "timezon", "time", "zone"]},
{"A_title": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situationsIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example the following unit test fails:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;      // more commonly constructed with: cal = new GregorianCalendar(2009 9 16 8 42 16)     // for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);       FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));      However this unit test passes:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));   ", "A_clean_title": ["dateformatutil", "format", "date", "format", "util", "not", "correctli", "chang", "calendar", "timezon", "time", "zone", "certain", "situationsif", "situat", "calendar", "object", "construct", "certain", "way", "call", "calendar", "settimezon", "set", "time", "zone", "not", "correctli", "chang", "calendar", "field", "call", "calenar", "gettim", "get", "time", "seem", "fix", "thi", "problem", "while", "thi", "probabl", "bug", "jdk", "it", "would", "nice", "dateformatutil", "date", "format", "util", "wa", "smart", "enough", "detect", "resolv", "thi", "problem", "exampl", "follow", "unit", "test", "fail", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "more", "commonli", "construct", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "2009", "16", "42", "16", "unit", "test", "work", "ani", "time", "zone", "construct", "gmt", "rather", "than", "default", "local", "time", "zone", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal", "howev", "thi", "unit", "test", "pass", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "cal", "gettim", "get", "time", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal"], "B_title": "Reset the calendar time to GMT on Sunday .. ", "B_clean_title": ["reset", "calendar", "time", "gmt", "sunday"]},
{"A_title": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situationsIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example the following unit test fails:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;      // more commonly constructed with: cal = new GregorianCalendar(2009 9 16 8 42 16)     // for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);       FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));      However this unit test passes:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));   ", "A_clean_title": ["dateformatutil", "format", "date", "format", "util", "not", "correctli", "chang", "calendar", "timezon", "time", "zone", "certain", "situationsif", "situat", "calendar", "object", "construct", "certain", "way", "call", "calendar", "settimezon", "set", "time", "zone", "not", "correctli", "chang", "calendar", "field", "call", "calenar", "gettim", "get", "time", "seem", "fix", "thi", "problem", "while", "thi", "probabl", "bug", "jdk", "it", "would", "nice", "dateformatutil", "date", "format", "util", "wa", "smart", "enough", "detect", "resolv", "thi", "problem", "exampl", "follow", "unit", "test", "fail", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "more", "commonli", "construct", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "2009", "16", "42", "16", "unit", "test", "work", "ani", "time", "zone", "construct", "gmt", "rather", "than", "default", "local", "time", "zone", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal", "howev", "thi", "unit", "test", "pass", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "cal", "gettim", "get", "time", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal"], "B_title": "Fix null pointer check in FastDateFormat. ", "B_clean_title": ["fix", "null", "pointer", "check", "fastdateformat", "fast", "date", "format"]},
{"A_title": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situationsIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example the following unit test fails:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;      // more commonly constructed with: cal = new GregorianCalendar(2009 9 16 8 42 16)     // for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);       FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));      However this unit test passes:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));   ", "A_clean_title": ["dateformatutil", "format", "date", "format", "util", "not", "correctli", "chang", "calendar", "timezon", "time", "zone", "certain", "situationsif", "situat", "calendar", "object", "construct", "certain", "way", "call", "calendar", "settimezon", "set", "time", "zone", "not", "correctli", "chang", "calendar", "field", "call", "calenar", "gettim", "get", "time", "seem", "fix", "thi", "problem", "while", "thi", "probabl", "bug", "jdk", "it", "would", "nice", "dateformatutil", "date", "format", "util", "wa", "smart", "enough", "detect", "resolv", "thi", "problem", "exampl", "follow", "unit", "test", "fail", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "more", "commonli", "construct", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "2009", "16", "42", "16", "unit", "test", "work", "ani", "time", "zone", "construct", "gmt", "rather", "than", "default", "local", "time", "zone", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal", "howev", "thi", "unit", "test", "pass", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "cal", "gettim", "get", "time", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal"], "B_title": "Fix null pointer check in FastDateFormat. ", "B_clean_title": ["fix", "null", "pointer", "check", "fastdateformat", "fast", "date", "format"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "Fix NPE triggered by nullability exception. ", "B_clean_title": ["fix", "npe", "trigger", "by", "nullabl", "except"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "added null check in Hercules . fixed. null check in Hercules for fixed. fix null pointer check. ", "B_clean_title": ["ad", "null", "check", "hercul", "fix", "null", "check", "hercul", "fix", "fix", "null", "pointer", "check"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed unnecessary loop. ", "B_clean_title": ["remov", "unnecessari", "loop"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed unnecessary copy of ClassUtils. ", "B_clean_title": ["remov", "unnecessari", "copi", "classutil", "class", "util"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "MultivariateNormalDistribution.density(double) returns wrong value when the dimension is oddTo reproduce:  Assert.assertEquals(0.398942280401433 new MultivariateNormalDistribution(new double0 new double1).density(new double0) 1e-15);", "A_clean_title": ["multivariatenormaldistribut", "densiti", "multivari", "normal", "distribut", "doubl", "return", "wrong", "valu", "when", "dimens", "oddto", "odd", "reproduc", "assert", "assertequ", "assert", "equal", "398942280401433", "new", "multivariatenormaldistribut", "multivari", "normal", "distribut", "new", "double0", "new", "double1", "densiti", "new", "double0", "1e", "15"], "B_title": "Fix MultivariateNormalDistribution precision thingie in 1 . 6 . 2. ", "B_clean_title": ["fix", "multivariatenormaldistribut", "multivari", "normal", "distribut", "precis", "thingi"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "don  t append QUOTE if escaping is on. ", "B_clean_title": ["don", "append", "quot", "escap"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); ", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix format. ", "B_clean_title": ["fix", "format"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "convert string to lower case since it  s a number. ", "B_clean_title": ["convert", "string", "lower", "case", "sinc", "it", "number"]},
{"A_title": "SimplexSolver not working as expected?I guess (but I could be wrong) that SimplexSolver does not always return the optimal solution nor satisfies all the constraints... Consider this LP: max: 0.8 x0 + 0.2 x1 + 0.7 x2 + 0.3 x3 + 0.6 x4 + 0.4 x5; r1: x0 + x2 + x4 = 23.0; r2: x1 + x3 + x5 = 23.0; r3: x0 >= 10.0; r4: x2 >= 8.0; r5: x4 >= 5.0; LPSolve returns 25.8 with x0 = 10.0 x1 = 0.0 x2 = 8.0 x3 = 0.0 x4 = 5.0 x5 = 23.0; The same LP expressed in Apache commons math is: LinearObjectiveFunction f = new LinearObjectiveFunction(new double   0.8 0.2 0.7 0.3 0.6 0.4   0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double   1 0 1 0 1 0   Relationship.EQ 23.0)); constraints.add(new LinearConstraint(new double   0 1 0 1 0 1   Relationship.EQ 23.0)); constraints.add(new LinearConstraint(new double   1 0 0 0 0 0   Relationship.GEQ 10.0)); constraints.add(new LinearConstraint(new double   0 0 1 0 0 0   Relationship.GEQ 8.0)); constraints.add(new LinearConstraint(new double   0 0 0 0 1 0   Relationship.GEQ 5.0)); RealPointValuePair solution = new SimplexSolver().optimize(f constraints GoalType.MAXIMIZE true); that returns 22.20 with x0 = 15.0 x1 = 23.0 x2 = 8.0 x3 = 0.0 x4 = 0.0 x5 = 0.0; Is it possible SimplexSolver is buggy that way? The returned value is 22.20 instead of 25.8 and the last constraint (x4 >= 5.0) is not satisfied... Am I using the interface wrongly?", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "guess", "but", "could", "wrong", "that", "simplexsolv", "simplex", "solver", "not", "alway", "return", "optim", "solut", "nor", "satisfi", "all", "constraint", "consid", "thi", "lp", "max", "x0", "x1", "x2", "x3", "x4", "x5", "r1", "x0", "x2", "x4", "23", "r2", "x1", "x3", "x5", "23", "r3", "x0", "10", "r4", "x2", "r5", "x4", "lpsolv", "lp", "solv", "return", "25", "x0", "10", "x1", "x2", "x3", "x4", "x5", "23", "same", "lp", "express", "apach", "common", "math", "linearobjectivefunct", "linear", "object", "function", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "constraint", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "eq", "23", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "eq", "23", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "10", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "constraint", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "geq", "realpointvaluepair", "real", "point", "valu", "pair", "solut", "new", "simplexsolv", "simplex", "solver", "optim", "constraint", "goaltyp", "maxim", "goal", "type", "true", "that", "return", "22", "20", "x0", "15", "x1", "23", "x2", "x3", "x4", "x5", "it", "possibl", "simplexsolv", "simplex", "solver", "buggi", "that", "way", "return", "valu", "22", "20", "instead", "25", "last", "constraint", "x4", "not", "satisfi", "am", "interfac", "wrongli"], "B_title": "fixed an error leading the simplex solver to compute the right solution but return another one JIRA: MATH-286", "B_clean_title": ["fix", "error", "lead", "simplex", "solver", "comput", "right", "solut", "but", "return", "anoth", "one", "jira", "math", "286"]},
{"A_title": "ODE integrator goes past specified end of integration rangeEnd of integration range in ODE solving is handled as an event. In some cases numerical accuracy in events detection leads to error in events location. The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range more than twice the specified range.    public void testMissedEvent() throws IntegratorException DerivativeException            final double t0 = 1878250320.0000029;           final double t =  1878250379.9999986;           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations()                           public int getDimension()                  return 1;                                       public void computeDerivatives(double t double y double yDot)                 throws DerivativeException                  yDot0 = y0 * 1.0e-6;                      ;          DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0 100.0                                                                                1.0e-10 1.0e-10);          double y =  1.0 ;         integrator.setInitialStepSize(60.0);         double finalT = integrator.integrate(ode t0 y t y);         Assert.assertEquals(t finalT 1.0e-6);", "A_clean_title": ["ode", "integr", "goe", "past", "specifi", "end", "integr", "rangeend", "rang", "end", "integr", "rang", "ode", "solv", "handl", "as", "event", "some", "case", "numer", "accuraci", "event", "detect", "lead", "error", "event", "locat", "follow", "test", "case", "show", "end", "event", "not", "handl", "properli", "integr", "that", "cover", "60", "rang", "fact", "cover", "160", "rang", "more", "than", "twice", "specifi", "rang", "public", "void", "testmissedev", "test", "miss", "event", "throw", "integratorexcept", "integr", "except", "derivativeexcept", "deriv", "except", "final", "doubl", "t0", "1878250320", "0000029", "final", "doubl", "1878250379", "9999986", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "ode", "new", "firstorderdifferentialequ", "first", "order", "differenti", "equat", "public", "int", "getdimens", "get", "dimens", "return", "public", "void", "computederiv", "comput", "deriv", "doubl", "doubl", "doubl", "ydot", "dot", "throw", "derivativeexcept", "deriv", "except", "ydot0", "dot0", "y0", "0e", "dormandprince853integr", "dormand", "prince853integr", "integr", "new", "dormandprince853integr", "dormand", "prince853integr", "100", "10", "0e", "10", "0e", "doubl", "integr", "setinitialsteps", "set", "initi", "step", "size", "60", "doubl", "finalt", "final", "integr", "integr", "ode", "t0", "assert", "assertequ", "assert", "equal", "finalt", "final", "0e"], "B_title": "Fixed an error in events handling in ODE solvers. In some rare cases events occurring close to a step start were handled without truncating the step making them appear as is they occurred close to the step end JIRA: MATH-358", "B_clean_title": ["fix", "error", "event", "handl", "ode", "solver", "some", "rare", "case", "event", "occur", "close", "step", "start", "were", "handl", "without", "truncat", "step", "make", "them", "appear", "as", "they", "occur", "close", "step", "end", "jira", "math", "358"]},
{"A_title": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situationsIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example the following unit test fails:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;      // more commonly constructed with: cal = new GregorianCalendar(2009 9 16 8 42 16)     // for the unit test to work in any time zone constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);       FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));      However this unit test passes:    public void testFormat_CalendarIsoMsZulu()      final String dateTime = 2009-10-16T16:42:16.000Z;     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(GMT-8));     cal.clear();     cal.set(2009 9 16 8 42 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance(yyyy-MM-ddTHH:mm:ss.SSSZ TimeZone.getTimeZone(GMT));     assertEquals(dateTime dateTime format.format(cal));", "A_clean_title": ["dateformatutil", "format", "date", "format", "util", "not", "correctli", "chang", "calendar", "timezon", "time", "zone", "certain", "situationsif", "situat", "calendar", "object", "construct", "certain", "way", "call", "calendar", "settimezon", "set", "time", "zone", "not", "correctli", "chang", "calendar", "field", "call", "calenar", "gettim", "get", "time", "seem", "fix", "thi", "problem", "while", "thi", "probabl", "bug", "jdk", "it", "would", "nice", "dateformatutil", "date", "format", "util", "wa", "smart", "enough", "detect", "resolv", "thi", "problem", "exampl", "follow", "unit", "test", "fail", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "more", "commonli", "construct", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "2009", "16", "42", "16", "unit", "test", "work", "ani", "time", "zone", "construct", "gmt", "rather", "than", "default", "local", "time", "zone", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal", "howev", "thi", "unit", "test", "pass", "public", "void", "testformat", "calendarisomszulu", "test", "format", "calendar", "iso", "ms", "zulu", "final", "string", "datetim", "date", "time", "2009", "10", "16t16:42:16", "000z", "gregoriancalendar", "gregorian", "calendar", "cal", "new", "gregoriancalendar", "gregorian", "calendar", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "cal", "clear", "cal", "set", "2009", "16", "42", "16", "cal", "gettim", "get", "time", "fastdateformat", "fast", "date", "format", "format", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "yyyi", "mm", "ddthh", "dd", "thh", "mm", "ss", "sssz", "timezon", "gettimezon", "time", "zone", "get", "time", "zone", "gmt", "assertequ", "assert", "equal", "datetim", "date", "time", "datetim", "date", "time", "format", "format", "cal"], "B_title": "Fixing LANG-538 - you need to call getTime() on a calendar sometimes to get it in the right state otherwise the timezone gets out of whack.", "B_clean_title": ["fix", "lang", "538", "you", "need", "call", "gettim", "get", "time", "calendar", "sometim", "get", "it", "right", "state", "otherwis", "timezon", "get", "out", "whack"]},
{"A_title": "during ODE integration the last event in a pair of very close event may not be detectedWhen an events follows a previous one very closely it may be ignored. The occurrence of the bug depends on the side of the bracketing interval that was selected. For example consider a switching function that is increasing around first event around t = 90 reaches its maximum and is decreasing around the second event around t = 135. If an integration step spans from 67.5 and 112.5 the switching function values at start and end of step will  have opposite signs so the first event will be detected. The solver will find the event really occurs at 90.0 and will therefore truncate the step at 90.0. The next step will start from where the first step ends i.e. it will start at 90.0. Lets say this step spans from 90.0 to 153.0. The switching function switches once again in this step. If the solver for the first event converged to a value slightly before 90.0 (say 89.9999999) then the switch will not be detected because g(89.9999999) and g(153.0) are both negative. This bug was introduced as of r781157 (2009-06-02) when special handling of events very close to step start was added.", "A_clean_title": ["dure", "ode", "integr", "last", "event", "pair", "veri", "close", "event", "may", "not", "detectedwhen", "detect", "when", "event", "follow", "previou", "one", "veri", "close", "it", "may", "ignor", "occurr", "bug", "depend", "side", "bracket", "interv", "that", "wa", "select", "exampl", "consid", "switch", "function", "that", "increas", "around", "first", "event", "around", "90", "reach", "it", "maximum", "decreas", "around", "second", "event", "around", "135", "integr", "step", "span", "67", "112", "switch", "function", "valu", "at", "start", "end", "step", "will", "have", "opposit", "sign", "so", "first", "event", "will", "detect", "solver", "will", "find", "event", "realli", "occur", "at", "90", "will", "therefor", "truncat", "step", "at", "90", "next", "step", "will", "start", "where", "first", "step", "end", "it", "will", "start", "at", "90", "let", "say", "thi", "step", "span", "90", "153", "switch", "function", "switch", "onc", "again", "thi", "step", "solver", "first", "event", "converg", "valu", "slightli", "befor", "90", "say", "89", "9999999", "then", "switch", "will", "not", "detect", "becaus", "89", "9999999", "153", "are", "both", "neg", "thi", "bug", "wa", "introduc", "as", "r781157", "2009", "06", "02", "when", "special", "handl", "event", "veri", "close", "step", "start", "wa", "ad"], "B_title": "Fixed an error in handling of very close events during ODE integration JIRA: MATH-322", "B_clean_title": ["fix", "error", "handl", "veri", "close", "event", "dure", "ode", "integr", "jira", "math", "322"]},
{"A_title": "StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as uD840uDC00 private static final String CharU20000 = uD840uDC00; private static final String CharU20001 = uD840uDC01; You can see Unicode supplementary characters correctly implemented in the JRE call: assertEquals(-1 CharU20000.indexOf(CharU20001)); But this is broken: assertEquals(false StringUtils.containsAny(CharU20000 CharU20001)); assertEquals(false StringUtils.containsAny(CharU20001 CharU20000)); This is fine: assertEquals(true StringUtils.contains(CharU20000 + CharU20001 CharU20000)); assertEquals(true StringUtils.contains(CharU20000 + CharU20001 CharU20001)); assertEquals(true StringUtils.contains(CharU20000 CharU20000)); assertEquals(false StringUtils.contains(CharU20000 CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/", "A_clean_title": ["stringutil", "string", "util", "method", "not", "handl", "unicod", "0+", "supplementari", "charact", "correctli", "stringutil", "containsani", "string", "util", "contain", "ani", "method", "incorrectli", "match", "unicod", "0+", "supplementari", "charact", "exampl", "defin", "test", "fixtur", "unicod", "charact", "u+20000", "where", "u+20000", "written", "java", "sourc", "as", "ud840udc00", "d840u", "dc00", "privat", "static", "final", "string", "charu20000", "char", "u20000", "ud840udc00", "d840u", "dc00", "privat", "static", "final", "string", "charu20001", "char", "u20001", "ud840udc01", "d840u", "dc01", "you", "see", "unicod", "supplementari", "charact", "correctli", "implement", "jre", "call", "assertequ", "assert", "equal", "charu20000", "indexof", "char", "u20000", "index", "charu20001", "char", "u20001", "but", "thi", "broken", "assertequ", "assert", "equal", "fals", "stringutil", "containsani", "string", "util", "contain", "ani", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "assertequ", "assert", "equal", "fals", "stringutil", "containsani", "string", "util", "contain", "ani", "charu20001", "char", "u20001", "charu20000", "char", "u20000", "thi", "fine", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "charu20000", "char", "u20000", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "charu20001", "char", "u20001", "assertequ", "assert", "equal", "true", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20000", "char", "u20000", "assertequ", "assert", "equal", "fals", "stringutil", "contain", "string", "util", "charu20000", "char", "u20000", "charu20001", "char", "u20001", "becaus", "method", "call", "jre", "perform", "match", "more", "than", "you", "want", "know", "http", "sun", "java", "com", "develop", "technicalarticl", "intl", "supplementari", "technic", "articl"], "B_title": "StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.", "B_clean_title": ["stringutil", "string", "util", "method", "not", "handl", "unicod", "0+", "supplementari", "charact", "correctli"]},
{"A_title": "ClassUtils.toClass(Object) throws NPE on null array elementsee summary", "A_clean_title": ["classutil", "toclass", "class", "util", "class", "object", "throw", "npe", "null", "array", "elementse", "summari"], "B_title": "avoid NPE in ClassUtils.toClass(Object)", "B_clean_title": ["avoid", "npe", "classutil", "toclass", "class", "util", "class", "object"]},
{"A_title": "ConvergenceException in normal CDFNormalDistributionImpl::cumulativeProbability(double x) throws ConvergenceException if x deviates too much from the mean. For example when x=+/-100 mean=0 sd=1. Of course the value of the CDF is hard to evaluate in these cases but effectively it should be either zero or one.", "A_clean_title": ["convergenceexcept", "converg", "except", "normal", "cdfnormaldistributionimpl", "cdf", "normal", "distribut", "impl", ":cumulativeprob", ":cumul", "probabl", "doubl", "throw", "convergenceexcept", "converg", "except", "deviat", "too", "much", "mean", "exampl", "when", "100", "x=+", "mean=0", "sd=1", "cours", "valu", "cdf", "hard", "evalu", "these", "case", "but", "effect", "it", "either", "zero", "or", "one"], "B_title": "Modified NormalDistributionImpl.cumulativeProbablity to catch MaxIterationsExceededException and return 0 or 1 resp. if the argument is more than 20 standard deviations from the mean.", "B_clean_title": ["modifi", "normaldistributionimpl", "cumulativeprobabl", "normal", "distribut", "impl", "cumul", "probabl", "catch", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "return", "or", "resp", "argument", "more", "than", "20", "standard", "deviat", "mean"]},
{"A_title": "Duration.toPeriod with fixed time zones.I have a question concerning the conversion of a Duration to Period. Im not sure if this is a bug or if there is a different way to do this.  The basis of the problem is that using Duration.toPeriod() uses the chronology of the default time zone to do the conversion. This can cause different results from a timezone with DST and one without. This can be reproduced easily with this test. In the joda code Duration.toPeriod() uses a period constructor that takes the chronology but null is passed in so the chronology of the default time zone is used which leads to this behavior.  The javadoc of toPeriod() states that only precise fields of hours minutes seconds and millis will be converted. But for a fixed timezone days and weeks are also precise which is stated in the javadoc for toPeriod(Chronology chrono). In our app we need consistent behavior regardless of the default time zone which is to have all the extra hours put into the hours bucket. Since Duration is supposed to be a time zone independent length of time I dont think we should have to do any chronology manipulation to get this to work.", "A_clean_title": ["durat", "toperiod", "period", "fix", "time", "zone", "have", "question", "concern", "convers", "durat", "period", "im", "not", "sure", "thi", "bug", "or", "there", "differ", "way", "thi", "basi", "problem", "that", "durat", "toperiod", "period", "use", "chronolog", "default", "time", "zone", "convers", "thi", "caus", "differ", "result", "timezon", "dst", "one", "without", "thi", "reproduc", "easili", "thi", "test", "joda", "code", "durat", "toperiod", "period", "use", "period", "constructor", "that", "take", "chronolog", "but", "null", "pass", "so", "chronolog", "default", "time", "zone", "use", "which", "lead", "thi", "behavior", "javadoc", "toperiod", "period", "state", "that", "onli", "precis", "field", "hour", "minut", "second", "milli", "will", "convert", "but", "fix", "timezon", "day", "week", "are", "also", "precis", "which", "state", "javadoc", "toperiod", "period", "chronolog", "chrono", "our", "app", "we", "need", "consist", "behavior", "regardless", "default", "time", "zone", "which", "have", "all", "extra", "hour", "put", "into", "hour", "bucket", "sinc", "durat", "suppos", "time", "zone", "independ", "length", "time", "dont", "think", "we", "have", "ani", "chronolog", "manipul", "get", "thi", "work"], "B_title": "Duraton.toPeriod() new Period(long) new MutablePeriod(long) 3264409 Fixed to obey Javadoc. Previously they didnt obey the Javadoc if the default time-zone had no daylight savings.", "B_clean_title": ["duraton", "toperiod", "period", "new", "period", "long", "new", "mutableperiod", "mutabl", "period", "long", "3264409", "fix", "obey", "javadoc", "previous", "they", "didnt", "obey", "javadoc", "default", "time", "zone", "had", "no", "daylight", "save"]},
{"A_title": "MultivariateNormalDistribution.density(double) returns wrong value when the dimension is oddTo reproduce:  Assert.assertEquals(0.398942280401433 new MultivariateNormalDistribution(new double0 new double1).density(new double0) 1e-15);", "A_clean_title": ["multivariatenormaldistribut", "densiti", "multivari", "normal", "distribut", "doubl", "return", "wrong", "valu", "when", "dimens", "oddto", "odd", "reproduc", "assert", "assertequ", "assert", "equal", "398942280401433", "new", "multivariatenormaldistribut", "multivari", "normal", "distribut", "new", "double0", "new", "double1", "densiti", "new", "double0", "1e", "15"], "B_title": "Fixed truncated value. Thanks to Piotr Wydrych. Added unit test: comparing density values with univariate normal distribution.", "B_clean_title": ["fix", "truncat", "valu", "thank", "piotr", "wydrych", "ad", "unit", "test", "compar", "densiti", "valu", "univari", "normal", "distribut"]},
{"A_title": "LocaleUtils.toLocale does not parse strings starting with an underscoreHi Javadocs of Locale.toString() states that If the language is missing the string will begin with an underbar.. This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString(). The fix for the ticket 328 does not handle well the case fr__P which I found out during fixing the first bug. I am attaching the patch for both problems.", "A_clean_title": ["localeutil", "tolocal", "local", "util", "local", "not", "pars", "string", "start", "underscorehi", "underscor", "hi", "javadoc", "local", "tostr", "string", "state", "that", "languag", "miss", "string", "will", "begin", "underbar", "thi", "not", "handl", "localeutil", "tolocal", "local", "util", "local", "method", "it", "meant", "invers", "method", "local", "tostr", "string", "fix", "ticket", "328", "not", "handl", "well", "case", "fr", "which", "found", "out", "dure", "fix", "first", "bug", "am", "attach", "patch", "both", "problem"], "B_title": "LocaleUtils.toLocale does not parse strings starting with an underscore.", "B_clean_title": ["localeutil", "tolocal", "local", "util", "local", "not", "pars", "string", "start", "underscor"]},
{"A_title": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotesWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String Object> formatRegistry = new HashMap<String Object>();         static          formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT new DummyFormatFactory());               public static void main(String args)          ExtendedMessageFormat mf = new ExtendedMessageFormat(its a dummy test! formatRegistry);         String formattedPattern = mf.format(new String great);         System.out.println(formattedPattern);          The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && cstart == QUOTE)          return appendTo == null ? null : appendTo.append(QUOTE);   WORKING: if (escapingOn && cstart == QUOTE)          next(pos);         return appendTo == null ? null : appendTo.append(QUOTE);", "A_clean_title": ["extendedmessageformat", "extend", "messag", "format", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quoteswhen", "quot", "when", "extendedmessageformat", "extend", "messag", "format", "custom", "format", "registri", "pattern", "conatin", "singl", "quot", "outofmemoryerror", "out", "memori", "error", "will", "occur", "exampl", "that", "will", "caus", "error", "extendedmessageformattest", "java", "extend", "messag", "format", "test", "privat", "static", "map", "string", "object", "formatregistri", "format", "registri", "new", "hashmap", "hash", "map", "string", "object", "static", "formatregistri", "put", "format", "registri", "dummyformatfactori", "dummi", "format", "factori", "dummi", "format", "new", "dummyformatfactori", "dummi", "format", "factori", "public", "static", "void", "main", "string", "arg", "extendedmessageformat", "extend", "messag", "format", "mf", "new", "extendedmessageformat", "extend", "messag", "format", "it", "dummi", "test", "formatregistri", "format", "registri", "string", "formattedpattern", "format", "pattern", "mf", "format", "new", "string", "great", "system", "out", "println", "formattedpattern", "format", "pattern", "follow", "chang", "start", "at", "line", "421", "releas", "seem", "fix", "problem", "extendedmessageformat", "java", "extend", "messag", "format", "current", "broken", "escapingon", "escap", "cstart", "quot", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot", "work", "escapingon", "escap", "cstart", "quot", "next", "po", "return", "appendto", "append", "null", "null", "appendto", "append", "append", "quot"], "B_title": "Fix for LANG-477 OutOfMemory with custom format registry and a pattern containing single quotes - thanks to Duncan Eley", "B_clean_title": ["fix", "lang", "477", "outofmemori", "out", "memori", "custom", "format", "registri", "pattern", "contain", "singl", "quot", "thank", "duncan", "eley"]},
{"A_title": "NumberUtils does not handle upper-case hex: 0X and -0XNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0xnumberutil", "createnumb", "0x", "number", "util", "creat", "number", "work", "equal", "0x1234", "0x1234", "current", "0x1234", "gener", "numberformatexcept", "number", "format", "except", "integ", "decod", "handl", "both", "upper", "lower", "case", "hex"], "B_title": "NumberUtils does not handle upper-case hex: 0X and -0X", "B_clean_title": ["numberutil", "number", "util", "not", "handl", "upper", "case", "hex", "0x", "0x"]}]