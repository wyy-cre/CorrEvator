[{"A_title": "StringEscapeUtils.escapeJava(String) escapes / charactersCommons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes / characters which is not a valid escapable character in Java strings.  I havent tried the other Java escape/unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off in that / should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase      public void testEscapeJavaWithSlash()           final String input = String with a slash (/) in it;                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes / characters          * which are not a valid character to escape in a Java string.            */         assertEquals( expected actual );      ", "A_clean_title": ["stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "characterscommon", "charact", "common", "lang", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "now", "escap", "charact", "which", "not", "valid", "escap", "charact", "java", "string", "havent", "tri", "other", "java", "escap", "unescap", "method", "see", "they", "have", "similar", "problem", "or", "that", "onli", "java", "escap", "charact", "are", "escap", "by", "escapejava", "escap", "java", "string", "thi", "bug", "may", "have", "appear", "as", "unintend", "side", "effect", "fix", "lang", "363", "also", "javadoc", "escapejava", "escap", "java", "now", "littl", "off", "that", "now", "includ", "sentenc", "describ", "differ", "between", "java", "javascript", "string", "respect", "escap", "rule", "follow", "junit3", "unit3", "test", "demonstr", "bug", "import", "junit", "framework", "testcas", "test", "case", "import", "org", "apach", "common", "lang", "stringescapeutil", "string", "escap", "util", "public", "class", "stringescapeutilstest", "string", "escap", "util", "test", "extend", "testcas", "test", "case", "public", "void", "testescapejavawithslash", "test", "escap", "java", "slash", "final", "string", "input", "string", "slash", "it", "final", "string", "expect", "input", "final", "string", "actual", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "input", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "charact", "which", "are", "not", "valid", "charact", "escap", "java", "string", "assertequ", "assert", "equal", "expect", "actual"], "B_title": "don  t escape single quote when escaping backslash. ", "B_clean_title": ["don", "escap", "singl", "quot", "when", "escap", "backslash"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "isDigits ( numeric ) will ignore - > long. ", "B_clean_title": ["isdigit", "digit", "numer", "will", "ignor", "long"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle isDigits ( numeric ) as well as ( exp == null ). ", "B_clean_title": ["handl", "isdigit", "digit", "numer", "as", "well", "as", "exp", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle negative exponentiblity in StringUtils . java. ", "B_clean_title": ["handl", "neg", "exponentibl", "stringutil", "string", "util", "java"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Handle isDigits ( string ) with patch 1 - Lang - 58 - Hercules . fixed. ", "B_clean_title": ["handl", "isdigit", "digit", "string", "patch", "lang", "58", "hercul", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "isDigits ( string ) fix. ", "B_clean_title": ["isdigit", "digit", "string", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "try to create long from Javadoc. ", "B_clean_title": ["tri", "creat", "long", "javadoc"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix parse error. ", "B_clean_title": ["fix", "pars", "error"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "try StringUtils . isDigit. I had left it harwired to null .. ", "B_clean_title": ["tri", "stringutil", "string", "util", "isdigit", "digit", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix regex processing. I had left it harwired to null .. ", "B_clean_title": ["fix", "regex", "process", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "don  t throw NumberFormatException if decPos < decPos. I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["don", "throw", "numberformatexcept", "number", "format", "except", "decpo", "dec", "po", "decpo", "dec", "po", "had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. start with - -. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "start"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a missing patch. I had left it harwired to null .. don  t check isEmpty ( str )  because it seems we  re trying to understand why. ", "B_clean_title": ["add", "miss", "patch", "had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "becaus", "it", "seem", "we", "re", "tri", "understand", "whi"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t check isEmpty ( str ) in StringUtils. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "remove exp = null ; fix for patched code. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["remov", "exp", "null", "fix", "patch", "code", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. Add an error if the string is blank .. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["allow", "null", "string", "input", "add", "error", "string", "blank", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add the missing throw exception. I had left it harwired to null .. ", "B_clean_title": ["add", "miss", "throw", "except", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove exp = null in numberUtils. I had left it harwired to null .. ", "B_clean_title": ["remov", "exp", "null", "numberutil", "number", "util", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix NPE. don  t check isEmpty ( str ) in StringUtils. ", "B_clean_title": ["fix", "npe", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. isEmpty ( str ) fixed NHY - 1342  fixed NHY - 1342. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "isempti", "empti", "str", "fix", "nhi", "1342", "fix", "nhi", "1342"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fixed String . isBlank ( ). Add a patch for formatting numbers in Avro settings. I had left it harwired to null .. ", "B_clean_title": ["fix", "string", "isblank", "blank", "add", "patch", "format", "number", "avro", "set", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fix a numeric type request. I had left it harwired to null .. ", "B_clean_title": ["fix", "numer", "type", "request", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. I had left it harwired to null .. ", "B_clean_title": ["allow", "null", "string", "input", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. remove fix. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "remov", "fix"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow null string input. I had left it harwired to null .. ", "B_clean_title": ["allow", "null", "string", "input", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t check isEmpty ( str ) in StringUtils. Add an error if a blank string is not a valid number. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "check", "isempti", "empti", "str", "stringutil", "string", "util", "add", "error", "blank", "string", "not", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused method. I had left it harwired to null .. ", "B_clean_title": ["remov", "old", "unus", "method", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Allow string to be parsed as a literal int. I had left it harwired to null .. ", "B_clean_title": ["allow", "string", "pars", "as", "liter", "int", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. add null check. add isDigit to StringUtils. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "null", "check", "add", "isdigit", "digit", "stringutil", "string", "util"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fixed String . isBlank ( ). I had left it harwired to null .. ", "B_clean_title": ["fix", "string", "isblank", "blank", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Allow null to be passed. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "allow", "null", "pass"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. add null check. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "null", "check"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. ", "B_clean_title": ["had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an error if the string is blank .. I had left it harwired to null .. ", "B_clean_title": ["add", "error", "string", "blank", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Add string isEmpty ( ) to isAllZeros ( ). ", "B_clean_title": ["had", "left", "it", "harwir", "null", "add", "string", "isempti", "empti", "isallzero", "all", "zero"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an exception if the string is null. I had left it harwired to null .. ", "B_clean_title": ["add", "except", "string", "null", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "add patch for isDigit. I had left it harwired to null .. ", "B_clean_title": ["add", "patch", "isdigit", "digit", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a missing patch. I had left it harwired to null .. Add a throw statement so that it can be cleaned up by the patcher .. ", "B_clean_title": ["add", "miss", "patch", "had", "left", "it", "harwir", "null", "add", "throw", "statement", "so", "that", "it", "clean", "up", "by", "patcher"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. isDigits method patched. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "isdigit", "digit", "method", "patch"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused method. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["remov", "old", "unus", "method", "had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add an error if the string is blank .. don  t throw NPE at end of definition file. I had left it harwired to null .. ", "B_clean_title": ["add", "error", "string", "blank", "don", "throw", "npe", "at", "end", "definit", "file", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. don  t throw NumberFormatException on isBlank ( string ). ", "B_clean_title": ["had", "left", "it", "harwir", "null", "don", "throw", "numberformatexcept", "number", "format", "except", "isblank", "blank", "string"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "fix", "isallzero", "all", "zero", "persian", "urdu", "languag", "map"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Add a throw if it is not a valid number. I had left it harwired to null .. ", "B_clean_title": ["add", "throw", "it", "not", "valid", "number", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to say that it was a valid number .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Remove old and unused patch. Allow null to be passed in for numberUtils . createBigInteger ( ). start with - -. ", "B_clean_title": ["remov", "old", "unus", "patch", "allow", "null", "pass", "numberutil", "number", "util", "createbiginteg", "creat", "big", "integ", "start"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "I had left it harwired to null .. @ patch_1228 for StringUtils . isDigit. ", "B_clean_title": ["had", "left", "it", "harwir", "null", "patch", "1228", "stringutil", "string", "util", "isdigit", "digit"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix 143 potential value error. fixed NHYD fixed. I had left it harwired to null .. ", "B_clean_title": ["fix", "143", "potenti", "valu", "error", "fix", "nhyd", "fix", "had", "left", "it", "harwir", "null"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "fix null string handling. I had left it harwired to null .. ", "B_clean_title": ["fix", "null", "string", "handl", "had", "left", "it", "harwir", "null"]},
{"A_title": "GJChronology rejects valid Julian datesThe 2nd statement fails with org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range 128.  Given that I left the cutover date at the default (October 15 1582) isnt 1500/02/29 a valid date in the GJChronology?", "A_clean_title": ["gjchronolog", "gj", "chronolog", "reject", "valid", "julian", "datesth", "date", "2nd", "statement", "fail", "org", "joda", "time", "illegalfieldvalueexcept", "illeg", "field", "valu", "except", "valu", "29", "dayofmonth", "day", "month", "must", "rang", "128", "given", "that", "left", "cutov", "date", "at", "default", "octob", "15", "1582", "isnt", "1500", "02", "29", "valid", "date", "gjchronolog", "gj", "chronolog"], "B_title": "Fixed incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "FastDateFormat formats year differently than SimpleDateFormat in Java 7Starting with Java 7 does SimpleDateFormat format a year pattern of Y or YYY as 2003 instead of 03 as in former Java releases. According Javadoc this pattern should have been always been formatted as number therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "format", "year", "differ", "than", "simpledateformat", "simpl", "date", "format", "java", "7start", "java", "simpledateformat", "simpl", "date", "format", "format", "year", "pattern", "or", "yyy", "as", "2003", "instead", "03", "as", "former", "java", "releas", "accord", "javadoc", "thi", "pattern", "have", "been", "alway", "been", "format", "as", "number", "therefor", "new", "behavior", "seem", "bug", "fix", "jdk", "fastdateformat", "fast", "date", "format", "adjust", "behav", "same"], "B_title": "FastDateFormat doesn  t select week / month fields ( issue # 507 ). ", "B_clean_title": ["fastdateformat", "fast", "date", "format", "doesn", "select", "week", "month", "field", "issu", "507"]},
{"A_title": "numerical problems in rotation creationbuilding a rotation from the following vector pairs leads to NaN: u1 = -4921140.837095533 -2.1512094250440013E7 -890093.279426377 u2 = -2.7238580938724895E9 -2.169664921341876E9 6.749688708885301E10 v1 = 1 0 0 v2 = 0 0 1 The constructor first changes the (v1 v2) pair into (v1 v2) ensuring the following scalar products hold:  <v1|v1> == <u1|u1>  <v2|v2> == <u2|u2>  <u1 |u2>  == <v1|v2> Once the (v1 v2) pair has been computed we compute the cross product:   k = (v1 - u1)^(v2 - u2) and the scalar product:   c = <k | (u1^u2)> By construction c is positive or null and the quaternion axis we want to build is q = k/2*sqrt(c). c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm. However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision: commons math:   k = 38514476.5            -84.                           -1168590144 high precision: k = 38514410.36093388...  -0.374075245201180409222711... -1168590152.10599715208... and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations. We get: commons math    c = -1.2397173627587605E20 high precision: c =  558382746168463196.7079627... We have lost ALL significant digits in cancellations and even the sign is wrong!", "A_clean_title": ["numer", "problem", "rotat", "creationbuild", "rotat", "follow", "vector", "pair", "lead", "nan", "na", "u1", "4921140", "837095533", "1512094250440013e7", "890093", "279426377", "u2", "7238580938724895e9", "169664921341876e9", "749688708885301e10", "v1", "v2", "constructor", "first", "chang", "v1", "v2", "pair", "into", "v1", "v2", "ensur", "follow", "scalar", "product", "hold", "v1|v1", "u1|u1", "v2|v2", "u2|u2", "u1", "|u2", "v1|v2", "onc", "v1", "v2", "pair", "ha", "been", "comput", "we", "comput", "cross", "product", "v1", "u1", "v2", "u2", "scalar", "product", "u1^u2", "by", "construct", "posit", "or", "null", "quaternion", "axi", "we", "want", "build", "sqrt", "null", "onli", "some", "vector", "are", "align", "thi", "dealt", "later", "algorithm", "howev", "there", "are", "numer", "problem", "vector", "abov", "way", "these", "comput", "are", "done", "as", "shown", "by", "follow", "comparison", "show", "result", "we", "get", "our", "java", "code", "result", "we", "get", "manual", "comput", "same", "formula", "but", "enhanc", "precis", "common", "math", "38514476", "84", "1168590144", "high", "precis", "38514410", "36093388", "374075245201180409222711", "1168590152", "10599715208", "it", "becom", "wors", "when", "comput", "becaus", "vector", "are", "almost", "orthogon", "each", "other", "henc", "induc", "addit", "cancel", "we", "get", "common", "math", "2397173627587605e20", "high", "precis", "558382746168463196", "7079627", "we", "have", "lost", "all", "signific", "digit", "cancel", "even", "sign", "wrong"], "B_title": "Fixed a bug in the cross product test. ", "B_clean_title": ["fix", "bug", "cross", "product", "test"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor from Lee Butts. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "lee", "butt"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor result. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "result"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix false alarm in JKali patch. ", "B_clean_title": ["fix", "fals", "alarm", "jkali", "kali", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix a bug in JMutRepair where abs ( u ) > v. ", "B_clean_title": ["fix", "bug", "jmutrepair", "mut", "repair", "where", "ab"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix # 1796. remove patch for 1 . 7 . 0 - > 1 . 7 . 0. ", "B_clean_title": ["fix", "1796", "remov", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor patch. Fix string comparison in Fraction . equals ( ). ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "patch", "fix", "string", "comparison", "fraction", "equal"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "remove patch for 1 . 6. Fix string comparison between 0 . 1 and 1 . 2. ", "B_clean_title": ["remov", "patch", "fix", "string", "comparison", "between"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "fix a numeric equality bug in Fraction. remove patch for 1 . 6. ", "B_clean_title": ["fix", "numer", "equal", "bug", "fraction", "remov", "patch"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "remove 582  as it is not applicable. fixed a small bug. ", "B_clean_title": ["remov", "582", "as", "it", "not", "applic", "fix", "small", "bug"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Add missing toProperString. remove 583  as it is not maintained by OpenJDK .. ", "B_clean_title": ["add", "miss", "toproperstr", "proper", "string", "remov", "583", "as", "it", "not", "maintain", "by", "openjdk", "open", "jdk"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction patch. Fix string comparison in Fraction . equals ( ). ", "B_clean_title": ["fix", "fraction", "patch", "fix", "string", "comparison", "fraction", "equal"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Add missing toProperString. Fix accidental conversion of inf to int. ", "B_clean_title": ["add", "miss", "toproperstr", "proper", "string", "fix", "accident", "convers", "inf", "int"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 5 more space for appendFixedWidthPadRight ( ). ", "B_clean_title": ["add", "more", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 5 elements for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "element", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add some space .. ", "B_clean_title": ["add", "some", "space"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added more ensureCapacity. ", "B_clean_title": ["ad", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add more space for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "more", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 + 4 space for appendFixedWidthPadRight ( ). ", "B_clean_title": ["add", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added more ensureCapacity. ", "B_clean_title": ["ad", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 + 4 ensureCapacity ( ). ", "B_clean_title": ["add", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( ) for string builder. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 + 4 entries for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "entri", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add some space for StringBuilder . appendFixedWidthPadRight ( ). ", "B_clean_title": ["add", "some", "space", "stringbuild", "string", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 +. ", "B_clean_title": ["strbuilder", "str", "builder", "add"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( ) for string builder. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add the right padding right .. ", "B_clean_title": ["strbuilder", "str", "builder", "add", "right", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add padChar + width if object is null. ", "B_clean_title": ["strbuilder", "str", "builder", "add", "padchar", "pad", "char", "width", "object", "null"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder copy ( ) . ", "B_clean_title": ["strbuilder", "str", "builder", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder ( ) uses char instead of char   for the char array .. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "instead", "char", "char", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) needs buffer .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "need", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity ( ) for string builder. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 +. ", "B_clean_title": ["strbuilder", "str", "builder", "add"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should add 4 spaces for appendFixedWidthPadRight ( ). ", "B_clean_title": ["strbuilder", "str", "builder", "add", "space", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder ( ) uses char instead of char .. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "instead", "char"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) will reset the array. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "will", "reset", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "add missing backslash. ", "B_clean_title": ["add", "miss", "backslash"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses CAPACITY rather than arrayCopy. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "capac", "rather", "than", "arraycopi", "array", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity .. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added ensureCapacity ( size + 1 ) for appendFixedWidthPadRight. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "size", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) now uses char  as the indexing array is. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "now", "use", "char", "as", "index", "array"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses char instead of char because it is not compatible. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "instead", "char", "becaus", "it", "not", "compat"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t create arrayCopy ( ) .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "creat", "arraycopi", "array", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( changed ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "chang"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build .. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add empty buffer for appendFixedWidthPadRight. ", "B_clean_title": ["add", "empti", "buffer", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix an issue with the appendFixedWidthPadRight method where the object is null .. ", "B_clean_title": ["fix", "issu", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "method", "where", "object", "null"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "added expanded array structure. ", "B_clean_title": ["ad", "expand", "array", "structur"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should reset the StringBuilder and not use the array when creating the string. ", "B_clean_title": ["strbuilder", "str", "builder", "reset", "stringbuild", "string", "builder", "not", "use", "array", "when", "creat", "string"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses empty array for easier building. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "empti", "array", "easier", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Reset nullText if we have text .. ", "B_clean_title": ["reset", "nulltext", "null", "text", "we", "have", "text"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix an issue with null string builders .. ", "B_clean_title": ["fix", "issu", "null", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix nullText setting .. ", "B_clean_title": ["fix", "nulltext", "null", "text", "set"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses char  instead of char   for the append of. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "instead", "char", "append"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Reset line endings. ", "B_clean_title": ["reset", "line", "end"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix NPE in StrBuilder . appendFixedWidthPadRight. ", "B_clean_title": ["fix", "npe", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add empty array if we can  t append string with spaces .. ", "B_clean_title": ["add", "empti", "array", "we", "append", "string", "space"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add null check in StrBuilder. ", "B_clean_title": ["add", "null", "check", "strbuilder", "str", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) uses new char   not nullText. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "char", "not", "nulltext", "null", "text"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should fix the build. ", "B_clean_title": ["strbuilder", "str", "builder", "fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add 4 more ensureCapacity .. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set the nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses buffer . length - > string . length. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "buffer", "length", "string", "length"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set the nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix buffer issue. ", "B_clean_title": ["fix", "buffer", "issu"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText field. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "field"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix ensureCapacity ( ) for string builders. ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses a char array initially. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "char", "array", "initi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity .. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t overwrite existing buffer .. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "overwrit", "exist", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight ( ) didn  t set nullText properly. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "didn", "set", "nulltext", "null", "text", "properli"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses new array constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "new", "array", "constructor"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( initially empty ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "initi", "empti"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder . appendFixedWidthPadRight uses stringBuilder  but string is not expanding the buffer ;. ", "B_clean_title": ["strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "use", "stringbuild", "string", "builder", "but", "string", "not", "expand", "buffer"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder patched ( initially empty ). ", "B_clean_title": ["strbuilder", "str", "builder", "patch", "initi", "empti"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add more space for string builders. ", "B_clean_title": ["add", "more", "space", "string", "builder"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should reset the array if we add null text  otherwise it will throw an NPE. ", "B_clean_title": ["strbuilder", "str", "builder", "reset", "array", "we", "add", "null", "text", "otherwis", "it", "will", "throw", "npe"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "StrBuilder should use the newLine setting for each builder object. ", "B_clean_title": ["strbuilder", "str", "builder", "use", "newlin", "new", "line", "set", "each", "builder", "object"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add null string if possible. ", "B_clean_title": ["add", "null", "string", "possibl"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Add one more ensureCapacity ( ) call. ", "B_clean_title": ["add", "one", "more", "ensurecapac", "ensur", "capac", "call"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix lost ensureCapacity .. ", "B_clean_title": ["fix", "lost", "ensurecapac", "ensur", "capac"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Fix the bug in StrBuilder . appendFixedWidthPadRight. ", "B_clean_title": ["fix", "bug", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right"]},
{"A_title": "ConvergenceException in NormalDistributionImpl.cumulativeProbability()I get a ConvergenceException in  NormalDistributionImpl.cumulativeProbability() for very large/small parameters including Infinity -Infinity. For instance in the following code: @Test public void testCumulative()  final NormalDistribution nd = new NormalDistributionImpl(); for (int i = 0; i < 500; i++)  final double val = Math.exp; try   System.out.println(val =  + val +  cumulative =  + nd.cumulativeProbability(val));   catch (MathException e)   e.printStackTrace(); fail();    In version 2.0 I get no exception.  My suggestion is to change in the implementation of cumulativeProbability(double) to catch all ConvergenceException (and return for very large and very small values) not just MaxIterationsExceededException.", "A_clean_title": ["convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "get", "convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "veri", "larg", "small", "paramet", "includ", "infin", "infin", "instanc", "follow", "code", "test", "public", "void", "testcumul", "test", "cumul", "final", "normaldistribut", "normal", "distribut", "nd", "new", "normaldistributionimpl", "normal", "distribut", "impl", "int", "500", "i++", "final", "doubl", "val", "math", "exp", "tri", "system", "out", "println", "val", "val", "cumul", "nd", "cumulativeprob", "cumul", "probabl", "val", "catch", "mathexcept", "math", "except", "printstacktrac", "print", "stack", "trace", "fail", "version", "get", "no", "except", "my", "suggest", "chang", "implement", "cumulativeprob", "cumul", "probabl", "doubl", "catch", "all", "convergenceexcept", "converg", "except", "return", "veri", "larg", "veri", "small", "valu", "not", "just", "maxiterationsexceededexcept", "max", "iter", "exceed", "except"], "B_title": "BUGS. Missing return from convergedFraction method. ", "B_clean_title": ["bug", "miss", "return", "convergedfract", "converg", "fraction", "method"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Fix minor bug in SimplexSolver . compareTo ( double  double  double  double ) .. Added minRatioPositions . size ( ) == 0 ? null : minRatioPositions. ", "B_clean_title": ["fix", "minor", "bug", "simplexsolv", "simplex", "solver", "compareto", "compar", "doubl", "doubl", "doubl", "doubl", "ad", "minratioposit", "min", "ratio", "posit", "size", "null", "minratioposit", "min", "ratio", "posit"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "remove column to drop from list of columns to avoid duplicates. ", "B_clean_title": ["remov", "column", "drop", "list", "column", "avoid", "duplic"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Added a test to see if the dataset is not sufficiently large and not too large .. ", "B_clean_title": ["ad", "test", "see", "dataset", "not", "suffici", "larg", "not", "too", "larg"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Add missing column to drop from tableau if it is too large. ", "B_clean_title": ["add", "miss", "column", "drop", "tableau", "it", "too", "larg"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "@@ changed to use packageCanonicalName instead of getPackageName ( ) for inner class access. make ClassUtils . getShortCanonicalName static. ", "B_clean_title": ["chang", "use", "packagecanonicalnam", "packag", "canon", "name", "instead", "getpackagenam", "get", "packag", "name", "inner", "class", "access", "make", "classutil", "class", "util", "getshortcanonicalnam", "get", "short", "canon", "name", "static"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "Fix ClassUtils # getShortClassName ( ). ", "B_clean_title": ["fix", "classutil", "class", "util", "getshortclassnam", "get", "short", "class", "name"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "make ClassUtils . getShortCanonicalName work for 1 . 7. made ClassUtils . getPackageCanonicalName a little easier to resolve. ", "B_clean_title": ["make", "classutil", "class", "util", "getshortcanonicalnam", "get", "short", "canon", "name", "work", "made", "classutil", "class", "util", "getpackagecanonicalnam", "get", "packag", "canon", "name", "littl", "easier", "resolv"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a bug in MultiDirectional .. ", "B_clean_title": ["fix", "bug", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix a typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fixed a bug in MultiDirectional .. Removed a redundant line. ", "B_clean_title": ["fix", "bug", "multidirect", "multi", "direct", "remov", "redund", "line"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "removed incorrect patch. ", "B_clean_title": ["remov", "incorrect", "patch"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Add a return statement so the contract can be used .. ", "B_clean_title": ["add", "return", "statement", "so", "contract", "use"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Fix typo in MultiDirectional .. ", "B_clean_title": ["fix", "typo", "multidirect", "multi", "direct"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "added a missing if / else. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "Missing in previous patch. ", "B_clean_title": ["miss", "previou", "patch"]}]