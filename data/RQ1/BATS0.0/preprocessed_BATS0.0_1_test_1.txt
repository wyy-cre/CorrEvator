[{"A_title": "StopWatch: suspend() acts as split() if followed by stop()In my opinion it is a bug that suspend() acts as split() if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause where time counter doesnt continue. So a following stop()-call shouldnt increase the time counter should it?", "A_clean_title": ["stopwatch", "stop", "watch", "suspend", "act", "as", "split", "follow", "by", "stop", "my", "opinion", "it", "bug", "that", "suspend", "act", "as", "split", "follow", "by", "stop", "see", "below", "stopwatch", "stop", "watch", "sw", "new", "stopwatch", "stop", "watch", "sw", "start", "thread", "sleep", "1000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "2000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "sw", "resum", "thread", "sleep", "3000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "4000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "5000", "sw", "stop", "time", "but", "time", "not", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "suspend", "resum", "like", "paus", "where", "time", "counter", "doesnt", "continu", "so", "follow", "stop", "call", "shouldnt", "increas", "time", "counter", "it"], "B_title": "Add a test to make sure that no one keeps being left in StopWatch after a running state ==. ", "B_clean_title": ["add", "test", "make", "sure", "that", "no", "one", "keep", "be", "left", "stopwatch", "stop", "watch", "after", "run", "state"]},
{"A_title": "StopWatch: suspend() acts as split() if followed by stop()In my opinion it is a bug that suspend() acts as split() if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause where time counter doesnt continue. So a following stop()-call shouldnt increase the time counter should it?", "A_clean_title": ["stopwatch", "stop", "watch", "suspend", "act", "as", "split", "follow", "by", "stop", "my", "opinion", "it", "bug", "that", "suspend", "act", "as", "split", "follow", "by", "stop", "see", "below", "stopwatch", "stop", "watch", "sw", "new", "stopwatch", "stop", "watch", "sw", "start", "thread", "sleep", "1000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "2000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "sw", "resum", "thread", "sleep", "3000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "4000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "5000", "sw", "stop", "time", "but", "time", "not", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "suspend", "resum", "like", "paus", "where", "time", "counter", "doesnt", "continu", "so", "follow", "stop", "call", "shouldnt", "increas", "time", "counter", "it"], "B_title": "Fixed bug in StopWatch . stopTime. ", "B_clean_title": ["fix", "bug", "stopwatch", "stop", "watch", "stoptim", "stop", "time"]},
{"A_title": "HypergeometricDistribution.sample suffers from integer overflowHi I have an application which broke when ported from commons math 2.2 to 3.2. It looks like the HypergeometricDistribution.sample() method doesnt work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50.  import org.apache.commons.math3.distribution.HypergeometricDistribution;  public class Foo    public static void main(String args)      HypergeometricDistribution a = new HypergeometricDistribution(         43130568 42976365 50);     System.out.printf(%d %d%n a.getSupportLowerBound() a.getSupportUpperBound()); // Prints 0 50     System.out.printf(%d%na.sample());                                             // Prints -50       In the debugger I traced it as far as an integer overflow in HypergeometricDistribution.getNumericalMean() – instead of doing  return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();   it could do:  return getSampleSize() * ((double) getNumberOfSuccesses() / (double) getPopulationSize());   This seemed to fix it based on a quick test.", "A_clean_title": ["hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "suffer", "integ", "overflowhi", "overflow", "hi", "have", "applic", "which", "broke", "when", "port", "common", "math", "it", "look", "like", "hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "method", "doesnt", "work", "as", "well", "as", "it", "use", "larg", "integ", "valu", "exampl", "code", "below", "return", "sampl", "between", "50", "but", "usual", "return", "50", "import", "org", "apach", "common", "math3", "distribut", "hypergeometricdistribut", "hypergeometr", "distribut", "public", "class", "foo", "public", "static", "void", "main", "string", "arg", "hypergeometricdistribut", "hypergeometr", "distribut", "new", "hypergeometricdistribut", "hypergeometr", "distribut", "43130568", "42976365", "50", "system", "out", "printf", "getsupportlowerbound", "get", "support", "lower", "bound", "getsupportupperbound", "get", "support", "upper", "bound", "print", "50", "system", "out", "printf", "na", "sampl", "print", "50", "debugg", "trace", "it", "as", "far", "as", "integ", "overflow", "hypergeometricdistribut", "getnumericalmean", "hypergeometr", "distribut", "get", "numer", "mean", "instead", "do", "return", "doubl", "getsamples", "get", "sampl", "size", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "it", "could", "return", "getsamples", "get", "sampl", "size", "doubl", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "thi", "seem", "fix", "it", "base", "quick", "test"], "B_title": "Fix numeric mean .. ", "B_clean_title": ["fix", "numer", "mean"]},
{"A_title": "HypergeometricDistribution.sample suffers from integer overflowHi I have an application which broke when ported from commons math 2.2 to 3.2. It looks like the HypergeometricDistribution.sample() method doesnt work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50.  import org.apache.commons.math3.distribution.HypergeometricDistribution;  public class Foo    public static void main(String args)      HypergeometricDistribution a = new HypergeometricDistribution(         43130568 42976365 50);     System.out.printf(%d %d%n a.getSupportLowerBound() a.getSupportUpperBound()); // Prints 0 50     System.out.printf(%d%na.sample());                                             // Prints -50       In the debugger I traced it as far as an integer overflow in HypergeometricDistribution.getNumericalMean() – instead of doing  return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();   it could do:  return getSampleSize() * ((double) getNumberOfSuccesses() / (double) getPopulationSize());   This seemed to fix it based on a quick test.", "A_clean_title": ["hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "suffer", "integ", "overflowhi", "overflow", "hi", "have", "applic", "which", "broke", "when", "port", "common", "math", "it", "look", "like", "hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "method", "doesnt", "work", "as", "well", "as", "it", "use", "larg", "integ", "valu", "exampl", "code", "below", "return", "sampl", "between", "50", "but", "usual", "return", "50", "import", "org", "apach", "common", "math3", "distribut", "hypergeometricdistribut", "hypergeometr", "distribut", "public", "class", "foo", "public", "static", "void", "main", "string", "arg", "hypergeometricdistribut", "hypergeometr", "distribut", "new", "hypergeometricdistribut", "hypergeometr", "distribut", "43130568", "42976365", "50", "system", "out", "printf", "getsupportlowerbound", "get", "support", "lower", "bound", "getsupportupperbound", "get", "support", "upper", "bound", "print", "50", "system", "out", "printf", "na", "sampl", "print", "50", "debugg", "trace", "it", "as", "far", "as", "integ", "overflow", "hypergeometricdistribut", "getnumericalmean", "hypergeometr", "distribut", "get", "numer", "mean", "instead", "do", "return", "doubl", "getsamples", "get", "sampl", "size", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "it", "could", "return", "getsamples", "get", "sampl", "size", "doubl", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "thi", "seem", "fix", "it", "base", "quick", "test"], "B_title": "Remove extraneous whitespace. ", "B_clean_title": ["remov", "extran", "whitespac"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Fix step size = t - stepStart ;. ", "B_clean_title": ["fix", "step", "size", "stepstart", "step", "start"]},
{"A_title": "FastMath.max(50.0f -50.0f) => -50.0f; should be +50.0fFastMath.max(50.0f -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case testMinMaxFloat() because that has a bug too - it tests doubles not floats.", "A_clean_title": ["fastmath", "max", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0ffastmath", "max", "0f", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0f", "thi", "becaus", "wrong", "variabl", "return", "bug", "wa", "not", "detect", "by", "test", "case", "testminmaxfloat", "test", "min", "max", "float", "becaus", "that", "ha", "bug", "too", "it", "test", "doubl", "not", "float"], "B_title": "Fix 3481 test. ", "B_clean_title": ["fix", "3481", "test"]},
{"A_title": "FastMath.max(50.0f -50.0f) => -50.0f; should be +50.0fFastMath.max(50.0f -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case testMinMaxFloat() because that has a bug too - it tests doubles not floats.", "A_clean_title": ["fastmath", "max", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0ffastmath", "max", "0f", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0f", "thi", "becaus", "wrong", "variabl", "return", "bug", "wa", "not", "detect", "by", "test", "case", "testminmaxfloat", "test", "min", "max", "float", "becaus", "that", "ha", "bug", "too", "it", "test", "doubl", "not", "float"], "B_title": "Fix float . max ( a  b ). ", "B_clean_title": ["fix", "float", "max"]},
{"A_title": "FastMath.max(50.0f -50.0f) => -50.0f; should be +50.0fFastMath.max(50.0f -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case testMinMaxFloat() because that has a bug too - it tests doubles not floats.", "A_clean_title": ["fastmath", "max", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0ffastmath", "max", "0f", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0f", "thi", "becaus", "wrong", "variabl", "return", "bug", "wa", "not", "detect", "by", "test", "case", "testminmaxfloat", "test", "min", "max", "float", "becaus", "that", "ha", "bug", "too", "it", "test", "doubl", "not", "float"], "B_title": "Fix typo in FastMath . exp ( x ). Fix NaN in FastMath . max ( a  b ). ", "B_clean_title": ["fix", "typo", "fastmath", "fast", "math", "exp", "fix", "nan", "na", "fastmath", "fast", "math", "max"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Don  t set the length of a string to 0 if the object is null .. Don  t use the constructor of StrBuilder in some cases .. ", "B_clean_title": ["don", "set", "length", "string", "object", "null", "don", "use", "constructor", "strbuilder", "str", "builder", "some", "case"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix the bug in Hercules . fixed. Fix the bug in Hercules .. ", "B_clean_title": ["fix", "bug", "hercul", "fix", "fix", "bug", "hercul"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix an NPE in StrBuilder . toString ( ). ", "B_clean_title": ["fix", "npe", "strbuilder", "str", "builder", "tostr", "string"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "removed test. ", "B_clean_title": ["remov", "test"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Fixed epsilon regression in tableau objective function. ", "B_clean_title": ["fix", "epsilon", "regress", "tableau", "object", "function"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Improved the garbage collection profile of TwoDimTableau .. ", "B_clean_title": ["improv", "garbag", "collect", "profil", "twodimtableau", "two", "dim", "tableau"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "removed epsilon label from tableau objective function. ", "B_clean_title": ["remov", "epsilon", "label", "tableau", "object", "function"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Fixed an example of the regression in LinearSolver . . .. ", "B_clean_title": ["fix", "exampl", "regress", "linearsolv", "linear", "solver"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Using less restrictive conditionals .. ", "B_clean_title": ["less", "restrict", "condit"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "Fixed epsilon. ", "B_clean_title": ["fix", "epsilon"]},
{"A_title": "MathUtils.gcd(Integer.MIN_VALUE 0) should throw an Exception instead of returning Integer.MIN_VALUEThe gcd method should throw an Exception for gcd(Integer.MIN_VALUE 0) like for gcd(Integer.MIN_VALUE Integer.MIN_VALUE). The method should only return nonnegative results.", "A_clean_title": ["mathutil", "gcd", "math", "util", "integ", "min", "valu", "throw", "except", "instead", "return", "integ", "min", "valueth", "valu", "gcd", "method", "throw", "except", "gcd", "integ", "min", "valu", "like", "gcd", "integ", "min", "valu", "integ", "min", "valu", "method", "onli", "return", "nonneg", "result"], "B_title": "Fix divide by zero error in MathUtils. Add a throw if it wasn  t possible to do this .. ", "B_clean_title": ["fix", "divid", "by", "zero", "error", "mathutil", "math", "util", "add", "throw", "it", "wasn", "possibl", "thi"]},
{"A_title": "WordUtils.abbreviate bug when lower is greater than str.lengthIn WordUtils.abbreviate upper is adjusted to the length of the string then to lower. But lower is never adjusted to the length of the string so if lower is greater than str.lengt() upper will be too... Then str.substring(0 upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string", "A_clean_title": ["wordutil", "abbrevi", "word", "util", "bug", "when", "lower", "greater", "than", "str", "lengthin", "length", "wordutil", "abbrevi", "word", "util", "upper", "adjust", "length", "string", "then", "lower", "but", "lower", "never", "adjust", "length", "string", "so", "lower", "greater", "than", "str", "lengt", "upper", "will", "too", "then", "str", "substr", "upper", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "fix", "adjust", "lower", "length", "string"], "B_title": "Fixed misc problems caused by the use of substringBefore and substringAfter methods in WordUtils. ", "B_clean_title": ["fix", "misc", "problem", "caus", "by", "use", "substringbefor", "substr", "befor", "substringaft", "substr", "after", "method", "wordutil", "word", "util"]},
{"A_title": "WordUtils.abbreviate bug when lower is greater than str.lengthIn WordUtils.abbreviate upper is adjusted to the length of the string then to lower. But lower is never adjusted to the length of the string so if lower is greater than str.lengt() upper will be too... Then str.substring(0 upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string", "A_clean_title": ["wordutil", "abbrevi", "word", "util", "bug", "when", "lower", "greater", "than", "str", "lengthin", "length", "wordutil", "abbrevi", "word", "util", "upper", "adjust", "length", "string", "then", "lower", "but", "lower", "never", "adjust", "length", "string", "so", "lower", "greater", "than", "str", "lengt", "upper", "will", "too", "then", "str", "substr", "upper", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "fix", "adjust", "lower", "length", "string"], "B_title": "Extend word utils upper bounds. ", "B_clean_title": ["extend", "word", "util", "upper", "bound"]},
{"A_title": "ArrayIndexOutOfBoundsException in MathArrays.linearCombinationWhen MathArrays.linearCombination is passed arguments with length 1 it throws an ArrayOutOfBoundsException. This is caused by this line: double prodHighNext = prodHigh1; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.", "A_clean_title": ["arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "matharray", "linearcombinationwhen", "math", "array", "linear", "combin", "when", "matharray", "linearcombin", "math", "array", "linear", "combin", "pass", "argument", "length", "it", "throw", "arrayoutofboundsexcept", "array", "out", "bound", "except", "thi", "caus", "by", "thi", "line", "doubl", "prodhighnext", "prod", "high", "next", "prodhigh1", "prod", "high1", "linearcombin", "linear", "combin", "check", "length", "argument", "fall", "back", "simpl", "multipl", "length"], "B_title": "Added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "unescapeXml(&12345678;) should be &12345678;Following test (in EntitiesTest.java) fails:     public void testNumberOverflow() throws Exception           doTestUnescapeEntity(&#12345678; &#12345678;);         doTestUnescapeEntity(x&#12345678;y x&#12345678;y);         doTestUnescapeEntity(&#x12345678; &#x12345678;);         doTestUnescapeEntity(x&#x12345678;y x&#x12345678;y);       Maximim value for char is 0xFFFF so &#12345678; is invalid entity reference and so should be left as is.", "A_clean_title": ["unescapexml", "unescap", "xml", "12345678", "12345678", "follow", "test", "entitiestest", "java", "entiti", "test", "fail", "public", "void", "testnumberoverflow", "test", "number", "overflow", "throw", "except", "dotestunescapeent", "test", "unescap", "entiti", "12345678", "12345678", "dotestunescapeent", "test", "unescap", "entiti", "12345678", "12345678", "dotestunescapeent", "test", "unescap", "entiti", "x12345678", "x12345678", "dotestunescapeent", "test", "unescap", "entiti", "x12345678", "x12345678", "maximim", "valu", "char", "0xffff", "0x", "ffff", "so", "12345678", "invalid", "entiti", "refer", "so", "left", "as"], "B_title": "Applying unit test and fix for #LANG-292. Also fixes a couple of problems with the unescape(Writer..) overload that came up", "B_clean_title": ["appli", "unit", "test", "fix", "lang", "292", "also", "fix", "coupl", "problem", "unescap", "writer", "overload", "that", "came", "up"]},
{"A_title": "StopWatch: suspend() acts as split() if followed by stop()In my opinion it is a bug that suspend() acts as split() if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause where time counter doesnt continue. So a following stop()-call shouldnt increase the time counter should it?", "A_clean_title": ["stopwatch", "stop", "watch", "suspend", "act", "as", "split", "follow", "by", "stop", "my", "opinion", "it", "bug", "that", "suspend", "act", "as", "split", "follow", "by", "stop", "see", "below", "stopwatch", "stop", "watch", "sw", "new", "stopwatch", "stop", "watch", "sw", "start", "thread", "sleep", "1000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "2000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "sw", "resum", "thread", "sleep", "3000", "sw", "suspend", "time", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "4000", "time", "again", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "thread", "sleep", "5000", "sw", "stop", "time", "but", "time", "not", "ok", "system", "out", "println", "sw", "gettim", "get", "time", "suspend", "resum", "like", "paus", "where", "time", "counter", "doesnt", "continu", "so", "follow", "stop", "call", "shouldnt", "increas", "time", "counter", "it"], "B_title": "Applying test and fix for LANG-315", "B_clean_title": ["appli", "test", "fix", "lang", "315"]},
{"A_title": "Errors in BOBYQAOptimizer when numberOfInterpolationPoints is greater than 2*dim+1Ive been having trouble getting BOBYQA to minimize a function (actually a non-linear least squares fit) so as one change I increased the number of interpolation points.  It seems that anything larger than 2*dim+1 causes an error (typically at line 1662                    interpolationPoints.setEntry(nfm ipt interpolationPoints.getEntry(ipt ipt)); Im guessing there is an off by one error in the translation from FORTRAN.  Changing the BOBYQAOptimizerTest as follows (increasing number of interpolation points by one) will cause failures. Bruce Index: src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java =================================================================== — src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java(revision 1221065) +++ src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java(working copy) @@ -2587 +2587 @@  //        RealPointValuePair result = optim.optimize(100000 func goal startPoint);          final double lB = boundaries == null ? null : boundaries0;          final double uB = boundaries == null ? null : boundaries1;  BOBYQAOptimizer optim = new BOBYQAOptimizer(2 * dim + 1); +        BOBYQAOptimizer optim = new BOBYQAOptimizer(2 * dim + 2);          RealPointValuePair result = optim.optimize(maxEvaluations func goal startPoint lB uB);  //        System.out.println(func.getClass().getName() +  =    //              + optim.getEvaluations() +  f();", "A_clean_title": ["error", "bobyqaoptim", "bobyqa", "optim", "when", "numberofinterpolationpoint", "number", "interpol", "point", "greater", "than", "dim+1iv", "been", "have", "troubl", "get", "bobyqa", "minim", "function", "actual", "non", "linear", "least", "squar", "fit", "so", "as", "one", "chang", "increas", "number", "interpol", "point", "it", "seem", "that", "anyth", "larger", "than", "dim+1", "caus", "error", "typic", "at", "line", "1662", "interpolationpoint", "setentri", "interpol", "point", "set", "entri", "nfm", "ipt", "interpolationpoint", "getentri", "interpol", "point", "get", "entri", "ipt", "ipt", "im", "guess", "there", "off", "by", "one", "error", "translat", "fortran", "chang", "bobyqaoptimizertest", "bobyqa", "optim", "test", "as", "follow", "increas", "number", "interpol", "point", "by", "one", "will", "caus", "failur", "bruce", "index", "java", "src", "test", "java", "org", "apach", "common", "math", "optim", "direct", "bobyqaoptimizertest", "bobyqa", "optim", "test", "java", "src", "test", "java", "org", "apach", "common", "math", "optim", "direct", "bobyqaoptimizertest", "bobyqa", "optim", "test", "revis", "1221065", "java", "src", "test", "java", "org", "apach", "common", "math", "optim", "direct", "bobyqaoptimizertest", "bobyqa", "optim", "test", "work", "copi", "2587", "+2587", "realpointvaluepair", "real", "point", "valu", "pair", "result", "optim", "optim", "100000", "func", "goal", "startpoint", "start", "point", "final", "doubl", "lb", "boundari", "null", "null", "boundaries0", "final", "doubl", "ub", "boundari", "null", "null", "boundaries1", "bobyqaoptim", "bobyqa", "optim", "optim", "new", "bobyqaoptim", "bobyqa", "optim", "dim", "bobyqaoptim", "bobyqa", "optim", "optim", "new", "bobyqaoptim", "bobyqa", "optim", "dim", "realpointvaluepair", "real", "point", "valu", "pair", "result", "optim", "optim", "maxevalu", "max", "evalu", "func", "goal", "startpoint", "start", "point", "lb", "ub", "system", "out", "println", "func", "getclass", "get", "class", "getnam", "get", "name", "optim", "getevalu", "get", "evalu"], "B_title": "Offset by one bug. Suggested fix provided by Bruce Johnson. Ive added a unit test that exercises the use of more interpolation points; two previously unexplored code paths are now being traversed.", "B_clean_title": ["offset", "by", "one", "bug", "suggest", "fix", "provid", "by", "bruce", "johnson", "ive", "ad", "unit", "test", "that", "exercis", "use", "more", "interpol", "point", "two", "previous", "unexplor", "code", "path", "are", "now", "be", "travers"]},
{"A_title": "Result of multiplying and equals for complex numbers is wrongHi. The bug relates on complex numbers. The methods multiply and equals of the class Complex are involved. mathematic background:  (0i) * (-10i) = (0-i). little java program + output that shows the bug: -----------------------------------------------------------------------  import org.apache.commons.math.complex.*; public class TestProg          public static void main(String args)                   ComplexFormat f = new ComplexFormat();                 Complex c1 = new Complex(01);                 Complex c2 = new Complex(-10);                  Complex res = c1.multiply(c2);                 Complex comp = new Complex(0-1);                  System.out.println(res:  +f.format(res));                 System.out.println(comp: +f.format(comp));                  System.out.println(res=comp: +res.equals(comp));             ----------------------------------------------------------------------- res:  -0 - 1i comp: 0 - 1i res=comp: false ----------------------------------------------------------------------- I think the equals should return true. The problem could either be the multiply method that gives (-0-1i) instead of (0-1i) or if you think thats right the equals method has to be modified. Good Luck Dieter", "A_clean_title": ["result", "multipli", "equal", "complex", "number", "wronghi", "wrong", "hi", "bug", "relat", "complex", "number", "method", "multipli", "equal", "class", "complex", "are", "involv", "mathemat", "background", "0i", "10i", "littl", "java", "program", "output", "that", "show", "bug", "import", "org", "apach", "common", "math", "complex", "public", "class", "testprog", "test", "prog", "public", "static", "void", "main", "string", "arg", "complexformat", "complex", "format", "new", "complexformat", "complex", "format", "complex", "c1", "new", "complex", "01", "complex", "c2", "new", "complex", "10", "complex", "re", "c1", "multipli", "c2", "complex", "comp", "new", "complex", "system", "out", "println", "re", "+f", "format", "re", "system", "out", "println", "comp", "+f", "format", "comp", "system", "out", "println", "res=comp", "+re", "equal", "comp", "re", "1i", "comp", "1i", "res=comp", "fals", "think", "equal", "return", "true", "problem", "could", "either", "multipli", "method", "that", "give", "1i", "instead", "1i", "or", "you", "think", "that", "right", "equal", "method", "ha", "modifi", "good", "luck", "dieter"], "B_title": "Changed the Complex.equals() method so that it considers +0 and -0 are equal as required by IEEE-754 standard. JIRA: MATH-221", "B_clean_title": ["chang", "complex", "equal", "method", "so", "that", "it", "consid", "+0", "are", "equal", "as", "requir", "by", "ieee", "754", "standard", "jira", "math", "221"]},
{"A_title": "HypergeometricDistribution.sample suffers from integer overflowHi I have an application which broke when ported from commons math 2.2 to 3.2. It looks like the HypergeometricDistribution.sample() method doesnt work as well as it used to with large integer values – the example code below should return a sample between 0 and 50 but usually returns -50.  import org.apache.commons.math3.distribution.HypergeometricDistribution;  public class Foo    public static void main(String args)      HypergeometricDistribution a = new HypergeometricDistribution(         43130568 42976365 50);     System.out.printf(%d %d%n a.getSupportLowerBound() a.getSupportUpperBound()); // Prints 0 50     System.out.printf(%d%na.sample());                                             // Prints -50       In the debugger I traced it as far as an integer overflow in HypergeometricDistribution.getNumericalMean() – instead of doing  return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();   it could do:  return getSampleSize() * ((double) getNumberOfSuccesses() / (double) getPopulationSize());   This seemed to fix it based on a quick test.", "A_clean_title": ["hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "suffer", "integ", "overflowhi", "overflow", "hi", "have", "applic", "which", "broke", "when", "port", "common", "math", "it", "look", "like", "hypergeometricdistribut", "sampl", "hypergeometr", "distribut", "method", "doesnt", "work", "as", "well", "as", "it", "use", "larg", "integ", "valu", "exampl", "code", "below", "return", "sampl", "between", "50", "but", "usual", "return", "50", "import", "org", "apach", "common", "math3", "distribut", "hypergeometricdistribut", "hypergeometr", "distribut", "public", "class", "foo", "public", "static", "void", "main", "string", "arg", "hypergeometricdistribut", "hypergeometr", "distribut", "new", "hypergeometricdistribut", "hypergeometr", "distribut", "43130568", "42976365", "50", "system", "out", "printf", "getsupportlowerbound", "get", "support", "lower", "bound", "getsupportupperbound", "get", "support", "upper", "bound", "print", "50", "system", "out", "printf", "na", "sampl", "print", "50", "debugg", "trace", "it", "as", "far", "as", "integ", "overflow", "hypergeometricdistribut", "getnumericalmean", "hypergeometr", "distribut", "get", "numer", "mean", "instead", "do", "return", "doubl", "getsamples", "get", "sampl", "size", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "it", "could", "return", "getsamples", "get", "sampl", "size", "doubl", "getnumberofsuccess", "get", "number", "success", "doubl", "getpopulations", "get", "popul", "size", "thi", "seem", "fix", "it", "base", "quick", "test"], "B_title": "Reordering can prevent some overflow occurrences (fix suggested by Brian Bloniarz). Added unit test.", "B_clean_title": ["reorder", "prevent", "some", "overflow", "occurr", "fix", "suggest", "by", "brian", "bloniarz", "ad", "unit", "test"]},
{"A_title": "too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(53) ...)Adaptive step size integrators compute the first step size by themselves if it is not provided. For embedded Runge-Kutta type this step size is not checked against the integration range so if the integration range is extremely short this step size may evaluate the function out of the range (and in fact it tries afterward to go back and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem the step size is checked and truncated if needed.", "A_clean_title": ["too", "larg", "first", "step", "embed", "rung", "kutta", "integr", "dormand", "princ", "53", "adapt", "step", "size", "integr", "comput", "first", "step", "size", "by", "themselv", "it", "not", "provid", "embed", "rung", "kutta", "type", "thi", "step", "size", "not", "check", "against", "integr", "rang", "so", "integr", "rang", "extrem", "short", "thi", "step", "size", "may", "evalu", "function", "out", "rang", "fact", "it", "tri", "afterward", "go", "back", "fail", "stop", "gragg", "bulirsch", "stoer", "integr", "not", "have", "thi", "problem", "step", "size", "check", "truncat", "need"], "B_title": "Check first step size in embedded Runge-Kutta integrators.", "B_clean_title": ["check", "first", "step", "size", "embed", "rung", "kutta", "integr"]},
{"A_title": "FastMath.max(50.0f -50.0f) => -50.0f; should be +50.0fFastMath.max(50.0f -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case testMinMaxFloat() because that has a bug too - it tests doubles not floats.", "A_clean_title": ["fastmath", "max", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0ffastmath", "max", "0f", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0f", "thi", "becaus", "wrong", "variabl", "return", "bug", "wa", "not", "detect", "by", "test", "case", "testminmaxfloat", "test", "min", "max", "float", "becaus", "that", "ha", "bug", "too", "it", "test", "doubl", "not", "float"], "B_title": "FastMath.max(50.0f -50.0f) => -50.0f; should be +50.0f", "B_clean_title": ["fastmath", "max", "fast", "math", "50", "0f", "50", "0f", "50", "0f", "+50", "0f"]},
{"A_title": "DateTimeZone.getOffsetFromLocal error during DST transitionThis may be a failure of my understanding but the comments in DateTimeZone.getOffsetFromLocal lead me to believe that if an ambiguous local time is given the offset corresponding to the later of the two possible UTC instants will be returned - i.e. the greater offset.  This doesnt appear to tally with my experience. In fall 2009 America/Los_Angeles changed from -7 to -8 at 2am wall time on November 11. Thus 2am became 1am - so 1:30am is ambiguous. I would therefore expect that constructing a DateTime for November 11th 1:30am would give an instant corresponding with the later value (i.e. 9:30am UTC).", "A_clean_title": ["datetimezon", "getoffsetfromloc", "date", "time", "zone", "get", "offset", "local", "error", "dure", "dst", "transitionthi", "transit", "thi", "may", "failur", "my", "understand", "but", "comment", "datetimezon", "getoffsetfromloc", "date", "time", "zone", "get", "offset", "local", "lead", "me", "believ", "that", "ambigu", "local", "time", "given", "offset", "correspond", "later", "two", "possibl", "utc", "instant", "will", "return", "greater", "offset", "thi", "doesnt", "appear", "talli", "my", "experi", "fall", "2009", "angel", "america", "lo", "chang", "at", "2am", "wall", "time", "novemb", "11", "thu", "2am", "becam", "1am", "so", "1:30am", "ambigu", "would", "therefor", "expect", "that", "construct", "datetim", "date", "time", "novemb", "11th", "1:30am", "would", "give", "instant", "correspond", "later", "valu", "9:30am", "utc"], "B_title": "2952991 The behaviour during DST overlaps is now defined to always return the earlier instant which is normally known as daylight or summer time. Previously the result varied by hemisphere. This affects the constructor of DateTime and other methods", "B_clean_title": ["2952991", "behaviour", "dure", "dst", "overlap", "now", "defin", "alway", "return", "earlier", "instant", "which", "normal", "known", "as", "daylight", "or", "summer", "time", "previous", "result", "vari", "by", "hemispher", "thi", "affect", "constructor", "datetim", "date", "time", "other", "method"]},
{"A_title": "Unable to add days to a MonthDay set to the ISO leap dateIts not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.", "A_clean_title": ["unabl", "add", "day", "monthday", "month", "day", "set", "iso", "leap", "dateit", "date", "it", "not", "possibl", "add", "day", "monthday", "month", "day", "set", "iso", "leap", "date", "februari", "29th", "thi", "even", "more", "bizarr", "given", "exact", "error", "messag", "thrown"], "B_title": "Fix MonthDay add/subtract around Feb29 3528941", "B_clean_title": ["fix", "monthday", "month", "day", "add", "subtract", "around", "feb29", "3528941"]},
{"A_title": "StrBuilder appendFixedWidth does not handle nullsAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "A_clean_title": ["strbuilder", "str", "builder", "appendfixedwidth", "append", "fix", "width", "not", "handl", "nullsappend", "null", "append", "null", "valu", "fix", "width", "caus", "null", "pointer", "except", "getnulltext", "get", "null", "text", "ha", "not", "been", "set"], "B_title": "Applying my patch from LANG-412; fixing Peter Oxenhams report that the appendFixedWidthPadRight and appendFixedWidthPadLeft are not null safe if the nullText has not been set", "B_clean_title": ["appli", "my", "patch", "lang", "412", "fix", "peter", "oxenham", "report", "that", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "are", "not", "null", "safe", "nulltext", "null", "text", "ha", "not", "been", "set"]},
{"A_title": "SimplexSolver not working as expected 2SimplexSolver didnt find the optimal solution. Program for Lpsolve: ===================== /* Objective function */ max: 7 a 3 b; /* Constraints */ R1: +3 a -5 c <= 0; R2: +2 a -5 d <= 0; R3: +2 b -5 c <= 0; R4: +3 b -5 d <= 0; R5: +3 a +2 b <= 5; R6: +2 a +3 b <= 5; /* Variable bounds */ a <= 1; b <= 1; ===================== Results(correct): a = 1 b = 1 value = 10 Program for SimplexSolve: ===================== LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double 7 3 0 0  0); Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>(); podmienky.add(new LinearConstraint(new double 1 0 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 0 1 0 0  Relationship.LEQ 1)); podmienky.add(new LinearConstraint(new double 3 0 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 2 0 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 2 -5 0  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 0 3 0 -5  Relationship.LEQ 0)); podmienky.add(new LinearConstraint(new double 3 2 0 0  Relationship.LEQ 5)); podmienky.add(new LinearConstraint(new double 2 3 0 0  Relationship.LEQ 5)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair result = solver.optimize(kritFcia podmienky GoalType.MAXIMIZE true); ===================== Results(incorrect): a = 1 b = 0.5 value = 8.5 P.S. I used the latest software from the repository (including MATH-286 fix).", "A_clean_title": ["simplexsolv", "simplex", "solver", "not", "work", "as", "expect", "2simplexsolv", "2simplex", "solver", "didnt", "find", "optim", "solut", "program", "lpsolv", "object", "function", "max", "constraint", "r1", "+3", "r2", "+2", "r3", "+2", "r4", "+3", "r5", "+3", "+2", "r6", "+2", "+3", "variabl", "bound", "result", "correct", "valu", "10", "program", "simplexsolv", "simplex", "solv", "linearobjectivefunct", "linear", "object", "function", "kritfcia", "krit", "fcia", "new", "linearobjectivefunct", "linear", "object", "function", "new", "doubl", "collect", "linearconstraint", "linear", "constraint", "podmienki", "new", "arraylist", "array", "list", "linearconstraint", "linear", "constraint", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "podmienki", "add", "new", "linearconstraint", "linear", "constraint", "new", "doubl", "relationship", "leq", "simplexsolv", "simplex", "solver", "solver", "new", "simplexsolv", "simplex", "solver", "realpointvaluepair", "real", "point", "valu", "pair", "result", "solver", "optim", "kritfcia", "krit", "fcia", "podmienki", "goaltyp", "maxim", "goal", "type", "true", "result", "incorrect", "valu", "use", "latest", "softwar", "repositori", "includ", "math", "286", "fix"], "B_title": "fixed an error induced by zero entries in simplex solver JIRA: MATH-288", "B_clean_title": ["fix", "error", "induc", "by", "zero", "entri", "simplex", "solver", "jira", "math", "288"]},
{"A_title": "ArrayIndexOutOfBoundException in EigenDecompositionImplThe following test triggers an ArrayIndexOutOfBoundException:      public void testMath308()           double mainTridiagonal =              22.330154644539597 46.65485522478641 17.393672330044705 54.46687435351116 80.17800767709437         ;         double secondaryTridiagonal =              13.04450406501361 -5.977590941539671 2.9040909856707517 7.1570352792841225         ;          // the reference values have been computed using routine DSTEMR         // from the fortran library LAPACK version 3.2.1         double refEigenValues =              14.138204224043099 18.847969733754262 52.536278520113882 53.456697699894512 82.044413207204002         ;         RealVector refEigenVectors =              new ArrayRealVector(new double   0.584677060845929 -0.367177264979103 -0.721453187784497  0.052971054621812 -0.005740715188257 )             new ArrayRealVector(new double   0.713933751051495 -0.190582113553930  0.671410443368332 -0.056056055955050  0.006541576993581 )             new ArrayRealVector(new double   0.222368839324646  0.514921891363332 -0.021377019336614  0.801196801016305 -0.207446991247740 )             new ArrayRealVector(new double   0.314647769490148  0.750806415553905 -0.167700312025760 -0.537092972407375  0.143854968127780 )             new ArrayRealVector(new double  -0.000462690386766 -0.002118073109055  0.011530080757413  0.252322434584915  0.967572088232592 )         ;          // the following line triggers the exception         EigenDecomposition decomposition =             new EigenDecompositionImpl(mainTridiagonal secondaryTridiagonal MathUtils.SAFE_MIN);          double eigenValues = decomposition.getRealEigenvalues();         for (int i = 0; i < refEigenValues.length; ++i)              assertEquals(refEigenValuesi eigenValuesi 1.0e-6);             if (refEigenVectorsi.dotProduct(decomposition.getEigenvector(i)) < 0)                  assertEquals(0 refEigenVectorsi.add(decomposition.getEigenvector(i)).getNorm() 1.0e-6);              else                  assertEquals(0 refEigenVectorsi.subtract(decomposition.getEigenvector(i)).getNorm() 1.0e-6);                               Running the previous method as a Junit test triggers the exception when the EigenDecompositionImpl instance is built. The first few lines of the stack trace are:  java.lang.ArrayIndexOutOfBoundsException: -1 at org.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement(EigenDecompositionImpl.java:1545) at org.apache.commons.math.linear.EigenDecompositionImpl.goodStep(EigenDecompositionImpl.java:1072) at org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock(EigenDecompositionImpl.java:894) at org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues(EigenDecompositionImpl.java:658) at org.apache.commons.math.linear.EigenDecompositionImpl.decompose(EigenDecompositionImpl.java:246) at org.apache.commons.math.linear.EigenDecompositionImpl.<init>(EigenDecompositionImpl.java:205) at org.apache.commons.math.linear.EigenDecompositionImplTest.testMath308(EigenDecompositionImplTest.java:136)   Im currently investigating this bug. It is not a simple index translation error between the original fortran (Lapack) and commons-math implementation.", "A_clean_title": ["arrayindexoutofboundexcept", "array", "index", "out", "bound", "except", "eigendecompositionimplth", "eigen", "decomposit", "impl", "follow", "test", "trigger", "arrayindexoutofboundexcept", "array", "index", "out", "bound", "except", "public", "void", "testmath308", "test", "math308", "doubl", "maintridiagon", "main", "tridiagon", "22", "330154644539597", "46", "65485522478641", "17", "393672330044705", "54", "46687435351116", "80", "17800767709437", "doubl", "secondarytridiagon", "secondari", "tridiagon", "13", "04450406501361", "977590941539671", "9040909856707517", "1570352792841225", "refer", "valu", "have", "been", "comput", "routin", "dstemr", "fortran", "librari", "lapack", "version", "doubl", "refeigenvalu", "ref", "eigen", "valu", "14", "138204224043099", "18", "847969733754262", "52", "536278520113882", "53", "456697699894512", "82", "044413207204002", "realvector", "real", "vector", "refeigenvector", "ref", "eigen", "vector", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "584677060845929", "367177264979103", "721453187784497", "052971054621812", "005740715188257", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "713933751051495", "190582113553930", "671410443368332", "056056055955050", "006541576993581", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "222368839324646", "514921891363332", "021377019336614", "801196801016305", "207446991247740", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "314647769490148", "750806415553905", "167700312025760", "537092972407375", "143854968127780", "new", "arrayrealvector", "array", "real", "vector", "new", "doubl", "000462690386766", "002118073109055", "011530080757413", "252322434584915", "967572088232592", "follow", "line", "trigger", "except", "eigendecomposit", "eigen", "decomposit", "decomposit", "new", "eigendecompositionimpl", "eigen", "decomposit", "impl", "maintridiagon", "main", "tridiagon", "secondarytridiagon", "secondari", "tridiagon", "mathutil", "math", "util", "safe", "min", "doubl", "eigenvalu", "eigen", "valu", "decomposit", "getrealeigenvalu", "get", "real", "eigenvalu", "int", "refeigenvalu", "length", "ref", "eigen", "valu", "++i", "assertequ", "assert", "equal", "refeigenvaluesi", "ref", "eigen", "valuesi", "eigenvaluesi", "eigen", "valuesi", "0e", "refeigenvectorsi", "dotproduct", "ref", "eigen", "vectorsi", "dot", "product", "decomposit", "geteigenvector", "get", "eigenvector", "assertequ", "assert", "equal", "refeigenvectorsi", "add", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "assertequ", "assert", "equal", "refeigenvectorsi", "subtract", "ref", "eigen", "vectorsi", "decomposit", "geteigenvector", "get", "eigenvector", "getnorm", "get", "norm", "0e", "run", "previou", "method", "as", "junit", "test", "trigger", "except", "when", "eigendecompositionimpl", "eigen", "decomposit", "impl", "instanc", "built", "first", "few", "line", "stack", "trace", "are", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpl", "computeshiftincr", "eigen", "decomposit", "impl", "comput", "shift", "increment", "eigendecompositionimpl", "java:1545", "eigen", "decomposit", "impl", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpl", "goodstep", "eigen", "decomposit", "impl", "good", "step", "eigendecompositionimpl", "java:1072", "eigen", "decomposit", "impl", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpl", "processgeneralblock", "eigen", "decomposit", "impl", "process", "gener", "block", "eigendecompositionimpl", "java:894", "eigen", "decomposit", "impl", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpl", "findeigenvalu", "eigen", "decomposit", "impl", "find", "eigenvalu", "eigendecompositionimpl", "java:658", "eigen", "decomposit", "impl", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpl", "decompos", "eigen", "decomposit", "impl", "eigendecompositionimpl", "java:246", "eigen", "decomposit", "impl", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpl", "eigen", "decomposit", "impl", "init", "eigendecompositionimpl", "java:205", "eigen", "decomposit", "impl", "at", "org", "apach", "common", "math", "linear", "eigendecompositionimpltest", "testmath308", "eigen", "decomposit", "impl", "test", "test", "math308", "eigendecompositionimpltest", "java:136", "eigen", "decomposit", "impl", "test", "im", "current", "investig", "thi", "bug", "it", "not", "simpl", "index", "translat", "error", "between", "origin", "fortran", "lapack", "common", "math", "implement"], "B_title": "fixed an ArrayIndexOutOfBoundsException Kudos to Dimitri who debugged this mess of fortran/java array indices translation JIRA: MATH-308", "B_clean_title": ["fix", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "kudo", "dimitri", "who", "debug", "thi", "mess", "fortran", "java", "array", "indic", "translat", "jira", "math", "308"]},
{"A_title": "math Function math.fraction.ProperFractionFormat.parse(String ParsePosition) return illogical resultHello I find illogical returned result from function Fraction parse(String source  ParsePostion pos) (in class ProperFractionFormat of the Fraction Package) of  the Commons Math library. Please see the following code segment for more  details:  ProperFractionFormat properFormat = new ProperFractionFormat(); result = null; String source = 1 -1 / 2; ParsePosition pos = new ParsePosition(0); //Test 1 : fail  public void testParseNegative()    String source = -1 -2 / 3;    ParsePosition pos = new ParsePosition(0);    Fraction actual = properFormat.parse(source pos);    assertNull(actual);  // Test2: success public void testParseNegative()    String source = -1 -2 / 3;    ParsePosition pos = new ParsePosition(0);    Fraction actual = properFormat.parse(source pos);  // return Fraction 1/3    assertEquals(1 source.getNumerator());    assertEquals(3 source.getDenominator());   Note: Similarly when I passed in the following inputs:    input 2: (source = “1 2 / -3” pos = 0)   input 3: ( source = ” -1 -2 / 3” pos = 0) Function Fraction parse(String ParsePosition) returned Fraction 1/3 (means  the result Fraction had numerator = 1 and  denominator = 3)for all 3 inputs  above. I think the function does not handle parsing the numberator/ denominator  properly incase input string provide invalid numerator/denominator.  Thank you!", "A_clean_title": ["math", "function", "math", "fraction", "properfractionformat", "pars", "proper", "fraction", "format", "string", "parseposit", "pars", "posit", "return", "illog", "resulthello", "result", "hello", "find", "illog", "return", "result", "function", "fraction", "pars", "string", "sourc", "parsepost", "pars", "postion", "po", "class", "properfractionformat", "proper", "fraction", "format", "fraction", "packag", "common", "math", "librari", "pleas", "see", "follow", "code", "segment", "more", "detail", "properfractionformat", "proper", "fraction", "format", "properformat", "proper", "format", "new", "properfractionformat", "proper", "fraction", "format", "result", "null", "string", "sourc", "parseposit", "pars", "posit", "po", "new", "parseposit", "pars", "posit", "test", "fail", "public", "void", "testparseneg", "test", "pars", "neg", "string", "sourc", "parseposit", "pars", "posit", "po", "new", "parseposit", "pars", "posit", "fraction", "actual", "properformat", "pars", "proper", "format", "sourc", "po", "assertnul", "assert", "null", "actual", "test2", "success", "public", "void", "testparseneg", "test", "pars", "neg", "string", "sourc", "parseposit", "pars", "posit", "po", "new", "parseposit", "pars", "posit", "fraction", "actual", "properformat", "pars", "proper", "format", "sourc", "po", "return", "fraction", "assertequ", "assert", "equal", "sourc", "getnumer", "get", "numer", "assertequ", "assert", "equal", "sourc", "getdenomin", "get", "denomin", "note", "similarli", "when", "pass", "follow", "input", "input", "sourc", "po", "input", "sourc", "po", "function", "fraction", "pars", "string", "parseposit", "pars", "posit", "return", "fraction", "mean", "result", "fraction", "had", "numer", "denomin", "all", "input", "abov", "think", "function", "not", "handl", "pars", "number", "denomin", "properli", "incas", "input", "string", "provid", "invalid", "numer", "denomin", "thank", "you"], "B_title": "Modified ProperFractionFormat to reject embedded minus signs. JIRA: MATH-60 Reported by Nhung Nnguyen", "B_clean_title": ["modifi", "properfractionformat", "proper", "fraction", "format", "reject", "embed", "minu", "sign", "jira", "math", "60", "report", "by", "nhung", "nnguyen"]},
{"A_title": "LevenbergMarquardtOptimizer reports 0 iterationsThe method LevenbergMarquardtOptimizer.getIterations() does not report the correct number of iterations; It always returns 0. A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer.incrementEvaluationsCount() Ive put a test case below. Notice how the evaluations count is correctly incremented but the iterations count is not.      @Test     public void testGetIterations()          // setup         LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer();          // action         otim.optimize(new MaxEval(100) new Target(new double  1 )                 new Weight(new double  1 ) new InitialGuess(                         new double  3 ) new ModelFunction(                         new MultivariateVectorFunction()                              @Override                             public double value(double point)                                     throws IllegalArgumentException                                  return new double  FastMath.pow(point0 4) ;                                                      ) new ModelFunctionJacobian(                         new MultivariateMatrixFunction()                              @Override                             public double value(double point)                                     throws IllegalArgumentException                                  return new double   0.25 * FastMath.pow(                                         point0 3)  ;                                                      ));          // verify         assertThat(otim.getEvaluations() greaterThan(1));         assertThat(otim.getIterations() greaterThan(1));", "A_clean_title": ["levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "report", "iterationsth", "iter", "method", "levenbergmarquardtoptim", "getiter", "levenberg", "marquardt", "optim", "get", "iter", "not", "report", "correct", "number", "iter", "it", "alway", "return", "quick", "look", "at", "code", "show", "that", "onli", "simplexoptim", "simplex", "optim", "call", "baseoptim", "incrementevaluationscount", "base", "optim", "increment", "evalu", "count", "ive", "put", "test", "case", "below", "notic", "how", "evalu", "count", "correctli", "increment", "but", "iter", "count", "not", "test", "public", "void", "testgetiter", "test", "get", "iter", "setup", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "otim", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "action", "otim", "optim", "new", "maxev", "max", "eval", "100", "new", "target", "new", "doubl", "new", "weight", "new", "doubl", "new", "initialguess", "initi", "guess", "new", "doubl", "new", "modelfunct", "model", "function", "new", "multivariatevectorfunct", "multivari", "vector", "function", "overrid", "public", "doubl", "valu", "doubl", "point", "throw", "illegalargumentexcept", "illeg", "argument", "except", "return", "new", "doubl", "fastmath", "pow", "fast", "math", "point0", "new", "modelfunctionjacobian", "model", "function", "jacobian", "new", "multivariatematrixfunct", "multivari", "matrix", "function", "overrid", "public", "doubl", "valu", "doubl", "point", "throw", "illegalargumentexcept", "illeg", "argument", "except", "return", "new", "doubl", "25", "fastmath", "pow", "fast", "math", "point0", "verifi", "assertthat", "assert", "that", "otim", "getevalu", "get", "evalu", "greaterthan", "greater", "than", "assertthat", "assert", "that", "otim", "getiter", "get", "iter", "greaterthan", "greater", "than"], "B_title": "Increment iteration counter. By default the maximum number of iterations is Integer.MAX_VALUE.", "B_clean_title": ["increment", "iter", "counter", "by", "default", "maximum", "number", "iter", "integ", "max", "valu"]},
{"A_title": "MathUtils.gcd(Integer.MIN_VALUE 0) should throw an Exception instead of returning Integer.MIN_VALUEThe gcd method should throw an Exception for gcd(Integer.MIN_VALUE 0) like for gcd(Integer.MIN_VALUE Integer.MIN_VALUE). The method should only return nonnegative results.", "A_clean_title": ["mathutil", "gcd", "math", "util", "integ", "min", "valu", "throw", "except", "instead", "return", "integ", "min", "valueth", "valu", "gcd", "method", "throw", "except", "gcd", "integ", "min", "valu", "like", "gcd", "integ", "min", "valu", "integ", "min", "valu", "method", "onli", "return", "nonneg", "result"], "B_title": "Fixed an error in computing gcd and lcm for some extreme values at integer range boundaries. JIRA: MATH-243", "B_clean_title": ["fix", "error", "comput", "gcd", "lcm", "some", "extrem", "valu", "at", "integ", "rang", "boundari", "jira", "math", "243"]},
{"A_title": "Wrong parameter for first step size guess for Embedded Runge Kutta methodsIn a space application using DOP853 i detected what seems to be a bad parameter in the call to the method  initializeStep of class AdaptiveStepsizeIntegrator. Here DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate(...) The problem comes from the array scale that is used as a parameter in the call off initializeStep(..) Following the theory described by Hairer in his book Solving Ordinary Differential Equations 1 : Nonstiff Problems the scaling should be : sci = Atol i + |y0i| * Rtoli Whereas EmbeddedRungeKuttaIntegrator uses :  sci = Atoli Note that the Gragg-Bulirsch-Stoer integrator uses the good implementation sci = Atol i + |y0i| * Rtoli   when he performs the call to the same method initializeStep(..) In the method initializeStep the error leads to a wrong step size h used to perform an  Euler step. Most of the time it is unvisible for the user. But in my space application the Euler step with this wrong step size h (much bigger than it should be)  makes an exception occur (my satellite hits the ground...) To fix the bug one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator For exemple :  final double scale= new doubley0.length;;           if (vecAbsoluteTolerance == null)                for (int i = 0; i < scale.length; ++i)                   final double yi = Math.max(Math.abs(y0i) Math.abs(y0i));                 scalei = scalAbsoluteTolerance + scalRelativeTolerance * yi;                             else                for (int i = 0; i < scale.length; ++i)                   final double yi = Math.max(Math.abs(y0i) Math.abs(y0i));                 scalei = vecAbsoluteTolerancei + vecRelativeTolerancei * yi;                                       hNew = initializeStep(equations forward getOrder() scale                            stepStart y yDotK0 yTmp yDotK1); Sorry for the length of this message looking forward to hearing from you soon Vincent Morand", "A_clean_title": ["wrong", "paramet", "first", "step", "size", "guess", "embed", "rung", "kutta", "methodsin", "method", "space", "applic", "dop853", "detect", "what", "seem", "bad", "paramet", "call", "method", "initializestep", "initi", "step", "class", "adaptivestepsizeintegr", "adapt", "stepsiz", "integr", "here", "dormandprince853integr", "dormand", "prince853integr", "subclass", "embeddedrungekuttaintegr", "embed", "rung", "kutta", "integr", "which", "perform", "call", "initializestep", "initi", "step", "at", "begin", "it", "method", "integr", "problem", "come", "array", "scale", "that", "use", "as", "paramet", "call", "off", "initializestep", "initi", "step", "follow", "theori", "describ", "by", "hairer", "hi", "book", "solv", "ordinari", "differenti", "equat", "nonstiff", "problem", "scale", "sci", "atol", "|y0i|", "rtoli", "wherea", "embeddedrungekuttaintegr", "embed", "rung", "kutta", "integr", "use", "sci", "atoli", "note", "that", "gragg", "bulirsch", "stoer", "integr", "use", "good", "implement", "sci", "atol", "|y0i|", "rtoli", "when", "he", "perform", "call", "same", "method", "initializestep", "initi", "step", "method", "initializestep", "initi", "step", "error", "lead", "wrong", "step", "size", "use", "perform", "euler", "step", "most", "time", "it", "unvis", "user", "but", "my", "space", "applic", "euler", "step", "thi", "wrong", "step", "size", "much", "bigger", "than", "it", "make", "except", "occur", "my", "satellit", "hit", "ground", "fix", "bug", "one", "use", "same", "algorithm", "as", "rescal", "method", "graggbulirschstoerintegr", "gragg", "bulirsch", "stoer", "integr", "exempl", "final", "doubl", "scale=", "new", "doubley0", "length", "vecabsolutetoler", "vec", "absolut", "toler", "null", "int", "scale", "length", "++i", "final", "doubl", "yi", "math", "max", "math", "ab", "y0i", "math", "ab", "y0i", "scalei", "scalabsolutetoler", "scal", "absolut", "toler", "scalrelativetoler", "scal", "rel", "toler", "yi", "int", "scale", "length", "++i", "final", "doubl", "yi", "math", "max", "math", "ab", "y0i", "math", "ab", "y0i", "scalei", "vecabsolutetolerancei", "vec", "absolut", "tolerancei", "vecrelativetolerancei", "vec", "rel", "tolerancei", "yi", "hnew", "new", "initializestep", "initi", "step", "equat", "forward", "getord", "get", "order", "scale", "stepstart", "step", "start", "ydotk0", "dot", "k0", "ytmp", "tmp", "ydotk1", "dot", "k1", "sorri", "length", "thi", "messag", "look", "forward", "hear", "you", "soon", "vincent", "morand"], "B_title": "Fixed automatic step initialization in embedded Runge-Kutta integrators. The relative tolerance setting was never used only the absolute tolerance was used. JIRA: MATH-338", "B_clean_title": ["fix", "automat", "step", "initi", "embed", "rung", "kutta", "integr", "rel", "toler", "set", "wa", "never", "use", "onli", "absolut", "toler", "wa", "use", "jira", "math", "338"]},
{"A_title": "WordUtils.abbreviate bug when lower is greater than str.lengthIn WordUtils.abbreviate upper is adjusted to the length of the string then to lower. But lower is never adjusted to the length of the string so if lower is greater than str.lengt() upper will be too... Then str.substring(0 upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string", "A_clean_title": ["wordutil", "abbrevi", "word", "util", "bug", "when", "lower", "greater", "than", "str", "lengthin", "length", "wordutil", "abbrevi", "word", "util", "upper", "adjust", "length", "string", "then", "lower", "but", "lower", "never", "adjust", "length", "string", "so", "lower", "greater", "than", "str", "lengt", "upper", "will", "too", "then", "str", "substr", "upper", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "fix", "adjust", "lower", "length", "string"], "B_title": "Applying Vincent Behars second patch for LANG-419 - fixing a bug in abbreviate such that lower limits greater than the length of the string werent working correctly", "B_clean_title": ["appli", "vincent", "behar", "second", "patch", "lang", "419", "fix", "bug", "abbrevi", "such", "that", "lower", "limit", "greater", "than", "length", "string", "werent", "work", "correctli"]},
{"A_title": "ArrayIndexOutOfBoundsException in MathArrays.linearCombinationWhen MathArrays.linearCombination is passed arguments with length 1 it throws an ArrayOutOfBoundsException. This is caused by this line: double prodHighNext = prodHigh1; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.", "A_clean_title": ["arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "matharray", "linearcombinationwhen", "math", "array", "linear", "combin", "when", "matharray", "linearcombin", "math", "array", "linear", "combin", "pass", "argument", "length", "it", "throw", "arrayoutofboundsexcept", "array", "out", "bound", "except", "thi", "caus", "by", "thi", "line", "doubl", "prodhighnext", "prod", "high", "next", "prodhigh1", "prod", "high1", "linearcombin", "linear", "combin", "check", "length", "argument", "fall", "back", "simpl", "multipl", "length"], "B_title": "Array of length 1 must be handled as a special case.", "B_clean_title": ["array", "length", "must", "handl", "as", "special", "case"]},
{"A_title": "Miscellaneous issues concerning the optimization packageRevision 990792 contains changes triggered the following issues:  MATH-394 MATH-397 MATH-404  This issue collects the currently still unsatisfactory code (not necessarily sorted in order of annoyance):  BrentOptimizer: a specific convergence checker must be used. LevenbergMarquardtOptimizer also has specific convergence checks. Trying to make convergence checking independent of the optimization algorithm creates problems (conceptual and practical):  See BrentOptimizer and LevenbergMarquardtOptimizer the algorithm passes points to the convergence checker but the actual meaning of the points can very well be different in the caller (optimization algorithm) and the callee (convergence checker). In PowellOptimizer the line search (BrentOptimizer) tolerances depend on the tolerances within the main algorithm. Since tolerances come with ConvergenceChecker and so can be changed at any time it is awkward to adapt the values within the line search optimizer without exposing its internals (BrentOptimizer field) to the enclosing class (PowellOptimizer).   Given the numerous changes some Javadoc comments might be out-of-sync although I did try to update them all. Class DirectSearchOptimizer (in package optimization.direct) inherits from class AbstractScalarOptimizer (in package optimization.general). Some interfaces are defined in package optimization but their base implementations (abstract class that contain the boiler-plate code) are in package optimization.general (e.g. DifferentiableMultivariateVectorialOptimizer and BaseAbstractVectorialOptimizer). No check is performed to ensure the the convergence checker has been set (see e.g. BrentOptimizer and PowellOptimizer); if it hasnt there will be a NPE. The alternative is to initialize a default checker that will never be used in case the user had intended to explicitly sets the checker. NonLinearConjugateGradientOptimizer: Ugly workaround for the checked ConvergenceException. Everywhere we trail the checked FunctionEvaluationException although it is never used. There remains some duplicate code (such as the multi-start loop in the various MultiStart... implementations). The ConvergenceChecker interface is very general (the converged method can take any number of ...PointValuePair). However there remains a semantic problem: One cannot be sure that the list of points means the same thing for the caller of converged and within the implementation of the ConvergenceChecker that was independently set. It is not clear whether it is wise to aggregate the counter of gradient evaluations to the function evaluation counter. In LevenbergMarquartdOptimizer for example it would be unfair to do so. Currently I had to remove all tests referring to gradient and Jacobian evaluations. In AbstractLeastSquaresOptimizer and LevenbergMarquardtOptimizer occurences of OptimizationException were replaced by the unchecked ConvergenceException but in some cases it might not be the most appropriate one. MultiStartUnivariateRealOptimizer: in the other classes (MultiStartMultivariate...) similar to this one the randomization is on the firts-guess value while in this class it is on the search interval. I think that here also we should randomly choose the start value (within the user-selected interval). The Javadoc utility raises warnings (see output of mvn site) which I couldnt figure out how to correct. Some previously existing classes and interfaces have become no more than a specialisation of new generics classes; it might be interesting to remove them in order to reduce the number of classes and thus limit the potential for confusion.", "A_clean_title": ["miscellan", "issu", "concern", "optim", "packagerevis", "packag", "revis", "990792", "contain", "chang", "trigger", "follow", "issu", "math", "394", "math", "397", "math", "404", "thi", "issu", "collect", "current", "still", "unsatisfactori", "code", "not", "necessarili", "sort", "order", "annoy", "brentoptim", "brent", "optim", "specif", "converg", "checker", "must", "use", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "also", "ha", "specif", "converg", "check", "tri", "make", "converg", "check", "independ", "optim", "algorithm", "creat", "problem", "conceptu", "practic", "see", "brentoptim", "brent", "optim", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "algorithm", "pass", "point", "converg", "checker", "but", "actual", "mean", "point", "veri", "well", "differ", "caller", "optim", "algorithm", "calle", "converg", "checker", "powelloptim", "powel", "optim", "line", "search", "brentoptim", "brent", "optim", "toler", "depend", "toler", "within", "main", "algorithm", "sinc", "toler", "come", "convergencecheck", "converg", "checker", "so", "chang", "at", "ani", "time", "it", "awkward", "adapt", "valu", "within", "line", "search", "optim", "without", "expos", "it", "intern", "brentoptim", "brent", "optim", "field", "enclos", "class", "powelloptim", "powel", "optim", "given", "numer", "chang", "some", "javadoc", "comment", "might", "out", "sync", "although", "did", "tri", "updat", "them", "all", "class", "directsearchoptim", "direct", "search", "optim", "packag", "optim", "direct", "inherit", "class", "abstractscalaroptim", "abstract", "scalar", "optim", "packag", "optim", "gener", "some", "interfac", "are", "defin", "packag", "optim", "but", "their", "base", "implement", "abstract", "class", "that", "contain", "boiler", "plate", "code", "are", "packag", "optim", "gener", "differentiablemultivariatevectorialoptim", "differenti", "multivari", "vectori", "optim", "baseabstractvectorialoptim", "base", "abstract", "vectori", "optim", "no", "check", "perform", "ensur", "converg", "checker", "ha", "been", "set", "see", "brentoptim", "brent", "optim", "powelloptim", "powel", "optim", "it", "hasnt", "there", "will", "npe", "altern", "initi", "default", "checker", "that", "will", "never", "use", "case", "user", "had", "intend", "explicitli", "set", "checker", "nonlinearconjugategradientoptim", "non", "linear", "conjug", "gradient", "optim", "ugli", "workaround", "check", "convergenceexcept", "converg", "except", "everywher", "we", "trail", "check", "functionevaluationexcept", "function", "evalu", "except", "although", "it", "never", "use", "there", "remain", "some", "duplic", "code", "such", "as", "multi", "start", "loop", "variou", "multistart", "multi", "start", "implement", "convergencecheck", "converg", "checker", "interfac", "veri", "gener", "converg", "method", "take", "ani", "number", "pointvaluepair", "point", "valu", "pair", "howev", "there", "remain", "semant", "problem", "one", "not", "sure", "that", "list", "point", "mean", "same", "thing", "caller", "converg", "within", "implement", "convergencecheck", "converg", "checker", "that", "wa", "independ", "set", "it", "not", "clear", "whether", "it", "wise", "aggreg", "counter", "gradient", "evalu", "function", "evalu", "counter", "levenbergmarquartdoptim", "levenberg", "marquartd", "optim", "exampl", "it", "would", "unfair", "so", "current", "had", "remov", "all", "test", "refer", "gradient", "jacobian", "evalu", "abstractleastsquaresoptim", "abstract", "least", "squar", "optim", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "occur", "optimizationexcept", "optim", "except", "were", "replac", "by", "uncheck", "convergenceexcept", "converg", "except", "but", "some", "case", "it", "might", "not", "most", "appropri", "one", "multistartunivariaterealoptim", "multi", "start", "univari", "real", "optim", "other", "class", "multistartmultivari", "multi", "start", "multivari", "similar", "thi", "one", "random", "firt", "guess", "valu", "while", "thi", "class", "it", "search", "interv", "think", "that", "here", "also", "we", "randomli", "choos", "start", "valu", "within", "user", "select", "interv", "javadoc", "util", "rais", "warn", "see", "output", "mvn", "site", "which", "couldnt", "figur", "out", "how", "correct", "some", "previous", "exist", "class", "interfac", "have", "becom", "no", "more", "than", "specialis", "new", "gener", "class", "it", "might", "interest", "remov", "them", "order", "reduc", "number", "class", "thu", "limit", "potenti", "confus"], "B_title": "(point 13) Selecting a random start value (instead of interval bounds).", "B_clean_title": ["point", "13", "select", "random", "start", "valu", "instead", "interv", "bound"]},
{"A_title": "Negative value with restrictNonNegativeProblem: commons-math-2.2 SimplexSolver. A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver.optimize(function constraints GoalType.MINIMIZE true); Function 1 * x + 1 * y + 0 Constraints: 1 * x + 0 * y = 1 Result: x = 1; y = -1; Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.", "A_clean_title": ["neg", "valu", "restrictnonnegativeproblem", "restrict", "non", "neg", "problem", "common", "math", "simplexsolv", "simplex", "solver", "variabl", "coeffici", "may", "assign", "neg", "valu", "nevertheless", "restricttononneg", "restrict", "nonneg", "flag", "call", "simplexsolv", "optim", "simplex", "solver", "function", "constraint", "goaltyp", "minim", "goal", "type", "true", "function", "constraint", "result", "probabl", "variabl", "coeffici", "are", "omit", "at", "some", "point", "comput", "becaus", "that", "restrict", "not", "affect", "their", "valu"], "B_title": "Fixed case of unconstrained variables that still occur in the objective function in simplex solver.", "B_clean_title": ["fix", "case", "unconstrain", "variabl", "that", "still", "occur", "object", "function", "simplex", "solver"]}]