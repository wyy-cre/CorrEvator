[{"A_title": "getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)the L_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries. The current implementation in ArrayRealVector has a typo:      public double getLInfNorm()          double max = 0;         for (double a : data)              max += Math.max(max Math.abs(a));                  return max;        the += should just be an =. There is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test not a test for correctness). Worse the implementation in OpenMapRealVector is not even positive semi-definite:          public double getLInfNorm()          double max = 0;         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             max += iter.value();                  return max;        I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():    public double getLInfNorm()      double norm = 0;     Iterator<Entry> it = sparseIterator();     Entry e;     while(it.hasNext() && (e = it.next()) != null)        norm = Math.max(norm Math.abs(e.getValue()));          return norm;      Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future.", "A_clean_title": ["getlinfnorm", "get", "inf", "norm", "use", "wrong", "formula", "both", "arrayrealvector", "array", "real", "vector", "openmaprealvector", "open", "map", "real", "vector", "differ", "way", "infin", "norm", "finit", "dimension", "vector", "just", "max", "absolut", "valu", "it", "entri", "current", "implement", "arrayrealvector", "array", "real", "vector", "ha", "typo", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "doubl", "data", "max", "math", "max", "max", "math", "ab", "return", "max", "just", "there", "sadli", "unit", "test", "assur", "us", "that", "thi", "correct", "behavior", "effect", "regress", "onli", "test", "not", "test", "correct", "wors", "implement", "openmaprealvector", "open", "map", "real", "vector", "not", "even", "posit", "semi", "definit", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "max", "iter", "valu", "return", "max", "would", "suggest", "that", "thi", "method", "move", "up", "abstractrealvector", "abstract", "real", "vector", "superclass", "implement", "sparseiter", "spars", "iter", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "norm", "iter", "entri", "it", "sparseiter", "spars", "iter", "entri", "while", "it", "hasnext", "ha", "next", "it", "next", "null", "norm", "math", "max", "norm", "math", "ab", "getvalu", "get", "valu", "return", "norm", "unit", "test", "neg", "valu", "vector", "would", "help", "check", "thi", "kind", "thing", "futur"], "B_title": "Fix ArrayRealVector . getLInfNorm ( ). Added get ( ) method to OpenMapRealVector. ", "B_clean_title": ["fix", "arrayrealvector", "array", "real", "vector", "getlinfnorm", "get", "inf", "norm", "ad", "get", "method", "openmaprealvector", "open", "map", "real", "vector"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix partial constructor to not use iChronology directly in the partial constructor. ", "B_clean_title": ["fix", "partial", "constructor", "not", "use", "ichronolog", "chronolog", "directli", "partial", "constructor"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Fix partial constructor to work with joda - time. ", "B_clean_title": ["fix", "partial", "constructor", "work", "joda", "time"]},
{"A_title": "LocaleUtils.toLocale() rejects strings with only language+variantLocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale(fr  POSIX).toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code. Commons Configuration handles this case in its PropertyConverter.toLocale() method. Id like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case.", "A_clean_title": ["localeutil", "tolocal", "local", "util", "local", "reject", "string", "onli", "language+variantlocaleutil", "tolocal", "language+vari", "local", "util", "local", "throw", "except", "string", "contain", "languag", "variant", "but", "no", "countri", "code", "exampl", "fr", "posix", "thi", "string", "produc", "jdk", "by", "instanci", "local", "empti", "string", "countri", "new", "local", "fr", "posix", "tostr", "string", "accord", "javadoc", "local", "class", "variant", "allow", "just", "languag", "code", "or", "just", "countri", "code", "common", "configur", "handl", "thi", "case", "it", "propertyconvert", "tolocal", "properti", "convert", "local", "method", "id", "like", "replac", "our", "implement", "by", "one", "provid", "by", "localeutil", "local", "util", "but", "our", "test", "fail", "due", "thi", "case"], "B_title": "Remove spaces. Missing _ sign in LocaleUtils. Added missing copy of LocaleUtils. ", "B_clean_title": ["remov", "space", "miss", "sign", "localeutil", "local", "util", "ad", "miss", "copi", "localeutil", "local", "util"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "AddValue ( Object ) to Frequency  throw exception if it is not a Comparable. ", "B_clean_title": ["addvalu", "add", "valu", "object", "frequenc", "throw", "except", "it", "not", "compar"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "Adding missing throw in Frequency . addValue ( ). ", "B_clean_title": ["ad", "miss", "throw", "frequenc", "addvalu", "add", "valu"]},
{"A_title": "Bugs in BrentOptimizerI apologize for having provided a buggy implementation of Brents optimization algorithm (class BrentOptimizer in package optimization.univariate). The unit tests didnt show that there was something wrong although (from the changes.xml file) I discovered that at the time Luc had noticed something weird in the implementations behaviour. Comparing with an implementation in Python I could figure out the fixes. Ill modify BrentOptimizer and add a test. I also propose to change the name of the unit test class from BrentMinimizerTest to BrentOptimizerTest.", "A_clean_title": ["bug", "brentoptimizeri", "brent", "optim", "apolog", "have", "provid", "buggi", "implement", "brent", "optim", "algorithm", "class", "brentoptim", "brent", "optim", "packag", "optim", "univari", "unit", "test", "didnt", "show", "that", "there", "wa", "someth", "wrong", "although", "chang", "xml", "file", "discov", "that", "at", "time", "luc", "had", "notic", "someth", "weird", "implement", "behaviour", "compar", "implement", "python", "could", "figur", "out", "fix", "ill", "modifi", "brentoptim", "brent", "optim", "add", "test", "also", "propos", "chang", "name", "unit", "test", "class", "brentminimizertest", "brent", "minim", "test", "brentoptimizertest", "brent", "optim", "test"], "B_title": "Another bug uncovered; all things being equal the code now behaves like the Puthon implementation. MATH-397: Modified BrentOptimizer following the changes in AbstractUnivariateRealOptimizer.", "B_clean_title": ["anoth", "bug", "uncov", "all", "thing", "be", "equal", "code", "now", "behav", "like", "puthon", "implement", "math", "397", "modifi", "brentoptim", "brent", "optim", "follow", "chang", "abstractunivariaterealoptim", "abstract", "univari", "real", "optim"]},
{"A_title": "StringUtils equals() relies on undefined behaviorSince the java.lang.CharSequence class was first introduced in 1.4 the JavaDoc block has contained the following note:  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore in general undefined. Each object may be implemented by a different class and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. When the signature of the StringUtils equals() method was changed from equals(String String) to equals(CharSequence CharSequence) in R920543 the implementation still relied on calling CharSequence#equals(Object) even though in general the result is undefined. One example where equals(Object) returns false even though as CharSequences two objects represent equal sequences is when one object is an instance of javax.lang.model.element.Name and the other object is a String.", "A_clean_title": ["stringutil", "string", "util", "equal", "reli", "undefin", "behaviorsinc", "behavior", "sinc", "java", "lang", "charsequ", "char", "sequenc", "class", "wa", "first", "introduc", "javadoc", "java", "doc", "block", "ha", "contain", "follow", "note", "thi", "interfac", "not", "refin", "gener", "contract", "equal", "hashcod", "hash", "code", "method", "result", "compar", "two", "object", "that", "implement", "charsequ", "char", "sequenc", "therefor", "gener", "undefin", "each", "object", "may", "implement", "by", "differ", "class", "there", "no", "guarante", "that", "each", "class", "will", "capabl", "test", "it", "instanc", "equal", "those", "other", "when", "signatur", "stringutil", "string", "util", "equal", "method", "wa", "chang", "equal", "string", "string", "equal", "charsequ", "char", "sequenc", "charsequ", "char", "sequenc", "r920543", "implement", "still", "reli", "call", "charsequ", "char", "sequenc", "equal", "object", "even", "though", "gener", "result", "undefin", "one", "exampl", "where", "equal", "object", "return", "fals", "even", "though", "as", "charsequ", "char", "sequenc", "two", "object", "repres", "equal", "sequenc", "when", "one", "object", "instanc", "javax", "lang", "model", "element", "name", "other", "object", "string"], "B_title": "StringUtils equals() relies on undefined behavior; thanks to Daniel Trebbien", "B_clean_title": ["stringutil", "string", "util", "equal", "reli", "undefin", "behavior", "thank", "daniel", "trebbien"]},
{"A_title": "Simplex Solver arrives at incorrect solutionI have reduced the problem reported to me down to a minimal test case which I will attach.", "A_clean_title": ["simplex", "solver", "arriv", "at", "incorrect", "solutioni", "solut", "have", "reduc", "problem", "report", "me", "down", "minim", "test", "case", "which", "will", "attach"], "B_title": "Fixed a problem when setting some variables (several variables were set instead of only one) JIRA: MATH-272", "B_clean_title": ["fix", "problem", "when", "set", "some", "variabl", "sever", "variabl", "were", "set", "instead", "onli", "one", "jira", "math", "272"]},
{"A_title": "Incorrect date parsed when week and month used togetherIt should print 2011-01-03 but it is printing 2010-01-04.", "A_clean_title": ["incorrect", "date", "pars", "when", "week", "month", "use", "togetherit", "togeth", "it", "print", "2011", "01", "03", "but", "it", "print", "2010", "01", "04"], "B_title": "Conversion from parsed values to a date-time handles weird sets of fields better 3161586 This change is mostly for combinations like weekyear-month-week The new code doesnt handle all combinations perfectly but its better than it was", "B_clean_title": ["convers", "pars", "valu", "date", "time", "handl", "weird", "set", "field", "better", "3161586", "thi", "chang", "mostli", "combin", "like", "weekyear", "month", "week", "new", "code", "doesnt", "handl", "all", "combin", "perfectli", "but", "it", "better", "than", "it", "wa"]},
{"A_title": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing e and E is passed inNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is 1eE.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "argument", "contain", "pass", "innumberutil", "number", "util", "createnumb", "creat", "number", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead", "numberformatexcept", "number", "format", "except", "when", "string", "contain", "both", "possibl", "expon", "indic", "pass", "one", "exampl", "such", "string", "1ee", "1e"], "B_title": "Making it so that NumberUtils.createNumber throws a NumberFormatException instead of a StringIndexOutOfBoundsException when Strings such as 1eE are passed in. Thanks to Ingo Heinrichs report and patch in LANG-638", "B_clean_title": ["make", "it", "so", "that", "numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "instead", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "string", "such", "as", "1ee", "1e", "are", "pass", "thank", "ingo", "heinrich", "report", "patch", "lang", "638"]},
{"A_title": "LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to itLevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.", "A_clean_title": ["levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "ignor", "vectorialconvergencecheck", "vectori", "converg", "checker", "paramet", "pass", "itlevenbergmarquardtoptim", "it", "levenberg", "marquardt", "optim", "ignor", "vectorialconvergencecheck", "vectori", "converg", "checker", "paramet", "pass", "it", "thi", "make", "it", "hard", "specifi", "custom", "stop", "criteria", "optim"], "B_title": "Fixed Levenberg-Marquardt optimizer that did not use the vectorial convergence checker. Now this optimizer can use either the general vectorial convergence checker or its own specialized convergence settings. Minor changes had to be introduced in the test data they have been validated JIRA: MATH-362", "B_clean_title": ["fix", "levenberg", "marquardt", "optim", "that", "did", "not", "use", "vectori", "converg", "checker", "now", "thi", "optim", "use", "either", "gener", "vectori", "converg", "checker", "or", "it", "own", "special", "converg", "set", "minor", "chang", "had", "introduc", "test", "data", "they", "have", "been", "valid", "jira", "math", "362"]},
{"A_title": "getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)the L_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries. The current implementation in ArrayRealVector has a typo:      public double getLInfNorm()          double max = 0;         for (double a : data)              max += Math.max(max Math.abs(a));                  return max;        the += should just be an =. There is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test not a test for correctness). Worse the implementation in OpenMapRealVector is not even positive semi-definite:          public double getLInfNorm()          double max = 0;         Iterator iter = entries.iterator();         while (iter.hasNext())              iter.advance();             max += iter.value();                  return max;        I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():    public double getLInfNorm()      double norm = 0;     Iterator<Entry> it = sparseIterator();     Entry e;     while(it.hasNext() && (e = it.next()) != null)        norm = Math.max(norm Math.abs(e.getValue()));          return norm;      Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future.", "A_clean_title": ["getlinfnorm", "get", "inf", "norm", "use", "wrong", "formula", "both", "arrayrealvector", "array", "real", "vector", "openmaprealvector", "open", "map", "real", "vector", "differ", "way", "infin", "norm", "finit", "dimension", "vector", "just", "max", "absolut", "valu", "it", "entri", "current", "implement", "arrayrealvector", "array", "real", "vector", "ha", "typo", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "doubl", "data", "max", "math", "max", "max", "math", "ab", "return", "max", "just", "there", "sadli", "unit", "test", "assur", "us", "that", "thi", "correct", "behavior", "effect", "regress", "onli", "test", "not", "test", "correct", "wors", "implement", "openmaprealvector", "open", "map", "real", "vector", "not", "even", "posit", "semi", "definit", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "max", "iter", "iter", "entri", "iter", "while", "iter", "hasnext", "ha", "next", "iter", "advanc", "max", "iter", "valu", "return", "max", "would", "suggest", "that", "thi", "method", "move", "up", "abstractrealvector", "abstract", "real", "vector", "superclass", "implement", "sparseiter", "spars", "iter", "public", "doubl", "getlinfnorm", "get", "inf", "norm", "doubl", "norm", "iter", "entri", "it", "sparseiter", "spars", "iter", "entri", "while", "it", "hasnext", "ha", "next", "it", "next", "null", "norm", "math", "max", "norm", "math", "ab", "getvalu", "get", "valu", "return", "norm", "unit", "test", "neg", "valu", "vector", "would", "help", "check", "thi", "kind", "thing", "futur"], "B_title": "fixed a wrong implementation of the Linf vector norm JIRA: MATH-326", "B_clean_title": ["fix", "wrong", "implement", "linf", "vector", "norm", "jira", "math", "326"]},
{"A_title": "PearsonsCorrelation.getCorrelationPValues() precision limited by machine epsilonSimilar to the issue described in MATH-201 using PearsonsCorrelation.getCorrelationPValues() with many treatments results in p-values that are continuous down to 2.2e-16 but that drop to 0 after that. In MATH-201 the problem was described as such: > So in essence the p-value returned by TTestImpl.tTest() is: >  > 1.0 - (cumulativeProbability(t) - cumulativeProbabily(-t)) >  > For large-ish t-statistics cumulativeProbabilty(-t) can get quite small and cumulativeProbabilty(t) can get very close to 1.0. When  > cumulativeProbability(-t) is less than the machine epsilon we get p-values equal to zero because: >  > 1.0 - 1.0 + 0.0 = 0.0 The solution in MATH-201 was to modify the p-value calculation to this: > p = 2.0 * cumulativeProbability(-t) Here the problem is similar.  From PearsonsCorrelation.getCorrelationPValues():   p = 2 * (1 - tDistribution.cumulativeProbability(t)); Directly calculating the p-value using identical code as PearsonsCorrelation.getCorrelationPValues() but with the following change seems to solve the problem:   p = 2 * (tDistribution.cumulativeProbability(-t));", "A_clean_title": ["pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "precis", "limit", "by", "machin", "epsilonsimilar", "epsilon", "similar", "issu", "describ", "math", "201", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "mani", "treatment", "result", "valu", "that", "are", "continu", "down", "16", "2e", "but", "that", "drop", "after", "that", "math", "201", "problem", "wa", "describ", "as", "such", "so", "essenc", "valu", "return", "by", "ttestimpl", "ttest", "test", "impl", "test", "cumulativeprob", "cumul", "probabl", "cumulativeprobabili", "cumul", "probabili", "larg", "ish", "statist", "cumulativeprobabilti", "cumul", "probabilti", "get", "quit", "small", "cumulativeprobabilti", "cumul", "probabilti", "get", "veri", "close", "when", "cumulativeprob", "cumul", "probabl", "less", "than", "machin", "epsilon", "we", "get", "valu", "equal", "zero", "becaus", "solut", "math", "201", "wa", "modifi", "valu", "calcul", "thi", "cumulativeprob", "cumul", "probabl", "here", "problem", "similar", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "tdistribut", "cumulativeprob", "distribut", "cumul", "probabl", "directli", "calcul", "valu", "ident", "code", "as", "pearsonscorrel", "getcorrelationpvalu", "pearson", "correl", "get", "correl", "valu", "but", "follow", "chang", "seem", "solv", "problem", "tdistribut", "cumulativeprob", "distribut", "cumul", "probabl"], "B_title": "Fixed loss of significance error in PersonsCorrelation p-value computation causing p-values smaller than the machine epsilon (~1E-16) to be reported as 0. JIRA: MATH-371 Reported and patched by Kevin Childs", "B_clean_title": ["fix", "loss", "signific", "error", "personscorrel", "person", "correl", "valu", "comput", "caus", "valu", "smaller", "than", "machin", "epsilon", "~1e", "16", "report", "as", "jira", "math", "371", "report", "patch", "by", "kevin", "child"]},
{"A_title": "DerivativeStructure.atan2(yx) does not handle special cases properlyThe four special cases +/-0 for both x and y should give the same values as Math.atan2 and FastMath.atan2. However they give NaN for the value in all cases.", "A_clean_title": ["derivativestructur", "atan2", "deriv", "structur", "yx", "not", "handl", "special", "case", "properlyth", "properli", "four", "special", "case", "both", "give", "same", "valu", "as", "math", "atan2", "fastmath", "atan2", "fast", "math", "howev", "they", "give", "nan", "na", "valu", "all", "case"], "B_title": "Fixed DerivativeStructure.atan2 for special cases when both arguments are +/-0.", "B_clean_title": ["fix", "derivativestructur", "atan2", "deriv", "structur", "special", "case", "when", "both", "argument", "are"]},
{"A_title": "BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundaryIn some cases the aging feature in BracketingNthOrderBrentSolver fails. It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However the chosen target is too close too zero and the inverse polynomial approximation is always on the same side thus always updates the same bracket. In the real used case for a large program I had a bracket point xA = 12500.0 yA = 3.7e-16 agingA = 0 which is the (really good) estimate of the zero on one side of the root and xB = 12500.03 yB = -7.0e-5 agingB = 97. This shows that the bracketing interval is completely unbalanced and we never succeed to rebalance it as we always updates (xA yA) and never updates (xB yB).", "A_clean_title": ["bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "exce", "maxiterationcount", "max", "iter", "count", "while", "updat", "alway", "same", "boundaryin", "boundari", "some", "case", "age", "featur", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver", "fail", "it", "attempt", "balanc", "bracket", "point", "by", "target", "non", "zero", "valu", "instead", "real", "root", "howev", "chosen", "target", "too", "close", "too", "zero", "invers", "polynomi", "approxim", "alway", "same", "side", "thu", "alway", "updat", "same", "bracket", "real", "use", "case", "larg", "program", "had", "bracket", "point", "xa", "12500", "ya", "16", "7e", "aginga", "age", "which", "realli", "good", "estim", "zero", "one", "side", "root", "xb", "12500", "03", "yb", "0e", "agingb", "age", "97", "thi", "show", "that", "bracket", "interv", "complet", "unbalanc", "we", "never", "succeed", "rebal", "it", "as", "we", "alway", "updat", "xa", "ya", "never", "updat", "xb", "yb"], "B_title": "Fixed bracketing interval balancing in BracketingNthOrderBrentSolver.", "B_clean_title": ["fix", "bracket", "interv", "balanc", "bracketingnthorderbrentsolv", "bracket", "nth", "order", "brent", "solver"]},
{"A_title": "Constructing invalid PartialsPartials can be constructed by invoking a constructor Partial(DateTimeFieldType int) or by merging together a set of partials using with each constructed by calling Partial(DateTimeFieldType int). However the above doesnt work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  Theres also a related issue (probably stems from the fact that the Partial is invalid):", "A_clean_title": ["construct", "invalid", "partialsparti", "partial", "partial", "construct", "by", "invok", "constructor", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "or", "by", "merg", "togeth", "set", "partial", "each", "construct", "by", "call", "partial", "datetimefieldtyp", "date", "time", "field", "type", "int", "howev", "abov", "doesnt", "work", "all", "case", "suppos", "partial", "not", "allow", "construct", "either", "case", "that", "right", "there", "also", "relat", "issu", "probabl", "stem", "fact", "that", "partial", "invalid"], "B_title": "Prevent creation of invalid partials via Partial.with(DateTimeFieldTypeint)", "B_clean_title": ["prevent", "creation", "invalid", "partial", "via", "partial", "datetimefieldtypeint", "date", "time", "field", "typeint"]},
{"A_title": "FastDateParser does not handle unterminated quotes correctlyFDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: dd Date: d3 This should fail to parse the format and date but it actually works. The format is parsed as: Pattern: d(p IsNd ++)", "A_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "untermin", "quot", "correctlyfdp", "correctli", "fdp", "not", "handl", "untermin", "quot", "same", "way", "as", "simpledateformat", "simpl", "date", "format", "exampl", "format", "dd", "date", "d3", "thi", "fail", "pars", "format", "date", "but", "it", "actual", "work", "format", "pars", "as", "pattern", "isnd", "nd"], "B_title": "FastDateParser does not handle unterminated quotes correctly", "B_clean_title": ["fastdatepars", "fast", "date", "parser", "not", "handl", "untermin", "quot", "correctli"]},
{"A_title": "LocaleUtils.toLocale() rejects strings with only language+variantLocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale(fr  POSIX).toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code. Commons Configuration handles this case in its PropertyConverter.toLocale() method. Id like to replace our implementation by the one provided by LocaleUtils but our tests fail due to this case.", "A_clean_title": ["localeutil", "tolocal", "local", "util", "local", "reject", "string", "onli", "language+variantlocaleutil", "tolocal", "language+vari", "local", "util", "local", "throw", "except", "string", "contain", "languag", "variant", "but", "no", "countri", "code", "exampl", "fr", "posix", "thi", "string", "produc", "jdk", "by", "instanci", "local", "empti", "string", "countri", "new", "local", "fr", "posix", "tostr", "string", "accord", "javadoc", "local", "class", "variant", "allow", "just", "languag", "code", "or", "just", "countri", "code", "common", "configur", "handl", "thi", "case", "it", "propertyconvert", "tolocal", "properti", "convert", "local", "method", "id", "like", "replac", "our", "implement", "by", "one", "provid", "by", "localeutil", "local", "util", "but", "our", "test", "fail", "due", "thi", "case"], "B_title": "Applying unit test/fix for LANG-328", "B_clean_title": ["appli", "unit", "test", "fix", "lang", "328"]},
{"A_title": "Vector3D.crossProduct is sensitive to numerical cancellationCross product implementation uses the naive formulas (y1 z2 - y2 z1 ...). These formulas fail when vectors are almost colinear like in the following example:  Vector3D v1 = new Vector3D(9070467121.0 4535233560.0 1); Vector3D v2 = new Vector3D(9070467123.0 4535233561.0 1); System.out.println(Vector3D.crossProduct(v1 v2));   The previous code displays   -1 2 0   instead of the correct answer   -1 2 1", "A_clean_title": ["vector3d", "crossproduct", "cross", "product", "sensit", "numer", "cancellationcross", "cancel", "cross", "product", "implement", "use", "naiv", "formula", "y1", "z2", "y2", "z1", "these", "formula", "fail", "when", "vector", "are", "almost", "colinear", "like", "follow", "exampl", "vector3d", "v1", "new", "vector3d", "9070467121", "4535233560", "vector3d", "v2", "new", "vector3d", "9070467123", "4535233561", "system", "out", "println", "vector3d", "crossproduct", "cross", "product", "v1", "v2", "previou", "code", "display", "instead", "correct", "answer"], "B_title": "Reduced cancellation errors in Vector3D.crossProduct", "B_clean_title": ["reduc", "cancel", "error", "vector3d", "crossproduct", "cross", "product"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "- throw IllegalArgument rather than ClassCast to better retain original behaviour", "B_clean_title": ["throw", "illegalargu", "illeg", "argument", "rather", "than", "classcast", "class", "cast", "better", "retain", "origin", "behaviour"]},
{"A_title": "Bug on withLaterOffsetAtOverlap methodOn the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).", "A_clean_title": ["bug", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "methodon", "method", "last", "two", "bracket", "we", "see", "that", "withlateroffsetatoverlap", "later", "offset", "at", "overlap", "not", "undo", "withearlieroffsetatoverlap", "earlier", "offset", "at", "overlap", "as", "it", "not", "even", "work", "at", "all"], "B_title": "Fix time zone later/earlier offset methods in Western hemisphere 3476684", "B_clean_title": ["fix", "time", "zone", "later", "earlier", "offset", "method", "western", "hemispher", "3476684"]}]