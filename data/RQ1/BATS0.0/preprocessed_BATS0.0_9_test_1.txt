[{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "Allow null to be stored in Java ArrayUtils. Allow null to be added to the array .. ", "B_clean_title": ["allow", "null", "store", "java", "arrayutil", "array", "util", "allow", "null", "ad", "array"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "allow L with a decimal point. ", "B_clean_title": ["allow", "decim", "point"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow trailing commas in NumberUtils. ", "B_clean_title": ["allow", "trail", "comma", "numberutil", "number", "util"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow L with an exponent or decimal point. remove wrong java char. ", "B_clean_title": ["allow", "expon", "or", "decim", "point", "remov", "wrong", "java", "char"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             ", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Allow L with an exponent or decimal point. ", "B_clean_title": ["allow", "expon", "or", "decim", "point"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "KMeansPlusPlusClusterer copy constructor. ", "B_clean_title": ["kmeanspluspluscluster", "mean", "plu", "plu", "cluster", "copi", "constructor"]},
{"A_title": "FastDateFormat.format() outputs incorrect week of year because locale isnt respectedFastDateFormat apparently doesnt respect the locale it was sent on creation when outputting week in year (e.g. ww) in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo      public static void main(String args)          Locale.setDefault(new Locale(en US));         Locale locale = new Locale(sv SE);          Calendar cal = Calendar.getInstance(); // setting locale here doesnt change outcome         cal.set(2010 0 1 12 0 0);         Date d = cal.getTime();         System.out.println(Target date:  + d);          FastDateFormat fdf = FastDateFormat.getInstance(EEEE week ww locale);         SimpleDateFormat sdf = new SimpleDateFormat(EEEE week ww locale);         System.out.println(FastDateFormat:    + fdf.format(d)); // will output FastDateFormat:   fredag week 01         System.out.println(SimpleDateFormat:  + sdf.format(d)); // will output SimpleDateFormat: fredag week 53         If sv/SE is passed to Locale.setDefault() instead of en/US both FastDateFormat and SimpleDateFormat output the correct week number.", "A_clean_title": ["fastdateformat", "format", "fast", "date", "format", "output", "incorrect", "week", "year", "becaus", "local", "isnt", "respectedfastdateformat", "respect", "fast", "date", "format", "appar", "doesnt", "respect", "local", "it", "wa", "sent", "creation", "when", "output", "week", "year", "ww", "format", "it", "seem", "use", "set", "system", "local", "firstdayofweek", "first", "day", "week", "minimaldaysinfirstweek", "minim", "day", "first", "week", "which", "depend", "year", "may", "result", "incorrect", "week", "number", "be", "output", "here", "simpl", "test", "program", "demonstr", "problem", "by", "compar", "simpledateformat", "simpl", "date", "format", "which", "get", "week", "number", "right", "import", "java", "util", "calendar", "import", "java", "util", "date", "import", "java", "util", "local", "import", "java", "text", "simpledateformat", "simpl", "date", "format", "import", "org", "apach", "common", "lang", "time", "fastdateformat", "fast", "date", "format", "public", "class", "fastdateformatweekbugdemo", "fast", "date", "format", "week", "bug", "demo", "public", "static", "void", "main", "string", "arg", "local", "setdefault", "set", "default", "new", "local", "en", "us", "local", "local", "new", "local", "sv", "se", "calendar", "cal", "calendar", "getinst", "get", "instanc", "set", "local", "here", "doesnt", "chang", "outcom", "cal", "set", "2010", "12", "date", "cal", "gettim", "get", "time", "system", "out", "println", "target", "date", "fastdateformat", "fast", "date", "format", "fdf", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "eeee", "week", "ww", "local", "simpledateformat", "simpl", "date", "format", "sdf", "new", "simpledateformat", "simpl", "date", "format", "eeee", "week", "ww", "local", "system", "out", "println", "fastdateformat", "fast", "date", "format", "fdf", "format", "will", "output", "fastdateformat", "fast", "date", "format", "fredag", "week", "01", "system", "out", "println", "simpledateformat", "simpl", "date", "format", "sdf", "format", "will", "output", "simpledateformat", "simpl", "date", "format", "fredag", "week", "53", "sv", "se", "pass", "local", "setdefault", "set", "default", "instead", "en", "us", "both", "fastdateformat", "fast", "date", "format", "simpledateformat", "simpl", "date", "format", "output", "correct", "week", "number"], "B_title": "Missing locale argument. ", "B_clean_title": ["miss", "local", "argument"]},
{"A_title": "FastDateFormat.format() outputs incorrect week of year because locale isnt respectedFastDateFormat apparently doesnt respect the locale it was sent on creation when outputting week in year (e.g. ww) in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo      public static void main(String args)          Locale.setDefault(new Locale(en US));         Locale locale = new Locale(sv SE);          Calendar cal = Calendar.getInstance(); // setting locale here doesnt change outcome         cal.set(2010 0 1 12 0 0);         Date d = cal.getTime();         System.out.println(Target date:  + d);          FastDateFormat fdf = FastDateFormat.getInstance(EEEE week ww locale);         SimpleDateFormat sdf = new SimpleDateFormat(EEEE week ww locale);         System.out.println(FastDateFormat:    + fdf.format(d)); // will output FastDateFormat:   fredag week 01         System.out.println(SimpleDateFormat:  + sdf.format(d)); // will output SimpleDateFormat: fredag week 53         If sv/SE is passed to Locale.setDefault() instead of en/US both FastDateFormat and SimpleDateFormat output the correct week number.", "A_clean_title": ["fastdateformat", "format", "fast", "date", "format", "output", "incorrect", "week", "year", "becaus", "local", "isnt", "respectedfastdateformat", "respect", "fast", "date", "format", "appar", "doesnt", "respect", "local", "it", "wa", "sent", "creation", "when", "output", "week", "year", "ww", "format", "it", "seem", "use", "set", "system", "local", "firstdayofweek", "first", "day", "week", "minimaldaysinfirstweek", "minim", "day", "first", "week", "which", "depend", "year", "may", "result", "incorrect", "week", "number", "be", "output", "here", "simpl", "test", "program", "demonstr", "problem", "by", "compar", "simpledateformat", "simpl", "date", "format", "which", "get", "week", "number", "right", "import", "java", "util", "calendar", "import", "java", "util", "date", "import", "java", "util", "local", "import", "java", "text", "simpledateformat", "simpl", "date", "format", "import", "org", "apach", "common", "lang", "time", "fastdateformat", "fast", "date", "format", "public", "class", "fastdateformatweekbugdemo", "fast", "date", "format", "week", "bug", "demo", "public", "static", "void", "main", "string", "arg", "local", "setdefault", "set", "default", "new", "local", "en", "us", "local", "local", "new", "local", "sv", "se", "calendar", "cal", "calendar", "getinst", "get", "instanc", "set", "local", "here", "doesnt", "chang", "outcom", "cal", "set", "2010", "12", "date", "cal", "gettim", "get", "time", "system", "out", "println", "target", "date", "fastdateformat", "fast", "date", "format", "fdf", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "eeee", "week", "ww", "local", "simpledateformat", "simpl", "date", "format", "sdf", "new", "simpledateformat", "simpl", "date", "format", "eeee", "week", "ww", "local", "system", "out", "println", "fastdateformat", "fast", "date", "format", "fdf", "format", "will", "output", "fastdateformat", "fast", "date", "format", "fredag", "week", "01", "system", "out", "println", "simpledateformat", "simpl", "date", "format", "sdf", "format", "will", "output", "simpledateformat", "simpl", "date", "format", "fredag", "week", "53", "sv", "se", "pass", "local", "setdefault", "set", "default", "instead", "en", "us", "both", "fastdateformat", "fast", "date", "format", "simpledateformat", "simpl", "date", "format", "output", "correct", "week", "number"], "B_title": "Missing locale string for format ( Date ). ", "B_clean_title": ["miss", "local", "string", "format", "date"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Added missing if (. Added missing if (. ", "B_clean_title": ["ad", "miss", "ad", "miss"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added fix. added fix. ", "B_clean_title": ["ad", "fix", "ad", "fix"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Add null check in SubLine. Add null check in SubLine  closes # 77. ", "B_clean_title": ["add", "null", "check", "sublin", "sub", "line", "add", "null", "check", "sublin", "sub", "line", "close", "77"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added null check in subLine copy. ", "B_clean_title": ["ad", "null", "check", "sublin", "sub", "line", "copi"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Add null check in patch2. ", "B_clean_title": ["add", "null", "check", "patch2"]},
{"A_title": "Bug propgated from v1.0.5 on to presentThe method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset (possibly zero).  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "A_clean_title": ["bug", "propgat", "v1", "presentth", "present", "method", "getrowcount", "get", "row", "count", "class", "org", "jfree", "data", "categori", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "say", "that", "it", "return", "number", "seri", "dataset", "possibl", "zero", "implement", "v1", "no", "longer", "check", "null", "condit", "which", "would", "then", "return", "zero", "serieskey", "seri", "key", "as", "it", "did", "v1", "previou", "thi", "now", "throw", "null", "pointer", "serieskey", "seri", "key", "never", "got", "initi", "getrowcount", "get", "row", "count", "method", "call"], "B_title": "Fix bug in chart 16. ", "B_clean_title": ["fix", "bug", "chart", "16"]},
{"A_title": "Bug propgated from v1.0.5 on to presentThe method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset (possibly zero).  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "A_clean_title": ["bug", "propgat", "v1", "presentth", "present", "method", "getrowcount", "get", "row", "count", "class", "org", "jfree", "data", "categori", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "say", "that", "it", "return", "number", "seri", "dataset", "possibl", "zero", "implement", "v1", "no", "longer", "check", "null", "condit", "which", "would", "then", "return", "zero", "serieskey", "seri", "key", "as", "it", "did", "v1", "previou", "thi", "now", "throw", "null", "pointer", "serieskey", "seri", "key", "never", "got", "initi", "getrowcount", "get", "row", "count", "method", "call"], "B_title": "Fix bug in chart - 16. ", "B_clean_title": ["fix", "bug", "chart", "16"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here"], "B_title": "Add fix from MATH - 657. Fix typo in MATH - 657. ", "B_clean_title": ["add", "fix", "math", "657", "fix", "typo", "math", "657"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability assertion .. ", "B_clean_title": ["fix", "nullabl", "assert"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fixed nullability assertion that was accidentally made too strong. ", "B_clean_title": ["fix", "nullabl", "assert", "that", "wa", "accident", "made", "too", "strong"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability note in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "nullabl", "note", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix null pointer check in AbstractCategoryItemRenderer. ", "B_clean_title": ["fix", "null", "pointer", "check", "abstractcategoryitemrender", "abstract", "categori", "item", "render"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "Fix nullability assertion .. ", "B_clean_title": ["fix", "nullabl", "assert"]},
{"A_title": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsExceptions. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.deleteAll(n%BLAH%);         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder(n%BLAH%nDo more stuffneven more stuffn%BLAH%n);         sb.replaceAll(n%BLAH% );         assertEquals(nDo more stuffneven more stuffn sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException at java.lang.System.arraycopy(Native Method) at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult 1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "A_clean_title": ["strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "throw", "arrayindexoutofboundsexcept", "strbuilder", "replaceal", "array", "index", "out", "bound", "except", "str", "builder", "replac", "all", "strbuilder", "deleteal", "str", "builder", "delet", "all", "thrown", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "here", "are", "coupl", "addit", "strbuildertest", "str", "builder", "test", "class", "that", "demonstr", "thi", "problem", "strbuilder", "deleteal", "str", "builder", "delet", "all", "ad", "testdeleteal", "string", "test", "delet", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "deleteal", "delet", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "follow", "error", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteimpl", "str", "builder", "delet", "impl", "strbuilder", "java:1114", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "deleteal", "str", "builder", "delet", "all", "strbuilder", "java:1188", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testdeleteal", "string", "test", "delet", "all", "strbuildertest", "java:606", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner", "strbuilder", "replaceal", "str", "builder", "replac", "all", "ad", "testreplaceal", "string", "string", "test", "replac", "all", "sb", "new", "strbuilder", "str", "builder", "blah", "ndo", "more", "stuffneven", "more", "stuffn", "blah", "sb", "replaceal", "replac", "all", "blah", "assertequ", "assert", "equal", "ndo", "more", "stuffneven", "more", "stuffn", "sb", "tostr", "string", "thi", "caus", "except", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "at", "java", "lang", "system", "arraycopi", "nativ", "method", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceimpl", "str", "builder", "replac", "impl", "strbuilder", "java:1256", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuilder", "replaceal", "str", "builder", "replac", "all", "strbuilder", "java:1339", "str", "builder", "at", "org", "apach", "common", "lang", "text", "strbuildertest", "str", "builder", "test", "testreplaceal", "string", "string", "test", "replac", "all", "strbuildertest", "java:763", "str", "builder", "test", "at", "sun", "reflect", "nativemethodaccessorimpl", "invoke0", "nativ", "method", "accessor", "impl", "nativ", "method", "at", "sun", "reflect", "nativemethodaccessorimpl", "invok", "nativ", "method", "accessor", "impl", "nativemethodaccessorimpl", "java:39", "nativ", "method", "accessor", "impl", "at", "sun", "reflect", "delegatingmethodaccessorimpl", "invok", "deleg", "method", "accessor", "impl", "delegatingmethodaccessorimpl", "java:25", "deleg", "method", "accessor", "impl", "at", "java", "lang", "reflect", "method", "invok", "method", "java:585", "at", "junit", "framework", "testcas", "runtest", "test", "case", "run", "test", "testcas", "java:154", "test", "case", "at", "junit", "framework", "testcas", "runbar", "test", "case", "run", "bare", "testcas", "java:127", "test", "case", "at", "junit", "framework", "testresult", "test", "result", "protect", "testresult", "java:106", "test", "result", "at", "junit", "framework", "testresult", "runprotect", "test", "result", "run", "protect", "testresult", "java:124", "test", "result", "at", "junit", "framework", "testresult", "run", "test", "result", "testresult", "java:109", "test", "result", "at", "junit", "framework", "testcas", "run", "test", "case", "testcas", "java:118", "test", "case", "at", "junit", "framework", "testsuit", "runtest", "test", "suit", "run", "test", "testsuit", "java:208", "test", "suit", "at", "junit", "framework", "testsuit", "run", "test", "suit", "testsuit", "java:203", "test", "suit", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "junit3", "junit3testrefer", "run", "unit3test", "refer", "junit3testrefer", "java:128", "unit3test", "refer", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "testexecut", "run", "test", "execut", "testexecut", "java:38", "test", "execut", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:460", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "runtest", "remot", "test", "runner", "run", "test", "remotetestrunn", "java:673", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "run", "remot", "test", "runner", "remotetestrunn", "java:386", "remot", "test", "runner", "at", "org", "eclips", "jdt", "intern", "junit", "runner", "remotetestrunn", "main", "remot", "test", "runner", "remotetestrunn", "java:196", "remot", "test", "runner"], "B_title": "Fixing #LANG-294. The indexOf method did not take into account the size variable that limited the amount of the buffer that should be looked at.", "B_clean_title": ["fix", "lang", "294", "indexof", "index", "method", "did", "not", "take", "into", "account", "size", "variabl", "that", "limit", "amount", "buffer", "that", "look", "at"]},
{"A_title": "Line.revert() is impreciseLine.revert() only maintains ~10 digits for the direction. This becomes an issue when the lines position is evaluated far from the origin. A simple fix would be to use Vector3D.negate() for the direction. Also is there a reason why Line is not immutable? It is just comprised of two vectors.", "A_clean_title": ["line", "revert", "impreciselin", "revert", "imprecis", "line", "onli", "maintain", "~10", "digit", "direct", "thi", "becom", "issu", "when", "line", "posit", "evalu", "far", "origin", "simpl", "fix", "would", "use", "vector3d", "negat", "direct", "also", "there", "reason", "whi", "line", "not", "immut", "it", "just", "compris", "two", "vector"], "B_title": "Fixed accuracy of 3D Line.revert().", "B_clean_title": ["fix", "accuraci", "3d", "line", "revert"]},
{"A_title": "Brent solver returns the wrong value if either bracket endpoint is rootThe solve(final UnivariateRealFunction f final double min final double max final double initial) function returns yMin or yMax if min or max are deemed to be roots respectively instead of min or max.", "A_clean_title": ["brent", "solver", "return", "wrong", "valu", "either", "bracket", "endpoint", "rootth", "root", "solv", "final", "univariaterealfunct", "univari", "real", "function", "final", "doubl", "min", "final", "doubl", "max", "final", "doubl", "initi", "function", "return", "ymin", "min", "or", "ymax", "max", "min", "or", "max", "are", "deem", "root", "respect", "instead", "min", "or", "max"], "B_title": "Fixed wrong return values when enpoints are roots in Brent solver with a user provided initial guess JIRA: MATH-344", "B_clean_title": ["fix", "wrong", "return", "valu", "when", "enpoint", "are", "root", "brent", "solver", "user", "provid", "initi", "guess", "jira", "math", "344"]},
{"A_title": "ArrayUtils.add(T array T element) can create unexpected ClassCastExceptionArrayUtils.add(T array T element) can create an unexpected ClassCastException. For example the following code compiles without a warning:  String sa = ArrayUtils.add(stringArray aString);   and works fine provided at least one of the parameters is non-null. However if both parameters are null the add() method returns an Object array hence the Exception. If both parameters are null its not possible to determine the correct array type to return so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "A_clean_title": ["arrayutil", "add", "array", "util", "array", "element", "creat", "unexpect", "classcastexceptionarrayutil", "add", "class", "cast", "except", "array", "util", "array", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except", "exampl", "follow", "code", "compil", "without", "warn", "string", "sa", "arrayutil", "add", "array", "util", "stringarray", "string", "array", "astr", "string", "work", "fine", "provid", "at", "least", "one", "paramet", "non", "null", "howev", "both", "paramet", "are", "null", "add", "method", "return", "object", "array", "henc", "except", "both", "paramet", "are", "null", "it", "not", "possibl", "determin", "correct", "array", "type", "return", "so", "it", "seem", "me", "thi", "disallow", "think", "method", "ought", "chang", "throw", "illegalparameterexcept", "illeg", "paramet", "except", "when", "both", "paramet", "are", "null"], "B_title": "ArrayUtils.add(T array offset T element) can create unexpected ClassCastException", "B_clean_title": ["arrayutil", "add", "array", "util", "array", "offset", "element", "creat", "unexpect", "classcastexcept", "class", "cast", "except"]},
{"A_title": "NumberUtils.isNumber(String)  is not right when the String is 1.1L1.1L  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp;                to:              if (charsi == l                 || charsi == L)                  // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "string", "not", "right", "when", "string", "1l1", "1l", "not", "java", "number", "but", "numberutil", "isnumb", "number", "util", "number", "string", "return", "true", "perhap", "chang", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "charsi", "charsi", "not", "allow", "expon", "return", "founddigit", "found", "digit", "hasexp", "ha", "exp", "hasdecpoint", "ha", "dec", "point"], "B_title": "Fixing NumberUtils.isNumber so that 1.1L is not considered a number. LANG-664", "B_clean_title": ["fix", "numberutil", "isnumb", "number", "util", "number", "so", "that", "1l", "not", "consid", "number", "lang", "664"]},
{"A_title": "math Complex Tanh for big numbersHi In Complex.java the tanh is computed with the following formula: tanh(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + sin(2b)/(cosh(2a)+cos(2b))i The problem that Im finding is that as soon as a is a big number both sinh(2a) and cosh(2a) are infinity and then the method tanh returns in the real part NaN (infinity/infinity) when it should return 1.0. Wouldnt it be appropiate to add something as in the FastMath library??: if (real>20.0)       return createComplex(1.0 0.0);  if (real<-20.0)       return createComplex(-1.0 0.0);  Best regards JBB", "A_clean_title": ["math", "complex", "tanh", "big", "numbershi", "number", "hi", "complex", "java", "tanh", "comput", "follow", "formula", "tanh", "bi", "sinh", "2a", "cosh", "2a", "+co", "2b", "sin", "2b", "cosh", "2a", "+co", "2b", "problem", "that", "im", "find", "that", "as", "soon", "as", "big", "number", "both", "sinh", "2a", "cosh", "2a", "are", "infin", "then", "method", "tanh", "return", "real", "part", "nan", "na", "infin", "infin", "when", "it", "return", "wouldnt", "it", "appropi", "add", "someth", "as", "fastmath", "fast", "math", "librari", "real", "20", "return", "createcomplex", "creat", "complex", "real", "20", "return", "createcomplex", "creat", "complex", "best", "regard", "jbb"], "B_title": "Introduced tests to guard against overflow (MATH-722). Corrected Javadoc and updated unit tests accordingly.", "B_clean_title": ["introduc", "test", "guard", "against", "overflow", "math", "722", "correct", "javadoc", "updat", "unit", "test", "accordingli"]},
{"A_title": "BigFraction.doubleValue() returns Double.NaN for large numerators or denominatorsThe current implementation of doubleValue() divides numerator.doubleValue() / denominator.doubleValue().  BigInteger.doubleValue() fails for any number greater than Double.MAX_VALUE.  So if the user has 308-digit numerator or denominator the resulting quotient fails even in cases where the result would be well inside Doubles range. I have a patch to fix it if I can figure out how to attach it here I will.", "A_clean_title": ["bigfract", "doublevalu", "big", "fraction", "doubl", "valu", "return", "doubl", "nan", "na", "larg", "numer", "or", "denominatorsth", "denomin", "current", "implement", "doublevalu", "doubl", "valu", "divid", "numer", "doublevalu", "doubl", "valu", "denomin", "doublevalu", "doubl", "valu", "biginteg", "doublevalu", "big", "integ", "doubl", "valu", "fail", "ani", "number", "greater", "than", "doubl", "max", "valu", "so", "user", "ha", "308", "digit", "numer", "or", "denomin", "result", "quotient", "fail", "even", "case", "where", "result", "would", "well", "insid", "doubl", "rang", "have", "patch", "fix", "it", "figur", "out", "how", "attach", "it", "here", "will"], "B_title": "Fixed doubleValue() and floatValue() when numerator and denominator are larger than the range of the corresponding primitive type.", "B_clean_title": ["fix", "doublevalu", "doubl", "valu", "floatvalu", "float", "valu", "when", "numer", "denomin", "are", "larger", "than", "rang", "correspond", "primit", "type"]},
{"A_title": "Negative millis display incorrectly in Period.toStringThe last line should produce PT-0.100S instead of PT0.100S.", "A_clean_title": ["neg", "milli", "display", "incorrectli", "period", "tostringth", "string", "last", "line", "produc", "pt", "100", "instead", "pt0", "100"], "B_title": "Fix period formatter to correctly output values negative milliseconds 3564249", "B_clean_title": ["fix", "period", "formatt", "correctli", "output", "valu", "neg", "millisecond", "3564249"]},
{"A_title": "TypeUtils.getTypeArguments() misses type arguments for partially-assigned classesfailing test code to add to TypeUtilsTest.testGetTypeArguments():  typeVarAssigns = TypeUtils.getTypeArguments(Other.class This.class); Assert.assertEquals(2 typeVarAssigns.size()); Assert.assertEquals(String.class typeVarAssigns.get(This.class.getTypeParameters()0)); Assert.assertEquals(Other.class.getTypeParameters()0 typeVarAssigns.get(This.class.getTypeParameters()1));   These should pass based on:   public interface This<K V>    public class Other<T> implements This<String T>     This case fails because the current code ignores the Other class due to its specifying its own type variables which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.", "A_clean_title": ["typeutil", "gettypeargu", "type", "util", "get", "type", "argument", "miss", "type", "argument", "partial", "assign", "classesfail", "test", "code", "add", "typeutilstest", "testgettypeargu", "type", "util", "test", "test", "get", "type", "argument", "typevarassign", "type", "var", "assign", "typeutil", "gettypeargu", "type", "util", "get", "type", "argument", "other", "class", "thi", "class", "assert", "assertequ", "assert", "equal", "typevarassign", "size", "type", "var", "assign", "assert", "assertequ", "assert", "equal", "string", "class", "typevarassign", "get", "type", "var", "assign", "thi", "class", "gettypeparamet", "get", "type", "paramet", "assert", "assertequ", "assert", "equal", "other", "class", "gettypeparamet", "get", "type", "paramet", "typevarassign", "get", "type", "var", "assign", "thi", "class", "gettypeparamet", "get", "type", "paramet", "these", "pass", "base", "public", "interfac", "thi", "public", "class", "other", "implement", "thi", "string", "thi", "case", "fail", "becaus", "current", "code", "ignor", "other", "class", "due", "it", "specifi", "it", "own", "type", "variabl", "which", "obvious", "incorrect", "thi", "report", "extrapol", "offlin", "report", "receiv", "by", "hen"], "B_title": "LANG-776 fix related bugs dealing with type variable inheritance", "B_clean_title": ["lang", "776", "fix", "relat", "bug", "deal", "type", "variabl", "inherit"]},
{"A_title": "Truncation issue in KMeansPlusPlusClustererThe for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable   int sum = 0; This variable should have type double rather than int.  Using an int causes the method to truncate the distances between points to (square roots of) integers.  Its especially bad when the distances between points are typically less than 1. As an aside in version 2.2 this bug manifested itself by making the clusterer return empty clusters.  I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "A_clean_title": ["truncat", "issu", "kmeansplusplusclustererth", "mean", "plu", "plu", "cluster", "loop", "insid", "kmeanspluspluscluster", "chooseinitialclust", "mean", "plu", "plu", "cluster", "choos", "initi", "cluster", "defin", "variabl", "int", "sum", "thi", "variabl", "have", "type", "doubl", "rather", "than", "int", "int", "caus", "method", "truncat", "distanc", "between", "point", "squar", "root", "integ", "it", "especi", "bad", "when", "distanc", "between", "point", "are", "typic", "less", "than", "as", "asid", "version", "thi", "bug", "manifest", "itself", "by", "make", "cluster", "return", "empti", "cluster", "wonder", "emptyclusterstrategi", "empti", "cluster", "strategi", "would", "still", "necessari", "thi", "bug", "were", "fix"], "B_title": "Wrong  variable type (int instead of double).", "B_clean_title": ["wrong", "variabl", "type", "int", "instead", "doubl"]},
{"A_title": "Days#daysBetween throw exception for MonthDay with 29 FebruaryIs there a way to avoid this happening? I understand fiddling around with the leap year youre bound to get issues.", "A_clean_title": ["day", "daysbetween", "day", "between", "throw", "except", "monthday", "month", "day", "29", "februaryi", "februari", "there", "way", "avoid", "thi", "happen", "understand", "fiddl", "around", "leap", "year", "your", "bound", "get", "issu"], "B_title": "Days.daysBetween fails for MonthDay", "B_clean_title": ["day", "daysbetween", "day", "between", "fail", "monthday", "month", "day"]},
{"A_title": "Fix case-insensitive string handlingString.to*Case() is locale-sensitive this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.", "A_clean_title": ["fix", "case", "insensit", "string", "handlingstr", "handl", "string", "case", "local", "sensit", "thi", "usual", "not", "intend", "case", "insensit", "comparis", "pleas", "see", "common", "bug", "detail"], "B_title": "Applying the final part of Benjamin Bentmanns patch to LANG-432 improving our handling of case-insensitive Strings", "B_clean_title": ["appli", "final", "part", "benjamin", "bentmann", "patch", "lang", "432", "improv", "our", "handl", "case", "insensit", "string"]},
{"A_title": "FastDateFormat.format() outputs incorrect week of year because locale isnt respectedFastDateFormat apparently doesnt respect the locale it was sent on creation when outputting week in year (e.g. ww) in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo      public static void main(String args)          Locale.setDefault(new Locale(en US));         Locale locale = new Locale(sv SE);          Calendar cal = Calendar.getInstance(); // setting locale here doesnt change outcome         cal.set(2010 0 1 12 0 0);         Date d = cal.getTime();         System.out.println(Target date:  + d);          FastDateFormat fdf = FastDateFormat.getInstance(EEEE week ww locale);         SimpleDateFormat sdf = new SimpleDateFormat(EEEE week ww locale);         System.out.println(FastDateFormat:    + fdf.format(d)); // will output FastDateFormat:   fredag week 01         System.out.println(SimpleDateFormat:  + sdf.format(d)); // will output SimpleDateFormat: fredag week 53         If sv/SE is passed to Locale.setDefault() instead of en/US both FastDateFormat and SimpleDateFormat output the correct week number.", "A_clean_title": ["fastdateformat", "format", "fast", "date", "format", "output", "incorrect", "week", "year", "becaus", "local", "isnt", "respectedfastdateformat", "respect", "fast", "date", "format", "appar", "doesnt", "respect", "local", "it", "wa", "sent", "creation", "when", "output", "week", "year", "ww", "format", "it", "seem", "use", "set", "system", "local", "firstdayofweek", "first", "day", "week", "minimaldaysinfirstweek", "minim", "day", "first", "week", "which", "depend", "year", "may", "result", "incorrect", "week", "number", "be", "output", "here", "simpl", "test", "program", "demonstr", "problem", "by", "compar", "simpledateformat", "simpl", "date", "format", "which", "get", "week", "number", "right", "import", "java", "util", "calendar", "import", "java", "util", "date", "import", "java", "util", "local", "import", "java", "text", "simpledateformat", "simpl", "date", "format", "import", "org", "apach", "common", "lang", "time", "fastdateformat", "fast", "date", "format", "public", "class", "fastdateformatweekbugdemo", "fast", "date", "format", "week", "bug", "demo", "public", "static", "void", "main", "string", "arg", "local", "setdefault", "set", "default", "new", "local", "en", "us", "local", "local", "new", "local", "sv", "se", "calendar", "cal", "calendar", "getinst", "get", "instanc", "set", "local", "here", "doesnt", "chang", "outcom", "cal", "set", "2010", "12", "date", "cal", "gettim", "get", "time", "system", "out", "println", "target", "date", "fastdateformat", "fast", "date", "format", "fdf", "fastdateformat", "getinst", "fast", "date", "format", "get", "instanc", "eeee", "week", "ww", "local", "simpledateformat", "simpl", "date", "format", "sdf", "new", "simpledateformat", "simpl", "date", "format", "eeee", "week", "ww", "local", "system", "out", "println", "fastdateformat", "fast", "date", "format", "fdf", "format", "will", "output", "fastdateformat", "fast", "date", "format", "fredag", "week", "01", "system", "out", "println", "simpledateformat", "simpl", "date", "format", "sdf", "format", "will", "output", "simpledateformat", "simpl", "date", "format", "fredag", "week", "53", "sv", "se", "pass", "local", "setdefault", "set", "default", "instead", "en", "us", "both", "fastdateformat", "fast", "date", "format", "simpledateformat", "simpl", "date", "format", "output", "correct", "week", "number"], "B_title": "Applying my fix to LANG-645 and Mikaels test case; fixing the FastDateFormat to properly include the locale when formatting a Date", "B_clean_title": ["appli", "my", "fix", "lang", "645", "mikael", "test", "case", "fix", "fastdateformat", "fast", "date", "format", "properli", "includ", "local", "when", "format", "date"]},
{"A_title": "Inconsistent result from Levenberg-MarquardtLevenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair.  However the class holds the optimum point the vector of the objective function the cost and residuals.  The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost", "A_clean_title": ["inconsist", "result", "levenberg", "marquardtlevenberg", "marquardt", "marquardt", "levenberg", "it", "method", "dooptim", "optim", "return", "vectorialpointvaluepair", "vectori", "point", "valu", "pair", "howev", "class", "hold", "optimum", "point", "vector", "object", "function", "cost", "residu", "valu", "return", "by", "dooptim", "optim", "not", "alway", "correspond", "point", "which", "lead", "residu", "cost"], "B_title": "corrected", "B_clean_title": ["correct"]},
{"A_title": "NPE when calling SubLine.intersection() with non-intersecting linesWhen calling SubLine.intersection() with two lines that not intersect then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.", "A_clean_title": ["npe", "when", "call", "sublin", "intersect", "sub", "line", "non", "intersect", "lineswhen", "line", "when", "call", "sublin", "intersect", "sub", "line", "two", "line", "that", "not", "intersect", "then", "nullpointerexcept", "null", "pointer", "except", "thrown", "line", "tosubspac", "sub", "space", "thi", "bug", "twod", "threed", "implement", "attach", "patch", "fix", "both", "implement", "add", "requir", "test", "case"], "B_title": "Fixed NullPointerException in 2D and 3D sub-line intersections.", "B_clean_title": ["fix", "nullpointerexcept", "null", "pointer", "except", "2d", "3d", "sub", "line", "intersect"]},
{"A_title": "RandomStringUtils.random(count 0 0 false false universe random) always throws java.lang.ArrayIndexOutOfBoundsExceptionIn commons-lang 2.6 line 250 :  ch = charsrandom.nextInt(gap) + start;  This line of code takes a random int to fetch a char in the chars array regardless of its size. (Besides start is useless here) Fixed version would be :  //ch = charsrandom.nextInt(gap)%chars.length;  When user pass 0 as end or when the array is not null but empty this line ends up with an exception", "A_clean_title": ["randomstringutil", "random", "random", "string", "util", "count", "fals", "fals", "univers", "random", "alway", "throw", "java", "lang", "arrayindexoutofboundsexceptionin", "array", "index", "out", "bound", "except", "common", "lang", "line", "250", "ch", "charsrandom", "nextint", "next", "int", "gap", "start", "thi", "line", "code", "take", "random", "int", "fetch", "char", "char", "array", "regardless", "it", "size", "besid", "start", "useless", "here", "fix", "version", "would", "ch", "charsrandom", "nextint", "next", "int", "gap", "char", "length", "when", "user", "pass", "as", "end", "or", "when", "array", "not", "null", "but", "empti", "thi", "line", "end", "up", "except"], "B_title": "RandomStringUtils.random(count 0 0 false false universe random) always throws java.lang.ArrayIndexOutOfBoundsException", "B_clean_title": ["randomstringutil", "random", "random", "string", "util", "count", "fals", "fals", "univers", "random", "alway", "throw", "java", "lang", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except"]},
{"A_title": "Bug propgated from v1.0.5 on to presentThe method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it Returns the number of series in the dataset (possibly zero).  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "A_clean_title": ["bug", "propgat", "v1", "presentth", "present", "method", "getrowcount", "get", "row", "count", "class", "org", "jfree", "data", "categori", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "say", "that", "it", "return", "number", "seri", "dataset", "possibl", "zero", "implement", "v1", "no", "longer", "check", "null", "condit", "which", "would", "then", "return", "zero", "serieskey", "seri", "key", "as", "it", "did", "v1", "previou", "thi", "now", "throw", "null", "pointer", "serieskey", "seri", "key", "never", "got", "initi", "getrowcount", "get", "row", "count", "method", "call"], "B_title": " source/org/jfree/data/DefaultIntervalCategoryDataset.java (DefaultIntervalCategoryDataset(Comparable Comparable Number Number): Initialise seriesKeys and categoryKeys to empty arrays instead of null for empty dataset(setCategoryKeys): Fixed argument check to handle empty dataset.", "B_clean_title": ["java", "sourc", "org", "jfree", "data", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "defaultintervalcategorydataset", "default", "interv", "categori", "dataset", "compar", "compar", "number", "number", "initialis", "serieskey", "seri", "key", "categorykey", "categori", "key", "empti", "array", "instead", "null", "empti", "dataset", "setcategorykey", "set", "categori", "key", "fix", "argument", "check", "handl", "empti", "dataset"]},
{"A_title": "Division by zeroIn class Complex division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO otherwise the result should be INF. See here.", "A_clean_title": ["divis", "by", "zeroin", "zero", "class", "complex", "divis", "by", "zero", "alway", "return", "nan", "na", "think", "that", "it", "return", "nan", "na", "onli", "when", "numer", "also", "zero", "otherwis", "result", "inf", "see", "here"], "B_title": "Reverting to previous behaviour as requested by P. Steitz.", "B_clean_title": ["revert", "previou", "behaviour", "as", "request", "by", "steitz"]},
{"A_title": "CMAESOptimizer does not enforce boundsThe CMAESOptimizer can exceed the bounds passed to optimize.  Looking at the generationLoop in doOptimize() it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called.  Also even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring.  This is against svn revision 1387637.  I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "not", "enforc", "boundsth", "bound", "cmaesoptim", "cmae", "optim", "exceed", "bound", "pass", "optim", "look", "at", "generationloop", "gener", "loop", "dooptim", "optim", "it", "bound", "check", "by", "call", "isfeas", "feasibl", "but", "checkfeasablecount", "check", "feasabl", "count", "zero", "default", "then", "isfeas", "feasibl", "never", "even", "call", "also", "even", "non", "zero", "checkfeasablecount", "check", "feasabl", "count", "it", "may", "give", "up", "befor", "find", "bound", "offspr", "go", "forward", "out", "bound", "offspr", "thi", "against", "svn", "revis", "1387637", "provid", "exampl", "program", "where", "optim", "end", "up", "fit", "outsid", "prescrib", "bound", "that", "would", "help"], "B_title": "Fixed missing repair of a point that lies outside the boundaries. Thanks to Frank Hessen for the report and for pinpointing the cause of the problem.", "B_clean_title": ["fix", "miss", "repair", "point", "that", "lie", "outsid", "boundari", "thank", "frank", "hessen", "report", "pinpoint", "caus", "problem"]},
{"A_title": "Potential NPE in AbstractCategoryItemRender.getLegendItems()Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location I suppose that the check before that should actually read if (dataset == null) not if (dataset != null).", "A_clean_title": ["potenti", "npe", "abstractcategoryitemrend", "getlegenditem", "abstract", "categori", "item", "render", "get", "legend", "item", "set", "up", "work", "copi", "current", "jfreechart", "free", "chart", "trunk", "eclips", "got", "warn", "about", "null", "pointer", "access", "thi", "bit", "code", "abstractcategoryitemrend", "java", "abstract", "categori", "item", "render", "warn", "last", "code", "line", "where", "seriescount", "seri", "count", "assign", "variabl", "dataset", "guarante", "null", "thi", "locat", "suppos", "that", "check", "befor", "that", "actual", "read", "dataset", "null", "not", "dataset", "null"], "B_title": "source/org/jfree/chart/renderer/category/AbstractCategoryRenderer.java (getLegendItems): Fix null check.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "render", "categori", "abstractcategoryrender", "abstract", "categori", "render", "getlegenditem", "get", "legend", "item", "fix", "null", "check"]},
{"A_title": "Dfp Dfp.multiply(int x) does not comply with the general contract FieldElement.multiply(int n)In class org.apache.commons.math3.Dfp  the method multiply(int n) is limited to 0 <= n <= 9999. This is not consistent with the general contract of FieldElement.multiply(int n) where there should be no limitation on the values of n.", "A_clean_title": ["dfp", "dfp", "multipli", "int", "not", "compli", "gener", "contract", "fieldel", "multipli", "field", "element", "int", "class", "org", "apach", "common", "math3", "dfp", "method", "multipli", "int", "limit", "9999", "thi", "not", "consist", "gener", "contract", "fieldel", "multipli", "field", "element", "int", "where", "there", "no", "limit", "valu"], "B_title": "Allow unlimited input values for Dfp#multiply.", "B_clean_title": ["allow", "unlimit", "input", "valu", "dfp", "multipli"]}]