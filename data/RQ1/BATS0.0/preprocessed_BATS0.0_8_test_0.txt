[{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fixed misc problems caused by the string comparison. ", "B_clean_title": ["fix", "misc", "problem", "caus", "by", "string", "comparison"]},
{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Add withUTC suffix .. ", "B_clean_title": ["add", "withutc", "utc", "suffix"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. ", "B_clean_title": ["miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction . log. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction", "log"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing throw in ContinuedFraction .. ", "B_clean_title": ["miss", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add logm value to FDistribution . getNumericalVariance ( ). Fix merge conflict in MathIllegalStateException. Missing return from patch 1 . 0. ", "B_clean_title": ["add", "logm", "valu", "fdistribut", "distribut", "getnumericalvari", "get", "numer", "varianc", "fix", "merg", "conflict", "mathillegalstateexcept", "math", "illeg", "state", "except", "miss", "return", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a small bug. updated continous fraction patch. ", "B_clean_title": ["fix", "small", "bug", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "updated continous fraction patch. Missing backslash. ", "B_clean_title": ["updat", "contin", "fraction", "patch", "miss", "backslash"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch .. Missing context for format string .. Fix continousFraction . floor ( ) = > 1 . 5. ", "B_clean_title": ["miss", "patch", "miss", "context", "format", "string", "fix", "continousfract", "contin", "fraction", "floor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. Fix a bug in ContinuedFraction where NAN is not greater than 0 . 5. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "fix", "bug", "continuedfract", "continu", "fraction", "where", "nan", "not", "greater", "than"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Fix a missing var. ", "B_clean_title": ["miss", "patch", "fix", "miss", "var"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . floor ( ) where it  s not possible to express inversely. Add localization message for MathIllegalStateException. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "floor", "where", "it", "not", "possibl", "express", "invers", "add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing context for format string .. updated continous fraction patch. ", "B_clean_title": ["miss", "context", "format", "string", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "updated continous fraction patch. ", "B_clean_title": ["updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add logm value to numericalVariance  too .. updated continous fraction patch. ", "B_clean_title": ["add", "logm", "valu", "numericalvari", "numer", "varianc", "too", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. Missing patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "fixed formatting. Missing patch. ", "B_clean_title": ["fix", "format", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing MissingContextExceptionListener. Fix a minor typo in ContinuedFraction. ", "B_clean_title": ["miss", "missingcontextexceptionlisten", "miss", "context", "except", "listen", "fix", "minor", "typo", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Throw an exception if the numeratorDegreesOfFreedom is not strictly positive. Fix numerical variance being calculated in patched manner .. Missing patch. ", "B_clean_title": ["throw", "except", "numeratordegreesoffreedom", "numer", "degre", "freedom", "not", "strictli", "posit", "fix", "numer", "varianc", "be", "calcul", "patch", "manner", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "updated continous fraction patch. Fix accidental variable warning. ", "B_clean_title": ["updat", "contin", "fraction", "patch", "fix", "accident", "variabl", "warn"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for MathIllegalStateException. updated continous fraction patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a small bug. updated continous fraction patch. ", "B_clean_title": ["fix", "small", "bug", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch .. Fix a missing continuedFraction patch. ", "B_clean_title": ["miss", "patch", "fix", "miss", "continuedfract", "continu", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a small bug. Fix a missing continuedFraction patch. ", "B_clean_title": ["fix", "small", "bug", "fix", "miss", "continuedfract", "continu", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch for message getter for GenProg_Defects4J_Math_31. updated continous fraction patch. ", "B_clean_title": ["miss", "patch", "messag", "getter", "genprog", "defects4j", "math", "31", "gen", "prog", "updat", "contin", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Added patch for MathIllegalStateException. Fix continousFraction . floor ( ) where it  s not possible to express inversely. ", "B_clean_title": ["ad", "patch", "mathillegalstateexcept", "math", "illeg", "state", "except", "fix", "continousfract", "contin", "fraction", "floor", "where", "it", "not", "possibl", "express", "invers"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Missing backslash. ", "B_clean_title": ["miss", "patch", "miss", "backslash"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix a minor typo in ContinuedFraction. fixed ExceptionContext . getMessage. ", "B_clean_title": ["fix", "minor", "typo", "continuedfract", "continu", "fraction", "fix", "exceptioncontext", "except", "context", "getmessag", "get", "messag"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Added patch for denominator and freedom .. ", "B_clean_title": ["miss", "patch", "ad", "patch", "denomin", "freedom"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . floor ( ) = > 1 . 5. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "floor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . pow ( n ) to log1 = 1 ;. Missing context for format string .. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "pow", "log1", "miss", "context", "format", "string"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add a localization message for MathIllegalStateException. Missing patch. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix continousFraction . pow ( n ) to log1 = 1 ;. Missing patch .. Missing context for format string .. ", "B_clean_title": ["fix", "continousfract", "contin", "fraction", "pow", "log1", "miss", "patch", "miss", "context", "format", "string"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Remove path from fmt . getLocalizedMessage ( ). Fix continousFraction . floor ( ) = > 1 . 5. ", "B_clean_title": ["remov", "path", "fmt", "getlocalizedmessag", "get", "local", "messag", "fix", "continousfract", "contin", "fraction", "floor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Added missing patch. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["ad", "miss", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous fix. revert accidently change for 1 . 0 contemplative division. ", "B_clean_title": ["revert", "previou", "fix", "revert", "accid", "chang", "contempl", "divis"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add missing msgArguments = new ArrayList < Object > ( len ). revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["add", "miss", "msgargument", "msg", "argument", "new", "arraylist", "array", "list", "object", "len", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous patch. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["revert", "previou", "patch", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add a line break if we don  t have any text left in the string. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["add", "line", "break", "we", "don", "have", "ani", "text", "left", "string", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for continued fractions. ", "B_clean_title": ["revert", "accid", "chang", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Missing patch for message method. ", "B_clean_title": ["miss", "patch", "miss", "patch", "messag", "method"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contemplative division. ", "B_clean_title": ["revert", "accid", "chang", "contempl", "divis"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add a localization message for MathIllegalStateException. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["add", "local", "messag", "mathillegalstateexcept", "math", "illeg", "state", "except", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["miss", "patch", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing context map in message patterns to avoid NPE in RTP constructor. Missing patch. ", "B_clean_title": ["miss", "context", "map", "messag", "pattern", "avoid", "npe", "rtp", "constructor", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Added patch for numerical variance. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["ad", "patch", "numer", "varianc", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous fix. revert accidently change to continuedFraction where hN is NaN. ", "B_clean_title": ["revert", "previou", "fix", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change to continuedFraction where hN is NaN. Missing patch .. ", "B_clean_title": ["revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contibutor. Fix numerical variance .. ", "B_clean_title": ["revert", "accid", "chang", "contibutor", "fix", "numer", "varianc"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. Add a line break if we don  t have any text left in the string. revert accidently change for now. ", "B_clean_title": ["miss", "patch", "add", "line", "break", "we", "don", "have", "ani", "text", "left", "string", "revert", "accid", "chang", "now"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Expose original exception context string .. revert accidently change for now. ", "B_clean_title": ["expos", "origin", "except", "context", "string", "revert", "accid", "chang", "now"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix FDistribution . getSolverAbsoluteAccuracy ( ). Missing patch. ", "B_clean_title": ["fix", "fdistribut", "distribut", "getsolverabsoluteaccuraci", "get", "solver", "absolut", "accuraci", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add patch for denominatorDF > 2. Missing return from patch. ", "B_clean_title": ["add", "patch", "denominatordf", "denomin", "df", "miss", "return", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["miss", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Allow for more message patterns in case of error. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["allow", "more", "messag", "pattern", "case", "error", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change to continuedFraction where hN is NaN. Missing patch. ", "B_clean_title": ["revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "hn", "nan", "na", "miss", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add patch for denominatorDF > 2. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["add", "patch", "denominatordf", "denomin", "df", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Set exception context to empty string ( fix # 134 ). revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["set", "except", "context", "empti", "string", "fix", "134", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous patch. revert accidently change for continued fractions. ", "B_clean_title": ["revert", "previou", "patch", "revert", "accid", "chang", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Fix getNumericalVariance. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["fix", "getnumericalvari", "get", "numer", "varianc", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Add localization message for ARITHMETIC_EXCEPTION. revert accidently change to continuedFraction where it was not possible to set a precision thing. ", "B_clean_title": ["add", "local", "messag", "arithmet", "except", "revert", "accid", "chang", "continuedfract", "continu", "fraction", "where", "it", "wa", "not", "possibl", "set", "precis", "thing"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Missing patch .. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["miss", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Revert previous patch. revert accidently change for 1 . 0 contibutor. ", "B_clean_title": ["revert", "previou", "patch", "revert", "accid", "chang", "contibutor"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contibutor. Reset the ExceptionContext as well. ", "B_clean_title": ["revert", "accid", "chang", "contibutor", "reset", "exceptioncontext", "except", "context", "as", "well"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contibutor. Revert previous patch. ", "B_clean_title": ["revert", "accid", "chang", "contibutor", "revert", "previou", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "revert accidently change for 1 . 0 contemplative_fraction. ", "B_clean_title": ["revert", "accid", "chang", "contempl", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Removed erroneous throw in ContinuedFraction. ", "B_clean_title": ["remov", "erron", "throw", "continuedfract", "continu", "fraction"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Updated continuedFraction patch. ", "B_clean_title": ["updat", "continuedfract", "continu", "fraction", "patch"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Removed a couple incorrect exceptions. ", "B_clean_title": ["remov", "coupl", "incorrect", "except"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Updated continuedFraction patch. Missing patch .. ", "B_clean_title": ["updat", "continuedfract", "continu", "fraction", "patch", "miss", "patch"]},
{"A_title": "Check Calendar.ERA in LocalDate.fromCalendarFieldsNone", "A_clean_title": ["check", "calendar", "era", "locald", "fromcalendarfieldsnon", "local", "date", "calendar", "field", "none"], "B_title": "Fix incorrect merge. ", "B_clean_title": ["fix", "incorrect", "merg"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;        ", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "improve BrentSolver . java. ", "B_clean_title": ["improv", "brentsolv", "brent", "solver", "java"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;        ", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "Added missing throw exception check. ", "B_clean_title": ["ad", "miss", "throw", "except", "check"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;        ", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "Added fix for bracketing in model data. ", "B_clean_title": ["ad", "fix", "bracket", "model", "data"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "Add ( double ) cast to avoid warning ( varU = ( double ) n1n2. ", "B_clean_title": ["add", "doubl", "cast", "avoid", "warn", "varu", "var", "doubl", "n1n2"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL ", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "fixed a small bug in SimpleRegression. ", "B_clean_title": ["fix", "small", "bug", "simpleregress", "simpl", "regress"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL ", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "Added test case for 1 . 5. ", "B_clean_title": ["ad", "test", "case"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL ", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "Fix a bug in the SimpleRegression test .. ", "B_clean_title": ["fix", "bug", "simpleregress", "simpl", "regress", "test"]},
{"A_title": "CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval 01.  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "bound", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "when", "fit", "bound", "cmaesoptim", "cmae", "optim", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "thi", "becaus", "it", "intern", "map", "fit", "paramet", "rang", "into", "interv", "01", "unit", "least", "precis", "ulp", "between", "float", "point", "number", "much", "smaller", "near", "zero", "than", "near", "one", "thu", "fit", "have", "much", "better", "resolut", "near", "lower", "bound", "which", "map", "zero", "than", "upper", "bound", "which", "map", "one", "will", "attach", "exampl", "program", "demonstr"], "B_title": "Fix wrong import .. Fix NPE in CMAESOptimizer. ", "B_clean_title": ["fix", "wrong", "import", "fix", "npe", "cmaesoptim", "cmae", "optim"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix parseLong ( ) where - > parseLong ( ) works. ", "B_clean_title": ["fix", "parselong", "pars", "long", "where", "parselong", "pars", "long", "work"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix null precision thingie in StringUtils. ", "B_clean_title": ["fix", "null", "precis", "thingi", "stringutil", "string", "util"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix null - penalty in long precision spotting. ", "B_clean_title": ["fix", "null", "penalti", "long", "precis", "spot"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix build. ", "B_clean_title": ["fix", "build"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Manchester United FC = > NumberUtils copy ( ). ", "B_clean_title": ["manchest", "unit", "fc", "numberutil", "number", "util", "copi"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix typo in patch. ", "B_clean_title": ["fix", "typo", "patch"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix erroneous fallthrough in NumberUtils. ", "B_clean_title": ["fix", "erron", "fallthrough", "numberutil", "number", "util"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix error in last commit. ", "B_clean_title": ["fix", "error", "last", "commit"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0) ", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "Fix gcd ( ). ", "B_clean_title": ["fix", "gcd"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0) ", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "Fix gcd with System . currentTimeMillis ( ). ", "B_clean_title": ["fix", "gcd", "system", "currenttimemilli", "current", "time", "milli"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "FastMath . pow ( - x  y ) doesn  t handle long precision precision thing. ", "B_clean_title": ["fastmath", "fast", "math", "pow", "doesn", "handl", "long", "precis", "precis", "thing"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "Fix pow ( x  y ). ", "B_clean_title": ["fix", "pow"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "Fix output of Math . pow ( x  y ). ", "B_clean_title": ["fix", "output", "math", "pow"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "FastMath . pow ( - x  y ) doesn  t handle exponent range in JS backend. ", "B_clean_title": ["fastmath", "fast", "math", "pow", "doesn", "handl", "expon", "rang", "js", "backend"]},
{"A_title": "DateUtils.isSameLocalTime does not work correctHi I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)", "A_clean_title": ["dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "not", "work", "correcthi", "correct", "hi", "think", "found", "bug", "dateutil", "date", "util", "class", "method", "issamelocaltim", "same", "local", "time", "exampl", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297364400000l", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297321200000l", "assert", "assertfals", "assert", "fals", "dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "thi", "becaus", "method", "compar", "cal1", "get", "calendar", "hour", "cal2", "get", "calendar", "hour", "but", "think", "it", "ha", "cal1", "get", "calendar", "hour", "day", "cal2", "get", "calendar", "hour", "day"], "B_title": "Fixed bug for calendars with the same HOUR value. ", "B_clean_title": ["fix", "bug", "calendar", "same", "hour", "valu"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix previous patch. ", "B_clean_title": ["fix", "previou", "patch"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix FDistributionImpl . getDenominatorDegreesOfFreedom ( ). ", "B_clean_title": ["fix", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix FDistributionImpl . getDenominatorDegreesOfFreedom ( ). ", "B_clean_title": ["fix", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix POSIX issue in FDistributionImpl . getInitialDomain ( ). ", "B_clean_title": ["fix", "posix", "issu", "fdistributionimpl", "distribut", "impl", "getinitialdomain", "get", "initi", "domain"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "fix a minor bug in Controllers. ", "B_clean_title": ["fix", "minor", "bug", "control"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "removed erroneous legacy change .. ", "B_clean_title": ["remov", "erron", "legaci", "chang"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "remove extraneous line. ", "B_clean_title": ["remov", "extran", "line"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix FDistributionImpl . getDenominatorDegreesOfFreedom ( ). ", "B_clean_title": ["fix", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fixed incorrect patch. ", "B_clean_title": ["fix", "incorrect", "patch"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "Fix case. ", "B_clean_title": ["fix", "case"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "fix bug in double precision functions. ", "B_clean_title": ["fix", "bug", "doubl", "precis", "function"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "removed erroneous import. Fix my bad in this case. fixed return type for FDistributionImpl # getDenominatorDegreesOfFreedom. ", "B_clean_title": ["remov", "erron", "import", "fix", "my", "bad", "thi", "case", "fix", "return", "type", "fdistributionimpl", "distribut", "impl", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom"]}]