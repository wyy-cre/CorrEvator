[{"A_title": "SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VMCan be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681): ... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681): at org.apache.commons.lang.builder.ToStringStyle MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681): at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681): ... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681): at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681): at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681): at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)", "A_clean_title": ["systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "android", "runtim", "dalvik", "vmcan", "vm", "replic", "android", "emul", "quit", "easili", "stack", "trace", "at", "org", "apach", "common", "lang", "builder", "tostringbuild", "string", "builder", "clinit", "tostringbuild", "java:98", "string", "builder", "androidruntim", "android", "runtim", "1681", "17", "more", "androidruntim", "android", "runtim", "1681", "caus", "by", "java", "lang", "exceptionininitializererror", "except", "initi", "error", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "builder", "tostringstyl", "string", "style", "multilinetostringstyl", "multi", "line", "string", "style", "init", "tostringstyl", "java:2276", "string", "style", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "builder", "tostringstyl", "string", "style", "clinit", "tostringstyl", "java:94", "string", "style", "androidruntim", "android", "runtim", "1681", "18", "more", "androidruntim", "android", "runtim", "1681", "caus", "by", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "androidruntim", "android", "runtim", "1681", "at", "java", "lang", "string", "substr", "string", "java:1571", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "systemutil", "java:1153", "system", "util", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "systemutil", "system", "util", "clinit", "systemutil", "java:818", "system", "util"], "B_title": "Fix toJavaVersionInt from String to boolean. ", "B_clean_title": ["fix", "tojavaversionint", "java", "version", "int", "string", "boolean"]},
{"A_title": "Incomplete reinitialization with some events handlingI get a bug with event handling: I track 2 events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I cant give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests.", "A_clean_title": ["incomplet", "reiniti", "some", "event", "handlingi", "handl", "get", "bug", "event", "handl", "track", "event", "that", "occur", "same", "step", "when", "first", "one", "accept", "it", "reset", "state", "but", "reiniti", "not", "complet", "second", "one", "becom", "unabl", "find", "it", "way", "cant", "give", "my", "context", "which", "rather", "larg", "but", "tri", "patch", "that", "work", "me", "unfortun", "it", "break", "unit", "test"], "B_title": "Fix load / load of confix classes. Fix typo in EventState. ", "B_clean_title": ["fix", "load", "load", "confix", "class", "fix", "typo", "eventst", "event", "state"]},
{"A_title": "SerializationUtils throws ClassNotFoundException when cloning primitive classesIf a serializable object contains a reference to a primitive class e.g. int.class or int.class the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest    @Test public void primitiveTypeClassSerialization() Class<?> primitiveType = int.class;  Class<?> clone = SerializationUtils.clone(primitiveType); assertEquals(primitiveType clone);     The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStreams resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException              String name = desc.getName();             try                  return Class.forName(name false classLoader);              catch (ClassNotFoundException ex)              try                   return Class.forName(name false Thread.currentThread().getContextClassLoader());              catch (Exception e)       return super.resolveClass(desc);                          Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException      String name = desc.getName(); try      return Class.forName(name false latestUserDefinedLoader());  catch (ClassNotFoundException ex)      Class cl = (Class) primClasses.get(name);     if (cl != null)  return cl;      else  throw ex;           ", "A_clean_title": ["serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "clone", "primit", "classesif", "class", "serializ", "object", "contain", "refer", "primit", "class", "int", "class", "or", "int", "class", "serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "tri", "clone", "that", "object", "import", "org", "apach", "common", "lang3", "serializationutil", "serial", "util", "import", "org", "junit", "test", "public", "class", "serializationutilstest", "serial", "util", "test", "test", "public", "void", "primitivetypeclassseri", "primit", "type", "class", "serial", "class", "primitivetyp", "primit", "type", "int", "class", "class", "clone", "serializationutil", "clone", "serial", "util", "primitivetyp", "primit", "type", "assertequ", "assert", "equal", "primitivetyp", "primit", "type", "clone", "problem", "wa", "alreadi", "report", "as", "java", "bug", "http", "sun", "bug", "bug", "com", "view", "bug", "id=4171142", "objectinputstream", "object", "input", "stream", "fix", "sinc", "java", "version", "serializationutil", "serial", "util", "problem", "aris", "becaus", "serializationutil", "serial", "util", "intern", "use", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "that", "overrid", "objectinputstream", "object", "input", "stream", "resoleclass", "resol", "class", "method", "without", "deleg", "super", "method", "case", "classnotfoundexcept", "class", "not", "found", "except", "understand", "intent", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "but", "thi", "implement", "also", "implement", "fallback", "origin", "implement", "exampl", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "classload", "class", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "tri", "return", "class", "fornam", "name", "name", "fals", "thread", "currentthread", "current", "thread", "getcontextclassload", "get", "context", "class", "loader", "catch", "except", "return", "super", "resolveclass", "resolv", "class", "desc", "here", "code", "objectinputstream", "object", "input", "stream", "that", "fix", "java", "bug", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "latestuserdefinedload", "latest", "user", "defin", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "class", "cl", "class", "primclass", "get", "prim", "class", "name", "cl", "null", "return", "cl", "throw", "ex"], "B_title": "Remove unused resolveClass method. ", "B_clean_title": ["remov", "unus", "resolveclass", "resolv", "class", "method"]},
{"A_title": "SerializationUtils throws ClassNotFoundException when cloning primitive classesIf a serializable object contains a reference to a primitive class e.g. int.class or int.class the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest    @Test public void primitiveTypeClassSerialization() Class<?> primitiveType = int.class;  Class<?> clone = SerializationUtils.clone(primitiveType); assertEquals(primitiveType clone);     The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStreams resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException              String name = desc.getName();             try                  return Class.forName(name false classLoader);              catch (ClassNotFoundException ex)              try                   return Class.forName(name false Thread.currentThread().getContextClassLoader());              catch (Exception e)       return super.resolveClass(desc);                          Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException      String name = desc.getName(); try      return Class.forName(name false latestUserDefinedLoader());  catch (ClassNotFoundException ex)      Class cl = (Class) primClasses.get(name);     if (cl != null)  return cl;      else  throw ex;           ", "A_clean_title": ["serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "clone", "primit", "classesif", "class", "serializ", "object", "contain", "refer", "primit", "class", "int", "class", "or", "int", "class", "serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "tri", "clone", "that", "object", "import", "org", "apach", "common", "lang3", "serializationutil", "serial", "util", "import", "org", "junit", "test", "public", "class", "serializationutilstest", "serial", "util", "test", "test", "public", "void", "primitivetypeclassseri", "primit", "type", "class", "serial", "class", "primitivetyp", "primit", "type", "int", "class", "class", "clone", "serializationutil", "clone", "serial", "util", "primitivetyp", "primit", "type", "assertequ", "assert", "equal", "primitivetyp", "primit", "type", "clone", "problem", "wa", "alreadi", "report", "as", "java", "bug", "http", "sun", "bug", "bug", "com", "view", "bug", "id=4171142", "objectinputstream", "object", "input", "stream", "fix", "sinc", "java", "version", "serializationutil", "serial", "util", "problem", "aris", "becaus", "serializationutil", "serial", "util", "intern", "use", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "that", "overrid", "objectinputstream", "object", "input", "stream", "resoleclass", "resol", "class", "method", "without", "deleg", "super", "method", "case", "classnotfoundexcept", "class", "not", "found", "except", "understand", "intent", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "but", "thi", "implement", "also", "implement", "fallback", "origin", "implement", "exampl", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "classload", "class", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "tri", "return", "class", "fornam", "name", "name", "fals", "thread", "currentthread", "current", "thread", "getcontextclassload", "get", "context", "class", "loader", "catch", "except", "return", "super", "resolveclass", "resolv", "class", "desc", "here", "code", "objectinputstream", "object", "input", "stream", "that", "fix", "java", "bug", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "latestuserdefinedload", "latest", "user", "defin", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "class", "cl", "class", "primclass", "get", "prim", "class", "name", "cl", "null", "return", "cl", "throw", "ex"], "B_title": "Fix possible NPE in RSRepairDefects4J_Lang_13. ", "B_clean_title": ["fix", "possibl", "npe", "rsrepairdefects4j", "lang", "13", "rs", "repair", "defects4j"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "don  t sort XYSeries by default. ", "B_clean_title": ["don", "sort", "xyseri", "xy", "seri", "by", "default"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Updated chart with the new column doesn  t already exist .. ", "B_clean_title": ["updat", "chart", "new", "column", "doesn", "alreadi", "exist"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "AddOrUpdate ( double x  double y ). ", "B_clean_title": ["addorupd", "add", "or", "updat", "doubl", "doubl"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fixed bug in XYSeries. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in XYSeries. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in XYSeries. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix - issue with the XYSeries class - patch. ", "B_clean_title": ["fix", "issu", "xyseri", "xy", "seri", "class", "patch"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "don  t allow duplicate x values in XYSeries. ", "B_clean_title": ["don", "allow", "duplic", "valu", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Don  t allow duplicate x values in XYSeries. ", "B_clean_title": ["don", "allow", "duplic", "valu", "xyseri", "xy", "seri"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fixed issue with XYSeries . add ( ). ", "B_clean_title": ["fix", "issu", "xyseri", "xy", "seri", "add"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in XYSeries addOrUpdate. ", "B_clean_title": ["fix", "bug", "xyseri", "xy", "seri", "addorupd", "add", "or", "updat"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Improved method to append XYDataItems. ", "B_clean_title": ["improv", "method", "append", "xydataitem", "xy", "data", "item"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Add some missing imports. Fix bug in addOrUpdate. ", "B_clean_title": ["add", "some", "miss", "import", "fix", "bug", "addorupd", "add", "or", "updat"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix bug in chart. ", "B_clean_title": ["fix", "bug", "chart"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Remove an overwritten throw exception if it is null. Improved method to append XYSeries items. Fix overwritten variable. ", "B_clean_title": ["remov", "overwritten", "throw", "except", "it", "null", "improv", "method", "append", "xyseri", "xy", "seri", "item", "fix", "overwritten", "variabl"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Remove an overwritten check. Improved method to append XYSeries items. ", "B_clean_title": ["remov", "overwritten", "check", "improv", "method", "append", "xyseri", "xy", "seri", "item"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add a isNaN check. ", "B_clean_title": ["add", "isnan", "na", "check"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add the missing isNaN in Complex . isNaN ( ) .. ", "B_clean_title": ["add", "miss", "isnan", "na", "complex", "isnan", "na"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add the isNaN check. ", "B_clean_title": ["add", "isnan", "na", "check"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix isNaN in complex comparison output. ", "B_clean_title": ["fix", "isnan", "na", "complex", "comparison", "output"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix isNaN. ", "B_clean_title": ["fix", "isnan", "na"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix NaN in Object . equals ( ). ", "B_clean_title": ["fix", "nan", "na", "object", "equal"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed a bug in Complex . reciprocal ( ). ", "B_clean_title": ["fix", "bug", "complex", "reciproc"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Extend reciprocal to fix max claims. ", "B_clean_title": ["extend", "reciproc", "fix", "max", "claim"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix potential inf special case for complex type in code. Removed unnecessary equals implementation. ", "B_clean_title": ["fix", "potenti", "inf", "special", "case", "complex", "type", "code", "remov", "unnecessari", "equal", "implement"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed a minor typo in Complex . reciprocal ( ). Removed unnecessary equals implementation. ", "B_clean_title": ["fix", "minor", "typo", "complex", "reciproc", "remov", "unnecessari", "equal", "implement"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix potential inf special case for complex type in code. ", "B_clean_title": ["fix", "potenti", "inf", "special", "case", "complex", "type", "code"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Revert back to NaN since it  s defined in the old one. Fix toString ( ) of Complex. ", "B_clean_title": ["revert", "back", "nan", "na", "sinc", "it", "defin", "old", "one", "fix", "tostr", "string", "complex"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "fix a minor infinity in Complex . reciprocal ( ). Removed unnecessary equals implementation. ", "B_clean_title": ["fix", "minor", "infin", "complex", "reciproc", "remov", "unnecessari", "equal", "implement"]},
{"A_title": "Statistics.setVarianceImpl makes getStandardDeviation produce NaNInvoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int scores = 1 2 3 4; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use population variance for(int i : scores)    stats.addValue(i);  double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());", "A_clean_title": ["statist", "setvarianceimpl", "set", "varianc", "impl", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "naninvok", "na", "invok", "summarystatist", "setvarianceimpl", "summari", "statist", "set", "varianc", "impl", "new", "varianc", "true", "fals", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "nan", "na", "code", "reproduc", "it", "int", "score", "summarystatist", "summari", "statist", "stat", "new", "summarystatist", "summari", "statist", "stat", "setvarianceimpl", "set", "varianc", "impl", "new", "varianc", "fals", "use", "popul", "varianc", "int", "score", "stat", "addvalu", "add", "valu", "doubl", "sd", "stat", "getstandarddevi", "get", "standard", "deviat", "system", "out", "println", "sd", "workaround", "suggest", "by", "mikkel", "doubl", "sd", "fastmath", "sqrt", "fast", "math", "stat", "getsecondmo", "get", "second", "moment", "stat", "getn", "get"], "B_title": "Added missing if / else .. Fix secondMoment increment .. Fix minor bug in SummaryStatistics. ", "B_clean_title": ["ad", "miss", "fix", "secondmo", "second", "moment", "increment", "fix", "minor", "bug", "summarystatist", "summari", "statist"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder delete doesn  t overwrite the capacity. ", "B_clean_title": ["strbuilder", "str", "builder", "delet", "doesn", "overwrit", "capac"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder . contains ( ) now returns true if the builder contains the character. ", "B_clean_title": ["strbuilder", "str", "builder", "contain", "now", "return", "true", "builder", "contain", "charact"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder . contains ( ) uses the array copy constructor. ", "B_clean_title": ["strbuilder", "str", "builder", "contain", "use", "array", "copi", "constructor"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Added missing 1111. ", "B_clean_title": ["ad", "miss", "1111"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size > = length ( ). ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( len + 1 ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "len", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "reset nullText if it is empty string ( # 1267 ). Fix buffer size too large. ", "B_clean_title": ["reset", "nulltext", "null", "text", "it", "empti", "string", "1267", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "reset nullText on deleteFirst ( ). Fix buffer size > = length ( ). ", "B_clean_title": ["reset", "nulltext", "null", "text", "deletefirst", "delet", "first", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add more ensureCapacity .. Fix buffer size too large. ", "B_clean_title": ["add", "more", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( size + 4 ). Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "size", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix ensureCapacity .. Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( ). Fix buffer size increase. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "increas"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add throw inside if / else .. fixed a small bug. ", "B_clean_title": ["add", "throw", "insid", "fix", "small", "bug"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix ensureCapacity .. Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix buffer size > = length ( ). ", "B_clean_title": ["fix", "buffer", "size", "length"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Revert previous patch. ", "B_clean_title": ["revert", "previou", "patch"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add missing ensureCapacity .. Fix buffer size too large. ", "B_clean_title": ["add", "miss", "ensurecapac", "ensur", "capac", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder deleteFirst ( ) returns this if the builder is empty .. Fix buffer size too large. ", "B_clean_title": ["strbuilder", "str", "builder", "deletefirst", "delet", "first", "return", "thi", "builder", "empti", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fix buffer size increase. ", "B_clean_title": ["fix", "buffer", "size", "increas"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add patch for nullText builder. Fix buffer size too large. ", "B_clean_title": ["add", "patch", "nulltext", "null", "text", "builder", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add accidently removed backslash. ", "B_clean_title": ["add", "accid", "remov", "backslash"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add line separator. Fix buffer size too large. ", "B_clean_title": ["add", "line", "separ", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added ensureCapacity ( len + 1 ) if we have > 0 length. Fix buffer size too large. ", "B_clean_title": ["ad", "ensurecapac", "ensur", "capac", "len", "we", "have", "length", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Add patch for letter case. Fix buffer size too large. ", "B_clean_title": ["add", "patch", "letter", "case", "fix", "buffer", "size", "too", "larg"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug for empty range. ", "B_clean_title": ["fix", "bug", "empti", "rang"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug # 944. ", "B_clean_title": ["fix", "bug", "944"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix bug in TimeSeries . java. ", "B_clean_title": ["fix", "bug", "timeseri", "time", "seri", "java"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix an issue with TimeSeries . isEmptyRange ( ) .. ", "B_clean_title": ["fix", "issu", "timeseri", "time", "seri", "isemptyrang", "empti", "rang"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix a bug in chart_9_TimeSeries_t. ", "B_clean_title": ["fix", "bug", "chart", "timeseri", "time", "seri"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed loop. ", "B_clean_title": ["remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Fix bug in StringUtils. ", "B_clean_title": ["fix", "bug", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "match any string with spaces  fixes # 3642. ", "B_clean_title": ["match", "ani", "string", "space", "fix", "3642"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing loop. ", "B_clean_title": ["ad", "miss", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added fix. ", "B_clean_title": ["ad", "fix"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove replacementList . length ( ). ", "B_clean_title": ["remov", "replacementlist", "replac", "list", "length"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "start = textIndex + searchList  replaceIndex  . length ( ). ", "B_clean_title": ["start", "textindex", "text", "index", "searchlist", "search", "list", "replaceindex", "replac", "index", "length"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing if (. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "added missing patch. ", "B_clean_title": ["ad", "miss", "patch"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Fix bug in StringUtils. Fix bug in StringUtils. ", "B_clean_title": ["fix", "bug", "stringutil", "string", "util", "fix", "bug", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Added throw exception if search and replace array lengths do not match. revert accidently change. remove a for loop. ", "B_clean_title": ["ad", "throw", "except", "search", "replac", "array", "length", "not", "match", "revert", "accid", "chang", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed unnecessary check for null / non - empty text fields. remove a for loop. ", "B_clean_title": ["remov", "unnecessari", "check", "null", "non", "empti", "text", "field", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove accidently leftover from StringUtils. ", "B_clean_title": ["remov", "accid", "leftov", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "remove unused patch. ", "B_clean_title": ["remov", "unus", "patch"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "throw exception if timeToLive < 0. remove a unused variable. ", "B_clean_title": ["throw", "except", "timetol", "time", "live", "remov", "unus", "variabl"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "revert accidently change for StringUtils. remove a for loop. ", "B_clean_title": ["revert", "accid", "chang", "stringutil", "string", "util", "remov", "loop"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "revert accidently change. remove a redundant line. ", "B_clean_title": ["revert", "accid", "chang", "remov", "redund", "line"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "removed unnecessary check for null / non - empty text fields. reset replaceIndex. remove a for loop. fixed NPE and NPE in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "check", "null", "non", "empti", "text", "field", "reset", "replaceindex", "replac", "index", "remov", "loop", "fix", "npe", "npe", "stringutil", "string", "util"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix cost relative tolerance in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "cost", "rel", "toler", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "remove one more line. Fix the bit between the two ends of the matrix  and the one in the reverseEach method. ", "B_clean_title": ["remov", "one", "more", "line", "fix", "bit", "between", "two", "end", "matrix", "one", "reverseeach", "revers", "each", "method"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix the case for better orthotoxical fit in LevenbergMarquardtOptimizer . java. ", "B_clean_title": ["fix", "case", "better", "orthotox", "fit", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "java"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Added missing throw in patch 158 Gaussian dataset. ", "B_clean_title": ["ad", "miss", "throw", "patch", "158", "gaussian", "dataset"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Added correction for typo in case of erroneous data. ", "B_clean_title": ["ad", "correct", "typo", "case", "erron", "data"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Fix regression in GaussianFitter .. ", "B_clean_title": ["fix", "regress", "gaussianfitt", "gaussian", "fitter"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Added a throw if necessary. Add insampling error. ", "B_clean_title": ["add", "back", "miss", "patch", "ad", "throw", "necessari", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Add insampling error. Fix Gaussian function parameter length. ", "B_clean_title": ["revert", "accid", "remov", "fit", "add", "insampl", "error", "fix", "gaussian", "function", "paramet", "length"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Remove a couple of points that are not used .. ", "B_clean_title": ["revert", "accid", "remov", "param", "remov", "coupl", "point", "that", "are", "not", "use"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Added a null check. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "param", "ad", "null", "check", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Added throw if observations . length < 4 to GaussianFitter . guess ( ). ", "B_clean_title": ["revert", "accid", "remov", "param", "ad", "throw", "observ", "length", "gaussianfitt", "gaussian", "fitter", "guess"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling error. Add NPE if y is null. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "error", "add", "npe", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add NPE if points are null. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "npe", "point", "are", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Put back previous patch. Reverted accidently removed param. Throw NPE if observations . length < 4. Throw an error if observations is null. ", "B_clean_title": ["put", "back", "previou", "patch", "revert", "accid", "remov", "param", "throw", "npe", "observ", "length", "throw", "error", "observ", "null"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed change from fit ( ) .. Allow null input array to be used for GaussianFitter .. Add missing param for GaussianFitter ( maxYIdx - > X ). ", "B_clean_title": ["revert", "accid", "remov", "chang", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "miss", "param", "gaussianfitt", "gaussian", "fitter", "maxyidx", "max", "idx"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Remove a couple of points that are not used .. Fix GaussianFitter parameter error. ", "B_clean_title": ["revert", "accid", "remov", "param", "remov", "coupl", "point", "that", "are", "not", "use", "fix", "gaussianfitt", "gaussian", "fitter", "paramet", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Remove a couple of points that are not used .. Fix GaussianFitter . sort ( ). ", "B_clean_title": ["add", "back", "miss", "patch", "remov", "coupl", "point", "that", "are", "not", "use", "fix", "gaussianfitt", "gaussian", "fitter", "sort"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Add a patch for GaussianFitter . guess ( ). Add NPE if y is null. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "fit", "add", "patch", "gaussianfitt", "gaussian", "fitter", "guess", "add", "npe", "null", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Added throw exception if observations . length < 4. Add a throw if param  2  is not strictly positive. ", "B_clean_title": ["revert", "accid", "remov", "fit", "ad", "throw", "except", "observ", "length", "add", "throw", "param", "not", "strictli", "posit"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add a throw if observations . length < 3. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "throw", "observ", "length"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling error. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Allow null input array to be used for GaussianFitter .. Add one exception. ", "B_clean_title": ["revert", "accid", "remov", "param", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "one", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert accidently removed from fit ( ) .. Allow null input array to be used for GaussianFitter .. Add insampling error. ", "B_clean_title": ["revert", "accid", "remov", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter", "add", "insampl", "error"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Reverted accidently removed param. Add NPE if observations is null. Fix GaussianFitter . isBetween ( y  x  y ) .. ", "B_clean_title": ["revert", "accid", "remov", "param", "add", "npe", "observ", "null", "fix", "gaussianfitt", "gaussian", "fitter", "isbetween", "between"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Add insampling exception. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "add", "insampl", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Revert change to GaussianFitter . fit ( ) .. Allow null input array to be used for GaussianFitter .. ", "B_clean_title": ["revert", "chang", "gaussianfitt", "gaussian", "fitter", "fit", "allow", "null", "input", "array", "use", "gaussianfitt", "gaussian", "fitter"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add a dimension mismatch check. Reverted accidently removed param. Add insampling exception. ", "B_clean_title": ["add", "dimens", "mismatch", "check", "revert", "accid", "remov", "param", "add", "insampl", "except"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Add back missing patch. Remove a couple of points that are not used .. Added a null check. ", "B_clean_title": ["add", "back", "miss", "patch", "remov", "coupl", "point", "that", "are", "not", "use", "ad", "null", "check"]},
{"A_title": "MathUtils.factorial(n) fails for n >= 17The result of MathUtils.factorial( n ) for n = 17 18 19 is wrong probably because of rounding errors in the double calculations. Replace the first line of MathUtilsTest.testFactorial() by         for (int i = 1; i <= 20; i++)  to check all valid arguments for the long result and see the failure. I suggest implementing a simple loop to multiply the long result - or even using a precomputed long - instead of adding logarithms.", "A_clean_title": ["mathutil", "factori", "math", "util", "fail", "17the", "result", "mathutil", "factori", "math", "util", "17", "18", "19", "wrong", "probabl", "becaus", "round", "error", "doubl", "calcul", "replac", "first", "line", "mathutilstest", "testfactori", "math", "util", "test", "test", "factori", "by", "int", "20", "i++", "check", "all", "valid", "argument", "long", "result", "see", "failur", "suggest", "implement", "simpl", "loop", "multipli", "long", "result", "or", "even", "precomput", "long", "instead", "ad", "logarithm"], "B_title": "removed erroneous legacy call in MathUtils. ", "B_clean_title": ["remov", "erron", "legaci", "call", "mathutil", "math", "util"]}]