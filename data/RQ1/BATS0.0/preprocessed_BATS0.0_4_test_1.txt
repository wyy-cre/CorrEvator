[{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Use the method provided for sorting XYSeries. ", "B_clean_title": ["use", "method", "provid", "sort", "xyseri", "xy", "seri"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fix NaN - > org . apache . commons . math3 . complex . Complex. ", "B_clean_title": ["fix", "nan", "na", "org", "apach", "common", "math3", "complex", "complex"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Extend the definition of INF .. ", "B_clean_title": ["extend", "definit", "inf"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add 0 . 0 equals to Complex. ", "B_clean_title": ["add", "equal", "complex"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add the inverse of Complex . INF to check for 0 . 0 precision .. ", "B_clean_title": ["add", "invers", "complex", "inf", "check", "precis"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Add the inverse of Complex . INF as well .. ", "B_clean_title": ["add", "invers", "complex", "inf", "as", "well"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed a minor typo in Complex . reciprocal ( ). ", "B_clean_title": ["fix", "minor", "typo", "complex", "reciproc"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "NaN - > Complex . INF. ", "B_clean_title": ["nan", "na", "complex", "inf"]},
{"A_title": "Statistics.setVarianceImpl makes getStandardDeviation produce NaNInvoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int scores = 1 2 3 4; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use population variance for(int i : scores)    stats.addValue(i);  double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());", "A_clean_title": ["statist", "setvarianceimpl", "set", "varianc", "impl", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "naninvok", "na", "invok", "summarystatist", "setvarianceimpl", "summari", "statist", "set", "varianc", "impl", "new", "varianc", "true", "fals", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "nan", "na", "code", "reproduc", "it", "int", "score", "summarystatist", "summari", "statist", "stat", "new", "summarystatist", "summari", "statist", "stat", "setvarianceimpl", "set", "varianc", "impl", "new", "varianc", "fals", "use", "popul", "varianc", "int", "score", "stat", "addvalu", "add", "valu", "doubl", "sd", "stat", "getstandarddevi", "get", "standard", "deviat", "system", "out", "println", "sd", "workaround", "suggest", "by", "mikkel", "doubl", "sd", "fastmath", "sqrt", "fast", "math", "stat", "getsecondmo", "get", "second", "moment", "stat", "getn", "get"], "B_title": "updated hercules patch. Fix bug in secondMoment of mean implementation. fixed case. ", "B_clean_title": ["updat", "hercul", "patch", "fix", "bug", "secondmo", "second", "moment", "mean", "implement", "fix", "case"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "added missing patch. updated hercules bugfix. ", "B_clean_title": ["ad", "miss", "patch", "updat", "hercul", "bugfix"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "StrBuilder . contains ( ) now uses the same level of storage as ArrayList .. ", "B_clean_title": ["strbuilder", "str", "builder", "contain", "now", "use", "same", "level", "storag", "as", "arraylist", "array", "list"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix empty range in TimeSeries. ", "B_clean_title": ["fix", "empti", "rang", "timeseri", "time", "seri"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix an issue with time series end index < startIndex. ", "B_clean_title": ["fix", "issu", "time", "seri", "end", "index", "startindex", "start", "index"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix an issue with TimeSeries . isEmpty ( ) .. ", "B_clean_title": ["fix", "issu", "timeseri", "time", "seri", "isempti", "empti"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix an issue with TimeSeries . isEmptyRange ( ). ", "B_clean_title": ["fix", "issu", "timeseri", "time", "seri", "isemptyrang", "empti", "rang"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "Fix an issue with time series end index < startIndex. ", "B_clean_title": ["fix", "issu", "time", "seri", "end", "index", "startindex", "start", "index"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "still need more matches in StringUtils. ", "B_clean_title": ["still", "need", "more", "match", "stringutil", "string", "util"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);    ", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "fit ( ) now uses Gaussian . Parametric ( ). ", "B_clean_title": ["fit", "now", "use", "gaussian", "parametr"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "GaussianFitter . fit ( ) now uses parameter guesser. ", "B_clean_title": ["gaussianfitt", "gaussian", "fitter", "fit", "now", "use", "paramet", "guesser"]},
{"A_title": "MathUtils.factorial(n) fails for n >= 17The result of MathUtils.factorial( n ) for n = 17 18 19 is wrong probably because of rounding errors in the double calculations. Replace the first line of MathUtilsTest.testFactorial() by         for (int i = 1; i <= 20; i++)  to check all valid arguments for the long result and see the failure. I suggest implementing a simple loop to multiply the long result - or even using a precomputed long - instead of adding logarithms.", "A_clean_title": ["mathutil", "factori", "math", "util", "fail", "17the", "result", "mathutil", "factori", "math", "util", "17", "18", "19", "wrong", "probabl", "becaus", "round", "error", "doubl", "calcul", "replac", "first", "line", "mathutilstest", "testfactori", "math", "util", "test", "test", "factori", "by", "int", "20", "i++", "check", "all", "valid", "argument", "long", "result", "see", "failur", "suggest", "implement", "simpl", "loop", "multipli", "long", "result", "or", "even", "precomput", "long", "instead", "ad", "logarithm"], "B_title": "Added patch method for MathUtils .. Added patch_method ( ) for n = 20 . 0 .. ", "B_clean_title": ["ad", "patch", "method", "mathutil", "math", "util", "ad", "patch", "method", "20"]},
{"A_title": "SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VMCan be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681): ... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681): at org.apache.commons.lang.builder.ToStringStyle MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681): at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681): ... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681): at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681): at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681): at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)", "A_clean_title": ["systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "android", "runtim", "dalvik", "vmcan", "vm", "replic", "android", "emul", "quit", "easili", "stack", "trace", "at", "org", "apach", "common", "lang", "builder", "tostringbuild", "string", "builder", "clinit", "tostringbuild", "java:98", "string", "builder", "androidruntim", "android", "runtim", "1681", "17", "more", "androidruntim", "android", "runtim", "1681", "caus", "by", "java", "lang", "exceptionininitializererror", "except", "initi", "error", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "builder", "tostringstyl", "string", "style", "multilinetostringstyl", "multi", "line", "string", "style", "init", "tostringstyl", "java:2276", "string", "style", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "builder", "tostringstyl", "string", "style", "clinit", "tostringstyl", "java:94", "string", "style", "androidruntim", "android", "runtim", "1681", "18", "more", "androidruntim", "android", "runtim", "1681", "caus", "by", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "androidruntim", "android", "runtim", "1681", "at", "java", "lang", "string", "substr", "string", "java:1571", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "systemutil", "java:1153", "system", "util", "androidruntim", "android", "runtim", "1681", "at", "org", "apach", "common", "lang", "systemutil", "system", "util", "clinit", "systemutil", "java:818", "system", "util"], "B_title": "SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM. Oops fix return type.", "B_clean_title": ["systemutil", "getjavaversionasfloat", "system", "util", "get", "java", "version", "as", "float", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "android", "runtim", "dalvik", "vm", "oop", "fix", "return", "type"]},
{"A_title": "Incomplete reinitialization with some events handlingI get a bug with event handling: I track 2 events that occur in the same step when the first one is accepted it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I cant give my context which is rather large but I tried a patch that works for me unfortunately it breaks the unit tests.", "A_clean_title": ["incomplet", "reiniti", "some", "event", "handlingi", "handl", "get", "bug", "event", "handl", "track", "event", "that", "occur", "same", "step", "when", "first", "one", "accept", "it", "reset", "state", "but", "reiniti", "not", "complet", "second", "one", "becom", "unabl", "find", "it", "way", "cant", "give", "my", "context", "which", "rather", "larg", "but", "tri", "patch", "that", "work", "me", "unfortun", "it", "break", "unit", "test"], "B_title": "Fixed an event resetting issue in ODE.", "B_clean_title": ["fix", "event", "reset", "issu", "ode"]},
{"A_title": "SerializationUtils throws ClassNotFoundException when cloning primitive classesIf a serializable object contains a reference to a primitive class e.g. int.class or int.class the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest    @Test public void primitiveTypeClassSerialization() Class<?> primitiveType = int.class;  Class<?> clone = SerializationUtils.clone(primitiveType); assertEquals(primitiveType clone);     The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStreams resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException              String name = desc.getName();             try                  return Class.forName(name false classLoader);              catch (ClassNotFoundException ex)              try                   return Class.forName(name false Thread.currentThread().getContextClassLoader());              catch (Exception e)       return super.resolveClass(desc);                          Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException ClassNotFoundException      String name = desc.getName(); try      return Class.forName(name false latestUserDefinedLoader());  catch (ClassNotFoundException ex)      Class cl = (Class) primClasses.get(name);     if (cl != null)  return cl;      else  throw ex;", "A_clean_title": ["serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "clone", "primit", "classesif", "class", "serializ", "object", "contain", "refer", "primit", "class", "int", "class", "or", "int", "class", "serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "tri", "clone", "that", "object", "import", "org", "apach", "common", "lang3", "serializationutil", "serial", "util", "import", "org", "junit", "test", "public", "class", "serializationutilstest", "serial", "util", "test", "test", "public", "void", "primitivetypeclassseri", "primit", "type", "class", "serial", "class", "primitivetyp", "primit", "type", "int", "class", "class", "clone", "serializationutil", "clone", "serial", "util", "primitivetyp", "primit", "type", "assertequ", "assert", "equal", "primitivetyp", "primit", "type", "clone", "problem", "wa", "alreadi", "report", "as", "java", "bug", "http", "sun", "bug", "bug", "com", "view", "bug", "id=4171142", "objectinputstream", "object", "input", "stream", "fix", "sinc", "java", "version", "serializationutil", "serial", "util", "problem", "aris", "becaus", "serializationutil", "serial", "util", "intern", "use", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "that", "overrid", "objectinputstream", "object", "input", "stream", "resoleclass", "resol", "class", "method", "without", "deleg", "super", "method", "case", "classnotfoundexcept", "class", "not", "found", "except", "understand", "intent", "classloaderawareobjectinputstream", "class", "loader", "awar", "object", "input", "stream", "but", "thi", "implement", "also", "implement", "fallback", "origin", "implement", "exampl", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "classload", "class", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "tri", "return", "class", "fornam", "name", "name", "fals", "thread", "currentthread", "current", "thread", "getcontextclassload", "get", "context", "class", "loader", "catch", "except", "return", "super", "resolveclass", "resolv", "class", "desc", "here", "code", "objectinputstream", "object", "input", "stream", "that", "fix", "java", "bug", "protect", "class", "resolveclass", "resolv", "class", "objectstreamclass", "object", "stream", "class", "desc", "throw", "ioexcept", "io", "except", "classnotfoundexcept", "class", "not", "found", "except", "string", "name", "desc", "getnam", "get", "name", "tri", "return", "class", "fornam", "name", "name", "fals", "latestuserdefinedload", "latest", "user", "defin", "loader", "catch", "classnotfoundexcept", "class", "not", "found", "except", "ex", "class", "cl", "class", "primclass", "get", "prim", "class", "name", "cl", "null", "return", "cl", "throw", "ex"], "B_title": "SerializationUtils throws ClassNotFoundException when cloning primitive classes", "B_clean_title": ["serializationutil", "serial", "util", "throw", "classnotfoundexcept", "class", "not", "found", "except", "when", "clone", "primit", "class"]},
{"A_title": "XYSeries.addOrUpdate() should add if duplicates are allowedIve found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x Number y) was never modified to support this and therefore duplicate data were overwriting existing data.", "A_clean_title": ["xyseri", "addorupd", "xy", "seri", "add", "or", "updat", "add", "duplic", "are", "allowed", "allow", "ive", "found", "bug", "jfreechart", "code", "org", "jfree", "data", "xy", "xyseri", "xy", "seri", "there", "wa", "chang", "some", "time", "ago", "which", "introduc", "notion", "allow", "duplic", "valu", "xyseri", "xy", "seri", "data", "method", "addorupd", "add", "or", "updat", "number", "number", "wa", "never", "modifi", "support", "thi", "therefor", "duplic", "data", "were", "overwrit", "exist", "data"], "B_title": "Fix for bug 1955483.", "B_clean_title": ["fix", "bug", "1955483"]},
{"A_title": "Complex.ZERO.reciprocal() returns NaN but should return INF.Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn", "A_clean_title": ["complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "complex", "zero", "reciproc", "return", "nan", "na", "but", "return", "inf", "class", "org", "apach", "common", "math3", "complex", "complex", "method", "reciproc", "version", "id", "complex", "java", "1416643", "2012", "12", "03", "19:37:14z", "tn"], "B_title": "Fixed Complex.reciprocal() for zero argument.", "B_clean_title": ["fix", "complex", "reciproc", "zero", "argument"]},
{"A_title": "Statistics.setVarianceImpl makes getStandardDeviation produce NaNInvoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int scores = 1 2 3 4; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use population variance for(int i : scores)    stats.addValue(i);  double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());", "A_clean_title": ["statist", "setvarianceimpl", "set", "varianc", "impl", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "naninvok", "na", "invok", "summarystatist", "setvarianceimpl", "summari", "statist", "set", "varianc", "impl", "new", "varianc", "true", "fals", "make", "getstandarddevi", "get", "standard", "deviat", "produc", "nan", "na", "code", "reproduc", "it", "int", "score", "summarystatist", "summari", "statist", "stat", "new", "summarystatist", "summari", "statist", "stat", "setvarianceimpl", "set", "varianc", "impl", "new", "varianc", "fals", "use", "popul", "varianc", "int", "score", "stat", "addvalu", "add", "valu", "doubl", "sd", "stat", "getstandarddevi", "get", "standard", "deviat", "system", "out", "println", "sd", "workaround", "suggest", "by", "mikkel", "doubl", "sd", "fastmath", "sqrt", "fast", "math", "stat", "getsecondmo", "get", "second", "moment", "stat", "getn", "get"], "B_title": "Fixed errors in SummaryStatistics causing overriden statistics not to be updated if the supplied impls are commons-math classes.  JIRA: MATH-691.", "B_clean_title": ["fix", "error", "summarystatist", "summari", "statist", "caus", "overriden", "statist", "not", "updat", "suppli", "impl", "are", "common", "math", "class", "jira", "math", "691"]},
{"A_title": "NumberUtils does not handle Long Hex numbersNumberUtils.createLong() does not handle hex numbers but createInteger() handles hex and octal. This seems odd. NumberUtils.createNumber() assumes that hex numbers can only be Integer. Again why not handle bigger Hex numbers? == It is trivial to fix createLong() - just use Long.decode() instead of valueOf(). Its not clear why this was not done originally - the decode() method was added to both Integer and Long in Java 1.2. Fixing createNumber() is also fairly easy - if the hex string has more than 8 digits use Long. Should we allow for leading zeros in an Integer?  If not the length check is trivial.", "A_clean_title": ["numberutil", "number", "util", "not", "handl", "long", "hex", "numbersnumberutil", "createlong", "number", "number", "util", "creat", "long", "not", "handl", "hex", "number", "but", "createinteg", "creat", "integ", "handl", "hex", "octal", "thi", "seem", "odd", "numberutil", "createnumb", "number", "util", "creat", "number", "assum", "that", "hex", "number", "onli", "integ", "again", "whi", "not", "handl", "bigger", "hex", "number", "it", "trivial", "fix", "createlong", "creat", "long", "just", "use", "long", "decod", "instead", "valueof", "valu", "it", "not", "clear", "whi", "thi", "wa", "not", "done", "origin", "decod", "method", "wa", "ad", "both", "integ", "long", "java", "fix", "createnumb", "creat", "number", "also", "fairli", "easi", "hex", "string", "ha", "more", "than", "digit", "use", "long", "we", "allow", "lead", "zero", "integ", "not", "length", "check", "trivial"], "B_title": "NumberUtils does not handle Long Hex numbers", "B_clean_title": ["numberutil", "number", "util", "not", "handl", "long", "hex", "number"]},
{"A_title": "StrBuilder contains usages of thisBuf.length when they should use sizeWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless Im mistaken they shouldnt.", "A_clean_title": ["strbuilder", "str", "builder", "contain", "usag", "thisbuf", "length", "thi", "buf", "when", "they", "use", "sizewhil", "size", "while", "fix", "lang", "294", "notic", "that", "there", "are", "two", "other", "place", "strbuilder", "str", "builder", "that", "refer", "thisbuf", "length", "thi", "buf", "unless", "im", "mistaken", "they", "shouldnt"], "B_title": "Fixng LANG-295 - thisBuf.length calls. There were two of the calls so Ive committed a unit test showing things are broken and a fix in both cases.", "B_clean_title": ["fixng", "lang", "295", "thisbuf", "length", "thi", "buf", "call", "there", "were", "two", "call", "so", "ive", "commit", "unit", "test", "show", "thing", "are", "broken", "fix", "both", "case"]},
{"A_title": "Correlated random vector generator fails (silently) when faced with zero rows in covariance matrixThe following three matrices (which are basically permutations of each other) produce different results when sampling a multi-variate Gaussian with the help of CorrelatedRandomVectorGenerator (sample covariances calculated in R based on 10000 samples): Array2DRowRealMatrix  0.00.00.00.00.0  0.00.0134455320.010394690.0098811560.010499559  0.00.010394690.0230066160.0081968560.010732709  0.00.0098811560.0081968560.0190238660.009210099  0.00.0104995590.0107327090.0092100990.019107243 > cov(data1)    V1 V2 V3 V4 V5 V1 0 0.000000000 0.00000000 0.000000000 0.000000000 V2 0 0.013383931 0.01034401 0.009913271 0.010506733 V3 0 0.010344006 0.02309479 0.008374730 0.010759306 V4 0 0.009913271 0.00837473 0.019005488 0.009187287 V5 0 0.010506733 0.01075931 0.009187287 0.019021483 Array2DRowRealMatrix  0.0134455320.010394690.00.0098811560.010499559  0.010394690.0230066160.00.0081968560.010732709  0.00.00.00.00.0 0.0098811560.0081968560.00.0190238660.009210099 0.0104995590.0107327090.00.0092100990.019107243  > cov(data2)             V1 V2 V3 V4 V5 V1 0.006922905 0.010507692 0 0.005817399 0.010330529 V2 0.010507692 0.023428918 0 0.008273152 0.010735568 V3 0.000000000 0.000000000 0 0.000000000 0.000000000 V4 0.005817399 0.008273152 0 0.004929843 0.009048759 V5 0.010330529 0.010735568 0 0.009048759 0.018683544   Array2DRowRealMatrix 0.0134455320.010394690.0098811560.010499559 0.010394690.0230066160.0081968560.010732709 0.0098811560.0081968560.0190238660.009210099 0.0104995590.0107327090.0092100990.019107243  > cov(data3)             V1          V2          V3          V4 V1 0.013445047 0.010478862 0.009955904 0.010529542 V2 0.010478862 0.022910522 0.008610113 0.011046353 V3 0.009955904 0.008610113 0.019250975 0.009464442 V4 0.010529542 0.011046353 0.009464442 0.019260317   Ive traced this back to the RectangularCholeskyDecomposition which does not seem to handle the second matrix very well (decompositions in the same order as the matrices above):  CorrelatedRandomVectorGenerator.getRootMatrix() =  Array2DRowRealMatrix0.00.00.00.00.0  0.07595774181220630.08761251884742390.00.00.0  0.077644436225135050.051328212214607520.119763818217912350.00.0  0.066629305279094040.055016617441145850.00166625065193079970.107493242076536320.0 0.138228951381394770.00.00.00.0 CorrelatedRandomVectorGenerator.getRank() = 5 CorrelatedRandomVectorGenerator.getRootMatrix() =  Array2DRowRealMatrix0.07595774181220630.0345127513794487240.0 0.077644436225135050.130299491646287460.0  0.00.00.0  0.066629305279094040.0232039366948556740.0 0.138228951381394770.00.0 CorrelatedRandomVectorGenerator.getRank() = 3 CorrelatedRandomVectorGenerator.getRootMatrix() =  Array2DRowRealMatrix0.07595774181220630.0345127513794487240.0339137482263482250.07303890149947785 0.077644436225135050.130299491646287460.00.0  0.066629305279094040.0232039366948556740.118515733132299450.0 0.138228951381394770.00.00.0 CorrelatedRandomVectorGenerator.getRank() = 4 Clearly the rank of each of these matrices should be 4. The first matrix does not lead to incorrect results but the second one does. Unfortunately I dont know enough about the Cholesky decomposition to find the flaw in the implementation and I could not find documentation for the rectangular variant (also not at the links provided in the javadoc).", "A_clean_title": ["correl", "random", "vector", "gener", "fail", "silent", "when", "face", "zero", "row", "covari", "matrixth", "matrix", "follow", "three", "matric", "which", "are", "basic", "permut", "each", "other", "produc", "differ", "result", "when", "sampl", "multi", "variat", "gaussian", "help", "correlatedrandomvectorgener", "correl", "random", "vector", "gener", "sampl", "covari", "calcul", "base", "10000", "sampl", "array2drowrealmatrix", "array2d", "row", "real", "matrix", "00", "00", "00", "00", "00", "0134455320", "010394690", "0098811560", "010499559", "00", "010394690", "0230066160", "0081968560", "010732709", "00", "0098811560", "0081968560", "0190238660", "009210099", "00", "0104995590", "0107327090", "0092100990", "019107243", "cov", "data1", "v1", "v2", "v3", "v4", "v5", "v1", "000000000", "00000000", "000000000", "000000000", "v2", "013383931", "01034401", "009913271", "010506733", "v3", "010344006", "02309479", "008374730", "010759306", "v4", "009913271", "00837473", "019005488", "009187287", "v5", "010506733", "01075931", "009187287", "019021483", "array2drowrealmatrix", "array2d", "row", "real", "matrix", "0134455320", "010394690", "00", "0098811560", "010499559", "010394690", "0230066160", "00", "0081968560", "010732709", "00", "00", "00", "00", "0098811560", "0081968560", "00", "0190238660", "009210099", "0104995590", "0107327090", "00", "0092100990", "019107243", "cov", "data2", "v1", "v2", "v3", "v4", "v5", "v1", "006922905", "010507692", "005817399", "010330529", "v2", "010507692", "023428918", "008273152", "010735568", "v3", "000000000", "000000000", "000000000", "000000000", "v4", "005817399", "008273152", "004929843", "009048759", "v5", "010330529", "010735568", "009048759", "018683544", "array2drowrealmatrix", "array2d", "row", "real", "matrix", "0134455320", "010394690", "0098811560", "010499559", "010394690", "0230066160", "0081968560", "010732709", "0098811560", "0081968560", "0190238660", "009210099", "0104995590", "0107327090", "0092100990", "019107243", "cov", "data3", "v1", "v2", "v3", "v4", "v1", "013445047", "010478862", "009955904", "010529542", "v2", "010478862", "022910522", "008610113", "011046353", "v3", "009955904", "008610113", "019250975", "009464442", "v4", "010529542", "011046353", "009464442", "019260317", "ive", "trace", "thi", "back", "rectangularcholeskydecomposit", "rectangular", "choleski", "decomposit", "which", "not", "seem", "handl", "second", "matrix", "veri", "well", "decomposit", "same", "order", "as", "matric", "abov", "correlatedrandomvectorgener", "getrootmatrix", "correl", "random", "vector", "gener", "get", "root", "matrix", "array2drowrealmatrix0", "00", "00", "00", "00", "array2d", "row", "real", "matrix0", "07595774181220630", "08761251884742390", "00", "00", "077644436225135050", "051328212214607520", "119763818217912350", "00", "066629305279094040", "055016617441145850", "00166625065193079970", "107493242076536320", "138228951381394770", "00", "00", "00", "correlatedrandomvectorgener", "getrank", "correl", "random", "vector", "gener", "get", "rank", "correlatedrandomvectorgener", "getrootmatrix", "correl", "random", "vector", "gener", "get", "root", "matrix", "array2drowrealmatrix0", "07595774181220630", "0345127513794487240", "array2d", "row", "real", "matrix0", "077644436225135050", "130299491646287460", "00", "00", "066629305279094040", "0232039366948556740", "138228951381394770", "00", "correlatedrandomvectorgener", "getrank", "correl", "random", "vector", "gener", "get", "rank", "correlatedrandomvectorgener", "getrootmatrix", "correl", "random", "vector", "gener", "get", "root", "matrix", "array2drowrealmatrix0", "07595774181220630", "0345127513794487240", "0339137482263482250", "07303890149947785", "array2d", "row", "real", "matrix0", "077644436225135050", "130299491646287460", "00", "066629305279094040", "0232039366948556740", "118515733132299450", "138228951381394770", "00", "00", "correlatedrandomvectorgener", "getrank", "correl", "random", "vector", "gener", "get", "rank", "clearli", "rank", "each", "these", "matric", "first", "matrix", "not", "lead", "incorrect", "result", "but", "second", "one", "unfortun", "dont", "know", "enough", "about", "choleski", "decomposit", "find", "flaw", "implement", "could", "not", "find", "document", "rectangular", "variant", "also", "not", "at", "link", "provid", "javadoc"], "B_title": "Fixed an error in rectangular Cholesky decomposition.", "B_clean_title": ["fix", "error", "rectangular", "choleski", "decomposit"]},
{"A_title": "Error on TimeSeries createCopy() methodThe test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned not an exception. This is with jfreechart 1.0.7", "A_clean_title": ["error", "timeseri", "time", "seri", "createcopi", "creat", "copi", "methodth", "method", "test", "case", "at", "end", "fail", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "problem", "that", "int", "start", "end", "index", "correspond", "given", "timeperiod", "time", "period", "are", "comput", "incorectli", "here", "would", "expect", "empti", "seri", "return", "not", "except", "thi", "jfreechart"], "B_title": "source/org/jfree/data/time/TimeSeries.java (createCopy(RegularTimePeriod RegularTimePeriod)): Handle empty range.", "B_clean_title": ["java", "sourc", "org", "jfree", "data", "time", "timeseri", "time", "seri", "createcopi", "creat", "copi", "regulartimeperiod", "regular", "time", "period", "regulartimeperiod", "regular", "time", "period", "handl", "empti", "rang"]},
{"A_title": "StringUtils replaceEach - Bug or Missing DocumentationThe following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are null-friendly The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect because it is unclear what happens on the replace. I outlined three expectations in the test case of course only one should be met. If it is decided that none of them should be possible I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest   @Test public void replaceEach() String original = Hello World!; String searchList = Hello World; String replacementList = Greetings null; String result = StringUtils.replaceEach(original searchList replacementList); assertEquals(Greetings ! result); //perhaps this is ok as well                 //assertEquals(Greetings World! result);                 //or even //assertEquals(Greetings null! result);", "A_clean_title": ["stringutil", "string", "util", "replaceeach", "replac", "each", "bug", "or", "miss", "documentationth", "document", "follow", "test", "case", "replaceeach", "replac", "each", "fail", "null", "pointer", "except", "have", "expect", "that", "all", "stringutil", "string", "util", "method", "are", "null", "friendli", "use", "case", "that", "will", "stuff", "valu", "into", "replacementlist", "replac", "list", "which", "not", "want", "check", "whether", "they", "are", "null", "admit", "use", "case", "not", "perfect", "becaus", "it", "unclear", "what", "happen", "replac", "outlin", "three", "expect", "test", "case", "cours", "onli", "one", "met", "it", "decid", "that", "none", "them", "possibl", "propos", "updat", "document", "what", "happen", "when", "null", "pass", "as", "replac", "string", "import", "static", "org", "junit", "assert", "assertequ", "assert", "equal", "import", "org", "apach", "common", "lang", "stringutil", "string", "util", "import", "org", "junit", "test", "public", "class", "stringutilstest", "string", "util", "test", "test", "public", "void", "replaceeach", "replac", "each", "string", "origin", "hello", "world", "string", "searchlist", "search", "list", "hello", "world", "string", "replacementlist", "replac", "list", "greet", "null", "string", "result", "stringutil", "replaceeach", "string", "util", "replac", "each", "origin", "searchlist", "search", "list", "replacementlist", "replac", "list", "assertequ", "assert", "equal", "greet", "result", "perhap", "thi", "ok", "as", "well", "assertequ", "assert", "equal", "greet", "world", "result", "or", "even", "assertequ", "assert", "equal", "greet", "null", "result"], "B_title": "Applying fix for LANG-552. StringUtils.replaceEach(String String String) no longer NPEs when null appears in the last String", "B_clean_title": ["appli", "fix", "lang", "552", "stringutil", "replaceeach", "string", "util", "replac", "each", "string", "string", "string", "no", "longer", "npe", "np", "es", "when", "null", "appear", "last", "string"]},
{"A_title": "GaussianFitter Unexpectedly Throws NotStrictlyPositiveExceptionRunning the following:     double observations =         1.1143831578403364E-29       4.95281403484594E-28       1.1171347211930288E-26       1.7044813962636277E-25       1.9784716574832164E-24       1.8630236407866774E-23       1.4820532905097742E-22       1.0241963854632831E-21       6.275077366673128E-21       3.461808994532493E-20       1.7407124684715706E-19       8.056687953553974E-19       3.460193945992071E-18       1.3883326374011525E-17       5.233894983671116E-17       1.8630791465263745E-16       6.288759227922111E-16       2.0204433920597856E-15       6.198768938576155E-15       1.821419346860626E-14       5.139176445538471E-14       1.3956427429045787E-13       3.655705706448139E-13       9.253753324779779E-13       2.267636001476696E-12       5.3880460095836855E-12       1.2431632654852931E-11       ;     GaussianFitter g =      new GaussianFitter(new LevenbergMarquardtOptimizer());     for (int index = 0; index < 27; index++)          g.addObservedPoint(index observationsindex);             g.fit(); Results in: org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than or equal to the minimum (0) at org.apache.commons.math.analysis.function.Gaussian Parametric.validateParameters(Gaussian.java:184) at org.apache.commons.math.analysis.function.Gaussian Parametric.value(Gaussian.java:129) Im guessing the initial guess for sigma is off.", "A_clean_title": ["gaussianfitt", "gaussian", "fitter", "unexpectedli", "throw", "notstrictlypositiveexceptionrun", "not", "strictli", "posit", "except", "run", "follow", "doubl", "observ", "29", "1143831578403364e", "28", "95281403484594e", "26", "1171347211930288e", "25", "7044813962636277e", "24", "9784716574832164e", "23", "8630236407866774e", "22", "4820532905097742e", "21", "0241963854632831e", "21", "275077366673128e", "20", "461808994532493e", "19", "7407124684715706e", "19", "056687953553974e", "18", "460193945992071e", "17", "3883326374011525e", "17", "233894983671116e", "16", "8630791465263745e", "16", "288759227922111e", "15", "0204433920597856e", "15", "198768938576155e", "14", "821419346860626e", "14", "139176445538471e", "13", "3956427429045787e", "13", "655705706448139e", "13", "253753324779779e", "12", "267636001476696e", "12", "3880460095836855e", "11", "2431632654852931e", "gaussianfitt", "gaussian", "fitter", "new", "gaussianfitt", "gaussian", "fitter", "new", "levenbergmarquardtoptim", "levenberg", "marquardt", "optim", "int", "index", "index", "27", "index++", "addobservedpoint", "add", "observ", "point", "index", "observationsindex", "fit", "result", "org", "apach", "common", "math", "except", "notstrictlypositiveexcept", "not", "strictli", "posit", "except", "277", "smaller", "than", "or", "equal", "minimum", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "validateparamet", "valid", "paramet", "gaussian", "java:184", "at", "org", "apach", "common", "math", "analysi", "function", "gaussian", "parametr", "valu", "gaussian", "java:129", "im", "guess", "initi", "guess", "sigma", "off"], "B_title": "Workaround exception generated when the optimizer tries invalid values for the sigma parameter. Added a method to allow the user to pass his own initial guess.", "B_clean_title": ["workaround", "except", "gener", "when", "optim", "tri", "invalid", "valu", "sigma", "paramet", "ad", "method", "allow", "user", "pass", "hi", "own", "initi", "guess"]},
{"A_title": "MathUtils.factorial(n) fails for n >= 17The result of MathUtils.factorial( n ) for n = 17 18 19 is wrong probably because of rounding errors in the double calculations. Replace the first line of MathUtilsTest.testFactorial() by         for (int i = 1; i <= 20; i++)  to check all valid arguments for the long result and see the failure. I suggest implementing a simple loop to multiply the long result - or even using a precomputed long - instead of adding logarithms.", "A_clean_title": ["mathutil", "factori", "math", "util", "fail", "17the", "result", "mathutil", "factori", "math", "util", "17", "18", "19", "wrong", "probabl", "becaus", "round", "error", "doubl", "calcul", "replac", "first", "line", "mathutilstest", "testfactori", "math", "util", "test", "test", "factori", "by", "int", "20", "i++", "check", "all", "valid", "argument", "long", "result", "see", "failur", "suggest", "implement", "simpl", "loop", "multipli", "long", "result", "or", "even", "precomput", "long", "instead", "ad", "logarithm"], "B_title": "Fixed error in factorial accuracy.  JIRA: MATH-240.", "B_clean_title": ["fix", "error", "factori", "accuraci", "jira", "math", "240"]},
{"A_title": "none standard PeriodType without year throws exceptionI tried to get a Period only for months and weeks with following code:  This throws following exception:  Even removing the year component with .withYearsRemoved() throws the same exception:", "A_clean_title": ["none", "standard", "periodtyp", "period", "type", "without", "year", "throw", "exceptioni", "except", "tri", "get", "period", "onli", "month", "week", "follow", "code", "thi", "throw", "follow", "except", "even", "remov", "year", "compon", "withyearsremov", "year", "remov", "throw", "same", "except"], "B_title": "Fix handling of PeriodType when either years or months missing", "B_clean_title": ["fix", "handl", "periodtyp", "period", "type", "when", "either", "year", "or", "month", "miss"]}]