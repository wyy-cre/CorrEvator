[{"A_title": "Fraction percentageValue rare overflowThe percentageValue() method of the Fraction class works by first multiplying the Fraction by 100 then converting the Fraction to a double. This causes overflows when the numerator is greater than Integer.MAX_VALUE/100 even when the value of the fraction is far below this value. The patch changes the method to first convert to a double value and then multiply this value by 100 - the result should be the same but with less overflows. An addition to the test for the method that covers this bug is also included.", "A_clean_title": ["fraction", "percentagevalu", "percentag", "valu", "rare", "overflowth", "overflow", "percentagevalu", "percentag", "valu", "method", "fraction", "class", "work", "by", "first", "multipli", "fraction", "by", "100", "then", "convert", "fraction", "doubl", "thi", "caus", "overflow", "when", "numer", "greater", "than", "integ", "max", "valu", "100", "even", "when", "valu", "fraction", "far", "below", "thi", "valu", "patch", "chang", "method", "first", "convert", "doubl", "valu", "then", "multipli", "thi", "valu", "by", "100", "result", "same", "but", "less", "overflow", "addit", "test", "method", "that", "cover", "thi", "bug", "also", "includ"], "B_title": "Added Fraction copy of Fraction . percentageValue ( ). ", "B_clean_title": ["ad", "fraction", "copi", "fraction", "percentagevalu", "percentag", "valu"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix NumberFormatException. ", "B_clean_title": ["fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fix parse error ( l - > long ). ", "B_clean_title": ["fix", "pars", "error", "long"]},
{"A_title": "weight versus sigma in AbstractLeastSquaresIn AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS() these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi2.  Once corrected getRMS() can even reduce  public double getRMS()  return Math.sqrt(getChiSquare()/rows);", "A_clean_title": ["weight", "versu", "sigma", "abstractleastsquaresin", "abstract", "least", "squar", "abstractleastsquar", "abstract", "least", "squar", "residualsweight", "residu", "weight", "contain", "weight", "assign", "each", "observ", "method", "getrm", "get", "rm", "these", "weight", "are", "multipl", "as", "they", "unlik", "getchisquar", "get", "chi", "squar", "where", "it", "appear", "at", "denomin", "weight", "realli", "weight", "observ", "it", "multipli", "squar", "residu", "even", "comput", "chi2", "onc", "correct", "getrm", "get", "rm", "even", "reduc", "public", "doubl", "getrm", "get", "rm", "return", "math", "sqrt", "getchisquar", "get", "chi", "squar", "row"], "B_title": "Fix residualsWeights .. ", "B_clean_title": ["fix", "residualsweight", "residu", "weight"]},
{"A_title": "weight versus sigma in AbstractLeastSquaresIn AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS() these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi2.  Once corrected getRMS() can even reduce  public double getRMS()  return Math.sqrt(getChiSquare()/rows);", "A_clean_title": ["weight", "versu", "sigma", "abstractleastsquaresin", "abstract", "least", "squar", "abstractleastsquar", "abstract", "least", "squar", "residualsweight", "residu", "weight", "contain", "weight", "assign", "each", "observ", "method", "getrm", "get", "rm", "these", "weight", "are", "multipl", "as", "they", "unlik", "getchisquar", "get", "chi", "squar", "where", "it", "appear", "at", "denomin", "weight", "realli", "weight", "observ", "it", "multipli", "squar", "residu", "even", "comput", "chi2", "onc", "correct", "getrm", "get", "rm", "even", "reduc", "public", "doubl", "getrm", "get", "rm", "return", "math", "sqrt", "getchisquar", "get", "chi", "squar", "row"], "B_title": "Fix ColorConvertor .. ", "B_clean_title": ["fix", "colorconvertor", "color", "convertor"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);     ", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Fix an issue with getPct that was being too verbose .. ", "B_clean_title": ["fix", "issu", "getpct", "get", "pct", "that", "wa", "be", "too", "verbos"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);     ", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Fix getOwnPct return type. ", "B_clean_title": ["fix", "getownpct", "get", "own", "pct", "return", "type"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);     ", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Fix getFrequency ( Object ) to return precise value instead of getCumPct ( Object ). ", "B_clean_title": ["fix", "getfrequ", "get", "frequenc", "object", "return", "precis", "valu", "instead", "getcumpct", "get", "cum", "pct", "object"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);     ", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Add missing import .. Fix getFrequency ( Object ) to return 1  not 2. ", "B_clean_title": ["add", "miss", "import", "fix", "getfrequ", "get", "frequenc", "object", "return", "not"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix Fraction . greatestCommonDivisor ( ). ", "B_clean_title": ["fix", "fraction", "greatestcommondivisor", "greatest", "common", "divisor"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Fix greatestCommonDivisor in Fraction copy. ", "B_clean_title": ["fix", "greatestcommondivisor", "greatest", "common", "divisor", "fraction", "copi"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Removed reverseEach method from XmlConverterTest. ", "B_clean_title": ["remov", "reverseeach", "revers", "each", "method", "xmlconvertertest", "xml", "convert", "test"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "reduce error in SimplexTableau. ", "B_clean_title": ["reduc", "error", "simplextableau", "simplex", "tableau"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Removing epsilon from tableau test .. ", "B_clean_title": ["remov", "epsilon", "tableau", "test"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Using the copy of SimplexTableau  it is better for testing. ", "B_clean_title": ["copi", "simplextableau", "simplex", "tableau", "it", "better", "test"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Updated patch1 - Math - 33 - Hercules . fixed. ", "B_clean_title": ["updat", "patch1", "math", "33", "hercul", "fix"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "Fix missing import. reduce maxUlps to epsilon. ", "B_clean_title": ["fix", "miss", "import", "reduc", "maxulp", "max", "ulp", "epsilon"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "Using the best function to reduce the total number of tests for a fixed situation .. Fix the patch. ", "B_clean_title": ["best", "function", "reduc", "total", "number", "test", "fix", "situat", "fix", "patch"]},
{"A_title": "Fraction percentageValue rare overflowThe percentageValue() method of the Fraction class works by first multiplying the Fraction by 100 then converting the Fraction to a double. This causes overflows when the numerator is greater than Integer.MAX_VALUE/100 even when the value of the fraction is far below this value. The patch changes the method to first convert to a double value and then multiply this value by 100 - the result should be the same but with less overflows. An addition to the test for the method that covers this bug is also included.", "A_clean_title": ["fraction", "percentagevalu", "percentag", "valu", "rare", "overflowth", "overflow", "percentagevalu", "percentag", "valu", "method", "fraction", "class", "work", "by", "first", "multipli", "fraction", "by", "100", "then", "convert", "fraction", "doubl", "thi", "caus", "overflow", "when", "numer", "greater", "than", "integ", "max", "valu", "100", "even", "when", "valu", "fraction", "far", "below", "thi", "valu", "patch", "chang", "method", "first", "convert", "doubl", "valu", "then", "multipli", "thi", "valu", "by", "100", "result", "same", "but", "less", "overflow", "addit", "test", "method", "that", "cover", "thi", "bug", "also", "includ"], "B_title": "Avoid overflow.", "B_clean_title": ["avoid", "overflow"]},
{"A_title": "StringEscapeUtils.escapeJava(String) escapes / charactersCommons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes / characters which is not a valid escapable character in Java strings.  I havent tried the other Java escape/unescape methods to see if they have a similar problem or that only Java escapable characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off in that / should now be included in the sentence describing the differences between Java and Javascript strings with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase      public void testEscapeJavaWithSlash()           final String input = String with a slash (/) in it;                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes / characters          * which are not a valid character to escape in a Java string.            */         assertEquals( expected actual );", "A_clean_title": ["stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "characterscommon", "charact", "common", "lang", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "now", "escap", "charact", "which", "not", "valid", "escap", "charact", "java", "string", "havent", "tri", "other", "java", "escap", "unescap", "method", "see", "they", "have", "similar", "problem", "or", "that", "onli", "java", "escap", "charact", "are", "escap", "by", "escapejava", "escap", "java", "string", "thi", "bug", "may", "have", "appear", "as", "unintend", "side", "effect", "fix", "lang", "363", "also", "javadoc", "escapejava", "escap", "java", "now", "littl", "off", "that", "now", "includ", "sentenc", "describ", "differ", "between", "java", "javascript", "string", "respect", "escap", "rule", "follow", "junit3", "unit3", "test", "demonstr", "bug", "import", "junit", "framework", "testcas", "test", "case", "import", "org", "apach", "common", "lang", "stringescapeutil", "string", "escap", "util", "public", "class", "stringescapeutilstest", "string", "escap", "util", "test", "extend", "testcas", "test", "case", "public", "void", "testescapejavawithslash", "test", "escap", "java", "slash", "final", "string", "input", "string", "slash", "it", "final", "string", "expect", "input", "final", "string", "actual", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "input", "stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "charact", "which", "are", "not", "valid", "charact", "escap", "java", "string", "assertequ", "assert", "equal", "expect", "actual"], "B_title": "StringEscapeUtils.escapeJava(String) escapes / characters", "B_clean_title": ["stringescapeutil", "escapejava", "string", "escap", "util", "escap", "java", "string", "escap", "charact"]},
{"A_title": "NumberUtils.createNumber throws NumberFormatException for one digit longNumberUtils.createNumber throws a NumberFormatException when parsing 1l 2l .. etc... It works fine if you try to parse 01l or 02l.  The condition isDigits(numeric.substring(1)) line 455 return false as numeric.substring(1) is an empty string for 1l", "A_clean_title": ["numberutil", "createnumb", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "one", "digit", "longnumberutil", "createnumb", "long", "number", "util", "creat", "number", "throw", "numberformatexcept", "number", "format", "except", "when", "pars", "1l", "2l", "etc", "it", "work", "fine", "you", "tri", "pars", "01l", "or", "02l", "condit", "isdigit", "digit", "numer", "substr", "line", "455", "return", "fals", "as", "numer", "substr", "empti", "string", "1l"], "B_title": "Fixing LANG-300 (reported by Jeremy Lemaire) - 1L to 9L incorrectly throw exceptions when passed into NumberUtils.createNumber. Fixed in both the math.NumbersUtils and the deprecated NumberUtils classes.", "B_clean_title": ["fix", "lang", "300", "report", "by", "jeremi", "lemair", "1l", "9l", "incorrectli", "throw", "except", "when", "pass", "into", "numberutil", "createnumb", "number", "util", "creat", "number", "fix", "both", "math", "numbersutil", "number", "util", "deprec", "numberutil", "number", "util", "class"]},
{"A_title": "weight versus sigma in AbstractLeastSquaresIn AbstractLeastSquares residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS() these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation it should multiply the square of the residual even in the computation of the chi2.  Once corrected getRMS() can even reduce  public double getRMS()  return Math.sqrt(getChiSquare()/rows);", "A_clean_title": ["weight", "versu", "sigma", "abstractleastsquaresin", "abstract", "least", "squar", "abstractleastsquar", "abstract", "least", "squar", "residualsweight", "residu", "weight", "contain", "weight", "assign", "each", "observ", "method", "getrm", "get", "rm", "these", "weight", "are", "multipl", "as", "they", "unlik", "getchisquar", "get", "chi", "squar", "where", "it", "appear", "at", "denomin", "weight", "realli", "weight", "observ", "it", "multipli", "squar", "residu", "even", "comput", "chi2", "onc", "correct", "getrm", "get", "rm", "even", "reduc", "public", "doubl", "getrm", "get", "rm", "return", "math", "sqrt", "getchisquar", "get", "chi", "squar", "row"], "B_title": "fixed", "B_clean_title": ["fix"]},
{"A_title": "MathUtils.binomialCoefficient(nk) fails for large resultsProbably due to rounding errors MathUtils.binomialCoefficient(nk) fails for results near Long.MAX_VALUE. The existence of failures can be demonstrated by testing the recursive property:           assertEquals(MathUtils.binomialCoefficient(6532) + MathUtils.binomialCoefficient(6533)                  MathUtils.binomialCoefficient(6633));   Or by directly using the (externally calculated and hopefully correct) expected value:           assertEquals(7219428434016265740L MathUtils.binomialCoefficient(6633));   I suggest a nonrecursive test implementation along the lines of MathUtilsTest.java     /**      * Exact implementation using BigInteger and the explicit formula      * (n k) == ((k-1)*...*n) / (1*...*(n-k))      */ public static long binomialCoefficient(int n int k)  if (k == 0 || k == n) return 1; BigInteger result = BigInteger.ONE; for (int i = k + 1; i <= n; i++)  result = result.multiply(BigInteger.valueOf(i));  for (int i = 1; i <= n - k; i++)  result = result.divide(BigInteger.valueOf(i));  if (result.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0)  throw new ArithmeticException(                                 Binomial coefficient overflow:  + n +   + k);  return result.longValue();    Which would allow you to test the expected values directly:           assertEquals(binomialCoefficient(6633) MathUtils.binomialCoefficient(6633));", "A_clean_title": ["mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "nk", "fail", "larg", "resultsprob", "result", "probabl", "due", "round", "error", "mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "nk", "fail", "result", "near", "long", "max", "valu", "exist", "failur", "demonstr", "by", "test", "recurs", "properti", "assertequ", "assert", "equal", "mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "6532", "mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "6533", "mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "6633", "or", "by", "directli", "extern", "calcul", "hope", "correct", "expect", "valu", "assertequ", "assert", "equal", "7219428434016265740l", "mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "6633", "suggest", "nonrecurs", "test", "implement", "along", "line", "mathutilstest", "java", "math", "util", "test", "exact", "implement", "biginteg", "big", "integ", "explicit", "formula", "public", "static", "long", "binomialcoeffici", "binomi", "coeffici", "int", "int", "return", "biginteg", "big", "integ", "result", "biginteg", "one", "big", "integ", "int", "i++", "result", "result", "multipli", "biginteg", "valueof", "big", "integ", "valu", "int", "i++", "result", "result", "divid", "biginteg", "valueof", "big", "integ", "valu", "result", "compareto", "compar", "biginteg", "valueof", "big", "integ", "valu", "long", "max", "valu", "throw", "new", "arithmeticexcept", "arithmet", "except", "binomi", "coeffici", "overflow", "return", "result", "longvalu", "long", "valu", "which", "would", "allow", "you", "test", "expect", "valu", "directli", "assertequ", "assert", "equal", "binomialcoeffici", "binomi", "coeffici", "6633", "mathutil", "binomialcoeffici", "math", "util", "binomi", "coeffici", "6633"], "B_title": "Fixed error in binomial coefficient computation JIRA: MATH-241 Reported and patched by Christian Semrau", "B_clean_title": ["fix", "error", "binomi", "coeffici", "comput", "jira", "math", "241", "report", "patch", "by", "christian", "semrau"]},
{"A_title": "StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 charactersCharacters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely: import org.apache.commons.lang.*; public class J2      public static void main(String args) throws Exception          // this is the utf8 representation of the character:         // COUNTING ROD UNIT DIGIT THREE         // in unicode         // codepoint: U+1D362         byte data = new byte   (byte)0xF0 (byte)0x9D (byte)0x8D (byte)0xA2  ;         //output is: &#55348;&#57186;         // should be: &#119650;         System.out.println( + StringEscapeUtils.escapeHtml(new String(data UTF8)) + );       Should be very quick to fix feel free to drop me an email if you want a patch.", "A_clean_title": ["stringescapeutil", "escapehtml", "string", "escap", "util", "escap", "html", "incorrectli", "convert", "unicod", "charact", "abov", "u+00ffff", "into", "characterscharact", "charact", "charact", "that", "are", "repres", "as", "charact", "internali", "by", "java", "are", "incorrectli", "convert", "by", "function", "follow", "test", "display", "problem", "quit", "nice", "import", "org", "apach", "common", "lang", "public", "class", "j2", "public", "static", "void", "main", "string", "arg", "throw", "except", "thi", "utf8", "represent", "charact", "count", "rod", "unit", "digit", "three", "unicod", "codepoint", "u+1d362", "byte", "data", "new", "byte", "byte", "0xf0", "0x", "f0", "byte", "0x9d", "byte", "0x8d", "byte", "0xa2", "0x", "a2", "output", "55348", "57186", "119650", "system", "out", "println", "stringescapeutil", "escapehtml", "string", "escap", "util", "escap", "html", "new", "string", "data", "utf8", "veri", "quick", "fix", "feel", "free", "drop", "me", "email", "you", "want", "patch"], "B_title": "Applying Alexander Kjalls patch from LANG-480; along with a unit test made from his example. Fixes unicode conversion above U+00FFFF being done into 2 characters", "B_clean_title": ["appli", "alexand", "kjall", "patch", "lang", "480", "along", "unit", "test", "made", "hi", "exampl", "fix", "unicod", "convers", "abov", "u+00ffff", "be", "done", "into", "charact"]},
{"A_title": "Partial.with fails with NPEFails with yearOfCentury year and yearOfEra. Probably because weekyear has a null range duration type.", "A_clean_title": ["partial", "fail", "npefail", "npe", "fail", "yearofcenturi", "year", "centuri", "year", "yearofera", "year", "era", "probabl", "becaus", "weekyear", "ha", "null", "rang", "durat", "type"], "B_title": "Fix NPE in Partial.with()", "B_clean_title": ["fix", "npe", "partial"]},
{"A_title": "GJChronology rejects valid Julian datesThe 2nd statement fails with org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range 128.  Given that I left the cutover date at the default (October 15 1582) isnt 1500/02/29 a valid date in the GJChronology?", "A_clean_title": ["gjchronolog", "gj", "chronolog", "reject", "valid", "julian", "datesth", "date", "2nd", "statement", "fail", "org", "joda", "time", "illegalfieldvalueexcept", "illeg", "field", "valu", "except", "valu", "29", "dayofmonth", "day", "month", "must", "rang", "128", "given", "that", "left", "cutov", "date", "at", "default", "octob", "15", "1582", "isnt", "1500", "02", "29", "valid", "date", "gjchronolog", "gj", "chronolog"], "B_title": "Fix GJChronology to allow some leap year dates in JulianChronology to be created 3446915", "B_clean_title": ["fix", "gjchronolog", "gj", "chronolog", "allow", "some", "leap", "year", "date", "julianchronolog", "julian", "chronolog", "creat", "3446915"]},
{"A_title": "In stat.Frequency getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  @link #getPct(Comparable)  as of 2.0      */     @Deprecated     public double getPct(Object v)           return getCumPct((Comparable<?>) v);", "A_clean_title": ["stat", "frequenc", "getpct", "get", "pct", "object", "use", "getcumpct", "get", "cum", "pct", "compar", "instead", "getpct", "get", "pct", "compar", "drop", "replac", "not", "possibl", "becaus", "all", "getpct", "get", "pct", "call", "will", "cummul", "without", "code", "chang", "frequenc", "java", "return", "percentag", "valu", "that", "are", "equal", "deprec", "replac", "by", "link", "getpct", "get", "pct", "compar", "as", "deprec", "public", "doubl", "getpct", "get", "pct", "object", "return", "getcumpct", "get", "cum", "pct", "compar"], "B_title": "Fixed regression in Frequency.getPct(Object) introduced in 2.0. Cumulative percent was being returned for Object arguments in place of percent.", "B_clean_title": ["fix", "regress", "frequenc", "getpct", "get", "pct", "object", "introduc", "cumul", "percent", "wa", "be", "return", "object", "argument", "place", "percent"]},
{"A_title": "Questionable behaviour of GJChronology when dates pass 1BCI expect the following test to pass:  However I never provided 0 for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?", "A_clean_title": ["question", "behaviour", "gjchronolog", "gj", "chronolog", "when", "date", "pass", "1bci", "expect", "follow", "test", "pass", "howev", "never", "provid", "year", "myself", "thought", "it", "wa", "job", "framework", "skip", "over", "non", "exist", "year", "me", "return", "bc"], "B_title": "Fix GJChronology.plus/minus across cutover and year zero", "B_clean_title": ["fix", "gjchronolog", "gj", "chronolog", "plu", "minu", "across", "cutov", "year", "zero"]},
{"A_title": "FastDateFormat formats year differently than SimpleDateFormat in Java 7Starting with Java 7 does SimpleDateFormat format a year pattern of Y or YYY as 2003 instead of 03 as in former Java releases. According Javadoc this pattern should have been always been formatted as number therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.", "A_clean_title": ["fastdateformat", "fast", "date", "format", "format", "year", "differ", "than", "simpledateformat", "simpl", "date", "format", "java", "7start", "java", "simpledateformat", "simpl", "date", "format", "format", "year", "pattern", "or", "yyy", "as", "2003", "instead", "03", "as", "former", "java", "releas", "accord", "javadoc", "thi", "pattern", "have", "been", "alway", "been", "format", "as", "number", "therefor", "new", "behavior", "seem", "bug", "fix", "jdk", "fastdateformat", "fast", "date", "format", "adjust", "behav", "same"], "B_title": "Adjust FastDateFormat for Java 7 behavior regarding format of the year pattern (LANG-719).", "B_clean_title": ["adjust", "fastdateformat", "fast", "date", "format", "java", "behavior", "regard", "format", "year", "pattern", "lang", "719"]},
{"A_title": "numerical problems in rotation creationbuilding a rotation from the following vector pairs leads to NaN: u1 = -4921140.837095533 -2.1512094250440013E7 -890093.279426377 u2 = -2.7238580938724895E9 -2.169664921341876E9 6.749688708885301E10 v1 = 1 0 0 v2 = 0 0 1 The constructor first changes the (v1 v2) pair into (v1 v2) ensuring the following scalar products hold:  <v1|v1> == <u1|u1>  <v2|v2> == <u2|u2>  <u1 |u2>  == <v1|v2> Once the (v1 v2) pair has been computed we compute the cross product:   k = (v1 - u1)^(v2 - u2) and the scalar product:   c = <k | (u1^u2)> By construction c is positive or null and the quaternion axis we want to build is q = k/2*sqrt(c). c should be null only if some of the vectors are aligned and this is dealt with later in the algorithm. However there are numerical problems with the vector above with the way these computations are done as shown by the following comparisons showing the result we get from our Java code and the result we get from manual computation with the same formulas but with enhanced precision: commons math:   k = 38514476.5            -84.                           -1168590144 high precision: k = 38514410.36093388...  -0.374075245201180409222711... -1168590152.10599715208... and it becomes worse when computing c because the vectors are almost orthogonal to each other hence inducing additional cancellations. We get: commons math    c = -1.2397173627587605E20 high precision: c =  558382746168463196.7079627... We have lost ALL significant digits in cancellations and even the sign is wrong!", "A_clean_title": ["numer", "problem", "rotat", "creationbuild", "rotat", "follow", "vector", "pair", "lead", "nan", "na", "u1", "4921140", "837095533", "1512094250440013e7", "890093", "279426377", "u2", "7238580938724895e9", "169664921341876e9", "749688708885301e10", "v1", "v2", "constructor", "first", "chang", "v1", "v2", "pair", "into", "v1", "v2", "ensur", "follow", "scalar", "product", "hold", "v1|v1", "u1|u1", "v2|v2", "u2|u2", "u1", "|u2", "v1|v2", "onc", "v1", "v2", "pair", "ha", "been", "comput", "we", "comput", "cross", "product", "v1", "u1", "v2", "u2", "scalar", "product", "u1^u2", "by", "construct", "posit", "or", "null", "quaternion", "axi", "we", "want", "build", "sqrt", "null", "onli", "some", "vector", "are", "align", "thi", "dealt", "later", "algorithm", "howev", "there", "are", "numer", "problem", "vector", "abov", "way", "these", "comput", "are", "done", "as", "shown", "by", "follow", "comparison", "show", "result", "we", "get", "our", "java", "code", "result", "we", "get", "manual", "comput", "same", "formula", "but", "enhanc", "precis", "common", "math", "38514476", "84", "1168590144", "high", "precis", "38514410", "36093388", "374075245201180409222711", "1168590152", "10599715208", "it", "becom", "wors", "when", "comput", "becaus", "vector", "are", "almost", "orthogon", "each", "other", "henc", "induc", "addit", "cancel", "we", "get", "common", "math", "2397173627587605e20", "high", "precis", "558382746168463196", "7079627", "we", "have", "lost", "all", "signific", "digit", "cancel", "even", "sign", "wrong"], "B_title": "Fixed a wrong detection of rotation axis versus vectors plane in Rotation constructor using two vectors pairs.", "B_clean_title": ["fix", "wrong", "detect", "rotat", "axi", "versu", "vector", "plane", "rotat", "constructor", "two", "vector", "pair"]},
{"A_title": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE 2^k)The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java // additional test cases public void testReducedFactory_int_int()  // ... f = Fraction.getReducedFraction(Integer.MIN_VALUE 2); assertEquals(Integer.MIN_VALUE / 2 f.getNumerator()); assertEquals(1 f.getDenominator());  public void testReduce()  // ... f = Fraction.getFraction(Integer.MIN_VALUE 2); result = f.reduce(); assertEquals(Integer.MIN_VALUE / 2 result.getNumerator()); assertEquals(1 result.getDenominator());", "A_clean_title": ["org", "apach", "common", "lang3", "math", "fraction", "not", "reduc", "integ", "min", "valu", "2^k", "greatestcommondivisor", "greatest", "common", "divisor", "method", "class", "fraction", "not", "find", "gcd", "integ", "min", "valu", "2^k", "thi", "case", "trigger", "by", "take", "integ", "min", "valu", "as", "numer", "note", "that", "case", "take", "integ", "min", "valu", "as", "denomin", "handl", "explicitli", "getreducedfract", "get", "reduc", "fraction", "factori", "method", "fractiontest", "java", "fraction", "test", "addit", "test", "case", "public", "void", "testreducedfactori", "int", "int", "test", "reduc", "factori", "fraction", "getreducedfract", "get", "reduc", "fraction", "integ", "min", "valu", "assertequ", "assert", "equal", "integ", "min", "valu", "getnumer", "get", "numer", "assertequ", "assert", "equal", "getdenomin", "get", "denomin", "public", "void", "testreduc", "test", "reduc", "fraction", "getfract", "get", "fraction", "integ", "min", "valu", "result", "reduc", "assertequ", "assert", "equal", "integ", "min", "valu", "result", "getnumer", "get", "numer", "assertequ", "assert", "equal", "result", "getdenomin", "get", "denomin"], "B_title": "Adding first method check from Maths MathUtils.gcd method; and unit tests showing that this was needed. Bug reported and solved by Christian Semrau LANG-662", "B_clean_title": ["ad", "first", "method", "check", "math", "mathutil", "gcd", "math", "util", "method", "unit", "test", "show", "that", "thi", "wa", "need", "bug", "report", "solv", "by", "christian", "semrau", "lang", "662"]},
{"A_title": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsExceptionTheres a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj int width char padChar)          if (width > 0)              ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)    ==>            str.getChars(0 strLen buffer size);   <==== BUG: it should be str.getChars(0 width buffer size);               else                  int padLen = width - strLen;                 str.getChars(0 strLen buffer size);                 for (int i = 0; i < padLen; i++)                       buffersize + strLen + i = padChar;                                           size += width;                  return this;      This is causing an ArrayIndexOutOfBoundsException so this method is unusable when strLen > width. Its counterpart method appendFixedWidthPadLeft seems to be ok.", "A_clean_title": ["bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "caus", "arrayindexoutofboundsexceptionther", "array", "index", "out", "bound", "except", "there", "bug", "method", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "class", "strbuilder", "str", "builder", "public", "strbuilder", "str", "builder", "appendfixedwidthpadright", "append", "fix", "width", "pad", "right", "object", "obj", "int", "width", "char", "padchar", "pad", "char", "width", "ensurecapac", "ensur", "capac", "size", "width", "string", "str", "obj", "null", "getnulltext", "get", "null", "text", "obj", "tostr", "string", "int", "strlen", "str", "len", "str", "length", "strlen", "str", "len", "width", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "bug", "it", "str", "getchar", "get", "char", "width", "buffer", "size", "int", "padlen", "pad", "len", "width", "strlen", "str", "len", "str", "getchar", "get", "char", "strlen", "str", "len", "buffer", "size", "int", "padlen", "pad", "len", "i++", "buffers", "strlen", "str", "len", "padchar", "pad", "char", "size", "width", "return", "thi", "thi", "caus", "arrayindexoutofboundsexcept", "array", "index", "out", "bound", "except", "so", "thi", "method", "unus", "when", "strlen", "str", "len", "width", "it", "counterpart", "method", "appendfixedwidthpadleft", "append", "fix", "width", "pad", "left", "seem", "ok"], "B_title": "Applying a unit test for LANG-299 and the fix that Francisco Benavent suggests.", "B_clean_title": ["appli", "unit", "test", "lang", "299", "fix", "that", "francisco", "benav", "suggest"]},
{"A_title": "Incorrect mapping of the MET time zoneThis timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time.", "A_clean_title": ["incorrect", "map", "met", "time", "zonethi", "zone", "thi", "timezon", "map", "asia", "tehran", "datetimezon", "date", "time", "zone", "it", "middl", "europena", "time"], "B_title": "3216471 Time-zone ID MET from java.util.TimeZone is now mapped correctly. Other time-zone conversions have been updated appropriately", "B_clean_title": ["3216471", "time", "zone", "id", "met", "java", "util", "timezon", "time", "zone", "now", "map", "correctli", "other", "time", "zone", "convers", "have", "been", "updat", "appropri"]},
{"A_title": "ConvergenceException in NormalDistributionImpl.cumulativeProbability()I get a ConvergenceException in  NormalDistributionImpl.cumulativeProbability() for very large/small parameters including Infinity -Infinity. For instance in the following code: @Test public void testCumulative()  final NormalDistribution nd = new NormalDistributionImpl(); for (int i = 0; i < 500; i++)  final double val = Math.exp; try   System.out.println(val =  + val +  cumulative =  + nd.cumulativeProbability(val));   catch (MathException e)   e.printStackTrace(); fail();    In version 2.0 I get no exception.  My suggestion is to change in the implementation of cumulativeProbability(double) to catch all ConvergenceException (and return for very large and very small values) not just MaxIterationsExceededException.", "A_clean_title": ["convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "get", "convergenceexcept", "converg", "except", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "veri", "larg", "small", "paramet", "includ", "infin", "infin", "instanc", "follow", "code", "test", "public", "void", "testcumul", "test", "cumul", "final", "normaldistribut", "normal", "distribut", "nd", "new", "normaldistributionimpl", "normal", "distribut", "impl", "int", "500", "i++", "final", "doubl", "val", "math", "exp", "tri", "system", "out", "println", "val", "val", "cumul", "nd", "cumulativeprob", "cumul", "probabl", "val", "catch", "mathexcept", "math", "except", "printstacktrac", "print", "stack", "trace", "fail", "version", "get", "no", "except", "my", "suggest", "chang", "implement", "cumulativeprob", "cumul", "probabl", "doubl", "catch", "all", "convergenceexcept", "converg", "except", "return", "veri", "larg", "veri", "small", "valu", "not", "just", "maxiterationsexceededexcept", "max", "iter", "exceed", "except"], "B_title": "Modified NormalDistributionImpl.cumulativeProbability to return 0 or 1 respectively for values more than 40 standard deviations from the mean. For these values the actual probability is indistinguishable from 0 or 1 as a double.  Top coding improves performance for extreme values and prevents convergence exceptions.", "B_clean_title": ["modifi", "normaldistributionimpl", "cumulativeprob", "normal", "distribut", "impl", "cumul", "probabl", "return", "or", "respect", "valu", "more", "than", "40", "standard", "deviat", "mean", "these", "valu", "actual", "probabl", "indistinguish", "or", "as", "doubl", "top", "code", "improv", "perform", "extrem", "valu", "prevent", "converg", "except"]},
{"A_title": "chiSquare(double expected long observed) is returning incorrect test statisticChiSquareTestImpl is returning incorrect chi-squared value. An implicit assumption of public double chiSquare(double expected long observed) is that the sum of expected and observed are equal. That is in the code: for (int i = 0; i < observed.length; i++)               dev = ((double) observedi - expectedi);             sumSq += dev * dev / expectedi;          this calculation is only correct if sum(observed)==sum(expected). When they are not equal then one must rescale the expected value by sum(observed) / sum(expected) so that they are. Ironically it is an example in the unit test ChiSquareTestTest that highlights the error: long observed1 =   500 623 72 70 31  ;         double expected1 =   485 541 82 61 37  ;         assertEquals( chi-square test statistic 16.4131070362 testStatistic.chiSquare(expected1 observed1) 1E-10);         assertEquals(chi-square p-value 0.002512096 testStatistic.chiSquareTest(expected1 observed1) 1E-9); 16.413 is not correct because the expected values do not make sense they should be: 521.19403 581.37313  88.11940  65.55224  39.76119 so that the sum of expected equals 1296 which is the sum of observed. Here is some R code (r-project.org) which proves it: > o1 1 500 623  72  70  31 > e1 1 485 541  82  61  37 > chisq.test(o1p=e1rescale.p=TRUE)         Chi-squared test for given probabilities data:  o1  X-squared = 9.0233 df = 4 p-value = 0.06052 > chisq.test(o1p=e1rescale.p=TRUE) observed 1 500 623  72  70  31 > chisq.test(o1p=e1rescale.p=TRUE) expected 1 521.19403 581.37313  88.11940  65.55224  39.76119", "A_clean_title": ["chisquar", "chi", "squar", "doubl", "expect", "long", "observ", "return", "incorrect", "test", "statisticchisquaretestimpl", "statist", "chi", "squar", "test", "impl", "return", "incorrect", "chi", "squar", "valu", "implicit", "assumpt", "public", "doubl", "chisquar", "chi", "squar", "doubl", "expect", "long", "observ", "that", "sum", "expect", "observ", "are", "equal", "that", "code", "int", "observ", "length", "i++", "dev", "doubl", "observedi", "expectedi", "sumsq", "sum", "sq", "dev", "dev", "expectedi", "thi", "calcul", "onli", "correct", "sum", "observ", "==sum", "expect", "when", "they", "are", "not", "equal", "then", "one", "must", "rescal", "expect", "valu", "by", "sum", "observ", "sum", "expect", "so", "that", "they", "are", "iron", "it", "exampl", "unit", "test", "chisquaretesttest", "chi", "squar", "test", "test", "that", "highlight", "error", "long", "observed1", "500", "623", "72", "70", "31", "doubl", "expected1", "485", "541", "82", "61", "37", "assertequ", "assert", "equal", "chi", "squar", "test", "statist", "16", "4131070362", "teststatist", "chisquar", "test", "statist", "chi", "squar", "expected1", "observed1", "1e", "10", "assertequ", "assert", "equal", "chi", "squar", "valu", "002512096", "teststatist", "chisquaretest", "test", "statist", "chi", "squar", "test", "expected1", "observed1", "1e", "16", "413", "not", "correct", "becaus", "expect", "valu", "not", "make", "sens", "they", "521", "19403", "581", "37313", "88", "11940", "65", "55224", "39", "76119", "so", "that", "sum", "expect", "equal", "1296", "which", "sum", "observ", "here", "some", "code", "project", "org", "which", "prove", "it", "o1", "500", "623", "72", "70", "31", "e1", "485", "541", "82", "61", "37", "chisq", "test", "o1p=e1rescal", "p=true", "chi", "squar", "test", "given", "probabl", "data", "o1", "squar", "0233", "df", "valu", "06052", "chisq", "test", "o1p=e1rescal", "p=true", "observ", "500", "623", "72", "70", "31", "chisq", "test", "o1p=e1rescal", "p=true", "expect", "521", "19403", "581", "37313", "88", "11940", "65", "55224", "39", "76119"], "B_title": "Added check and rescaling of expected counts to sum to sum of expected counts if necessary in ChiSquare test. JIRA: MATH-175 Reported and patched by Carl Anderson.", "B_clean_title": ["ad", "check", "rescal", "expect", "count", "sum", "sum", "expect", "count", "necessari", "chisquar", "chi", "squar", "test", "jira", "math", "175", "report", "patch", "by", "carl", "anderson"]},
{"A_title": "SimplexSolver gives bad resultsMethode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.", "A_clean_title": ["simplexsolv", "simplex", "solver", "give", "bad", "resultsmethod", "result", "method", "simplexsolv", "optimez", "simplex", "solver", "give", "bad", "result", "common", "math3", "simpl", "test", "problem", "it", "work", "well", "common", "math"], "B_title": "use epsilon criteria when deciding to drop columns after phase 1.", "B_clean_title": ["use", "epsilon", "criteria", "when", "decid", "drop", "column", "after", "phase"]},
{"A_title": "NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal PlaceNumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g. 2. should be considered a number because new BigDecimal(2.) works fine.  This could be done by adding the code below after line 1444 which is the if (charsi == e || charsi == E) block. if (charsi == .)      if (hasDecPoint || hasExp)           // two decimal points or dec in exponent            return false;          return foundDigit; // single trailing decimal point after non-exponent is ok", "A_clean_title": ["numberutil", "isnumb", "number", "util", "number", "return", "true", "valid", "number", "trail", "decim", "placenumberutil", "isnumb", "place", "number", "util", "number", "return", "true", "valid", "number", "end", "trail", "decim", "place", "consid", "number", "becaus", "new", "bigdecim", "big", "decim", "work", "fine", "thi", "could", "done", "by", "ad", "code", "below", "after", "line", "1444", "which", "charsi", "charsi", "block", "charsi", "hasdecpoint", "ha", "dec", "point", "hasexp", "ha", "exp", "two", "decim", "point", "or", "dec", "expon", "return", "fals", "return", "founddigit", "found", "digit", "singl", "trail", "decim", "point", "after", "non", "expon", "ok"], "B_title": "isNumber(String) and createNumber(String) both modified to support 2.. LANG-521", "B_clean_title": ["isnumb", "number", "string", "createnumb", "creat", "number", "string", "both", "modifi", "support", "lang", "521"]},
{"A_title": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.A semicolon is introduced into the class name at the end for all arrays... String sArray = new String2; sArray0 = mark; sArray1 = is cool; String simpleString = chris; assertEquals(String ClassUtils.getShortClassName(simpleString null)); assertEquals(String; ClassUtils.getShortClassName(sArray null));", "A_clean_title": ["classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "will", "not", "work", "array", "it", "seem", "add", "semicolon", "end", "semicolon", "introduc", "into", "class", "name", "at", "end", "all", "array", "string", "sarray", "array", "new", "string2", "sarray0", "array0", "mark", "sarray1", "array1", "cool", "string", "simplestr", "simpl", "string", "chri", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "simplestr", "simpl", "string", "null", "assertequ", "assert", "equal", "string", "classutil", "getshortclassnam", "class", "util", "get", "short", "class", "name", "sarray", "array", "null"], "B_title": "Applying my patch from LANG-535 - adding support to getShortClassName and getPackageName for arrays including primitive arrays and multi-dimensional arrays. Also stopped getPackageName relying on the underlying class.getPackage as its sometimes null", "B_clean_title": ["appli", "my", "patch", "lang", "535", "ad", "support", "getshortclassnam", "get", "short", "class", "name", "getpackagenam", "get", "packag", "name", "array", "includ", "primit", "array", "multi", "dimension", "array", "also", "stop", "getpackagenam", "get", "packag", "name", "reli", "underli", "class", "getpackag", "get", "packag", "as", "it", "sometim", "null"]},
{"A_title": "AbstractEstimator: getCovariances() and guessParametersErrors() crash when having bound parametersthe two methods getCovariances() and guessParametersErrors() from org.apache.commons.math.estimation.AbstractEstimator crash with ArrayOutOfBounds exception when some of the parameters are bound. The reason is that the Jacobian is calculated only for the unbound parameters. in the code you loop through all parameters. line #166: final int cols = problem.getAllParameters().length; should be replaced by:  final int cols = problem.getUnboundParameters().length; (similar changes could be done in guessParametersErrors()) the dissadvantage of the above bug fix is that what is returned to the user is an array with smaller size than the number of all parameters. Alternatively you can have some logic in the code which writes zeros for the elements of the covariance matrix corresponding to the bound parameters", "A_clean_title": ["abstractestim", "abstract", "estim", "getcovari", "get", "covari", "guessparameterserror", "guess", "paramet", "error", "crash", "when", "have", "bound", "parametersth", "two", "method", "getcovari", "get", "covari", "guessparameterserror", "guess", "paramet", "error", "org", "apach", "common", "math", "estim", "abstractestim", "abstract", "estim", "crash", "arrayoutofbound", "array", "out", "bound", "except", "when", "some", "paramet", "are", "bound", "reason", "that", "jacobian", "calcul", "onli", "unbound", "paramet", "code", "you", "loop", "through", "all", "paramet", "line", "166", "final", "int", "col", "problem", "getallparamet", "get", "all", "paramet", "length", "replac", "by", "final", "int", "col", "problem", "getunboundparamet", "get", "unbound", "paramet", "length", "similar", "chang", "could", "done", "guessparameterserror", "guess", "paramet", "error", "dissadvantag", "abov", "bug", "fix", "that", "what", "return", "user", "array", "smaller", "size", "than", "number", "all", "paramet", "altern", "you", "have", "some", "logic", "code", "which", "write", "zero", "element", "covari", "matrix", "correspond", "bound", "paramet"], "B_title": "fixed crashes in AbstractEstimator when some parameters are bound. getCovariances() and guessParametersErrors() now only give result about unbound parameters JIRA: MATH-200", "B_clean_title": ["fix", "crash", "abstractestim", "abstract", "estim", "when", "some", "paramet", "are", "bound", "getcovari", "get", "covari", "guessparameterserror", "guess", "paramet", "error", "now", "onli", "give", "result", "about", "unbound", "paramet", "jira", "math", "200"]},
{"A_title": "RegulaFalsiSolver failureThe following unit test:  @Test public void testBug()      final UnivariateRealFunction f = new UnivariateRealFunction()              @Override             public double value(double x)                  return Math.exp(x) - Math.pow(Math.PI 3.0);                      ;      UnivariateRealSolver solver = new RegulaFalsiSolver();     double root = solver.solve(100 f 1 10);    fails with  illegal state: maximal count (100) exceeded: evaluations   Using PegasusSolver the answer is found after 17 evaluations.", "A_clean_title": ["regulafalsisolv", "regula", "falsi", "solver", "failureth", "failur", "follow", "unit", "test", "test", "public", "void", "testbug", "test", "bug", "final", "univariaterealfunct", "univari", "real", "function", "new", "univariaterealfunct", "univari", "real", "function", "overrid", "public", "doubl", "valu", "doubl", "return", "math", "exp", "math", "pow", "math", "pi", "univariaterealsolv", "univari", "real", "solver", "solver", "new", "regulafalsisolv", "regula", "falsi", "solver", "doubl", "root", "solver", "solv", "100", "10", "fail", "illeg", "state", "maxim", "count", "100", "exceed", "evalu", "pegasussolv", "pegasu", "solver", "answer", "found", "after", "17", "evalu"], "B_title": "Work around infinite loop.", "B_clean_title": ["work", "around", "infinit", "loop"]},
{"A_title": "Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environmentsThe thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapps use of LANG triggers the loading of this class a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.", "A_clean_title": ["use", "threadloc", "thread", "local", "tostringstyl", "string", "style", "hashcodebuild", "hash", "code", "builder", "trigger", "memori", "leak", "contain", "environmentsth", "environ", "thread", "local", "org", "apach", "common", "lang3", "builder", "tostringstyl", "string", "style", "creat", "but", "never", "remov", "no", "api", "provid", "remov", "it", "webapp", "use", "lang", "trigger", "load", "thi", "class", "refer", "chain", "will", "creat", "that", "will", "caus", "memori", "leak", "web", "applic", "reload", "see", "http", "markmail", "org", "thread", "uetw2fdrsqgbh2cv", "more", "info"], "B_title": "part 2: refactor ToStringStyle and ToStringBuilderTest to verify that we are unsetting the registry when no longer needed", "B_clean_title": ["part", "refactor", "tostringstyl", "string", "style", "tostringbuildertest", "string", "builder", "test", "verifi", "that", "we", "are", "unset", "registri", "when", "no", "longer", "need"]},
{"A_title": "MultiDirectional optimzation loops forver if started at the correct solutionMultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.", "A_clean_title": ["multidirect", "multi", "direct", "optimz", "loop", "forver", "start", "at", "correct", "solutionmultidirect", "iteratesimplex", "solut", "multi", "direct", "iter", "simplex", "loop", "forev", "start", "point", "correct", "solut", "see", "attach", "test", "case", "testmultidirectionalcorrectstart", "test", "multi", "direct", "correct", "start", "as", "exampl"], "B_title": "Prevent infinite loops in multi-directional direct optimization method when the start point is exactly at the optimal point JIRA: MATH-283", "B_clean_title": ["prevent", "infinit", "loop", "multi", "direct", "direct", "optim", "method", "when", "start", "point", "exactli", "at", "optim", "point", "jira", "math", "283"]},
{"A_title": "new multivariate vector optimizers cannot be used with large number of weightsWhen using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created (and copied) when a n elements vector is used. This exhausts memory when n is large. This happens for example when using curve fitters (even simple curve fitters like polynomial ones for low degree) with large number of points. I encountered this with curve fitting on 41200 points which created a matrix with 1.7 billion elements.", "A_clean_title": ["new", "multivari", "vector", "optim", "not", "use", "larg", "number", "weightswhen", "weight", "when", "weigth", "class", "pass", "larg", "number", "weight", "multivari", "vector", "optim", "nxn", "full", "matrix", "creat", "copi", "when", "element", "vector", "use", "thi", "exhaust", "memori", "when", "larg", "thi", "happen", "exampl", "when", "curv", "fitter", "even", "simpl", "curv", "fitter", "like", "polynomi", "one", "low", "degre", "larg", "number", "point", "encount", "thi", "curv", "fit", "41200", "point", "which", "creat", "matrix", "billion", "element"], "B_title": "Avoid memory exhaustion for large number of unclorrelated observations.", "B_clean_title": ["avoid", "memori", "exhaust", "larg", "number", "unclorrel", "observ"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "The best point is sometimes not the last one evaluated.", "B_clean_title": ["best", "point", "sometim", "not", "last", "one", "evalu"]}]