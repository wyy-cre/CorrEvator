[{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "formatting of numbers with spaces does not make much sense for number utils. ", "B_clean_title": ["format", "number", "space", "not", "make", "much", "sens", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix BigDecimal from string startsWith ( # 77 ). ", "B_clean_title": ["fix", "bigdecim", "big", "decim", "string", "startswith", "start", "77"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Handle early NPE when NumberUtils . startsWith ( ) is true. ", "B_clean_title": ["handl", "earli", "npe", "when", "numberutil", "number", "util", "startswith", "start", "true"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  --  from NumberUtils . startsWith ( )  it was restricting our. ", "B_clean_title": ["remov", "unnecessari", "numberutil", "number", "util", "startswith", "start", "it", "wa", "restrict", "our"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix 0x mistake in patch. ", "B_clean_title": ["fix", "0x", "mistak", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "NumberUtils#createNumber - bad behaviour for leading --", "B_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead"]},
{"A_title": "StringEscapeUtils.escapeXML() cant process UTF-16 supplementary charactersSupplementary characters in UTF-16 are those whose code points are above 0xffff that is require more than 1 Java char to be encoded as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/ Currently StringEscapeUtils.escapeXML() isnt aware of this coding scheme and treats each char as one character which is not always right. A possible solution in class Entities would be:     public void escape(Writer writer String str) throws IOException          int len = str.length();         for (int i = 0; i < len; i++)              int code = str.codePointAt;             String entityName = this.entityName(code);             if (entityName != null)                   writer.write(&);                 writer.write(entityName);                 writer.write(;);               else if (code > 0x7F)                       writer.write(&#);                     writer.write(code);                     writer.write(;);               else                       writer.write((char) code);                           if (code > 0xffff)                       i++;                            Besides fixing escapeXML() this will also affect HTML escaping functions. I guess thats a good thing but please remember I have only tested escapeXML().", "A_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "cant", "process", "utf", "16", "supplementari", "characterssupplementari", "charact", "supplementari", "charact", "utf", "16", "are", "those", "whose", "code", "point", "are", "abov", "0xffff", "that", "requir", "more", "than", "java", "char", "encod", "as", "explain", "here", "http", "sun", "java", "com", "develop", "technicalarticl", "intl", "supplementari", "technic", "articl", "current", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "isnt", "awar", "thi", "code", "scheme", "treat", "each", "char", "as", "one", "charact", "which", "not", "alway", "right", "possibl", "solut", "class", "entiti", "would", "public", "void", "escap", "writer", "writer", "string", "str", "throw", "ioexcept", "io", "except", "int", "len", "str", "length", "int", "len", "i++", "int", "code", "str", "codepointat", "code", "point", "at", "string", "entitynam", "entiti", "name", "thi", "entitynam", "entiti", "name", "code", "entitynam", "entiti", "name", "null", "writer", "write", "writer", "write", "entitynam", "entiti", "name", "writer", "write", "code", "0x7f", "writer", "write", "writer", "write", "code", "writer", "write", "writer", "write", "char", "code", "code", "0xffff", "i++", "besid", "fix", "escapexml", "escap", "xml", "thi", "will", "also", "affect", "html", "escap", "function", "guess", "that", "good", "thing", "but", "pleas", "rememb", "have", "onli", "test", "escapexml", "escap", "xml"], "B_title": "Adding a test and code fix to have supplementary chars working in numeric entity unescaping. See LANG-617", "B_clean_title": ["ad", "test", "code", "fix", "have", "supplementari", "char", "work", "numer", "entiti", "unescap", "see", "lang", "617"]},
{"A_title": "StringIndexOutOfBoundsException when calling unescapeHtml4(&#03)When calling unescapeHtml4() on the String &#03 (or any String that contains these characters) an Exception is thrown: Exception in thread main java.lang.StringIndexOutOfBoundsException: String index out of range: 4 at java.lang.String.charAt(String.java:686) at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49) at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60) at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "call", "unescapehtml4", "unescap", "html4", "03", "when", "call", "unescapehtml4", "unescap", "html4", "string", "03", "or", "ani", "string", "that", "contain", "these", "charact", "except", "thrown", "except", "thread", "main", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:686", "at", "org", "apach", "common", "lang3", "text", "translat", "numericentityunescap", "translat", "numer", "entiti", "unescap", "numericentityunescap", "java:49", "numer", "entiti", "unescap", "at", "org", "apach", "common", "lang3", "text", "translat", "aggregatetransl", "translat", "aggreg", "translat", "aggregatetransl", "java:53", "aggreg", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:88", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:60", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "unescapehtml4", "string", "escap", "util", "unescap", "html4", "stringescapeutil", "java:351", "string", "escap", "util"], "B_title": "Adding tests and resolving LANG-710 reported by Benjamin Valentin. Note that this changed such that the code will now escape an unfinished entity (i.e. &#030). This matches browser behaviour.", "B_clean_title": ["ad", "test", "resolv", "lang", "710", "report", "by", "benjamin", "valentin", "note", "that", "thi", "chang", "such", "that", "code", "will", "now", "escap", "unfinish", "entiti", "030", "thi", "match", "browser", "behaviour"]}]