[{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fix copy year. ", "B_clean_title": ["fix", "copi", "year"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0) ", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "Fix gcd ( ). ", "B_clean_title": ["fix", "gcd"]},
{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fix DateTimeFormatter.parseInto() where it obtains the default year", "B_clean_title": ["fix", "datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "where", "it", "obtain", "default", "year"]},
{"A_title": "infinite loop in Fraction.reduce when numerator == 0Summary pretty much says it all.", "A_clean_title": ["infinit", "loop", "fraction", "reduc", "when", "numer", "0summari", "pretti", "much", "say", "it", "all"], "B_title": "Fixed a bug in Fraction . reduce ( ) where the numerator = 0 would trigger an inf.", "B_clean_title": ["fix", "a", "bug", "fraction", "reduce", "where", "the", "numerator", "would", "trigger", "an", "inf"]},
{"A_title": "Method getResult() in MultiStartUnivariateRealOptimizerIn MultiStartUnivariateRealOptimizer (package optimization) the method getResult returns the result of the last run of the underlying optimizer; this last result might not be the best one in which case it will not correspond to the value returned by the optimize method. This is confusing and does not seem very useful. I think that getResult should be defined as    public double getResult()      return optima0;    and similarly  public double getFunctionValue()      return optimaValues0;", "A_clean_title": ["method", "getresult", "get", "result", "multistartunivariaterealoptimizerin", "multi", "start", "univari", "real", "optim", "multistartunivariaterealoptim", "multi", "start", "univari", "real", "optim", "packag", "optim", "method", "getresult", "get", "result", "return", "result", "last", "run", "underli", "optim", "thi", "last", "result", "might", "not", "best", "one", "which", "case", "it", "will", "not", "correspond", "valu", "return", "by", "optim", "method", "thi", "confus", "not", "seem", "veri", "use", "think", "that", "getresult", "get", "result", "defin", "as", "public", "doubl", "getresult", "get", "result", "return", "optima0", "similarli", "public", "doubl", "getfunctionvalu", "get", "function", "valu", "return", "optimavalues0", "optima", "values0"], "B_title": "Fixed inconsistent definition of getResult. Modified associated test accordingly.", "B_clean_title": ["fix", "inconsist", "definit", "getresult", "get", "result", "modifi", "associ", "test", "accordingli"]},
{"A_title": "new multivariate vector optimizers cannot be used with large number of weightsWhen using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created (and copied) when a n elements vector is used. This exhausts memory when n is large. This happens for example when using curve fitters (even simple curve fitters like polynomial ones for low degree) with large number of points. I encountered this with curve fitting on 41200 points which created a matrix with 1.7 billion elements.", "A_clean_title": ["new", "multivari", "vector", "optim", "not", "use", "larg", "number", "weightswhen", "weight", "when", "weigth", "class", "pass", "larg", "number", "weight", "multivari", "vector", "optim", "nxn", "full", "matrix", "creat", "copi", "when", "element", "vector", "use", "thi", "exhaust", "memori", "when", "larg", "thi", "happen", "exampl", "when", "curv", "fitter", "even", "simpl", "curv", "fitter", "like", "polynomi", "one", "low", "degre", "larg", "number", "point", "encount", "thi", "curv", "fit", "41200", "point", "which", "creat", "matrix", "billion", "element"], "B_title": "Using a diagonal matrix to avoid exhausting memory.", "B_clean_title": ["diagon", "matrix", "avoid", "exhaust", "memori"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0)", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "fixed overflow error in gdc computation JIRA: MATH-238", "B_clean_title": ["fix", "overflow", "error", "gdc", "comput", "jira", "math", "238"]}]