[{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fix copy year. ", "B_clean_title": ["fix", "copi", "year"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "long not int ( not long ). ", "B_clean_title": ["long", "not", "int", "not", "long"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "changed int to double .. ", "B_clean_title": ["chang", "int", "doubl"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "Fix warning. ", "B_clean_title": ["fix", "warn"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix build. formatting fixes. ", "B_clean_title": ["fix", "build", "format", "fix"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Fix post - release build. ", "B_clean_title": ["fix", "post", "releas", "build"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0) ", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "Fix gcd ( ). ", "B_clean_title": ["fix", "gcd"]},
{"A_title": "DateUtils.isSameLocalTime does not work correctHi I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)", "A_clean_title": ["dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "not", "work", "correcthi", "correct", "hi", "think", "found", "bug", "dateutil", "date", "util", "class", "method", "issamelocaltim", "same", "local", "time", "exampl", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297364400000l", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297321200000l", "assert", "assertfals", "assert", "fals", "dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "thi", "becaus", "method", "compar", "cal1", "get", "calendar", "hour", "cal2", "get", "calendar", "hour", "but", "think", "it", "ha", "cal1", "get", "calendar", "hour", "day", "cal2", "get", "calendar", "hour", "day"], "B_title": "Fixed fall through in DateUtils . java. ", "B_clean_title": ["fix", "fall", "through", "dateutil", "date", "util", "java"]},
{"A_title": "Fraction(double int) constructor strange behaviourThe Fraction constructor Fraction(double int) takes a double value and a int maximal denominator and approximates a fraction. When the double value is a large negative number with many digits in the fractional part and the maximal denominator is a big positive integer (in the 100000s) two distinct bugs can manifest: 1: the constructor returns a positive Fraction. Calling Fraction(-33655.1677817278 371880) returns the fraction 410517235/243036 which both has the wrong sign and is far away from the absolute value of the given value 2: the constructor does not manage to reduce the Fraction properly. Calling Fraction(-43979.60679604749 366081) returns the fraction -1651878166/256677 which should have* been reduced to -24654898/3831. I have as of yet not found a solution. The constructor looks like this: public Fraction(double value int maxDenominator)         throws FractionConversionException             this(value 0 maxDenominator 100);       Increasing the 100 value (max iterations) does not fix the problem for all cases. Changing the 0-value (the epsilon maximum allowed error) to something small does not work either as this breaks the tests in FractionTest.  The problem is not neccissarily that the algorithm is unable to approximate a fraction correctly. A solution where a FractionConversionException had been thrown in each of these examples would probably be the best solution if an improvement on the approximation algorithm turns out to be hard to find. This bug has been found when trying to explore the idea of axiom-based testing (http://bldl.ii.uib.no/testing.html). Attached is a java test class FractionTestByAxiom (junit goes into org.apache.commons.math3.fraction) which shows these bugs through a simplified approach to this kind of testing and a text file describing some of the value/maxDenominator combinations which causes one of these failures.  It is never specified in the documentation that the Fraction class guarantees that completely reduced rational numbers are constructed but a comment inside the equals method claims that since fractions are always in lowest terms numerators and can be compared directly for equality so it seems like this is the intention.", "A_clean_title": ["fraction", "doubl", "int", "constructor", "strang", "behaviourth", "behaviour", "fraction", "constructor", "fraction", "doubl", "int", "take", "doubl", "valu", "int", "maxim", "denomin", "approxim", "fraction", "when", "doubl", "valu", "larg", "neg", "number", "mani", "digit", "fraction", "part", "maxim", "denomin", "big", "posit", "integ", "100000", "two", "distinct", "bug", "manifest", "constructor", "return", "posit", "fraction", "call", "fraction", "33655", "1677817278", "371880", "return", "fraction", "410517235", "243036", "which", "both", "ha", "wrong", "sign", "far", "away", "absolut", "valu", "given", "valu", "constructor", "not", "manag", "reduc", "fraction", "properli", "call", "fraction", "43979", "60679604749", "366081", "return", "fraction", "1651878166", "256677", "which", "have", "been", "reduc", "24654898", "3831", "have", "as", "yet", "not", "found", "solut", "constructor", "look", "like", "thi", "public", "fraction", "doubl", "valu", "int", "maxdenomin", "max", "denomin", "throw", "fractionconversionexcept", "fraction", "convers", "except", "thi", "valu", "maxdenomin", "max", "denomin", "100", "increas", "100", "valu", "max", "iter", "not", "fix", "problem", "all", "case", "chang", "valu", "epsilon", "maximum", "allow", "error", "someth", "small", "not", "work", "either", "as", "thi", "break", "test", "fractiontest", "fraction", "test", "problem", "not", "neccissarili", "that", "algorithm", "unabl", "approxim", "fraction", "correctli", "solut", "where", "fractionconversionexcept", "fraction", "convers", "except", "had", "been", "thrown", "each", "these", "exampl", "would", "probabl", "best", "solut", "improv", "approxim", "algorithm", "turn", "out", "hard", "find", "thi", "bug", "ha", "been", "found", "when", "tri", "explor", "idea", "axiom", "base", "test", "http", "ii", "uib", "html", "bldl", "no", "test", "attach", "java", "test", "class", "fractiontestbyaxiom", "fraction", "test", "by", "axiom", "junit", "goe", "into", "org", "apach", "common", "math3", "fraction", "which", "show", "these", "bug", "through", "simplifi", "approach", "thi", "kind", "test", "text", "file", "describ", "some", "valu", "maxdenomin", "max", "denomin", "combin", "which", "caus", "one", "these", "failur", "it", "never", "specifi", "document", "that", "fraction", "class", "guarante", "that", "complet", "reduc", "ration", "number", "are", "construct", "but", "comment", "insid", "equal", "method", "claim", "that", "sinc", "fraction", "are", "alway", "lowest", "term", "numer", "compar", "directli", "equal", "so", "it", "seem", "like", "thi", "intent"], "B_title": "Improve overflow check for negative values in Fraction constructor.", "B_clean_title": ["improv", "overflow", "check", "neg", "valu", "fraction", "constructor"]},
{"A_title": "BrentOptimizer not always reporting the best pointBrentOptimizer (package o.a.c.m.optimization.univariate) does not check that the point it is going to return is indeed the best one it has encountered. Indeed the last evaluated point might be slightly worse than the one before last.", "A_clean_title": ["brentoptim", "brent", "optim", "not", "alway", "report", "best", "pointbrentoptim", "point", "brent", "optim", "packag", "optim", "univari", "not", "check", "that", "point", "it", "go", "return", "inde", "best", "one", "it", "ha", "encount", "inde", "last", "evalu", "point", "might", "slightli", "wors", "than", "one", "befor", "last"], "B_title": "(second take). Best point must be returned.", "B_clean_title": ["second", "take", "best", "point", "must", "return"]},
{"A_title": "RandomStringUtils throws confusing IAE when end <= startRandomUtils invokes Random#nextInt where n = end - start. If end <= start then Random throws: java.lang.IllegalArgumentException: n must be positive This is confusing and does not identify the source of the problem.", "A_clean_title": ["randomstringutil", "random", "string", "util", "throw", "confus", "iae", "when", "end", "startrandomutil", "start", "random", "util", "invok", "random", "nextint", "next", "int", "where", "end", "start", "end", "start", "then", "random", "throw", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "must", "posit", "thi", "confus", "not", "identifi", "sourc", "problem"], "B_title": "RandomStringUtils throws confusing IAE when end <= start", "B_clean_title": ["randomstringutil", "random", "string", "util", "throw", "confus", "iae", "when", "end", "start"]},
{"A_title": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks because the input mutable date times millis appear to be mishandled and the year for the parse is changed to 1999.", "A_clean_title": ["datetimeformat", "parseinto", "date", "time", "format", "pars", "into", "sometim", "miscalcul", "year", "follow", "code", "which", "ad", "org", "joda", "time", "format", "testdatetimeformatt", "test", "date", "time", "formatt", "break", "becaus", "input", "mutabl", "date", "time", "milli", "appear", "mishandl", "year", "pars", "chang", "1999"], "B_title": "Fix DateTimeFormatter.parseInto() where it obtains the default year", "B_clean_title": ["fix", "datetimeformatt", "parseinto", "date", "time", "formatt", "pars", "into", "where", "it", "obtain", "default", "year"]},
{"A_title": "inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000 0.5).inverseCumulativeProbability(0.5)); This returns 499525 though it should be 499999. Im not sure how it should be fixed but the cause is that the cumulativeProbability method returns Infinity not NaN.  As the result the checkedCumulativeProbability method doesnt work as expected.", "A_clean_title": ["inversecumulativeprob", "invers", "cumul", "probabl", "binomialdistribut", "binomi", "distribut", "return", "wrong", "valu", "larg", "trial", "inversecumulativeprob", "invers", "cumul", "probabl", "method", "binomialdistributionimpl", "binomi", "distribut", "impl", "class", "return", "wrong", "valu", "larg", "trial", "follow", "code", "will", "reproduc", "problem", "system", "out", "println", "new", "binomialdistributionimpl", "binomi", "distribut", "impl", "1000000", "inversecumulativeprob", "invers", "cumul", "probabl", "thi", "return", "499525", "though", "it", "499999", "im", "not", "sure", "how", "it", "fix", "but", "caus", "that", "cumulativeprob", "cumul", "probabl", "method", "return", "infin", "not", "nan", "na", "as", "result", "checkedcumulativeprob", "check", "cumul", "probabl", "method", "doesnt", "work", "as", "expect"], "B_title": "Use modified Lentz-Thompson algorithm for continued fraction evaluation.", "B_clean_title": ["use", "modifi", "lentz", "thompson", "algorithm", "continu", "fraction", "evalu"]},
{"A_title": "StringEscapeUtils.escapeJavaScript() method did not escape / into / it will make IE render page uncorrectlyIf Javascripts including/ IE will parse the scripts uncorrectly actually / should be escaped to /. For example document.getElementById(test).value = <script>alert(aaa);</script>;this expression will make IE render page uncorrect it should be document.getElementById(test).value = <script>alert(aaa);</script>; Btw Springs JavascriptEscape behavor is correct. Try  to run below codes you will find the difference:   String s = <script>alert(aaa);</script>;   String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);   System.out.println(Spring JS Escape : +str);   str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);   System.out.println(Apache Common Lang JS Escape : + str);", "A_clean_title": ["stringescapeutil", "escapejavascript", "string", "escap", "util", "escap", "java", "script", "method", "did", "not", "escap", "into", "it", "will", "make", "ie", "render", "page", "uncorrectlyif", "uncorrectli", "javascript", "includ", "ie", "will", "pars", "script", "uncorrectli", "actual", "escap", "exampl", "document", "getelementbyid", "get", "element", "by", "id", "test", "valu", "script", "alert", "aaa", "script", "thi", "express", "will", "make", "ie", "render", "page", "uncorrect", "it", "document", "getelementbyid", "get", "element", "by", "id", "test", "valu", "script", "alert", "aaa", "script", "btw", "spring", "javascriptescap", "javascript", "escap", "behavor", "correct", "tri", "run", "below", "code", "you", "will", "find", "differ", "string", "script", "alert", "aaa", "script", "string", "str", "org", "springframework", "web", "util", "javascriptutil", "javascriptescap", "java", "script", "util", "java", "script", "escap", "system", "out", "println", "spring", "js", "escap", "+str", "str", "org", "apach", "common", "lang", "stringescapeutil", "escapejavascript", "string", "escap", "util", "escap", "java", "script", "system", "out", "println", "apach", "common", "lang", "js", "escap", "str"], "B_title": "Applying Scott Bassins fix and test from LANG-363", "B_clean_title": ["appli", "scott", "bassin", "fix", "test", "lang", "363"]},
{"A_title": "Check Calendar.ERA in LocalDate.fromCalendarFieldsNone", "A_clean_title": ["check", "calendar", "era", "locald", "fromcalendarfieldsnon", "local", "date", "calendar", "field", "none"], "B_title": "Fix fromCalendarFields()/fromDateFields() to handle era BC correctly", "B_clean_title": ["fix", "fromcalendarfield", "calendar", "field", "fromdatefield", "date", "field", "handl", "era", "bc", "correctli"]},
{"A_title": "BrentSolver throws IllegalArgumentExceptionI am getting this exception: java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: -100000.01.7976931348623157E308  Values: 0.0-101945.04630982173 at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99) at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62) The exception should not be thrown with values  0.0-101945.04630982173 because 0.0 is positive. According to Brent Worden the algorithm should stop and return 0 as the root instead of throwing an exception. The problem comes from this method:     public double solve(double min double max) throws MaxIterationsExceededException          FunctionEvaluationException          clearResult();         verifyInterval(min max);         double yMin = f.value(min);         double yMax = f.value(max);         // Verify bracketing         if (yMin * yMax >= 0)               throw new IllegalArgumentException             (Function values at endpoints do not have different signs. +                       Endpoints:  + min +  + max +  +                        Values:  + yMin +  + yMax + );                          // solve using only the first endpoint as initial guess         return solve(min yMin max yMax min yMin);      One way to fix it would be to add this code after the assignment of yMin and yMax:         if (yMin ==0 || yMax == 0)           return 0;", "A_clean_title": ["brentsolv", "brent", "solver", "throw", "illegalargumentexceptioni", "illeg", "argument", "except", "am", "get", "thi", "except", "java", "lang", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "100000", "01", "7976931348623157e308", "valu", "101945", "04630982173", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:99", "brent", "solver", "at", "org", "apach", "common", "math", "analysi", "brentsolv", "solv", "brent", "solver", "brentsolv", "java:62", "brent", "solver", "except", "not", "thrown", "valu", "101945", "04630982173", "becaus", "posit", "accord", "brent", "worden", "algorithm", "stop", "return", "as", "root", "instead", "throw", "except", "problem", "come", "thi", "method", "public", "doubl", "solv", "doubl", "min", "doubl", "max", "throw", "maxiterationsexceededexcept", "max", "iter", "exceed", "except", "functionevaluationexcept", "function", "evalu", "except", "clearresult", "clear", "result", "verifyinterv", "verifi", "interv", "min", "max", "doubl", "ymin", "min", "valu", "min", "doubl", "ymax", "max", "valu", "max", "verifi", "bracket", "ymin", "min", "ymax", "max", "throw", "new", "illegalargumentexcept", "illeg", "argument", "except", "function", "valu", "at", "endpoint", "not", "have", "differ", "sign", "endpoint", "min", "max", "valu", "ymin", "min", "ymax", "max", "solv", "onli", "first", "endpoint", "as", "initi", "guess", "return", "solv", "min", "ymin", "min", "max", "ymax", "max", "min", "ymin", "min", "one", "way", "fix", "it", "would", "add", "thi", "code", "after", "assign", "ymin", "min", "ymax", "max", "ymin", "min", "==0", "ymax", "max", "return"], "B_title": "ported all changes from trunk between r6152100 (branch 2.0 creation) and r670469 (today) These changes contain fixes for MATH-204 and MATH-205", "B_clean_title": ["port", "all", "chang", "trunk", "between", "r6152100", "branch", "creation", "r670469", "today", "these", "chang", "contain", "fix", "math", "204", "math", "205"]},
{"A_title": "EqualsBuilder dont compare BigDecimals correctlyWhen comparing a BigDecimal the comparing is made using equals not compareTo which is more appropriate in the case of BigDecimal.", "A_clean_title": ["equalsbuild", "equal", "builder", "dont", "compar", "bigdecim", "big", "decim", "correctlywhen", "correctli", "when", "compar", "bigdecim", "big", "decim", "compar", "made", "equal", "not", "compareto", "compar", "which", "more", "appropri", "case", "bigdecim", "big", "decim"], "B_title": "Applying my patch from LANG-393; EqualsBuilder uses compareTo for BigDecimal and not equals", "B_clean_title": ["appli", "my", "patch", "lang", "393", "equalsbuild", "equal", "builder", "use", "compareto", "compar", "bigdecim", "big", "decim", "not", "equal"]},
{"A_title": "infinite loop in Fraction.reduce when numerator == 0 Summary pretty much says it all.", "A_clean_title": ["infinit", "loop", "fraction", "reduc", "when", "numer", "0summari", "pretti", "much", "say", "it", "all"], "B_title": "Fixed a bug in Fraction . reduce ( ) where the numerator = 0 would trigger an inf.", "B_clean_title": ["fix", "a", "bug", "fraction", "reduce", "where", "the", "numerator", "would", "trigger", "an", "inf"]},
{"A_title": "Method createNumber from NumberUtils doesnt work for floating point numbers other than FloatMethod createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown so in fact we will no be returning ever neither a Double nor a BigDecimal.", "A_clean_title": ["method", "createnumb", "creat", "number", "numberutil", "number", "util", "doesnt", "work", "float", "point", "number", "other", "than", "floatmethod", "float", "method", "createnumb", "creat", "number", "numberutil", "number", "util", "tri", "pars", "string", "float", "point", "number", "alway", "first", "as", "float", "that", "will", "caus", "that", "we", "send", "string", "number", "that", "will", "need", "doubl", "or", "even", "bigdecim", "big", "decim", "number", "will", "truncat", "accommod", "into", "float", "without", "except", "thrown", "so", "fact", "we", "will", "no", "return", "ever", "neither", "doubl", "nor", "bigdecim", "big", "decim"], "B_title": "Method createNumber from NumberUtils doesnt work for floating point numbers other than Float", "B_clean_title": ["method", "createnumb", "creat", "number", "numberutil", "number", "util", "doesnt", "work", "float", "point", "number", "other", "than", "float"]},
{"A_title": "Mann-Whitney U Test Suffers From Integer Overflow With Large Data SetsWhen performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets) intermediate integer values used in calculateAsymptoticPValue can overflow leading to invalid results such as p-values of NaN or incorrect calculations. Attached is a patch including a test and a fix which modifies the affected code to use doubles", "A_clean_title": ["mann", "whitney", "test", "suffer", "integ", "overflow", "larg", "data", "setswhen", "set", "when", "perform", "mann", "whitney", "test", "larg", "data", "set", "attach", "test", "use", "two", "1500", "element", "set", "intermedi", "integ", "valu", "use", "calculateasymptoticpvalu", "calcul", "asymptot", "valu", "overflow", "lead", "invalid", "result", "such", "as", "valu", "nan", "na", "or", "incorrect", "calcul", "attach", "patch", "includ", "test", "fix", "which", "modifi", "affect", "code", "use", "doubl"], "B_title": "Patch applied to fix the overflow issue.", "B_clean_title": ["patch", "appli", "fix", "overflow", "issu"]},
{"A_title": "text.ExtendedMessageFormat doesnt override java.text.MessageFormat.equals(Object)Findbugs: Bug: org.apache.commons.lang3.text.ExtendedMessageFormat doesnt override java.text.MessageFormat.equals(Object) Pattern id: EQ_DOESNT_OVERRIDE_EQUALS type: Eq category: STYLE This class extends a class that defines an equals method and adds fields but doesnt define an equals method itself. Thus equality on instances of this class will ignore the identity of the subclass and the added fields. Be sure this is what is intended and that you dont need to override the equals method. Even if you dont need to override the equals method consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super.equals(o).", "A_clean_title": ["text", "extendedmessageformat", "extend", "messag", "format", "doesnt", "overrid", "java", "text", "messageformat", "equal", "messag", "format", "object", "findbug", "bug", "org", "apach", "common", "lang3", "text", "extendedmessageformat", "extend", "messag", "format", "doesnt", "overrid", "java", "text", "messageformat", "equal", "messag", "format", "object", "pattern", "id", "eq", "doesnt", "overrid", "equal", "type", "eq", "categori", "style", "thi", "class", "extend", "class", "that", "defin", "equal", "method", "add", "field", "but", "doesnt", "defin", "equal", "method", "itself", "thu", "equal", "instanc", "thi", "class", "will", "ignor", "ident", "subclass", "ad", "field", "sure", "thi", "what", "intend", "that", "you", "dont", "need", "overrid", "equal", "method", "even", "you", "dont", "need", "overrid", "equal", "method", "consid", "overrid", "it", "anyway", "document", "fact", "that", "equal", "method", "subclass", "just", "return", "result", "invok", "super", "equal"], "B_title": "ExtendedMessageFormat doesnt override equals(Object)", "B_clean_title": ["extendedmessageformat", "extend", "messag", "format", "doesnt", "overrid", "equal", "object"]},
{"A_title": "DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hourDateTimeZone.forOffsetHoursMinutes(hm) cannot handle negative offset < 1 hour like -0:30 due to argument range checking. I used forOffsetMillis() instead.  This should probably be mentioned in the documentation or negative minutes be accepted.", "A_clean_title": ["datetimezon", "foroffsethoursminut", "date", "time", "zone", "offset", "hour", "minut", "not", "handl", "neg", "offset", "hourdatetimezon", "foroffsethoursminut", "hour", "date", "time", "zone", "offset", "hour", "minut", "hm", "not", "handl", "neg", "offset", "hour", "like", "0:30", "due", "argument", "rang", "check", "use", "foroffsetmilli", "offset", "milli", "instead", "thi", "probabl", "mention", "document", "or", "neg", "minut", "accept"], "B_title": "Fix to allow offsets from -00:01 to -00:59", "B_clean_title": ["fix", "allow", "offset", "00:01", "00:59"]},
{"A_title": "math  SimpleRegression getSumSquaredErrorsgetSumSquaredErrors returns -ve value. See test below: public void testSimpleRegression()  double y =    8915.102 8919.302 8923.502 ; double x =   1.107178495 1.107264895 1.107351295 ; double x2 =   1.107178495E2 1.107264895E2 1.107351295E2 ; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++)   reg.addData(xiyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK reg.clear(); for (int i = 0; i < x.length; i++)   reg.addData(x2iyi);  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL", "A_clean_title": ["math", "simpleregress", "simpl", "regress", "getsumsquarederrorsgetsumsquarederror", "get", "sum", "squar", "errorsget", "sum", "squar", "error", "return", "ve", "valu", "see", "test", "below", "public", "void", "testsimpleregress", "test", "simpl", "regress", "doubl", "8915", "102", "8919", "302", "8923", "502", "doubl", "107178495", "107264895", "107351295", "doubl", "x2", "107178495e2", "107264895e2", "107351295e2", "simpleregress", "simpl", "regress", "reg", "new", "simpleregress", "simpl", "regress", "int", "length", "i++", "reg", "adddata", "add", "data", "xiyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "ok", "reg", "clear", "int", "length", "i++", "reg", "adddata", "add", "data", "x2iyi", "asserttru", "assert", "true", "reg", "getsumsquarederror", "get", "sum", "squar", "error", "fail"], "B_title": "Modified getSumSquaredErrors method in SimpleRegression to always return a non-negative result. JIRA: MATH-85 Reported by Mark Osborn Patched by Luc Maisonobe", "B_clean_title": ["modifi", "getsumsquarederror", "get", "sum", "squar", "error", "method", "simpleregress", "simpl", "regress", "alway", "return", "non", "neg", "result", "jira", "math", "85", "report", "by", "mark", "osborn", "patch", "by", "luc", "maisonob"]},
{"A_title": "CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.When fitting with bounds the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval 01.  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.", "A_clean_title": ["cmaesoptim", "cmae", "optim", "bound", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "when", "fit", "bound", "cmaesoptim", "cmae", "optim", "fit", "fine", "near", "lower", "bound", "coars", "near", "upper", "bound", "thi", "becaus", "it", "intern", "map", "fit", "paramet", "rang", "into", "interv", "01", "unit", "least", "precis", "ulp", "between", "float", "point", "number", "much", "smaller", "near", "zero", "than", "near", "one", "thu", "fit", "have", "much", "better", "resolut", "near", "lower", "bound", "which", "map", "zero", "than", "upper", "bound", "which", "map", "one", "will", "attach", "exampl", "program", "demonstr"], "B_title": "Modified encode and decode methods. Unit test testFitAccuracyDependsOnBoundary now passes and is thus enabled. Unit test testConstrainedRosen had to be modified in order to not fail with the new code (starting point is set closer to the solution).", "B_clean_title": ["modifi", "encod", "decod", "method", "unit", "test", "testfitaccuracydependsonboundari", "test", "fit", "accuraci", "depend", "boundari", "now", "pass", "thu", "enabl", "unit", "test", "testconstrainedrosen", "test", "constrain", "rosen", "had", "modifi", "order", "not", "fail", "new", "code", "start", "point", "set", "closer", "solut"]},
{"A_title": "Method getResult() in MultiStartUnivariateRealOptimizerIn MultiStartUnivariateRealOptimizer (package optimization) the method getResult returns the result of the last run of the underlying optimizer; this last result might not be the best one in which case it will not correspond to the value returned by the optimize method. This is confusing and does not seem very useful. I think that getResult should be defined as    public double getResult()      return optima0;    and similarly  public double getFunctionValue()      return optimaValues0;", "A_clean_title": ["method", "getresult", "get", "result", "multistartunivariaterealoptimizerin", "multi", "start", "univari", "real", "optim", "multistartunivariaterealoptim", "multi", "start", "univari", "real", "optim", "packag", "optim", "method", "getresult", "get", "result", "return", "result", "last", "run", "underli", "optim", "thi", "last", "result", "might", "not", "best", "one", "which", "case", "it", "will", "not", "correspond", "valu", "return", "by", "optim", "method", "thi", "confus", "not", "seem", "veri", "use", "think", "that", "getresult", "get", "result", "defin", "as", "public", "doubl", "getresult", "get", "result", "return", "optima0", "similarli", "public", "doubl", "getfunctionvalu", "get", "function", "valu", "return", "optimavalues0", "optima", "values0"], "B_title": "Fixed inconsistent definition of getResult. Modified associated test accordingly.", "B_clean_title": ["fix", "inconsist", "definit", "getresult", "get", "result", "modifi", "associ", "test", "accordingli"]},
{"A_title": "new multivariate vector optimizers cannot be used with large number of weightsWhen using the Weigth class to pass a large number of weights to multivariate vector optimizers an nxn full matrix is created (and copied) when a n elements vector is used. This exhausts memory when n is large. This happens for example when using curve fitters (even simple curve fitters like polynomial ones for low degree) with large number of points. I encountered this with curve fitting on 41200 points which created a matrix with 1.7 billion elements.", "A_clean_title": ["new", "multivari", "vector", "optim", "not", "use", "larg", "number", "weightswhen", "weight", "when", "weigth", "class", "pass", "larg", "number", "weight", "multivari", "vector", "optim", "nxn", "full", "matrix", "creat", "copi", "when", "element", "vector", "use", "thi", "exhaust", "memori", "when", "larg", "thi", "happen", "exampl", "when", "curv", "fitter", "even", "simpl", "curv", "fitter", "like", "polynomi", "one", "low", "degre", "larg", "number", "point", "encount", "thi", "curv", "fit", "41200", "point", "which", "creat", "matrix", "billion", "element"], "B_title": "Using a diagonal matrix to avoid exhausting memory.", "B_clean_title": ["diagon", "matrix", "avoid", "exhaust", "memori"]},
{"A_title": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an l is passed in.Seems to be similar to LANG-300 except that if you dont place a digit in front of the l or L it throws a StringIndexOutOfBoundsException instead.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "thow", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "onli", "pass", "seem", "similar", "lang", "300", "except", "that", "you", "dont", "place", "digit", "front", "or", "it", "throw", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "instead"], "B_title": "Applying test/fix from LANG-457 - getting a StringIndexOutOfBounds from createNumber rather than a NumberFormatException", "B_clean_title": ["appli", "test", "fix", "lang", "457", "get", "stringindexoutofbound", "string", "index", "out", "bound", "createnumb", "creat", "number", "rather", "than", "numberformatexcept", "number", "format", "except"]},
{"A_title": "MathUtils.gcd(u v) fails when u and v both contain a high power of 2The test at the beginning of MathUtils.gcd(u v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.         assertEquals(3 * (1<<15) MathUtils.gcd(3 * (1<<20) 9 * (1<<15))); Fix: Replace the test at the start of MathUtils.gcd()         if (u * v == 0)  by         if (u == 0 || v == 0)", "A_clean_title": ["mathutil", "gcd", "math", "util", "fail", "when", "both", "contain", "high", "power", "2the", "test", "at", "begin", "mathutil", "gcd", "math", "util", "argument", "equal", "zero", "fail", "when", "contain", "high", "enough", "power", "so", "that", "their", "product", "overflow", "zero", "assertequ", "assert", "equal", "15", "mathutil", "gcd", "math", "util", "20", "15", "fix", "replac", "test", "at", "start", "mathutil", "gcd", "math", "util", "by"], "B_title": "fixed overflow error in gdc computation JIRA: MATH-238", "B_clean_title": ["fix", "overflow", "error", "gdc", "comput", "jira", "math", "238"]},
{"A_title": "FastMath.pow deviates from Math.pow for negative finite base values with an exponent 2^52 < y < 2^53As reported by Jeff Hain: pow(doubledouble): Math.pow(-1.05.000000000000001E15) = -1.0 FastMath.pow(-1.05.000000000000001E15) = 1.0 ===> This is due to considering that power is an even integer if it is >= 2^52 while you need to test that it is >= 2^53 for it. ===> replace if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) with if (y >= 2*TWO_POWER_52 || y <= -2*TWO_POWER_52) and that solves it.", "A_clean_title": ["fastmath", "pow", "fast", "math", "deviat", "math", "pow", "neg", "finit", "base", "valu", "expon", "2^52", "2^53a", "report", "by", "jeff", "hain", "pow", "doubledoubl", "math", "pow", "05", "000000000000001e15", "fastmath", "pow", "fast", "math", "05", "000000000000001e15", "thi", "due", "consid", "that", "power", "even", "integ", "it", "2^52", "while", "you", "need", "test", "that", "it", "2^53", "it", "replac", "two", "power", "52", "two", "power", "52", "two", "power", "52", "two", "power", "52", "that", "solv", "it"], "B_title": "Fixed wrong assumption in pow method.", "B_clean_title": ["fix", "wrong", "assumpt", "pow", "method"]},
{"A_title": "Partial.with fails with NPEFails with yearOfCentury year and yearOfEra. Probably because weekyear has a null range duration type.", "A_clean_title": ["partial", "fail", "npefail", "npe", "fail", "yearofcenturi", "year", "centuri", "year", "yearofera", "year", "era", "probabl", "becaus", "weekyear", "ha", "null", "rang", "durat", "type"], "B_title": "Fix NPE in Partial.with()", "B_clean_title": ["fix", "npe", "partial"]},
{"A_title": "DateUtils.isSameLocalTime does not work correctHi I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)", "A_clean_title": ["dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "not", "work", "correcthi", "correct", "hi", "think", "found", "bug", "dateutil", "date", "util", "class", "method", "issamelocaltim", "same", "local", "time", "exampl", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297364400000l", "calendar", "calendar", "getinst", "get", "instanc", "settimeinmilli", "set", "time", "milli", "1297321200000l", "assert", "assertfals", "assert", "fals", "dateutil", "issamelocaltim", "date", "util", "same", "local", "time", "thi", "becaus", "method", "compar", "cal1", "get", "calendar", "hour", "cal2", "get", "calendar", "hour", "but", "think", "it", "ha", "cal1", "get", "calendar", "hour", "day", "cal2", "get", "calendar", "hour", "day"], "B_title": "DateUtils isSameLocalTime() compares the hour using 12hour Calendar.HOUR instead of 24hour Calendar.HOUR_OF_DAY - thanks to Christian", "B_clean_title": ["dateutil", "date", "util", "issamelocaltim", "same", "local", "time", "compar", "hour", "12hour", "calendar", "hour", "instead", "24hour", "calendar", "hour", "day", "thank", "christian"]},
{"A_title": "denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracketWe are using the FDistributionImpl from the commons.math project to do some statistical calculations namely receiving the upper and lower boundaries of a confidence interval. Everything is working fine and the results are matching our reference calculations. However the FDistribution behaves strange if a denominatorDegreeOfFreedom of 2 is used with an alpha-value of 0.95. This results in an IllegalArgumentsException stating: Invalid endpoint parameters:  lowerBound=0.0 initial=Infinity upperBound=1.7976931348623157E308 coming from org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket The problem is the initial parameter to that function wich is POSITIVE_INFINITY and therefore not within the boundaries. I already pinned down the problem to the FDistributions getInitialDomain()-method wich goes like:         return getDenominatorDegreesOfFreedom() /                     (getDenominatorDegreesOfFreedom() - 2.0); Obviously in case of denominatorDegreesOfFreedom == 2 this must lead to a division-by-zero resulting in POSTIVE_INFINITY. The result of this operation is then directly passed into the UnivariateRealSolverUtils.bracket() - method as second argument.", "A_clean_title": ["denominatordegreeoffreedom", "denomin", "degre", "freedom", "fdistribut", "distribut", "lead", "illegalargumentsexcept", "illeg", "argument", "except", "univariaterealsolverutil", "bracketw", "univari", "real", "solver", "util", "bracket", "we", "are", "fdistributionimpl", "distribut", "impl", "common", "math", "project", "some", "statist", "calcul", "name", "receiv", "upper", "lower", "boundari", "confid", "interv", "everyth", "work", "fine", "result", "are", "match", "our", "refer", "calcul", "howev", "fdistribut", "distribut", "behav", "strang", "denominatordegreeoffreedom", "denomin", "degre", "freedom", "use", "alpha", "valu", "95", "thi", "result", "illegalargumentsexcept", "illeg", "argument", "except", "state", "invalid", "endpoint", "paramet", "lowerbound=0", "lower", "bound=0", "initial=infin", "upperbound=1", "7976931348623157e308", "upper", "bound=1", "come", "org", "apach", "common", "math", "analysi", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "problem", "initi", "paramet", "that", "function", "wich", "posit", "infin", "therefor", "not", "within", "boundari", "alreadi", "pin", "down", "problem", "fdistribut", "distribut", "getinitialdomain", "get", "initi", "domain", "method", "wich", "goe", "like", "return", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "getdenominatordegreesoffreedom", "get", "denomin", "degre", "freedom", "obvious", "case", "denominatordegreesoffreedom", "denomin", "degre", "freedom", "thi", "must", "lead", "divis", "by", "zero", "result", "postiv", "infin", "result", "thi", "oper", "then", "directli", "pass", "into", "univariaterealsolverutil", "bracket", "univari", "real", "solver", "util", "method", "as", "second", "argument"], "B_title": "propagated trunk changes from r699157 into branch 2.0 MATH-227.  fixed F distribution inverse CDF computation for small denominator degrees of freedom.", "B_clean_title": ["propag", "trunk", "chang", "r699157", "into", "branch", "math", "227", "fix", "distribut", "invers", "cdf", "comput", "small", "denomin", "degre", "freedom"]},
{"A_title": "FastDateFormat.mRules is not transient or serializableReported by FindBugs. Either we need to make the Rule interface Serializable or make mRules transient and add deserializing code to kick off init().", "A_clean_title": ["fastdateformat", "mrule", "fast", "date", "format", "rule", "not", "transient", "or", "serializablereport", "serializ", "report", "by", "findbug", "find", "bug", "either", "we", "need", "make", "rule", "interfac", "serializ", "or", "make", "mrule", "rule", "transient", "add", "deseri", "code", "kick", "off", "init"], "B_title": "Applying test for #LANG-303 and a fix.", "B_clean_title": ["appli", "test", "lang", "303", "fix"]}]