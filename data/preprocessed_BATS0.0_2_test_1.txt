[{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in solve ( ). ", "B_clean_title": ["fix", "typo", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added missing throws. ", "B_clean_title": ["ad", "miss", "throw"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated imports. Added missing closing parenthesis .. ", "B_clean_title": ["updat", "import", "ad", "miss", "close", "parenthesi"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "formatting of numbers with spaces does not make much sense for number utils. ", "B_clean_title": ["format", "number", "space", "not", "make", "much", "sens", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix BigDecimal from string startsWith ( # 77 ). ", "B_clean_title": ["fix", "bigdecim", "big", "decim", "string", "startswith", "start", "77"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Handle early NPE when NumberUtils . startsWith ( ) is true. ", "B_clean_title": ["handl", "earli", "npe", "when", "numberutil", "number", "util", "startswith", "start", "true"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  --  from NumberUtils . startsWith ( )  it was restricting our. ", "B_clean_title": ["remov", "unnecessari", "numberutil", "number", "util", "startswith", "start", "it", "wa", "restrict", "our"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix 0x mistake in patch. ", "B_clean_title": ["fix", "0x", "mistak", "patch"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "Fix a bug in Frequency . put ( Object  Long ). ", "B_clean_title": ["fix", "bug", "frequenc", "put", "object", "long"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "Fixing rat phase. ", "B_clean_title": ["fix", "rat", "phase"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Use availableLocaleList ( ) instead of cAvailableLocaleSet. ", "B_clean_title": ["use", "availablelocalelist", "avail", "local", "list", "instead", "cavailablelocaleset", "avail", "local", "set"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Fixed LocaleUtils # isAvailableLocale ( ). ", "B_clean_title": ["fix", "localeutil", "local", "util", "isavailablelocal", "avail", "local"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "@@ isAvailableLocale ( )  removed 222 from the comment. ", "B_clean_title": ["isavailablelocal", "avail", "local", "remov", "222", "comment"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Use the available locale list. ", "B_clean_title": ["use", "avail", "local", "list"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Use new java . util . HashSet ( ) instead of cAvailableLocaleSet. ", "B_clean_title": ["use", "new", "java", "util", "hashset", "hash", "set", "instead", "cavailablelocaleset", "avail", "local", "set"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Fixed bug in LocaleUtils. ", "B_clean_title": ["fix", "bug", "localeutil", "local", "util"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Improved javadoc in LocaleUtils. ", "B_clean_title": ["improv", "javadoc", "localeutil", "local", "util"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Add null check. ", "B_clean_title": ["add", "null", "check"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "Fix fieldUtils. ", "B_clean_title": ["fix", "fieldutil", "field", "util"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "Allow negative numbers in FieldUtils. ", "B_clean_title": ["allow", "neg", "number", "fieldutil", "field", "util"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "Fix a bug in FieldUtils. ", "B_clean_title": ["fix", "bug", "fieldutil", "field", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Optimize toBoolean ( ). ", "B_clean_title": ["optim", "toboolean", "boolean"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing return statement. ", "B_clean_title": ["ad", "miss", "return", "statement"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing bracket. ", "B_clean_title": ["miss", "bracket"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in BooleanUtils. ", "B_clean_title": ["ad", "miss", "case", "booleanutil", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing test for Y. ", "B_clean_title": ["miss", "test"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing break. ", "B_clean_title": ["miss", "break"]},
{"A_title": "Dangerous code in PoissonDistributionImplIn the following excerpt from class PoissonDistributionImpl: PoissonDistributionImpl.java     public PoissonDistributionImpl(double p NormalDistribution z)          super();         setNormal(z);         setMean(p);        (1) Overridable methods are called within the constructor. (2) The reference z is stored and modified within the class. Ive encountered problem (1) in several classes while working on issue 348. In those cases in order to remove potential problems I copied/pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether (i.e. make the classes immutable). Problem (2) can also create unexpected behaviour. Is it really necessary to pass the NormalDistribution object; cant it be always created within the class?", "A_clean_title": ["danger", "code", "poissondistributionimplin", "poisson", "distribut", "impl", "follow", "excerpt", "class", "poissondistributionimpl", "poisson", "distribut", "impl", "poissondistributionimpl", "java", "poisson", "distribut", "impl", "public", "poissondistributionimpl", "poisson", "distribut", "impl", "doubl", "normaldistribut", "normal", "distribut", "super", "setnorm", "set", "normal", "setmean", "set", "mean", "overrid", "method", "are", "call", "within", "constructor", "refer", "store", "modifi", "within", "class", "ive", "encount", "problem", "sever", "class", "while", "work", "issu", "348", "those", "case", "order", "remov", "potenti", "problem", "copi", "past", "bodi", "setter", "method", "insid", "constructor", "but", "think", "that", "more", "eleg", "solut", "would", "remov", "setter", "altogeth", "make", "class", "immut", "problem", "also", "creat", "unexpect", "behaviour", "it", "realli", "necessari", "pass", "normaldistribut", "normal", "distribut", "object", "cant", "it", "alway", "creat", "within", "class"], "B_title": "Add missing import. Add a check for strictly positive p = 0 .. ", "B_clean_title": ["add", "miss", "import", "add", "check", "strictli", "posit"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "NumberUtils#createNumber - bad behaviour for leading --", "B_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead"]},
{"A_title": "lang DateUtils.truncate method is buggy when dealing with DST switching hoursTry to truncate 2004-10-31 01:00:00 MDT by hour and youll actually get 2004-10- 31 01:00:00 MST which is one hour after the input hour.     // truncate 2004-10-31 01:00:00 MDT     Date oct31_01MDT = new Date(1099206000000L);         Date result = DateUtils.truncate(oct31_01MDT Calendar.HOUR_OF_DAY);     assertEquals(oct31_01MDT result);", "A_clean_title": ["lang", "dateutil", "truncat", "date", "util", "method", "buggi", "when", "deal", "dst", "switch", "hourstri", "hour", "tri", "truncat", "2004", "10", "31", "01:00:00", "mdt", "by", "hour", "youll", "actual", "get", "2004", "10", "31", "01:00:00", "mst", "which", "one", "hour", "after", "input", "hour", "truncat", "2004", "10", "31", "01:00:00", "mdt", "date", "oct31", "01mdt", "new", "date", "1099206000000l", "date", "result", "dateutil", "truncat", "date", "util", "oct31", "01mdt", "calendar", "hour", "day", "assertequ", "assert", "equal", "oct31", "01mdt", "result"], "B_title": "Adding Nialls fix for LANG-59 - an edge case in date truncation - and his enhancement for the unit test that was there.", "B_clean_title": ["ad", "niall", "fix", "lang", "59", "edg", "case", "date", "truncat", "hi", "enhanc", "unit", "test", "that", "wa", "there"]},
{"A_title": "Bugs in Frequency APII think the existing Frequency API has some bugs in it. The addValue(Object v) method allows one to add a plain Object but one cannot add anything further to the instance as the second add fails with IllegalArgumentException. In fact the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects. This could be fixed by checking that the object is Comparable. Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable. The getCount(Object) and getPct(Object) methods dont fail when given a non-Comparable object (because the class cast exception is caught) however they just return 0 as if the object was not present:          final Object OBJ = new Object();         f.addValue(OBJ); // This ought to fail but doesnt causing the unexpected behaviour below         System.out.println(f.getCount(OBJ)); // 0         System.out.println(f.getPct(OBJ)); // 0.0   Rather than adding extra checks for Comparable it seems to me that the API would be much improved by using Comparable instead of Object. Also it should make it easier to implement generics. However this would cause compilation failures for some programs that pass Object rather than Comparable to the class. These would need recoding but I think they would continue to run OK against the new API. It would also affect the run-time behaviour slightly as the first attempt to add a non-Comparable object would fail rather than the second add of a possibly valid object. But is that a viable program? It can only add one object and any attempt to get statistics will either return 0 or an Exception and applying the instanceof fix would also cause it to fail.", "A_clean_title": ["bug", "frequenc", "apii", "think", "exist", "frequenc", "api", "ha", "some", "bug", "it", "addvalu", "add", "valu", "object", "method", "allow", "one", "add", "plain", "object", "but", "one", "not", "add", "anyth", "further", "instanc", "as", "second", "add", "fail", "illegalargumentexcept", "illeg", "argument", "except", "fact", "problem", "first", "call", "addvalu", "add", "valu", "object", "which", "not", "allow", "plain", "object", "ad", "it", "onli", "allow", "compar", "object", "thi", "could", "fix", "by", "check", "that", "object", "compar", "similar", "consider", "appli", "getcumfreq", "get", "cum", "freq", "object", "getcumpct", "get", "cum", "pct", "object", "method", "they", "will", "onli", "work", "object", "that", "implement", "compar", "getcount", "get", "count", "object", "getpct", "get", "pct", "object", "method", "dont", "fail", "when", "given", "non", "compar", "object", "becaus", "class", "cast", "except", "caught", "howev", "they", "just", "return", "as", "object", "wa", "not", "present", "final", "object", "obj", "new", "object", "addvalu", "add", "valu", "obj", "thi", "ought", "fail", "but", "doesnt", "caus", "unexpect", "behaviour", "below", "system", "out", "println", "getcount", "get", "count", "obj", "system", "out", "println", "getpct", "get", "pct", "obj", "rather", "than", "ad", "extra", "check", "compar", "it", "seem", "me", "that", "api", "would", "much", "improv", "by", "compar", "instead", "object", "also", "it", "make", "it", "easier", "implement", "gener", "howev", "thi", "would", "caus", "compil", "failur", "some", "program", "that", "pass", "object", "rather", "than", "compar", "class", "these", "would", "need", "recod", "but", "think", "they", "would", "continu", "run", "ok", "against", "new", "api", "it", "would", "also", "affect", "run", "time", "behaviour", "slightli", "as", "first", "attempt", "add", "non", "compar", "object", "would", "fail", "rather", "than", "second", "add", "possibl", "valid", "object", "but", "that", "viabl", "program", "it", "onli", "add", "one", "object", "ani", "attempt", "get", "statist", "will", "either", "return", "or", "except", "appli", "instanceof", "fix", "would", "also", "caus", "it", "fail"], "B_title": "- check for Comparable when adding values", "B_clean_title": ["check", "compar", "when", "ad", "valu"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Applying test for LANG-304 and fix to LocaleUtils", "B_clean_title": ["appli", "test", "lang", "304", "fix", "localeutil", "local", "util"]},
{"A_title": "Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exceptionAn overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction.  For example: double d = 0.5000000001; Fraction f = new Fraction(d 10); Patch with unit test on way.", "A_clean_title": ["fraction", "specifi", "maxdenomin", "max", "denomin", "valu", "veri", "close", "simpl", "fraction", "not", "throw", "overflow", "exceptionan", "except", "overflow", "except", "thrown", "when", "fraction", "initi", "maxdenomin", "max", "denomin", "doubl", "that", "veri", "close", "simpl", "fraction", "exampl", "doubl", "5000000001", "fraction", "new", "fraction", "10", "patch", "unit", "test", "way"], "B_title": "Fix creation of Fraction/BigFraction objects in maxDenominator mode when the value is close to an actual fraction.", "B_clean_title": ["fix", "creation", "fraction", "bigfract", "big", "fraction", "object", "maxdenomin", "max", "denomin", "mode", "when", "valu", "close", "actual", "fraction"]},
{"A_title": "StringEscapeUtils.escapeXML() cant process UTF-16 supplementary charactersSupplementary characters in UTF-16 are those whose code points are above 0xffff that is require more than 1 Java char to be encoded as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/ Currently StringEscapeUtils.escapeXML() isnt aware of this coding scheme and treats each char as one character which is not always right. A possible solution in class Entities would be:     public void escape(Writer writer String str) throws IOException          int len = str.length();         for (int i = 0; i < len; i++)              int code = str.codePointAt;             String entityName = this.entityName(code);             if (entityName != null)                   writer.write(&);                 writer.write(entityName);                 writer.write(;);               else if (code > 0x7F)                       writer.write(&#);                     writer.write(code);                     writer.write(;);               else                       writer.write((char) code);                           if (code > 0xffff)                       i++;                            Besides fixing escapeXML() this will also affect HTML escaping functions. I guess thats a good thing but please remember I have only tested escapeXML().", "A_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "cant", "process", "utf", "16", "supplementari", "characterssupplementari", "charact", "supplementari", "charact", "utf", "16", "are", "those", "whose", "code", "point", "are", "abov", "0xffff", "that", "requir", "more", "than", "java", "char", "encod", "as", "explain", "here", "http", "sun", "java", "com", "develop", "technicalarticl", "intl", "supplementari", "technic", "articl", "current", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "isnt", "awar", "thi", "code", "scheme", "treat", "each", "char", "as", "one", "charact", "which", "not", "alway", "right", "possibl", "solut", "class", "entiti", "would", "public", "void", "escap", "writer", "writer", "string", "str", "throw", "ioexcept", "io", "except", "int", "len", "str", "length", "int", "len", "i++", "int", "code", "str", "codepointat", "code", "point", "at", "string", "entitynam", "entiti", "name", "thi", "entitynam", "entiti", "name", "code", "entitynam", "entiti", "name", "null", "writer", "write", "writer", "write", "entitynam", "entiti", "name", "writer", "write", "code", "0x7f", "writer", "write", "writer", "write", "code", "writer", "write", "writer", "write", "char", "code", "code", "0xffff", "i++", "besid", "fix", "escapexml", "escap", "xml", "thi", "will", "also", "affect", "html", "escap", "function", "guess", "that", "good", "thing", "but", "pleas", "rememb", "have", "onli", "test", "escapexml", "escap", "xml"], "B_title": "Adding a test and code fix to have supplementary chars working in numeric entity unescaping. See LANG-617", "B_clean_title": ["ad", "test", "code", "fix", "have", "supplementari", "char", "work", "numer", "entiti", "unescap", "see", "lang", "617"]},
{"A_title": "ValuedEnum.compareTo(Object other) not typesafe - it easily could be...int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  is not typesafe - if the int-values are the same it will return 0 even for two totally different sub-classes of ValuedEnum", "A_clean_title": ["valuedenum", "compareto", "valu", "enum", "compar", "object", "other", "not", "typesaf", "it", "easili", "could", "int", "org", "apach", "common", "lang", "enum", "valuedenum", "compareto", "valu", "enum", "compar", "object", "other", "not", "typesaf", "int", "valu", "are", "same", "it", "will", "return", "even", "two", "total", "differ", "sub", "class", "valuedenum", "valu", "enum"], "B_title": "- Fix compareTo to check the type is the same", "B_clean_title": ["fix", "compareto", "compar", "check", "type", "same"]},
{"A_title": "StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.Hello. I use StringEscapeUtils.escapeXml(input) to escape special characters for XML. This method outputs wrong results when input contains characters in Supplementary Planes. String str1 = uD842uDFB7 + A; String str2 = StringEscapeUtils.escapeXml(str1); // The value of str2 must be equal to the one of str1 // because str1 does not contain characters to be escaped. // However str2 is diffrent from str1. System.out.println(URLEncoder.encode(str1 UTF-16BE)); //%D8%42%DF%B7A System.out.println(URLEncoder.encode(str2 UTF-16BE)); //%D8%42%DF%B7%FF%FD The cause of this problem is that the loop to translate input character by character is wrong. In CharSequenceTranslator.translate(CharSequence input Writer out) loop counter i moves from 0 to Character.codePointCount(input 0 input.length()) but it should move from 0 to input.length().", "A_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "input", "output", "wrong", "result", "when", "input", "contain", "charact", "supplementari", "plane", "hello", "use", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "input", "escap", "special", "charact", "xml", "thi", "method", "output", "wrong", "result", "when", "input", "contain", "charact", "supplementari", "plane", "string", "str1", "ud842udfb7", "d842u", "dfb7", "string", "str2", "stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "str1", "valu", "str2", "must", "equal", "one", "str1", "becaus", "str1", "not", "contain", "charact", "escap", "howev", "str2", "diffrent", "str1", "system", "out", "println", "urlencod", "encod", "url", "encod", "str1", "utf", "16be", "d8", "42", "df", "b7a", "system", "out", "println", "urlencod", "encod", "url", "encod", "str2", "utf", "16be", "d8", "42", "df", "b7", "ff", "fd", "caus", "thi", "problem", "that", "loop", "translat", "input", "charact", "by", "charact", "wrong", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "loop", "counter", "move", "charact", "codepointcount", "code", "point", "count", "input", "input", "length", "but", "it", "move", "input", "length"], "B_title": "StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.  ALSO rewrite method to avoid modification of counter variable in for loop", "B_clean_title": ["stringescapeutil", "escapexml", "string", "escap", "util", "escap", "xml", "input", "output", "wrong", "result", "when", "input", "contain", "charact", "supplementari", "plane", "also", "rewrit", "method", "avoid", "modif", "counter", "variabl", "loop"]},
{"A_title": "NaN singular value from SVDThe following jython code Start code from org.apache.commons.math.linear import * Alist = 1.0 2.0 3.02.03.04.03.05.07.0 A = Array2DRowRealMatrix(Alist) decomp = SingularValueDecompositionImpl(A) print decomp.getSingularValues() End code prints array(d 11.218599757513008 0.3781791648535976 nan) The last singular value should be something very close to 0 since the matrix is rank deficient.  When i use the result from getSolver() to solve a system i end  up with a bunch of NaNs in the solution.  I assumed i would get back a least squares solution. Does this SVD implementation require that the matrix be full rank?  If so then i would expect an exception to be thrown from the constructor or one of the methods.", "A_clean_title": ["nan", "na", "singular", "valu", "svdthe", "svd", "follow", "jython", "code", "start", "code", "org", "apach", "common", "math", "linear", "import", "alist", "02", "03", "04", "03", "05", "07", "array2drowrealmatrix", "array2d", "row", "real", "matrix", "alist", "decomp", "singularvaluedecompositionimpl", "singular", "valu", "decomposit", "impl", "print", "decomp", "getsingularvalu", "get", "singular", "valu", "end", "code", "print", "array", "11", "218599757513008", "3781791648535976", "nan", "last", "singular", "valu", "someth", "veri", "close", "sinc", "matrix", "rank", "defici", "when", "use", "result", "getsolv", "get", "solver", "solv", "system", "end", "up", "bunch", "nan", "na", "ns", "solut", "assum", "would", "get", "back", "least", "squar", "solut", "thi", "svd", "implement", "requir", "that", "matrix", "full", "rank", "so", "then", "would", "expect", "except", "thrown", "constructor", "or", "one", "method"], "B_title": "Singular Value Decomposition now computes either the compact SVD (using only positive singular values) or truncated SVD (using a user-specified maximal number of singular values). Fixed Singular Value Decomposition solving of singular systems. JIRA: MATH-320 MATH-321", "B_clean_title": ["singular", "valu", "decomposit", "now", "comput", "either", "compact", "svd", "onli", "posit", "singular", "valu", "or", "truncat", "svd", "user", "specifi", "maxim", "number", "singular", "valu", "fix", "singular", "valu", "decomposit", "solv", "singular", "system", "jira", "math", "320", "math", "321"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add additional heuristic for rare cases in pivotRow selection.", "B_clean_title": ["add", "addit", "heurist", "rare", "case", "pivotrow", "pivot", "row", "select"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Adding a unit test for #LANG-281 and a fix. The fix involves removing the reduceAndCorrect method. It appears that this method was doing sod all - which is worrying as it used to be important. Im guessing that it was a bad fix for a bug that was then subsequently fixed with other code. Ill create a JIRA issue to create more tests to test out the +31 block of code.", "B_clean_title": ["ad", "unit", "test", "lang", "281", "fix", "fix", "involv", "remov", "reduceandcorrect", "reduc", "correct", "method", "it", "appear", "that", "thi", "method", "wa", "do", "sod", "all", "which", "worri", "as", "it", "use", "import", "im", "guess", "that", "it", "wa", "bad", "fix", "bug", "that", "wa", "then", "subsequ", "fix", "other", "code", "ill", "creat", "jira", "issu", "creat", "more", "test", "test", "out", "+31", "block", "code"]},
{"A_title": "Bugs in DatasetUtilities.iterateRangeBounds() methodsNone", "A_clean_title": ["bug", "datasetutil", "iteraterangebound", "dataset", "util", "iter", "rang", "bound", "methodsnon", "method", "none"], "B_title": "source/org/jfree/chart/DatasetUtilities.java (iterateRangeBounds(XYDataste boolean)): For IntervalXYDataset include regular value and account for nulls / Double.NaN.", "B_clean_title": ["java", "sourc", "org", "jfree", "chart", "datasetutil", "dataset", "util", "iteraterangebound", "iter", "rang", "bound", "xydatast", "xy", "datast", "boolean", "intervalxydataset", "interv", "xy", "dataset", "includ", "regular", "valu", "account", "null", "doubl", "nan", "na"]},
{"A_title": "possibly a bug in org.joda.time.field.FieldUtils.safeMultiplyIt seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1 int scalar) doesnt detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldnt see anything that looked relevant.", "A_clean_title": ["possibl", "bug", "org", "joda", "time", "field", "fieldutil", "safemultiplyit", "field", "util", "safe", "multipli", "it", "seem", "me", "that", "as", "current", "written", "joda", "time", "jar", "org", "joda", "time", "field", "fieldutil", "safemultipli", "field", "util", "safe", "multipli", "long", "val1", "int", "scalar", "doesnt", "detect", "overflow", "long", "val1", "long", "min", "valu", "int", "scalar", "attach", "file", "demonstr", "what", "think", "bug", "suggest", "patch", "look", "at", "joda", "time", "bug", "list", "sourceforg", "sourc", "forg", "but", "couldnt", "see", "anyth", "that", "look", "relev"], "B_title": "FieldUtils.safeMultiply(longint) 3520651", "B_clean_title": ["fieldutil", "safemultipli", "field", "util", "safe", "multipli", "longint", "3520651"]},
{"A_title": "StringIndexOutOfBoundsException when calling unescapeHtml4(&#03)When calling unescapeHtml4() on the String &#03 (or any String that contains these characters) an Exception is thrown: Exception in thread main java.lang.StringIndexOutOfBoundsException: String index out of range: 4 at java.lang.String.charAt(String.java:686) at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49) at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60) at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "when", "call", "unescapehtml4", "unescap", "html4", "03", "when", "call", "unescapehtml4", "unescap", "html4", "string", "03", "or", "ani", "string", "that", "contain", "these", "charact", "except", "thrown", "except", "thread", "main", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:686", "at", "org", "apach", "common", "lang3", "text", "translat", "numericentityunescap", "translat", "numer", "entiti", "unescap", "numericentityunescap", "java:49", "numer", "entiti", "unescap", "at", "org", "apach", "common", "lang3", "text", "translat", "aggregatetransl", "translat", "aggreg", "translat", "aggregatetransl", "java:53", "aggreg", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:88", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:60", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "unescapehtml4", "string", "escap", "util", "unescap", "html4", "stringescapeutil", "java:351", "string", "escap", "util"], "B_title": "Adding tests and resolving LANG-710 reported by Benjamin Valentin. Note that this changed such that the code will now escape an unfinished entity (i.e. &#030). This matches browser behaviour.", "B_clean_title": ["ad", "test", "resolv", "lang", "710", "report", "by", "benjamin", "valentin", "note", "that", "thi", "chang", "such", "that", "code", "will", "now", "escap", "unfinish", "entiti", "030", "thi", "match", "browser", "behaviour"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Applying Sebbs test and fix for LANG-365", "B_clean_title": ["appli", "sebb", "test", "fix", "lang", "365"]},
{"A_title": "Dangerous code in PoissonDistributionImplIn the following excerpt from class PoissonDistributionImpl: PoissonDistributionImpl.java     public PoissonDistributionImpl(double p NormalDistribution z)          super();         setNormal(z);         setMean(p);        (1) Overridable methods are called within the constructor. (2) The reference z is stored and modified within the class. Ive encountered problem (1) in several classes while working on issue 348. In those cases in order to remove potential problems I copied/pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether (i.e. make the classes immutable). Problem (2) can also create unexpected behaviour. Is it really necessary to pass the NormalDistribution object; cant it be always created within the class?", "A_clean_title": ["danger", "code", "poissondistributionimplin", "poisson", "distribut", "impl", "follow", "excerpt", "class", "poissondistributionimpl", "poisson", "distribut", "impl", "poissondistributionimpl", "java", "poisson", "distribut", "impl", "public", "poissondistributionimpl", "poisson", "distribut", "impl", "doubl", "normaldistribut", "normal", "distribut", "super", "setnorm", "set", "normal", "setmean", "set", "mean", "overrid", "method", "are", "call", "within", "constructor", "refer", "store", "modifi", "within", "class", "ive", "encount", "problem", "sever", "class", "while", "work", "issu", "348", "those", "case", "order", "remov", "potenti", "problem", "copi", "past", "bodi", "setter", "method", "insid", "constructor", "but", "think", "that", "more", "eleg", "solut", "would", "remov", "setter", "altogeth", "make", "class", "immut", "problem", "also", "creat", "unexpect", "behaviour", "it", "realli", "necessari", "pass", "normaldistribut", "normal", "distribut", "object", "cant", "it", "alway", "creat", "within", "class"], "B_title": "Removed deprecated methods.", "B_clean_title": ["remov", "deprec", "method"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "source/org/jfree/data/time/TimeSeries.java (clone): Reimplemented.", "B_clean_title": ["java", "sourc", "org", "jfree", "data", "time", "timeseri", "time", "seri", "clone", "reimplement"]}]