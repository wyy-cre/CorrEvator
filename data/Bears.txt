bears-95$$ClassGeneratingPropertyAccessorFactory.isTypeInjectable(…) fails with NPE for entities in default packages [DATACMNS-1201]$$opened and commented Introspecting ClassGeneratingPropertyAccessorFactory support for an entity fails with an NPE if the entity resides in the default package.     Affects: 1.13.8 (Ingalls SR8), 2.0 GA (Kay)  Referenced from: pull request #256  Backported to:  2.0.1 (Kay SR1) , 1.13.9 (Ingalls SR9)$$patch1-bears-95_Developer_PatchNaturalnessYe$$Fix ClassGeneratingPropertyAccessorFactory # isTypeInjectable. $$1
bears-92$$AnnotationRevisionMetadata throws ClassCastException [DATACMNS-1173]$$opened and commented  AnnotationRevisionMetadata throws ClassCastException at line 90 :  Most likely leftovers during migration to  java.util.Optional   Affects: 2.0 RC3 (Kay)$$patch1-bears-92_Developer_PatchNaturalnessYe$$Fix build. Fixing the build error of ControllerRevisionMetadata on Application level 9. Fix getRequiredRevisionDate return type. $$1
bears-103$$ClassCastExecption$$Hi,  I have started using a meitrack tc68s device, however when I try and generate a summary/trip report it returns the following error in console:  The device is not in the future and has the correct timezone, also I am using the official build. Any recommendation?  All the other, osram works fine.$$patch1-bears-103_Developer_PatchNaturalnessYe$$added parser . next ( ) and parser . nextInt ( ) to position so it will use the. Updated to use parser . nextInt ( ) * 1000 as value is stored in a variable. added parser . nextInt ( ) to position so it can be used as an alternative to parser .. $$1
bears-168$$address-controller: NPE when required parameters (address, plan or type) are not set$$Description:  When required parameter (address,plan or type) in address definition is not set then it cause NPE in address-controller.  https://github.com/EnMasseProject/enmasse/blob/master/address-model-lib/src/main/java/io/enmasse/address/model/v1/AddressV1Deserializer.java#L36 Steps to reproduce:    create brokered address-space "brokered-space"  create address without required parameter: "brokered_incorrect_address.json"    Automated test:  we have no automated test for that yet output from address-controller log:$$patch1-bears-168_Developer_PatchNaturalnessYe$$Add missing import. Removed special treatment for AddressController client errors. Add missing import. Added validate ( ) to AddressV1Deserializer . deserialize ( ObjectNode ). Added validate method on AddressV1Deserializer .. Add validate ( ) to AddressSpaceV1Deserializer. Added a few things so that we can have better error reporting. $$1
bears-150$$Locale deserialize 'zh-hant_CN'$$zh-hant_CN will convert to zh_HANT_cn Locale include (language, country, variant), Locale.toString() use '_' to split then  {language}_{country}_({variant}_# | #){script}-{extensions} but Jackson deserialize Locale use '-' or '_'  : (  code: LocaleHandle.readResolve()  iana language-tags   rfc4647 language lookup    in jdk1.5 -> 1.8$$patch1-bears-150_Developer_PatchNaturalnessYe$$Fix error in LocaleSerializer. missing fields. $$1
bears-166$$rest api returns wrong address status {"isReady":true,"phase":"Pending"}$$address-space: standard  addresses: queue(sharded-queue)/topic(sharded-topic)  addresses deployed into address-space are ready to use (simple send/receive) but .status.phase is set to "Pending" reproducer    create     deploy     get all addresses     result:   address_space definition: standardSpace.json   addresses definition: standard_qt.json   however in standard-controller log you can see that addresses are in phase "Active:   ConfigMap of myqueue contains phase "Active" as well   I'll try to reproduce with brokered...$$patch1-bears-166_Developer_PatchNaturalnessYe$$Copy phase from Status .. $$1
bears-35$$How could I disable static imports in the v55 output?$$I found v53+ are producing static imports.$$patch1-bears-35_Developer_PatchNaturalnessYe$$Changed imports to static for field references .. Added imports to avoid unused imports. Added imports for spoon . reflect . declaration .. Added unused imports. Added a fieldAndMethodsNames field to ImportScannerImpl . java. Changed superclass imports to local or not .. Improved JDK7 build breakage .. CtBlock is not in an inner class block .. Updated import scanner to ignore package imports .. $$1
bears-93$$EntityInstantiators deallocate params required for instantiation of parent object [DATACMNS-1175]$$opened and commented Fetching nested document from MongoDB into Kotlin data class structure will sometimes result in NullPointerException. This is caused by  DefaultingKotlinClassInstantiatorAdapter.createInstance(..) calling ClassGeneratingEntityInstantiator.deallocateArguments(..) method cleaning up the shared params array. Doing this while instantiating a child object will clean up all previously prepared arguments for parents constructor and thus causing NPEs on non-null parameters. Note that everything was fine while using version of Spring Data bundled with Spring Boot 2.0.0.M3    Affects: 2.0 RC3 (Kay)  Referenced from: pull request #247 , and commits , ,$$patch1-bears-93_Developer_PatchNaturalnessYe$$Removed unused static inner class .. Use the empty array if parameter count is zero. Removed extraneous try / catch block. Remove unused local variable. Remove deprecated method call .. Fix ClassGeneratingEntityInstantiator constructor to not allocate arguments on reflection .. fix constructor auto - allocate arguments. $$1
bears-94$$Failing generic type resolution of generic types within nested generic fields [DATACMNS-1196]$$opened and commented It seems that the type resolution is not working properly when having nested object composition with generic type.  Example of model: constructors, getters,... ommited  And create instance of  Outer with  When we create an instance of  Outer which has reference to instance of Generic whose generic type is MyEnum then if we save Outer instance using MongoTemplate it's persisted in db correctly converted to mongo's document.  { But, when we try to read it from db it is mapped incorrectly back to  Outer . Field myList in instance of Inner contains a List which contains instances of String , but field elem in instance of Inner is mapped correctly and it really contains an instance of MyEnum . Seems that problem is in MongoConverter . I'm attaching a simple project which is able to reproduce problem described above. In tests, I'm not actually storing an instance to mongo collection, but rather using only MongoConverter to convert an instance to Document and than back to Outer . I don't know if workaround for this cold be writing a custom Converter . My workaround for this (in real project) was to manually convert a Document to some domain specific instance, but that is really annoying.  I know that mapping from mongo types back can be tricky and sometimes type information is lost, but that is not case here. For comparison, I've tried Jackson 's ObjectMapper to do serialization of instance of Outer to JSON string and than de-serialize JSON on back to Outer and it seems that Jackson resolves  generic types correctly.   Affects: 1.13.8 (Ingalls SR8), 2.0 GA (Kay)  Attachments:     Backported to:  2.0.1 (Kay SR1) , 1.13.9 (Ingalls SR9)$$patch1-bears-94_Developer_PatchNaturalnessYe$$Remove unused import. Added missing constructor .. Remove unnecessary copy of generics. Remove some redundant code. Added private method to ParameterizedTypeInformation . flattenTypeVariables. $$1
bears-34$$ParentNotInitializedException on CtComments$$Hello,  When I build JavaFileTest from javapoet with comments enabled, the build throw me the following error:   snippet example:   assertThat(source)$$patch1-bears-34_Developer_PatchNaturalnessYe$$pretty printer always adds comment after expression. added comment after parentheses if it is not a statement. Removed unnecessary empty line before the condition is used in the AST .. Removed unnecessary scan ( ) method. Removed unnecessary whitespace .. Removed redundant comment in newly added array indexing operation. Removed redundant scan ( ) method. Updated code to write array comments. Add missing import. Added missing line separators to parent exiter .. $$1
bears-33$$CtTypeReferenceImpl#getSuperClass() fails in noClasspath mode$$The method has the following implementation:   As you can see, it doesn't check for noClasspath and, thus, may fail when calling  getActualClass() .$$patch1-bears-33_Developer_PatchNaturalnessYe$$Added catch block for CtTypeReferenceImpl . getDeclaredExecutables ( ). Added a catch block to prevent CtTypeReference from being able to find the superclass .. $$1
bears-167$$address-controller allows to create multiple addresses with the same "spec.address" value$$reproducible via following steps:    create standard address space (reproducible with brokered as well)  deploy 3 addresses into this address space     all addresses were created successfully, console shows only one of those addresses, next address appears once previous one is removed.  And only first of multiple addresses has isReady attribute set to true in configMap  standard_anycast.json$$patch1-bears-167_Developer_PatchNaturalnessYe$$Add missing import. Add missing import. Added check for same resource name in AddressApiHelper. $$1
bears-156$$Hibernate Subselect Entity not supported by EntityMetamodelImpl$$Description  After playing a bit with table functions (see also  #181 ), I had the idea to experiment with mapping a generate_series query to an entity using the annotation. Find below the produced stack trace. A trivial work around is to wrap the query into to a view and map that instead. I am uncertain whether a fix for this is worthwhile, but it could perhaps be a step towards implementing table functions (  #181 ).   Expected behavior  Actual behavior  Steps to reproduce  Environment  Version:            1.2.0.Alpha3  JPA-Provider:       Hibernate 5.2.12 DBMS:               PostgresSQL Application Server: Wildfly$$patch1-bears-156_Developer_PatchNaturalnessYe$$Fixed HHH - 7093 - Fixed issue # 506. $$1
bears-211$$Unable to set a compression input/output decorator to a  SmileFactory$$I have a special need for the  riak-java-client which only allows me to use an ObjectMapper to serialize/deserialize key-values, I would like to decorate a SmileFactory with compressors like LZ4, Snappy or GZip but at the moment this is not possible, when I try a mapper like the following:   This is the exception I get:  I used Gzip as an example, in reality I'm using both LZ4 and Gzip and both throw exceptions when I try with a  SmileFactory , this works perfectly with a JsonFactory , the reason for me to prefer a SmileFactory over a JsonFactory is because it is notice-able faster than the JsonFactory so basically it'll help compensate the price I pay for compression.$$patch1-bears-211_Developer_PatchNaturalnessYe$$Remove warning suppression. Fix error when _decorate is called with null input .. Add input decorator to parser for JSON output. Fix finalization of CBORGenerator. missing semicolon. $$1
bears-219$$feat: add support for ${java.version} in pom.xml$$Hi !  I have an issue creating a MavenLauncher for projects that have ${java.version} in their POM.xml .  Replacing it with  1.8 for example seems to work around. Thank you for your help !$$patch1-bears-219_Developer_PatchNaturalnessYe$$Corrected java version in SpoonPom , to make it work reliably outside. Fixed incorrect java version string in Getter for SpoonPom. $$1
bears-244$$ClassGeneratingPropertyAccessorFactory needs custom ClassLoader for defineClass() [DATACMNS-1422]$$opened and commented The  ClassGeneratingPropertyAccessorFactory fails to generate classes in an OSGi environment, where the ClassLoader for the model project, the store implementation and Spring Data is different. Here is the error we are facing:  The problem seems to be that  PropertyAccessorClassGenerator.generateBytecode() adds the interface PersistentPropertyAccessor which lives in Spring Data. In generateCustomAccessorClass() the ClassLoader of the model entity is used. Therefore the ClassLoader of the custom model project needs access to all classes which are added by the factory (especially the package org.springframework.data.mapping ). To resolve this problem, a child ClassLoader of the entity should be used that is able to access both projects: Spring Data and the custom entity model. Else this has to fail because different classes are mixed which cannot be accessed by a single ClassLoader    Affects: 2.1.2 (Lovelace SR2)  Attachments:      Referenced from: pull request #324  Backported to:  2.1.3 (Lovelace SR3)$$patch1-bears-244_Developer_PatchNaturalnessYe$$ spring - data - convert / ClassGeneratingEntityInstantiator implements EntityInstantiator. Added missing import. Using generics to check for unique property hashcodes in generated code. Removed public copy method note. $$1
bears-202$$Calling  blacklistLibOrExtJars without arguments causes an Exception$$Calling  blacklistLibOrExtJars() without arguments throws java.lang.IllegalArgumentException: Can only blacklist jars by leafname: /System/Library/Java/Extensions/MRJToolkit.jar while whitelistLibOrExtJars() without arguments works fine.$$patch1-bears-202_Developer_PatchNaturalnessYe$$Fix bug in ClassGraph. $$1
bears-174$$One-to-many with integer ids retrieval broken$$How to Reproduce  Upload:   string-id.xlsx Go to dataexplorer, select Subjects table  I don't like the order of the samples, so I want to change the ID attribute datatype of the samples to int Upload:  int-id.xlsx Go to your table again Expected behavior  My beautiful table, nicely int sorted --> happy datamanager  Observed behavior    --> Sad datamanager$$patch1-bears-174_Developer_PatchNaturalnessYe$$Fixed error in PostgreSqlEntityFactory , where MREF_ID is not a string. $$1
bears-180$$NPE for google cloud storage$$Hi ,  Any time I try to access Resource from the google storage it throws the following NPE. It happens on both read and write . Here is how the pom looks like   Here is the code   I even tried checking out the entire repo and just run the code as it is  from spring-cloud-gcp-storage-resource-sample and class WebController by changing my bucket name and still get the same NPE  I removed the entire .m2 directory and started all over all and still the issue persists  I double checked I have access to my bucket and even tried the same form my service account that have project admin access , but the problem persists$$patch1-bears-180_Developer_PatchNaturalnessYe$$Fixed bug in Controller impl. $$1
bears-20$$FromStringDeserializer ignores registered DeserializationProblemHandler for java.util.UUID$$Culprit appears to be  lines 155-161 of FromStringDeserializer :  The above lines appear to show that the exception will be thrown regardless of any problem handling logic.  Test Case:   The handler handles the issue properly; but an exception is thrown anyway:$$patch1-bears-20_Developer_PatchNaturalnessYe$$Add missing import. Remove spurious blank line. Fixing an internal warning in FromStringDeserializer .. $$1
bears-18$$Add support for handling primitive/discrepancy problem with type refinements$$(note: derived from  FasterXML/jackson-module-jaxb-annotations#64 ) The problem is that although  int and java.lang.Integer are related, logically, they are not related by inheritance (or implementation). Since some legacy code may try refinements in this axis it'd be nice to handle this somehow. Two basic approaches would be:   Just ignore primitive/wrapper override, return original type as is  Allow wrapper to "refine" primitive, return wrapper.  There is also related question of whether to allow "int to long" and similar refinements, but start with basics.$$patch1-bears-18_Developer_PatchNaturalnessYe$$Add staticTyping to JacksonAnnotationIntrospector , as per # 77. Fix JacksonAnnotationIntrospector # 1592. Fix JacksonAnnotationIntrospector ' s static typeing , so it can be ignored by the. Added support for @ Nullable and @ Primitive to JacksonAnnotationIntrospector. JacksonAnnotationIntrospector does not support keyType for MapLikeType. Fix JacksonAnnotationIntrospector - remove unnecessary check for primitive and wrapper. Added support for @ BeforeMethod. $$1
bears-173$$Importing an entitytype with several columns with the same name, import without errors$$How to Reproduce  Import a datasheet with multiple columns that have the same name.  Expected behavior  An error telling me to only use the name of every attribute once per entitytype  Observed behavior  Everything imports fine and I have issues much later then one would expect.$$patch1-bears-173_Developer_PatchNaturalnessYe$$Excel sheet should throw exception if column idx already exists. Added throw exception if existing column idx already exists. $$1
bears-27$$Changes to SourcePosition in 5.5.0 ?$$Hello,  according to #1081 I don't find any mentions of changes to the SourcePosition. In our use case we want to calculate the size of constructors and methods. Which worked just fine in 5.4.  Now with the 5.5 Snapshot I want to analyze a file which has a inner private class with no constructors. Spoon generates a default private constructor with one statement -> super() . The start line of this constructor is 1 and getPosition().getFile() returns null while the statements (super()) line is 383 and it has a file. My method throws a NP as my method size calculation now is wrong and gets passed the threshold and I try to access the file of the generated private constructor.  I always can implement the case to ignore generated constructors, but I just want to make sure this is intented or not.$$patch1-bears-27_Developer_PatchNaturalnessYe$$Do not place the compiler in the debug log when in debug log. $$1
bears-11$$Enum key for Map ignores SerializationFeature.WRITE_ENUMS_USING_INDEX$$Version: latest 2.8  Failing unit tests added here:   https://github.com/SolaKun/jackson-databind/commit/6e095f75edd1de3eb33be5950c56d562bd6d584a Only java.util.Map test case provided, but doesn't work with EnumMap as well..$$patch1-bears-11_Developer_PatchNaturalnessYe$$Fix serialization of enums ( via enum value ). Fix bug in StdKeySerializers. Fix serialization of Enums ( from # 77 ). $$1
bears-7$$@JsonEnumDefaultValue should take precedence over FAIL_ON_NUMBERS_FOR_ENUMS$$Consider the following  ObjectMapper definition:  With this  ObjectMapper , when one attempts to deserialize an enum value V for an enum with an @JsonEnumDefaultValue element, the deserialization will:   Pass, if  Pass, if  Fail, if  To me this seems highly unintuitive. I would have expected the  READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE feature to take precedence over the FAIL_ON_NUMBERS_FOR_ENUMS feature in those cases where it applies (i.e., when deserializing an enum with a default element). I've put together a test class enumerating the relevant cases. See the inline comments towards the bottom. In four cases I feel that Jackson's current behavior is not as one might expect.   Would love to hear your thoughts on this. (If there is some other feature I should enable to get the behavior I'm looking for, let me know :).)$$patch1-bears-7_Developer_PatchNaturalnessYe$$Allow use of enums with @ failOnNumbers. $$1
bears-16$$Wrong serializer causing JsonMappingException$$I'm using spring-data-rest (3.0.0), which uses jackson-databind 2.9.0.pr2.  I'm not sure what have changed, since, not so long ago, I had an functional application. But now I'm getting:  "Could not write JSON document: java.lang.Double cannot be cast to java.lang.Integer (through reference chain: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$PersistentEntityResourceSerializer$1["content"]->**.Contrato["storageUtilizado"]); nested exception is com.fasterxml.jackson.databind.JsonMappingException: java.lang.Double cannot be cast to java.lang.Integer (through reference chain: org.springframework.data.rest.webmvc.json.PersistentEntityJackson2Module$PersistentEntityResourceSerializer$1["content"]->**.Contrato["storageUtilizado"])" I've been stucked with this problem for a while and I'm just assuming that there is something wrong when de Serializer for this specific field is defined   I need, at least, some directions...$$patch1-bears-16_Developer_PatchNaturalnessYe$$Fix error in SerializerProvider .. Fix error in previous patch. Added missing initialization .. Added missing constructor .. Added check for non - filtered properties. Add an exception check for filtered properties. Added report of bad type in BeanSerializerFactory. $$1
bears-89$$Invalid generics resolution for locally declared wildcard and fully resolved target type [DATACMNS-1138]$$opened and commented Given the following context:    An entity declares a field which type is a class with a wildcard type  An implementation of the field's class is typed with a custom object  A custom converter has been declared for the custom object  We persist an entity with the custom class in Mongo  Then when we retrieve the entity from the database, the field with the custom type is not deserialized by the custom converter.  This problem does not happen if:   We remove the wildcard from the declared field  We use a type that does not require a custom converter (e.g. Integer)  I'm not sure if this description is clear, please take a look at the project on GitHub:  https://github.com/mclem/spring-data-mongodb-generics to reproduce the problem by running mvn test   Affects: 1.12.11 (Hopper SR11), 1.13.6 (Ingalls SR6), 2.0 RC2 (Kay)  Reference URL:  https://github.com/mclem/spring-data-mongodb-generics  Issue Links:     Backported to:  1.13.7 (Ingalls SR7) , 1.12.12 (Hopper SR12)$$patch1-bears-89_Developer_PatchNaturalnessYe$$Added missing @ Override + method that resolves ' type ' operand. $$1
bears-116$$MU-201 v3.xx doesnt work?$$Hi,  i've tried to install my tracker in Traccar but it doesn't work. The Logfile was generated and everything is running but not the tracker...  HEX is translatet to:   Port 5051  How can i add the device?  Kind regards  Daniel$$patch1-bears-116_Developer_PatchNaturalnessYe$$Fix german translation .. removed 0xhh postfix. $$1
bears-45$$CtFieldReference.getDefaultExpression() returns initializer from a field of another class$$Hi, I'm trying to collect and evaluate certain strings in the source repository.  I tried VisitorPartialEvaluator, but it runs into an infinite loop. The reason of this is that fields get mixed up. The code setup is like this:   Now if you try to read the return value of the  getKey() method, the CtFieldReference object will return the default value of ClassB.PREFIX , not BaseClass.PREFIX .$$patch1-bears-45_Developer_PatchNaturalnessYe$$Set the simpleName in CtNamedElementImpl .. Removed unneeded assignment .. Refactoring . changeTypeName ( ) now returns the same thing. Removed unused imports. Removed try catch block for field lookup dynamically. $$1
bears-87$$Converting to Vavr Option fails for present value [DATACMNS-1087]$$opened and commented Curently  QueryExecutionConverters tries to invoke Vavr's Optional.of like an instance method rather than static one. This causes exception:    Affects: 1.13.4 (Ingalls SR4)  Referenced from: commits ,$$patch1-bears-87_Developer_PatchNaturalnessYe$$Remove unneeded invoke of method .. $$1
bears-6$$@JsonProperty(access = Access.READ_ONLY) - unexpected behaviour$$Hey,  I was hoping to make use of @JsonProperty(access = Access.READ_ONLY), but failed.  Assume this class:   I couldn't find a way to stop the deserializer from attempting to deserialize the field "fullName".  The only thing that helps is to create a setter and annotate it with @JsonIgnore . However, that setter does not make sense and I don't want to have it. Is this a bug in behaviour or am I missing something? Thanks$$patch1-bears-6_Developer_PatchNaturalnessYe$$Add missing import. Added missing assignment in POJOPropertiesCollector. Added missing semicolon. Add missing return statement. $$1
bears-28$$ParentNotInitializedException when processing comments with -c$$I am aware that comments can be processed using the command "-c"  since Spoon 5.2.0. Thanks for this feature.  When using Spoon to process comments in either code snippet below, ParentNotInitializedException will be thrown. An empty processor can be used to reproduce this issue. This happens in both Spoon 5.2 and 5.4.  public class Comment_1 {   }  public class Comment2 {   }  Details of the exception are as follows.  spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/home/jifeng/workspace/Temp4/src/main/java/example/Comment1.java:17)  at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:284) at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:377) at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:131) at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:96) at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:387) at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:116) at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:99) at spoon.Launcher.buildModel(Launcher.java:712) at spoon.Launcher.run(Launcher.java:663) at spoon.Launcher.run(Launcher.java:106) at spoon.Launcher.main(Launcher.java:99)$$patch1-bears-28_Developer_PatchNaturalnessYe$$Corrected source start position for comments .. Suppressed the before comment of newly added elements to the AST .. Adding missing closing parenthesis in DefaultJavaPrettyPrinter .. @@ - 142 Added missing for loop. Updated comment builder. $$1
bears-17$$Extraneous type id mapping added for base type itself$$Looks like type id (name) matching base type is included in type resolution list, automatically. While this might be useful sometimes it seems quite odd, and probably should only be included if:    Base type is concrete and  Base type has explicit name (not add if default name used)$$patch1-bears-17_Developer_PatchNaturalnessYe$$Add missing import. Added javadoc. fix null property resolve bug. Fixing nullability note in stdSubtypeResolver. Fix stdSubtypeResolver. Fix stdSubtypeResolver. add rawBase before _combineNamedAndUnnamed ( ). remove unused modifier. Added ignore for abstract base type in stdSubtypeResolver. $$1
bears-1$$Wrong constructor picked up when deserializing object$$I discovered an issue with Jackson 2.7.8 (and Jackson 2.8.4) when several constructors have parameters annotated with  @JsonProperty but only one is annotated with @JsonCreator . Here's a test case to reproduce it:   This test throws an the following exception:   After some debugging, it looks like that  BasicDeserializerFactory#_addDeserializerConstructors(...) is looping over all the constructors, and is not favoring an explicit constructor over a non-explicit one. I actually don't know what should be the expected behavior: should jackson fail when two constructors are annotated, or should jackson favor the one annotated with  @JsonCreator . Both options look reasonable to me (and I'm actually removing one of the constructors).$$patch1-bears-1_Developer_PatchNaturalnessYe$$Fix a problem with quickly adding properties to the CreatorCollector. Added missing @ return for verifyNonDup .. Fix double - packaging. Fix change to not ignore generics. fix access modifier for setters. $$1
bears-10$$DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS only works for POJOs, Maps$$Documentation of  DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS only mentiones exceptional behavior for more than one value in the array ("If more than one value is found in the array, a JsonMappingException is thrown."). But trying to parse { "value" : [] } with value as String produces the following Stacktrace: (Parsing as null might be expected instead)   This shouldn't be problematic when using  DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT , but it does not take precedence over DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS (bug?) and still gives me the error from above! Are there any workarounds? I still need to map single element arrays, that sometimes appear to be empty. (I am using version 2.5.1, tested also 2.6.0: same behavior)$$patch1-bears-10_Developer_PatchNaturalnessYe$$Fixed EnumDeserializer . getEmptyValue ( ) .. Restore unhandled end - of - array handling. $$1
bears-172$$Repository.findOne method fails to return row for row level secured entity type if first row isn't readable$$Code inspection  FindOne shouldn't check if first row of delegate is readable but find first readable row.$$patch1-bears-172_Developer_PatchNaturalnessYe$$Fix row level security repo decorator findOne ( ). $$1
bears-8$$MapSerializer._orderEntries() throws NPE when operating on ConcurrentHashMap$$It seems that the fix introduced for  #1411 in 2.8 can be problematic for ConcurrentSkipListMap (and possibly other map data structures).  doc for ConcurrentSkipListMap.doGet()$$patch1-bears-8_Developer_PatchNaturalnessYe$$Fixed MapSerializer # 153. Fixed method name in MapSerializer. $$1
bears-175$$NPE importing EMX with abtract entity type data$$How to Reproduce  Import  this file Expected behavior  Success, or if I am not allowed to add data to abstract entities I expect a message  Observed behavior  Importer hangs, server logs report a null pointer exception in the  dataservice.add() method.$$patch1-bears-175_Developer_PatchNaturalnessYe$$removed unused imports. throw exception if entityType is abstract. $$1
bears-21$$DateTimeSerializerBase ignores configured date format when creating contextual$$DateTimeSerializerBase#createContextual creates a new serializer with StdDateFormat.DATE_FORMAT_STR_ISO8601 format instead of re-using the actual format that may have been specified on the configuration. See the following code:  Using the  @JsonFormat annotation on a field will therefore reset the format to Jackson's default even if the annotation doesn't specify any custom format.  DateBasedDeserializer#createContextual behaves differently and tries to re-use the configured format:  Shouldn't the serializer follow the same approach ?$$patch1-bears-21_Developer_PatchNaturalnessYe$$Fix # 1862. $$1
bears-86$$ProxyingHandlerMethodArgumentResolver handles interfaces not intended for projection [DATACMNS-776]$$opened and commented A Spring Boot application that depends on  spring-boot-starter-data-pa and uses Spring Mobile will create a proxy for Spring Mobile's Device interface when it's injected into a handler method. Calling isMobile on this proxy fails as follows:  The culprit is  ProxyingHandlerMethodArgumentResolver which takes responsibility for any argument that's an interface. I can work around the problem by ensuring that Spring Mobile's DeviceHandlerMethodArgumentResolver appears before ProxyingHandlerMethodArgumentResolver in Spring MVC's list of argument resolvers but I'd prefer not to have to do so. Can ProxyingHandlerMethodArgumentResolver be fixed so that it either doesn't claim responsibility for anything that's an interface, or so that it returns a working proxy?   Affects: 1.10.2 (Fowler SR2), 1.11 GA (Gosling)  Issue Links:     Backported to:  1.13 GA (Ingalls) , 1.12.7 (Hopper SR7) , 1.11.7 (Gosling SR7) 4 votes, 8 watchers$$patch1-bears-86_Developer_PatchNaturalnessYe$$Missing import. Remove unused import. Ignore data . web . proxy . support . SpelAwareProxyProjectionFactory. Fix support for non - interface parameters. $$1
bears-44$$bug in removeStatement$$In this example, if you want to remove the second i++ with  block.removeStatement(block.getStatement(3)); , Spoon removes the first one.  (found by  @martinezmatias thanks!)$$patch1-bears-44_Developer_PatchNaturalnessYe$$Added support for removeStatement. $$1
bears-88$$RepositoryBeanNameGenerator fails to resolve bean names for custom implementations detected via Spring's component index [DATACMNS-1115]$$opened and commented After upgrading to Spring Boot 2.0.0.M2 and Spring Data Kay.M4 I cannot start my microservices any more which are accessing MongoDB. A testcase is appended to produce the stacktrace below.  First I thought it is a Spring Boot issue spring-projects/spring-boot#9780 Stacktrace:    Affects: 2.0 M4 (Kay)  Attachments:     Backported to:  1.13.5 (Ingalls SR5) , 1.12.12 (Hopper SR12)$$patch1-bears-88_Developer_PatchNaturalnessYe$$Fix copyright year in repository . config. Fixing the build .. $$1
bears-31$$element.toString() crashes with a NP in DefaultJavaPrettyPrinter.visitCtTypeReference()$$When analyzing elasticsearch we get a NP when calling element.toString().  As this has something to do with type references, I can't give you a concrete source file with this problem, but rather a part of the project as tar archive. (  elasticsearch.tar.gz )$$patch1-bears-31_Developer_PatchNaturalnessYe$$Fix CtTypeReferenceImpl . is visible in package only. Added throw .. $$1
bears-131$$meitrack temp sensor with negative value$$Hi Anton,  I'm receiving a wrong value from temp sensor for negative temp values, example: data for temp is 06FB2E which should translate to -12.34°C according to doc for protocol v3.  Could you please check if traccar is reading temp correctly for negative values?  a sample data to test with:   Regards,$$patch1-bears-131_Developer_PatchNaturalnessYe$$Mimics the parser ' s rules about byte precision .. $$1
bears-91$$Jackson configuration is not used by ProjectingJackson2HttpMessageConverter  [DATACMNS-1152]$$opened and commented  ProjectingJackson2HttpMessageConverter is not using the default MappingJackson2HttpMessageConverter constructor to instantiate an ObjectMapper (that uses Jackson2ObjectMapperBuilder to create a Jackson ObjectMapper based on application configuration), instead ObjectMapper is created directly in SpringDataWebConfiguration.extendMessageConverters(…) . That causes  ProjectingJackson2HttpMessageConverter to not use Jackson configuration from application.properties to create the ObjectMapper and there is no possibility to configure Jackson ObjectMapper . That also breaks MappingJackson2HttpMessageConverter configuration functionality. To solve that issue ObjectMapper creation should be delegated to MappingJackson2HttpMessageConverter default constructor   Affects: 1.13.6 (Ingalls SR6), 2.0 RC2 (Kay)  Backported to:  1.13.7 (Ingalls SR7)$$patch1-bears-91_Developer_PatchNaturalnessYe$$Added missing import. Added missing property to spring data web config. Added private static method to get unique bean .. $$1
bears-96$$Repositories does not expose registered repository for proxy type [DATACMNS-1215]$$opened and commented Converting an entity to an ID using  DomainClassConverter.ToIdConverter fails if the entity instance is actually a proxy. This is because DomainClassConverter.ToIdConverter.matches(…) only checks for a repository with the sourceType.getType() . In the case of a Hibernate proxy, this type is EntityClass_$$patch1-bears-96_Developer_PatchNaturalnessYe$$Fix Repositories . containsKey ( Class ). Use the user class in the Repositories. $$1
bears-54$$Exception at compilation due to a constructor with private visibility$$Hello,  I'm having an issue while instrumenting the source code of  AssertJ with Spoon. The instrumentation part will work, but the compilation part will fail due to the following error:  I created a small Maven project with the part of the AssertJ source code that I cannot instrument/compile with Spoon.  The project architecture is the following:   According to the Exception message, the problems comes from the class  BooleanArraysBaseTest , which contains the following code:  The statement  arrays = new BooleanArrays(); refers to the BooleanArrays class contained in the same package ('internal'), which is a Singleton, having a constructor with the package visibility:  The other class also called  BooleanArrays , but contained in the other package ('test') has a private constructor. My Launcher configuration is the following:   Is there something wrong with my configuration ? I managed to instrument several other projects, but not this one.  Tell me if you need any other information. An archive containing this project is available  here . Thank you,  Thibault$$patch1-bears-54_Developer_PatchNaturalnessYe$$Added exploredReferences to ImportScannerImpl .. Added a method to check if another class reference has the same name .. Added simple check to see if class is still in another package .. Added note for classImports . put ( ref . getSimpleName ( ) , ref ). $$1
bears-199$$Stop receiving records with error  "Last request was dispatched at...but no response as of ...Cancelling subscription, and restarting." (KCL 2.0)$$I have a Kinesis stream of 2 shards with data published to it continuously. I use KCL 2.0.1 java to connect to the stream with polling (by populating retrievalConfig.retrievalSpecificConfig with a PollingConfig object). It works completely fine and keeps receiving messages from both shards for the first 10 minutes. After that, it stops receiving any message, even there is data continuously published to the stream. I leave the process running for 5 more minutes and issue persists. After that I restart the process, and it starts receiving messages again from both shards, but stops receiving messages again after running for 10 minutes. Issue happens repeatedly.  No throttling error is seen in logs. Instead, following errors are seen in logs:   2018-10-19 14:12:43,531 ERROR [main] shardId-000000000000: Last request was dispatched at 2018-10-19T03:12:07.772Z, but no response as of 2018-10-19T03:12:43.531Z (PT35.759S).  Cancelling subscription, and restarting. This kind of logs appear once for every 35 seconds for each shard. When it first appeared, it happened to shardId-000000000000, and no more messages are received from this shard. Then it appeared for shardId-000000000001 as well, and no more message is received from this shard.  To isolate the publishing factor, I've done another test where I first published lots of data to the stream without consuming. Then I stop publishing and start the consumer application. Same behaviours are observed.  Same behaviours are observed with KCL 2.0.3.  I've extracted and attached the relevant application logs and error logs for reference.   app.log  error.log Any idea?$$patch1-bears-199_Developer_PatchNaturalnessYe$$Fixed a bug in PrefetchRecordsPublisher . addArrivedRecordsInput. $$1
bears-99$$Blank map and no pointer when tracker is sending vibration alarm$$Hello,  Im very happy with the traccar platform but got a strange issue.  I got about 40 trackers connected but 2 is missing map and pointers. I noticed those 2 trackers is marked with ´vibration´ alarm and ignition OFF. Is it a bug or am I doing something wrong ? trackers is running on h02 protocol.  Thanks$$patch1-bears-99_Developer_PatchNaturalnessYe$$Fix checkstyle. Remove debug code. Missing return null for $ { } marker. Fix license header. Skip X char in H02 frame headers .. Improved H02 frame decode logic so that X messages are sent earlier. $$1
bears-55$$Variable called "java" messes with the imports$$Hello,  I'm Spooning the JUnit4 source code, and in the following class , a variable has been named "java":  String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java"; I configured my launcher with  launcher.getEnvironment().setAutoImports(false); , after running the launcher, the following code is generated:  java.lang.String java = ((((java.lang.System.getProperty("java.home")) + (java.io.File.separator)) + "bin") + (java.io.File.separator)) + "java"; Which is completely normal, but the compilation will fail because "java.lang.System" refers to the "java" String declared earlier, which has no "lang" attribute (obviously).  Since my previous issue I'm running Spoon using  launcher.getEnvironment().setAutoImports(false); . Since it is quite specific, I'm renaming the Java variable in the source code, but it can be a bit time-consuming, when there's multiple classes with a similar variable.  Thibault$$patch1-bears-55_Developer_PatchNaturalnessYe$$Added import spoon . reflect . code . CtLiteral to ImportScannerImpl . java. Added imports for StringTokenizer. removed redundant check. Changed imports .. Don ' t import class with name clash in java . lang .. Improve javadoc in ImportScannerImpl. Properly handle imports for literals. Updated parent type if it ' s a member of the interface. FIX GROOVY - 7791 - Added a note that the import of. Added missing @ param javadoc. Removed class imports from minimal import scanner. Removed class imports from minimal import scanner. @@ modifier to non - partial match for importTypeStr. $$1
bears-97$$When true setOneIndexedParameters still behaves as false in the links of the json response [DATACMNS-563]$$opened and commented When setting this to true, the argument 1 accepted from the HTTP request is indeed considered to be the index of the first page, but the json response still displays links as if the first page is indexed 0. For example, requesting the page 3 gets the page 3 but the links are described ignoring the index start at 1. The prev link should show 2 and the next link should show 4. As it stands now, the next page link has the same index as the current page in the request.     Affects: 1.8.2 (Dijkstra SR2)  Referenced from: pull request #267  Backported to:  2.0.3 (Kay SR3) , 1.13.10 (Ingalls SR10)$$patch1-bears-97_Developer_PatchNaturalnessYe$$Added missing license header. Add missing author tag. Added support for paged resources as property. $$1
bears-108$$cGuard protocol decoding issue$$I've got a pair of cGuard Atom devices,  one of the them is '2015' and another one - '2016'. I'm trying to install and configure the Traccar server (inside Docker) to acquire data from the devices.  Traccar version: 3.10,  cGuard Atom fw: 3.2.3 (the latest available) The server successfully detects a new device (2017-04-09 03:06:43  WARN: Unknown device - 35338606530**** (***)) and after a couple of minutes begins to decode gps-data. However, the navi data seem to be being decoded incorrectly. All the testing time, coordinates are zeroes, the datetime mark correspond to Unix epoch time, etc.. (see below).   The hex-decoder on the Trackar site correctly decodes HEX-parts of the data:$$patch1-bears-108_Developer_PatchNaturalnessYe$$Fix match for missing digits. $$1
bears-90$$AbstractPersistentProperty.getRawType() does not consider generics [DATACMNS-1139]$$opened and commented  AbstractPersistentProperty.getRawType() currently uses the field's or property descriptor's type which in turn doesn't use our generics resolution mechanism which means for generic fields you'll get different results if you call ….getTypeInformation().getType() and ….getRawType()   Affects: 1.12.11 (Hopper SR11), 1.13.6 (Ingalls SR6), 2.0 RC2 (Kay)  Backported to:  1.13.7 (Ingalls SR7) , 1.12.12 (Hopper SR12)$$patch1-bears-90_Developer_PatchNaturalnessYe$$Use the type when creating a persistent property .. $$1
bears-241$$should use provided pullRequestTitle when creating the PR$$Summary  Related to  societe-generale/ci-droid#6 : new "pullRequestTitle" field needs to be taken into account when creating the PR Type of Issue  It is a :       Motivation  Current Behavior  the PR is created, but takes the commitMessage as title : now that a dedicated field (pullRequestTitle) has been introduced in the model, we should use it  Expected Behavior  use pullRequestTitle if provided - otherwise use the branch name as PR title  Steps to Reproduce (for bugs)  Your Environment    Version used: 1.0.5  OS and version:  Version of libs used:$$patch1-bears-241_Developer_PatchNaturalnessYe$$disabled existing resource do not exist check for continue task. Fix consumer service pull request title provided by user. $$1
bears-212$$YamlGenerator closes the target stream when configured not to$$Bug description  YamlGenerator closes the target stream when configured not to.  Versions used  jackson-dataformat-yaml 2.9.2  jackson-databind 2.9.6 Expected result  The target stream not closed when writing a value. No output when running reproduction script/program.  Actual result  The target stream is closed when using the YamlGenerator, with the following output when running the reproduction script/program.   Steps to reproduce$$patch1-bears-212_Developer_PatchNaturalnessYe$$Allow parser to close the stream if it is resource - managed. Fix YAMLGenerator close. $$1
bears-240$$Context must read system properties to rewrite properties from file.$$Context must read system properties to rewrite properties from file.$$patch1-bears-240_Developer_PatchNaturalnessYe$$made constructor public. Added missing import. Ctor of StDefault can take multiple arguments. $$1
bears-225$$ReactiveCommandSegmentCommandFactory resolves StreamingOutput for all reactive types$$I'm using Redis Lettuce dynamic client as described in official documentation  https://github.com/lettuce-io/lettuce-core/wiki/Redis-Command-Interfaces#command-interfaces.response-types My commands interface looks exactly the same   The problem is when method get cannot find value by key there's exception thrown instead of returning empty Mono.   When using predefined RedisReactiveCommands get works fine, it returns empty Mono. So it seems like a bug to me.  The Redis Lettuce version being used is   < Also checked with 5.0.4 RELEASE - issue remained$$patch1-bears-225_Developer_PatchNaturalnessYe$$Added missing constructor .. Fix resolving of streaming configuration for RMI segment commands. remove dependency of ReactiveTypes . supports. $$1
bears-206$$Large HTML File conversion to PDF hangs.$$Hi,  I am trying to convert large HTML File approximately 600 pages which is not passing the conversion and hangs.  Following is my observation after debugging the core.  PdfRendererBuilder.class file has following method call.   renderer.layout(); // This action takes significant time but completes the process.  when I looked into it renderer.createPDF()  is trying to create entire PDF in memory (document) and after completion it starts writing to OutputStream.  Can we write it directly to OutputStream page by page? I think this might solve the problem.  Following is my code snippet please check the same if I am doing anything wrong here.   In  above code snippet it is not completing  builder.run(); process and hangs. Please help me with the solution.  Thanks in advance.$$patch1-bears-206_Developer_PatchNaturalnessYe$$Remove unused import .. always use left / right arrows in order to avoid an NPE in the selection .. always apply left margin of shadow page in LTR direction. Fix max FFT in PageBox. $$1
bears-230$$TracingP6SpyListener is not computing the Tags.DB_TYPE properly.$$Type: bugfix  In the TracingP6SpyListener class, line 112   We should take into account that a url returned by a DatabaseMetaData can be null.$$patch1-bears-230_Developer_PatchNaturalnessYe$$Missing peer name and dbInstance tags on p6spy listener. Fix NPEER_SERVICE_FINDER url reference .. isNullOrEmpty ( String ) returns a non - null value , even if it ' s empty ( ). $$1
bears-46$$CtElementImpl.getMetadataKeys() throws NPE$$I get NPE when invoking method getMetadataKeys() on CtElement. Looking through source code, it looks like metadata can be null. It should have null check and return null like getMetadata() method or return empty set.$$patch1-bears-46_Developer_PatchNaturalnessYe$$Added metadata keys if it is null. $$1
bears-79$$Processor is not using templated type when process method is in an abstract class$$We define an abstract spoon Processor declaring a process method on a templated type:     And create a concrete class extending the previous one:      The problem is that both the concrete processors are receiving every classes that matches the  upper bound of our template.$$patch1-bears-79_Developer_PatchNaturalnessYe$$Changed sympathy with ProcessingVisitor. $$1
bears-48$$[generic type] Regression in being able to spoon Guava$$It seems that  #1218 introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon, see the trace :     See full stack trace:   https://ci.inria.fr/sos/job/Guava/262/console$$patch1-bears-48_Developer_PatchNaturalnessYe$$Added note to ClassTypingContext . getActualTypeArguments for non - type scoped closures. Added getActualTypeArguments to ClassTypingContext .. $$1
bears-84$$Persist fails on entity without id and version field if @EnableAuditing [DATACMNS-957]$$opened and commented Follow domain should be persist:   It works, as long as auditing is turned off. After putting  @EnableAuditing to application follows exception is thrown:   Description: If auditing is enabled those steps are executed:    Determine strategy to fill auditing fields  Find fields that should be filled via auditing  Fill found fields  If strategy can't be determined (because id and version is not available in domain) exception is thrown and object isn't persisted.  This exception is also thrown if you don't have any fields in model that are filled via auditing.  There is no need to throw this exception if no fields are filled via auditing. Some code to make it clear:     I've patch for this ticket.  PR: #189   Issue Links:     Referenced from: pull request #189  Backported to:  1.13 GA (Ingalls) , 1.12.7 (Hopper SR7) , 1.11.7 (Gosling SR7)$$patch1-bears-84_Developer_PatchNaturalnessYe$$Added method that is considered to be auditable by the OSGi module. Do not log null - compilation error. $$1
bears-184$$Improve identifier metadata detection for XML based entity mappings [DATAJPA-658]$$opened and commented I have a model in POJO's and my persistence configuration in a separated project with an orm.xml file. I want to expose my persistence API and I have detected that entities are only configured when they are annotated with persistence annotations (  @Id for example). We cannot annotate our entities as they come from a target model which we don't have the source code. It would be great that Spring Data REST were configurable using  orm.xml files or other .xml source apart from annotations. Thank you    Affects: 1.7.1 (Evans SR1), 1.8 M1 (Fowler)  Issue Links:     Referenced from: pull request #146  Backported to:  2.0.4 (Kay SR4) , 1.11.11 (Ingalls SR11) 2 votes, 6 watchers$$patch1-bears-184_Developer_PatchNaturalnessYe$$Fix JPA spec. $$1
bears-170$$A mapping service mapping error has its toString value inserted into an integrated dataset$$How to Reproduce     Go to the mapping service  Create a new mapping project with  Add TypeTestRef as new source  Edit label attribute  Fill in  Create integrated dataset  Expected behaviour  Mapping fails because the validation for the label to label mapping contains script errors  Observed behaviour  The mapping is executed and the toString() value of the error is inserted as a label$$patch1-bears-170_Developer_PatchNaturalnessYe$$removed unused import. Convert exception in jsMagmaScriptEvaluator. If jsMagmaScriptEvaluator . eval ( ) throws , throw the exception. $$1
bears-24$$Infinite recursion when deserializing a class extending a Map, with a recursive value type.$$Hello, I am using jackson-databind 2.8.8, and have a class with an unusual definition (extending a Map, where the values are of the type of the same class). It seems like I am facing an infinite recursion issue.  To reproduce you can re-use or inspire from the class defined  here . Then, when executing the following code:    When calling  readValue() the mapper throws a StackOverflowException , here's the stacktrace:  Looking briefly into the code, it seems like because of the recursive definition of the class, the  equals call in MapLikeType may never get out of this loop. Any idea? Thanks.$$patch1-bears-24_Developer_PatchNaturalnessYe$$Added a note that the resolved type doesn ' t match any type .. $$1
bears-23$$StdDateFormat deserializes dates with no tz/offset as UTC instead of configured timezone$$Prior to version  2.8.9 , dates without time zone or time offset (eg 1970-01-01T00:00:00.000 ) were deserialised in the TimeZone set on the ObjectMapper. Starting from 2.8.9 , these dates are deserialised in UTC - which is a major (breaking) change in behaviour... Example:$$patch1-bears-23_Developer_PatchNaturalnessYe$$Add @ since comment for ' date . format ' method. Add ISO8601 NO_TZ date format to all supported date formats .. Remove RFC1123 and ISO8601 NO_TZ date formats .. Fixed erroneous override for ISO8601 no - TZ .. Add formatISO8601_noTz back. Remove possible timeZone fix. Fixed erroneous build .. Add missing fields. $$1
bears-4$$ArrayIndexOutOfBoundsException on impossible non-static inner class constructor$$Minimal repro:     Fails like this:   Validation is missing for this impossible constructor. Works as expected when  InnerSomething is static.$$patch1-bears-4_Developer_PatchNaturalnessYe$$Added getter for inner class property. $$1
bears-15$$@JsonIdentityReference not used when setup on class only$$I am trying to setup @JsonIdentityInfo/@JsonIdentityReference in order to serialize all references to a given class as Object Id (and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance)  I use @JsonIdentityReference(alwaysAsId=true) in order to enforce exporting the object id in all cases.  It does not work as expected when I define the annotation only on the class (but it works fine when I set it directly on the property). I would rather not have to define it on every property as I will probably miss some... From what I see in  BeanSerializerBase , the alwaysAsId is reset when not ObjectIdInfo is found on the accessor:   Shouldn't it be kept to the current value when no override is found ?  I tried to set it back in the default ObjectIdInfo created with NAME_FOR_OBJECT_REF but I am not sure if this is the right way to fix this. Here is test I added in  TestObjectIdSerialization for this case:$$patch1-bears-15_Developer_PatchNaturalnessYe$$Fix copy / paste error. Fix JacksonAnnotationIntrospector # findObjectReferenceInfo ( JsonIdentityReference ). Add empty constructor .. Add an empty method for ObjectIdInfo withAlwaysAsId. $$1
bears-3$$ACCEPT_CASE_INSENSITIVE_PROPERTIES fails with @JsonUnwrapped$$(note: moved from  FasterXML/jackson-dataformat-csv#133 ) When trying to deserialize type like:   with case-insensitive mapper (  mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES); ) I get exception:$$patch1-bears-3_Developer_PatchNaturalnessYe$$Added hash calculation of BeanPropertyMap , now that we have calculated the size of the primary. Added missing closing bracket. Add case note for property name. $$1
bears-12$$Missing properties when deserializing using a builder class with a non-default constructor and a mutator annotated with  @JsonUnwrapped$$When deserializing using a builder class with a non-default constructor and any number of mutator methods annotated with @JsonUnwrapped, the  BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped method cuts short the process of adding SettableBeanProperties. The logic dictates that once all properties necessary to construct the builder have been found, the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process.  Therefore, in the case that the builder has a single property required for construction, and that property is found anywhere other than at the end of the JSON content, any properties subsequent to the constructor property are not evaluated and are left with their default values.  Given the following classes:   And given the following JSON string:   { We will see the following output:   However, if we place the  emp_id property at the end of the JSON string, we would get the following output:  If we were to place  emp_age and emp_first_name and emp_last_name all after the emp_id property in the JSON string, we would get the following output:$$patch1-bears-12_Developer_PatchNaturalnessYe$$Added missing jackson annotation. Restore unwrapper access to BuilderBasedDeserializer. Add missing Override annotation. Add finishBuild ( ) method to BuilderBasedDeserializer. Added a comment. Removing a couple of false positives. Added missing jackson annotation. Added missing semicolon. Added missing if (. Added streamlined version of BuilderBasedDeserializer. Fix typo. Added missing semicolon. Add unintentional modifier to BuilderBasedDeserializer . deserializeWithView ( ). Add back missing jackson annotation. Added empty loop body. Added suppression. Fix an issue with builder based deserializer that can ' t handle unwrapped properties. Add unintentional modifier to BuilderBasedDeserializer . java. Add missing semicolon. $$1
bears-85$$NullPointerException in ProjectingJackson2HttpMessageConverter [DATACMNS-972]$$opened and commented Managed to get a nullpointer after switching to spring-boot 1.5.0.RC1 from 1.4.3.RELEASE  Nullpointer happens because the "rawType" is null when the "type" is generic type(like T or D).   With generic type the "targetClass" is initialised here correctly using ResolvableType.forMethodParameter(parameter).resolve():   spring The new "ProjectingJackson2HttpMessageConverter" converter is initialized as first converter here because spring-boot defines json-path depenency.   spring Stacktrace:     Affects: 1.13 RC1 (Ingalls)  Reference URL:  https://jira.spring.io/browse/DATACMNS-885  Attachments:      Backported to:  1.13 GA (Ingalls)$$patch1-bears-85_Developer_PatchNaturalnessYe$$Added missing owner to the cache key. $$1
bears-71$$issue with isOverriding behavior when extending TypeParameters$$If you consider the interface  Iterable<E> which contain a method forEach(Consumer<? super E>) and if you create a class with a T extends String which implements Iterable<T> , then you implement your own version of forEach : if you use ClassTypingContext.isSameSignature() on the two forEach methods, it will return false because they do not have the same type parameter. I'm really not sure if this is a bug or not: in the overriding method, the type parameter is more defined, so the signature is not exactly the same. But then, if we only use  isSameSignature in getAllMethods (see #1375 ) we will get both Iterable#forEach and ArrayList#forEach , when using it on ArrayList . WDYT? Should we consider the signature are the same, or should we consider that  getAllMethods should indeed return the two different methods? Edit: Actually I extended my test to check with  isOverriding and it returns false which is obviously wrong. So there's a real issue here.$$patch1-bears-71_Developer_PatchNaturalnessYe$$Removed unnecessary cast .. Changed visitType to use generics as value. fixing NPE in CtExecutableReferenceImpl . getDeclaration. Added missing negotiating parameterized bindings put in the code. Reduced the number of times that a superclass has a super class for Enum. $$1
bears-78$$NPE on DefaultJavaPrettyPrinter#printCtFieldAccess$$More intel about bug reproduction can be found on the following issue:  HabchiSarra/SmellDetector#8 The full stack trace using spoon 5.9.0-SNAPSHOT below$$patch1-bears-78_Developer_PatchNaturalnessYe$$Do not put fieldDeclaration in implicit target. $$1
bears-13$$@JsonProperty(access = READ_ONLY) together with generated constructor (lombok) causes JsonMappingException: Could not find creator property with name [...]$$The following class fails to deserialise with a  com.fasterxml.jackson.databind.JsonMappingException: Could not find creator property with name 's' (in class LombokObject) :  Whereas the following class - which is functionally identical but with constructors, getters and setters in the code - can be deserialised:   The exception is$$patch1-bears-13_Developer_PatchNaturalnessYe$$Added getter for creator properties in BeanDeserializerFactory. Fix getter / setter legis. fixed findConstructorParameter ( ) for non - concrete property. Added a couple of errors in the deser mapping , so that it is reported to the. $$1
bears-5$$No Object Id found for an instance when using @ConstructorProperties$$Hi! We recently migrated from 2.4.6. to 2.8.1. and we encountered the issue. We use lombok's  @AllArgsConstructor which adds @ConstructorProperties to constructor. We also used @JsonIdentityInfo on our POJO which lead to JsonMappingException: No Object Id found for an instance exception. The following test code demonstrates the issue   Stack trace   Prior to the version 2.5.0 this was not an issue, because the offending method (  com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer.handleIdValue(DeserializationContext, Object) ) had a comment // TODO: is this an error case? and did nothing else.$$patch1-bears-5_Developer_PatchNaturalnessYe$$Ignoring Id property in BeanDeserializer. Remove unnecessary check for ObjectId property. $$1
bears-14$$Jackson Deserializer security vulnerability via default typing (CVE-2017-7525)$$I have send email to  info@fasterxml.com$$patch1-bears-14_Developer_PatchNaturalnessYe$$Added check for illegal types in BeanDeserializerFactory. Added a method to check illegal types for JSON output. $$1
bears-22$$Missing properties from base class when recursive types are involved.$$When a type hierarchy as follows is constructed and the base class' type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class.   Serializes sub as  {"sub":2} where {"base":1,"sub":2} is expected. I've created a minimal scenario of this bug here:  https://github.com/slobo-showbie/jackson-recursive-type-bug I've experienced this bug in 2.7.8, 2.8.8, and 2.8.8.1$$patch1-bears-22_Developer_PatchNaturalnessYe$$Added missing superClass method. $$1
bears-149$$When i use the parameters configured in the dubbo provider in the routing rules, the rules can not be matched$$如果将参数添加到dubbo provider中，例如：   <dubbo:provider  serialization="fastjson" /> 这样生成的url中会带有 default.serialization=fastjson 这样的参数。 如果路由规则设置为 "=> serialization=fastjson"，是无法过滤出带有 default.serialization=fastjson 的提供者的。$$patch1-bears-149_Developer_PatchNaturalnessYe$$add default key prefix to sample. $$1
bears-171$$When I upload data with one row, data is not uploaded$$How to Reproduce  Upload with advanced importer, add mode:   eric_de_test_model.xlsx Upload csv in this zip:  eu_bbmri_eric_DE_biobanks.csv.zip Expected behavior  1 row is added to the biobanks table  Observed behavior  Import succeeds, 0 rows imported$$patch1-bears-171_Developer_PatchNaturalnessYe$$Add missing imports. Excel sheet has extra space left. Excel sheet has too many columns but no values. $$1
bears-185$$NativeQuery with Pagination validation error at startup [DATAJPA-928]$$opened and commented According to Example 50 at  Using @Query docs , it's possible to use a native query with pagination using Pageable but in my case it's failing with a org.springframework.data.jpa.repository.query.InvalidJpaQueryMethodException. NativeJpaQuery constructor is checking if the query has a Pageable parameter and if the queryString contains a #pageable or #sort sequence. The query has Pageable parameter but it  does not contain a #pageable string:   If I provide a #pageable string at the end of the query, validation passes, but when the query executes, it fails saying that it's expecting 3 parameters instead of 2.  Funny thing is that, when the server is starting, if I set a breakpoint inside NativeJpaQuery and change containsPageableOrSortInQueryExpression from false to true manually, validation passes just fine and the query executes well, paginating    Affects: 1.10.1 (Hopper SR1), 1.10.2 (Hopper SR2)  Reference URL:  http://stackoverflow.com/questions/38349930/spring-data-and-native-query-with-pagination  Issue Links:     Referenced from: pull request #246 , and commits , , ,  Backported to:  2.0.4 (Kay SR4) 1 votes, 12 watchers$$patch1-bears-185_Developer_PatchNaturalnessYe$$added missing author tag. Added invalid closing tag. $$1
bears-25$$StackOverflowError in Dynamic StdKeySerializer$$There seem to be a problem (checked and doesn't seem to be fixed in latest version) with the serialize method of the Dynamic static class of the StdKeySerializer.   The problem comes from the fact that when  ser is null , the new ser returned by _findAndAddDynamic is incorrectly filled.  So say we are in  ser#1 , ser#1._dynamicSerializers now has the correct PropertySerializerMap$Single . However, result.serializer._dynamicSerializers has PropertySerializerMap$Empty . Therefore, a new call with that result ser#2 is made which ends up creating an infinite loop. Possible fix:    replace  If I'm mistaken please let me know, but It seems obvious when debugging that something's is not working as intended$$patch1-bears-25_Developer_PatchNaturalnessYe$$Added fix for Object . toString ( ). $$1
bears-89$$Invalid generics resolution for locally declared wildcard and fully resolved target type [DATACMNS-1138]$$opened and commented Given the following context:    An entity declares a field which type is a class with a wildcard type  An implementation of the field's class is typed with a custom object  A custom converter has been declared for the custom object  We persist an entity with the custom class in Mongo  Then when we retrieve the entity from the database, the field with the custom type is not deserialized by the custom converter.  This problem does not happen if:   We remove the wildcard from the declared field  We use a type that does not require a custom converter (e.g. Integer)  I'm not sure if this description is clear, please take a look at the project on GitHub:  https://github.com/mclem/spring-data-mongodb-generics to reproduce the problem by running mvn test   Affects: 1.12.11 (Hopper SR11), 1.13.6 (Ingalls SR6), 2.0 RC2 (Kay)  Reference URL:  https://github.com/mclem/spring-data-mongodb-generics  Issue Links:     Backported to:  1.13.7 (Ingalls SR7) , 1.12.12 (Hopper SR12)$$patch1-bears-89_Kali_PatchNaturalnessYe$$Revert I3fdda2588a7c612d7c9cfb. $$0
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_HDRepair_PatchNaturalness$$fixed typo .. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_HDRepair_PatchNaturalness$$Use availableLocaleList ( ) instead of cAvailableLocaleSet. $$1
closure-61$$Closure removes needed code.$$None$$patch1-closure-61_Developer_PatchNaturalness$$Fix regexp global references for Math namespaces .. $$1
closure-95$$Use @public tag to prevent compression of symbol names$$None$$patch1-closure-95_Developer_PatchNaturalness$$Fix false positives in TypedScopeCreator. $$1
closure-132$$if statement$$None$$patch1-closure-132_Developer_PatchNaturalness$$don ' t mayEffectMutableState ( lhs ) if lhs is a literal if its side effects. $$1
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_Developer_PatchNaturalness$$"Fix for CB - 7044 "" Compiler does not disable "" GlobalThisLevel . is. $$1
closure-92$$bug with implicit namespaces across modules$$None$$patch1-closure-92_Developer_PatchNaturalness$$Fix code indexing .. $$1
closure-66$$@enum does not type correctly$$None$$patch1-closure-66_Developer_PatchNaturalness$$"Enable "" typeable = false """. $$1
closure-104$$Typos in externs/html5.js$$None$$patch1-closure-104_Developer_PatchNaturalness$$JSType . isNoType ( ) doesn ' t return any type when union type is no. $$1
closure-50$$Optimisation: convert array.join(",") to array.join()$$None$$patch1-closure-50_Developer_PatchNaturalness$$Fix PeepholeReplaceKnownMethods case .. Added reportCodeChange ( ) to replaceKnownMethods case .. $$1
closure-68$$Cryptic error message on invalid "@type function" annotation$$None$$patch1-closure-68_Developer_PatchNaturalness$$Fix the indentation of jsdoc info .. Restore look ahead to the beginning of array or object .. Restore look ahead to the generics compiler error that was spotted by the previous fix .. $$1
closure-103$$Compiler gives false error with respect to unreachable code$$None$$patch1-closure-103_Developer_PatchNaturalness$$Fix an issue with that damn type when checking for properties on objects with properties on them .. Add INSTANCEOF to control flow analysis .. $$1
closure-57$$compiler crashes when  goog.provide used with non string$$None$$patch1-closure-57_Developer_PatchNaturalness$$Fix CodingConvention. $$1
closure-32$$Preserve doesn't preserve whitespace at start of line$$None$$patch1-closure-32_Developer_PatchNaturalness$$Fix the JSDoc info parser ' s line start char .. Reset lineStartChar after each token .. Reset lineStartChar after PRESERVE .. Remove whitespace in JsDocInfoParser. $$1
closure-35$$assignment to object in conditional causes type error on function w/ record type return type$$None$$patch1-closure-35_Developer_PatchNaturalness$$Don ' t define the declared properties of record types as defined in the JSDoc .. $$1
closure-102$$compiler assumes that 'arguments' can be shadowed$$None$$patch1-closure-102_Developer_PatchNaturalness$$Fix jscomp warnings. $$1
closure-69$$Compiler should warn/error when instance methods are operated on$$None$$patch1-closure-69_Developer_PatchNaturalness$$Added missing report in TypeCheck .. $$1
closure-56$$Last warning or error in output is truncated$$None$$patch1-closure-56_Developer_PatchNaturalness$$Don ' t return null if end of file is reached. $$1
closure-105$$Array Join Munged Incorrectly$$None$$patch1-closure-105_Developer_PatchNaturalness$$Allow one - line ifs. Allow null string folding. $$1
closure-51$$-0.0 becomes 0 even in whitespace mode$$None$$patch1-closure-51_Developer_PatchNaturalness$$Fix negative zero log10. Add a method for testing negative zero numbers .. $$1
closure-58$$Online CC bug: report java error.$$None$$patch1-closure-58_Developer_PatchNaturalness$$Fix dead code .. $$1
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_Developer_PatchNaturalness$$Reset unread token on getRemainingJSDocLine ( ) .. $$1
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_Developer_PatchNaturalness$$Add an EXPR_RESULT to the usage list of properties in Java 8 .. $$1
closure-94$$closure-compiler @define annotation does not allow line to be split on 80 characters.$$None$$patch1-closure-94_Developer_PatchNaturalness$$Added define value validation for bit operators .. $$1
closure-60$$void function () {}(); wrongly identified as having no side effects$$None$$patch1-closure-60_Developer_PatchNaturalness$$Allow false / TRUE literals in boolean type arguments .. Allow vars to be used as side effects in JSF. $$1
closure-34$$StackOverflowError exception when running closure compiler (javascript attached)$$None$$patch1-closure-34_Developer_PatchNaturalness$$Fix unrollBinaryOperator. Fix cc issue. Fix appendOp ( ) with comma .. $$1
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_Developer_PatchNaturalness$$Avoid matching against an unreferenced type .. $$1
closure-20$$String conversion optimization is incorrect$$None$$patch1-closure-20_Developer_PatchNaturalness$$AllowImmutableValue to be used as a literal in PeepholeSubstituteAlternateSyntax. $$1
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_Developer_PatchNaturalness$$Don ' t do closure pass if closure pass is used .. $$1
closure-27$$Error trying to build try-catch block (AST)$$None$$patch1-closure-27_Developer_PatchNaturalness$$Add static method to create a block node from StatementStore .. try / finally body must be blocks , not labels .. Allow try / catch to be used as a try / catch statement. $$1
closure-9$$Compiler fails to find amd module in a subdirectory$$None$$patch1-closure-9_Developer_PatchNaturalness$$Fix DOS script for modules .. Remove normalizeSourceName from moduleName so it can be used as a source filename .. $$1
closure-11$$Record type invalid property not reported on function with @this annotation$$None$$patch1-closure-11_Developer_PatchNaturalness$$Remove unnecessary return statement in TypeCheck . java. $$1
closure-7$$Bad type inference with goog.isFunction and friends$$None$$patch1-closure-7_Developer_PatchNaturalness$$Don ' t filter out subtypes of "" function "" if the receiver is a prototype type .". $$1
closure-29$$closure compiler screws up a perfectly valid isFunction() implementation$$None$$patch1-closure-29_Developer_PatchNaturalness$$Add Set < String > .. Fix blacklisting of invalid properties in object literals. Add valid properties to inline object literals. $$1
closure-16$$JSCompiler does not recursively resolve typedefs$$None$$patch1-closure-16_Developer_PatchNaturalness$$Added check for null check in AliasedTypeNode constructor .. Fix scoped aliasing. $$1
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_Developer_PatchNaturalness$$Fix PrepareAst . java. $$1
closure-42$$Simple "Whitespace only" compression removing "each" keyword from "for each (var x in arr)" loop$$None$$patch1-closure-42_Developer_PatchNaturalness$$Add an error if an for - loop is to be used as a standard for ( / ). $$1
closure-89$$Compiler removes function properties that it should not$$None$$patch1-closure-89_Developer_PatchNaturalness$$Allow namespaces for functions .. Add a check forHosedThisReferences. $$1
closure-116$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-116_Developer_PatchNaturalness$$Allow side effects for functions with a return value. Allow side effects in function arguments .. $$1
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_Developer_PatchNaturalness$$Add an internal class to RemoveUnusedVars that can be used as an escape value .. Allow maybeEscaped to be used in assignments where vars are referenced elsewhere. Allow vars to be used as aliased in assignments .. $$1
closure-111$$goog.isArray doesn't hint compiler$$None$$patch1-closure-111_Developer_PatchNaturalness$$Allow array types in closure reverse implementation .. $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_Developer_PatchNaturalness$$Fix typo in codeGenerator where negative latin characters were passed .. $$1
closure-118$$Prototype method incorrectly removed$$None$$patch1-closure-118_Developer_PatchNaturalness$$Allow backslash. $$1
closure-87$$IE8 error: Object doesn't support this action$$None$$patch1-closure-87_Developer_PatchNaturalness$$fixing an issue with isExpressionNode ( ). $$1
closure-127$$Break in finally block isn't optimized properly$$None$$patch1-closure-127_Developer_PatchNaturalness$$Remove node from the unreachable code elimination list .. $$1
closure-80$$Unexpected expression nodeDELPROP 1$$None$$patch1-closure-80_Developer_PatchNaturalness$$improve NodeUtil. Allow delPROP to be used as a literal in simple operators .. $$1
closure-74$$Obvious optimizations don't works in "inline if"$$None$$patch1-closure-74_Developer_PatchNaturalness$$Fix swapped node types in PeepholeFoldConstants .. Fix NOT folding const type .. $$1
closure-120$$Overzealous optimization confuses variables$$None$$patch1-closure-120_Developer_PatchNaturalness$$Fix scoped functions .. $$1
closure-6$$better 'this' type checking$$None$$patch1-closure-6_Developer_PatchNaturalness$$Remove a redundant check .. Remove an unnecessary empty line. Remove a redundant call to registerMismatch ( ) in TypeValidator . expectCanAssignTo ( ). $$1
closure-28$$constant functions not inlined aggressively enough$$None$$patch1-closure-28_Developer_PatchNaturalness$$Add a method for adding constant to inline cost estimate .. $$1
closure-17$$@const dumps type cast information$$None$$patch1-closure-17_Developer_PatchNaturalness$$Don ' t evaluate type - casts in TypedScopeCreator .. $$1
closure-1$$function arguments should not be optimized away$$None$$patch1-closure-1_Developer_PatchNaturalness$$Do not remove unused vars if closure compiler doesn ' t remove globals .. $$1
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_Developer_PatchNaturalness$$Allow mayBeString matchers for regexps. $$1
closure-19$$Type refining of 'this' raises IllegalArgumentException$$None$$patch1-closure-19_Developer_PatchNaturalness$$Fix this case so that it can be refined quickly into the CFG .. $$1
closure-26$$ProcessCommonJSModules module exports failures when checkTypes enabled$$None$$patch1-closure-26_Developer_PatchNaturalness$$Add a field to track modules that export rights of js files .. Do not emit module exports if already emitted .. Add modulesWithExports . add ( moduleName ) to commonJS modules so that it gets. $$1
closure-8$$Obfuscated code triggers TypeError in Firefox$$None$$patch1-closure-8_Developer_PatchNaturalness$$Fix isNamedParameter check. $$1
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_Developer_PatchNaturalness$$Fix CheckSideEffects . java. Disable side - effects check for commas as compiler will infer them. $$1
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_Developer_PatchNaturalness$$Allow null string input.  improve isStrWhiteSpaceChar method. $$1
closure-81$$An unnamed function statement statements should generate a parse error$$None$$patch1-closure-81_Developer_PatchNaturalness$$Add an error if an unnamed function statement is found .. $$1
closure-121$$Overzealous optimization confuses variables$$None$$patch1-closure-121_Developer_PatchNaturalness$$Fix inline vars that are referenced in same ' on demand ' scope .. $$1
closure-119$$catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode$$None$$patch1-closure-119_Developer_PatchNaturalness$$Handle catch / else .. $$1
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch1-closure-86_Developer_PatchNaturalness$$Fix NodeUtil . hasLocalResult for cases where the value was never aliased from inside the. $$1
closure-72$$Internal Compiler Error on Bullet$$None$$patch1-closure-72_Developer_PatchNaturalness$$don ' t remove unused labels by default. Fix RenameLabels for functions with a label name .. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_Developer_PatchNaturalness$$Remove tryMinimizeExitPoints from minimizeExitPoints. $$1
closure-44$$alert(/ / / / /)$$None$$patch1-closure-44_Developer_PatchNaturalness$$Allow forward slash in DIV syntax. $$1
closure-110$$Allow @private top-level functions in goog.scope$$None$$patch1-closure-110_Developer_PatchNaturalness$$Add an error if n . next is not a child of the parent node .. Add isFunctionDecl to declarations in scope. Allow the variadic value to be null in assignments .. Fixing the scoped function definition for NAME .. Fix the scope name for ScopedAliases. fix the scope compiler error. $$1
closure-43$$@lends does not work unless class is defined beforehand$$None$$patch1-closure-43_Developer_PatchNaturalness$$Add a field to store object literals in case of closure compiler error .. Fix memory leak in TypedScopeCreator. Fix lends name for ObjectLit scope creation .. $$1
closure-128$$The compiler quotes the "0" keys in object literals$$None$$patch1-closure-128_Developer_PatchNaturalness$$Fix isSimpleNumber ( ) check for 0. $$1
closure-88$$Incorrect assignment removal from expression in simple mode.$$None$$patch1-closure-88_Developer_PatchNaturalness$$Add a check for isVariableReadBeforeKill ( ) in DeadAssignmentsElimination .. $$1
closure-117$$Wrong type name reported on missing property error.$$None$$patch1-closure-117_Developer_PatchNaturalness$$Fix dereferenced type names for GETPROP .. Remove dereference check for non - constructor fields .. $$1
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_Developer_PatchNaturalness$$Add missing - sign in negative zero - bit code consumer .. $$1
closure-36$$goog.addSingletonGetter prevents unused class removal$$None$$patch1-closure-36_Developer_PatchNaturalness$$Don ' t inline singleton getter methods .. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_Developer_PatchNaturalness$$"Fix the "" skipAllPasses "" flag .". $$1
closure-131$$unicode characters in property names result in invalid output$$None$$patch1-closure-131_Developer_PatchNaturalness$$Allow ' s . charAt ( 0 ) ' to be tokenized by the JavaScript compiler .. $$1
closure-91$$support @lends annotation$$None$$patch1-closure-91_Developer_PatchNaturalness$$Fix check for isObjectLitKey ( ). $$1
closure-65$$String escaping mishandles null byte$$None$$patch1-closure-65_Developer_PatchNaturalness$$Fix CodeGenerator . java. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Developer_PatchNaturalness$$Remove whitespaces from sourceExcerpt. $$1
closure-96$$Missing type-checks for var_args notation$$None$$patch1-closure-96_Developer_PatchNaturalness$$Fix var_args function definition .. $$1
closure-109$$Constructor types that return all or unknown fail to parse$$None$$patch1-closure-109_Developer_PatchNaturalness$$Added missing closing < / > tag in JsDocInfoParser. $$1
closure-100$$Only assignment to "this" issues a "dangerous use of the global this object" warning.$$None$$patch1-closure-100_Developer_PatchNaturalness$$Allow non - partial match in CheckGlobalThis. CheckGlobalThis now reports a THIS with a property access. $$1
closure-54$$Prototype methods can't be used from the constructor in case prototype is explicitly defined.$$None$$patch1-closure-54_Developer_PatchNaturalness$$"fix false alarm in "" Hide "" toolwindow / window type". Remove old prototype from FunctionType . prototype .. Fix the scope compiler warning that gtasks stylesheet stylesheet changed hands .. $$1
closure-107$$Variable names prefixed with MSG_ cause error with advanced optimizations$$None$$patch1-closure-107_Developer_PatchNaturalness$$shut off i18n warnings. $$1
closure-98$$bad variable inlining in closure$$None$$patch1-closure-98_Developer_PatchNaturalness$$Fix for loop references in JSF .. Fix the boolean flags of ReferenceCollectingCallback .. Fix broken reference check .. $$1
closure-53$$compiler-20110811 crashes with index(1) must be less than size(1)$$None$$patch1-closure-53_Developer_PatchNaturalness$$Allow object literals to be replaced with object literals .. Fix object literals going into an empty stream .. $$1
closure-30$$Combining temporary strings are over-optimized in advanced build$$None$$patch1-closure-30_Developer_PatchNaturalness$$Add an unused flag in Definition .. Fix a bug in mustBeReachingVariableDef. Do not mark unknown dependencies as error in mustBeReachingVariableDef .. Fix flow - sensitive inline vars traversal bug. $$1
closure-37$$incomplete function definition crashes the compiler when ideMode is enabled$$None$$patch1-closure-37_Developer_PatchNaturalness$$Added a check for the ide mode property on function bodies .. Add a check for ' body . isBlock ( ) ' at the end of a branch statement. $$1
closure-39$$externExport with @typedef can generate invalid externs$$None$$patch1-closure-39_Developer_PatchNaturalness$$Don ' t use toStringHelper for prototype properties .. Fix toString ( ) of PrototypeObjectType. $$1
closure-106$$Exception thrown from com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties$$None$$patch1-closure-106_Developer_PatchNaturalness$$Allow one - line ifs. The JSDocInfoBuilder does not parse documentation unless populated .. $$1
closure-99$$Prototypes declared with quotes produce a JSC_USED_GLOBAL_THIS warning.$$None$$patch1-closure-99_Developer_PatchNaturalness$$Add isInterface check to fix check for goog . isFunction ( ). Fix CheckGlobalThis . checkGlobalThis ( ) to only traverse the left side if it '. $$1
closure-52$$Converts string properties into numbers in literal object definitions$$None$$patch1-closure-52_Developer_PatchNaturalness$$Fix false positives in getSimpleNumber ( ). $$1
closure-101$$--process_closure_primitives can't be set to false$$None$$patch1-closure-101_Developer_PatchNaturalness$$Fix CommandLineRunner closure pass flag .. $$1
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_Developer_PatchNaturalness$$Allow functions with a parent to be reduced to only uses .. $$1
closure-97$$Unsigned Shift Right (>>>) bug operating on negative numbers$$None$$patch1-closure-97_Developer_PatchNaturalness$$Fix PeepholeFoldConstants case .. $$1
closure-108$$precondition crash: goog.scope local with aliased in the type declaration$$None$$patch1-closure-108_Developer_PatchNaturalness$$Add injectedDecls to declarations in declarations map .. reinitialized vars as injectedDecls is no longer needed. Add $ injectedDecls . add ( newDecl ) to the list of injected declarations .. Fix scoped vars for declarations that are never processed .. $$1
closure-130$$arguments is moved to another scope$$None$$patch1-closure-130_Developer_PatchNaturalness$$"fix for Eclipse "" inExterns "" check". $$1
closure-64$$--language_in=ECMASCRIPT5_STRICT results in 1 'use strict' per input file$$None$$patch1-closure-64_Developer_PatchNaturalness$$Fix an issue with ' use strict ' for compiler .. Added missing semicolon .. $$1
closure-90$$@this emits warning when used with a typedef$$None$$patch1-closure-90_Developer_PatchNaturalness$$Allow null values in function types. Don ' t warn about non - object types .. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_Developer_PatchNaturalness$$Remove equivalent methods from JSType . getLeastSupertype ( ). $$1
closure-79$$RuntimeException when compiling with extern prototype$$None$$patch1-closure-79_Developer_PatchNaturalness$$Add report of var changes in jscomp stylesheet. Add traverseRoots ( ) to the compiler ' s normalize tree .. $$1
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_Developer_PatchNaturalness$$Allow template types to be included in inferred .. $$1
closure-41$$In ADVANCED mode, Compiler fails to warn about overridden methods with different signatures.$$None$$patch1-closure-41_Developer_PatchNaturalness$$Fix copy / paste error in function type builder .. Add missing varargs parameter .. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_Developer_PatchNaturalness$$Allow functions to be run in side effects only from returns .. Remove canBeSideEffected check for function arguments .. $$1
closure-83$$Cannot see version with --version$$None$$patch1-closure-83_Developer_PatchNaturalness$$Catch the exception in CommandLineRunner . parseArguments ( ) .. $$1
closure-77$$\0 \x00 and \u0000 are translated to null character$$None$$patch1-closure-77_Developer_PatchNaturalness$$Fix CodeGenerator . java. $$1
closure-123$$Generates code with invalid for/in left-hand assignment$$None$$patch1-closure-123_Developer_PatchNaturalness$$Fix rhs context for ' in ' operator. $$1
closure-48$$Type checking error when replacing a function with a stub after calling.$$None$$patch1-closure-48_Developer_PatchNaturalness$$Fixing inferred = false for function declarations .. $$1
closure-70$$unexpected typed coverage of less than 100%$$None$$patch1-closure-70_Developer_PatchNaturalness$$Fix swapped arguments in TypedScopeCreator. $$1
closure-84$$Invalid left-hand side of assignment not detected$$None$$patch1-closure-84_Developer_PatchNaturalness$$Add an error if an invalid assignment target is found .. Add an error if we can ' t find a valid assignment target in a function / array .. Fix a bug in validAssignmentTarget ( ). $$1
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_Developer_PatchNaturalness$$Remove an unnecessary loop in ExploitAssigns. $$1
closure-24$$goog.scope doesn't properly check declared functions$$None$$patch1-closure-24_Developer_PatchNaturalness$$Fix scoped alias parsing .. Fix an issue with ' bad parameters ' report from ScopedAliases .. $$1
closure-23$$tryFoldArrayAccess does not check for side effects$$None$$patch1-closure-23_Developer_PatchNaturalness$$Fix PeepholeFoldConstants search for side effects. $$1
closure-4$$Converting from an interface type to a constructor which @implements itself causes stack overflow.$$None$$patch1-closure-4_Developer_PatchNaturalness$$Do not count ` undefined ` and ` undefined ` as cycles in JSType declarations. Do not detect cycles of named types .. $$1
closure-15$$Switched order of "delete key" and "key in" statements changes semantic$$None$$patch1-closure-15_Developer_PatchNaturalness$$Add ability to delete vars in CFG node for DexProp. $$1
closure-3$$optimization fails with variable in catch clause$$None$$patch1-closure-3_Developer_PatchNaturalness$$Fix inline vars canInline with given scope .. Fix canInline .. Add case for FlowSensitiveInlineVariables where the var is used instead of var . parent . var. $$1
closure-12$$Try/catch blocks incorporate code not inside original blocks$$None$$patch1-closure-12_Developer_PatchNaturalness$$Fix bug in MaybeReachingVariableUse . hasExceptionHandler. $$1
closure-85$$Reproduceable crash with switch statement$$None$$patch1-closure-85_Developer_PatchNaturalness$$Stops codeElimination . tryRemoveUnconditionalBranching ( ) at the end. Remove tryRemoveUnconditionalBranching from UnreachableCodeElimination . java. Added a few more code reductions. $$1
closure-71$$no warnings when @private prop is redeclared on subclass$$None$$patch1-closure-71_Developer_PatchNaturalness$$Fix override of non - global properties .. $$1
closure-125$$IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType$$None$$patch1-closure-125_Developer_PatchNaturalness$$Fix TypeCheck . hasInstanceType. $$1
closure-76$$Assignments within conditions are sometimes incorrectly removed$$None$$patch1-closure-76_Developer_PatchNaturalness$$fix the for cycles so they are ignored by the for cycles .. Stops ' die ' on dead  assignments for now .. Missing variable legitimization for AND / OR .. Remove the check for isVariableReadBeforeKill from dead assignments evaluator .. $$1
closure-82$$.indexOf fails to produce missing property warning$$None$$patch1-closure-82_Developer_PatchNaturalness$$Add to the isEmptyType check for isFunctionType. $$1
closure-49$$Incorrect output if a function is assigned to a variable, and the function contains a variable with the same name$$None$$patch1-closure-49_Developer_PatchNaturalness$$Remove function declarations that are never used .. Move the varargs and local variable declarations to the nameStack .. Add LP token to MakeDeclaredNamesUnique , that is , it ' s done in the same. $$1
closure-122$$Inconsistent handling of non-JSDoc comments$$None$$patch1-closure-122_Developer_PatchNaturalness$$Improved regex to match javadoc comments .. $$1
closure-40$$smartNameRemoval causing compiler crash$$None$$patch1-closure-40_Developer_PatchNaturalness$$Fix possible NPE for class - def .. $$1
closure-114$$Crash on the web closure compiler$$None$$patch1-closure-114_Developer_PatchNaturalness$$Fix an issue with ' = ' vs . ' < - ' usage in NameAnalyzer .. $$1
closure-47$$Original source line numbers are one-based in source maps.$$None$$patch1-closure-47_Developer_PatchNaturalness$$Fix source map generation for v1 or v2. Fix map indexing bug in V3 sourcemap due to bad sourcemap indexing .. $$1
closure-113$$Bug in require calls processing$$None$$patch1-closure-113_Developer_PatchNaturalness$$Stops ' provided ' check for broken requires .. $$1
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_Developer_PatchNaturalness$$Fix PeepholeFoldConstants case .. $$1
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_Developer_PatchNaturalness$$Fix TypeCheck . java. $$1
closure-13$$true/false are not always replaced for !0/!1$$None$$patch1-closure-13_Developer_PatchNaturalness$$Fix PeepholeOptimizationsPass. $$1
closure-5$$Compiler ignores 'delete' statements, can break functionality.$$None$$patch1-closure-5_Developer_PatchNaturalness$$Allow delete properties to be inlined if they ' re used as arguments .. $$1
closure-14$$bogus 'missing return' warning$$None$$patch1-closure-14_Developer_PatchNaturalness$$Fix finally map .. $$1
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_Developer_PatchNaturalness$$Allow ' + ' after ' + ' in a for - loop. $$1
closure-25$$anonymous object type inference behavior is different when calling constructors$$None$$patch1-closure-25_Developer_PatchNaturalness$$Remove children in constructor definition .. Remove backwardsInferenceFromCallSite ( n , constructor ) from TypeInference . java. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_Developer_PatchNaturalness$$Fix an issue with time series end index < startIndex. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_Developer_PatchNaturalness$$added p2 . getPathIterator ( null ) to fix looping over PathIterator. $$1
chart-16$$Bug propgated from v1.0.5 on to present$$The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it "Returns the number of series in the dataset (possibly zero)."  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.$$patch1-chart-16_Developer_PatchNaturalness$$Fix an issue with DefaultIntervalCategoryDataset . seriesKeys setter not being used .. Fix bug in DefaultIntervalCategoryDataset. $$1
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_Developer_PatchNaturalness$$deep clone TimeSeries ( super . clone ( ) , this . data ). $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Developer_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Developer_PatchNaturalness$$Set the dataset before using it in MultiplePiePlot .. $$1
chart-2$$Bugs in DatasetUtilities.iterateRangeBounds() methods$$None$$patch1-chart-2_Developer_PatchNaturalness$$Fix NaN values in XY dataset. Fix NaN values in y axis. $$1
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_Developer_PatchNaturalness$$Allow duplicate x values for XYSeries. $$1
time-20$$Errors creating/parsing dates with specific time zones.$$The results are out of 572 time zones 130 fail and 30 throw exceptions.  The failures are the most interesting. When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka. When I take that id and create a date time with it its time zone id is America/Adak. It is like there are multiple list of time zones in Joda time and they are out of sync.$$patch1-time-20_Developer_PatchNaturalness$$Fix DateTimeParserBuilder # parseInto ( ) where the best id was not found .. $$1
time-18$$GJChronology rejects valid Julian dates$$The 2nd statement fails with "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]".  Given that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?$$patch1-time-18_Developer_PatchNaturalness$$Fixed a bug in GJChronology . getDateTimeMillis + ( year , monthOfYear. $$1
time-27$$Different behaviour of PeriodFormatter$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.$$patch1-time-27_Developer_PatchNaturalness$$Fix extra parsing when PeriodFormatter . iAfterParser and PeriodFormatter . iAfterPrinter are not. $$1
time-9$$Ensure there is a max/min valid offset$$DateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.$$patch1-time-9_Developer_PatchNaturalness$$Add the MAX_MILLIS constant to DateTimeZone .. Fix hoursOffset value out of range .. throw exception if offset is out of range. $$1
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_Developer_PatchNaturalness$$Fix ThreadLocal ' s initialValue. $$1
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_Developer_PatchNaturalness$$Fix DateTimeFormatter year parser bug. $$1
time-16$$DateTimeFormatter.parseInto broken when no year in format$$In Joda Time 2.0, the default year was set to 2000 so that Feb 29 could be parsed correctly. However, parseInto now overwrites the given instant's year with 2000 (or whatever iDefaultYear is set to). The correct behavior would seem to be to use the given instant's year instead of iDefaultYear. This does mean that Feb 29 might not be parseable if the instant's year is not a leap year, but in this case the caller asked for that in a sense.$$patch1-time-16_Developer_PatchNaturalness$$Fixed year reference .. $$1
time-6$$Questionable behaviour of GJChronology when dates pass 1BC$$I expect the following test to pass:  However, I never provided "0" for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?$$patch1-time-6_Developer_PatchNaturalness$$Throw an exception if we run into an errant year. ConvertByWeekyear to year if gap was crossed .. convert weekyear to gregorian. $$1
time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).$$patch1-time-17_Developer_PatchNaturalness$$Fix an overlap between twoUTC - > GMT. $$1
time-1$$Partial.with fails with NPE$$Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.$$patch1-time-1_Developer_PatchNaturalness$$Fix errors found by previous fix .. Remove useless compareTo ( ) method. $$1
time-10$$Days#daysBetween throw exception for MonthDay with 29 February$$Is there a way to avoid this happening? I understand fiddling around with the leap year, you're bound to get issues.$$patch1-time-10_Developer_PatchNaturalness$$Added START_1972 to BaseSingleFieldPeriod. Fix # 109 , merge issues with Chronology. $$1
time-26$$.withHourOfDay() sets hour inconsistantly on DST transition.$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.$$patch1-time-26_Developer_PatchNaturalness$$Fixed a bug in DateTimeZone . convertLocalToUTC ( long , boolean ). $$1
time-8$$DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hour$$DateTimeZone.forOffsetHoursMinutes(h,m) cannot handle negative offset < 1 hour like -0:30 due to argument range checking. I used forOffsetMillis() instead.  This should probably be mentioned in the documentation or negative minutes be accepted.$$patch1-time-8_Developer_PatchNaturalness$$Fix errors. $$1
time-24$$Incorrect date parsed when week and month used together$$It should print 2011-01-03 but it is printing 2010-01-04.$$patch1-time-24_Developer_PatchNaturalness$$Don ' t reset fields on parse ( ) .. $$1
time-23$$Incorrect mapping of the MET time zone$$This timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time.$$patch1-time-23_Developer_PatchNaturalness$$Fixed bug in DateTimeZone. ISO 639 - 2 ( Australia / New_York ). $$1
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_Developer_PatchNaturalness$$Fix partial constructor to validate values with chronoology. $$1
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_Developer_PatchNaturalness$$Add an error if safeMultiply ( long , int ) overflows a long. $$1
time-3$$addDays(0) changes value of MutableDateTime$$Upon DST transition from summer to winter time zone, adding the amount of zero days to a mutable date time object changes the value of the object. The methods addMonths and addYears show the same problem; addSeconds, addMinutes and addHours are ok.  I have tested with version 2.3. However, if I repeat the test with Joda 1.5.2, the invocation of addDays(0) does not change the date's value.$$patch1-time-3_Developer_PatchNaturalness$$Fixed # 7751. Add years to MutableDateTime. Add weekyears ( ). Fix month - wise operation .. Add weeks method to MutableDateTime. Adding missing method to MutableDateTime # addDays ( ). Add hours to MutableDateTime. Adding minutes to MutableDateTime. Add seconds to MutableDateTime. AddMillis ( ) where the chrono doesn ' t take an 0 or less precision .. $$1
time-12$$Check Calendar.ERA in LocalDate.fromCalendarFields$$None$$patch1-time-12_Developer_PatchNaturalness$$Add the era to the LocalDateTime object .. Handle years in era BC .. Add the era value as a dependency of LocalDate .. Handle years in era BC .. $$1
time-2$$Partial.with fails with NPE$$Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.$$patch1-time-2_Developer_PatchNaturalness$$Fix compareTo ( ) of UnsupportedDurationField. Fix a typo in Partial . java. Added missing break in Partial where duration field is null. $$1
time-13$$Negative millis display incorrectly in Period.toString$$The last line should produce "PT-0.100S" instead of "PT0.100S".$$patch1-time-13_Developer_PatchNaturalness$$prepare 0 . 5 + for the abs value. Parser should print digits without spaces ( fixes # 507 ). Handle calendar year year input format change. $$1
time-5$$none standard PeriodType without year throws exception$$I tried to get a Period only for months and weeks with following code:  This throws following exception:  Even removing the year component with .withYearsRemoved() throws the same exception:$$patch1-time-5_Developer_PatchNaturalness$$Fix bug in Period # withMonths. $$1
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_Developer_PatchNaturalness$$Fix bug # 1216162 , year field added after month - of - year. $$1
time-22$$Duration.toPeriod with fixed time zones.$$I have a question concerning the conversion of a Duration to Period. I'm not sure if this is a bug, or if there is a different way to do this.  The basis of the problem, is that using Duration.toPeriod() uses the chronology of the default time zone to do the conversion. This can cause different results from a timezone with DST and one without. This can be reproduced easily with this test. In the joda code, Duration.toPeriod() uses a period constructor that takes the chronology, but null is passed in, so the chronology of the default time zone is used, which leads to this behavior.  The javadoc of toPeriod() states that only precise fields of hours, minutes, seconds, and millis will be converted. But for a fixed timezone, days and weeks are also precise, which is stated in the javadoc for toPeriod(Chronology chrono). In our app, we need consistent behavior regardless of the default time zone, which is to have all the extra hours put into the hours bucket. Since Duration is supposed to be a 'time zone independent' length of time, I don't think we should have to do any chronology manipulation to get this to work.$$patch1-time-22_Developer_PatchNaturalness$$Fix bug # 3264409 .. $$1
time-25$$DateTimeZone.getOffsetFromLocal error during DST transition$$This may be a failure of my understanding, but the comments in DateTimeZone.getOffsetFromLocal lead me to believe that if an ambiguous local time is given, the offset corresponding to the later of the two possible UTC instants will be returned - i.e. the greater offset.  This doesn't appear to tally with my experience. In fall 2009, America/Los_Angeles changed from -7 to -8 at 2am wall time on November 11. Thus 2am became 1am - so 1:30am is ambiguous. I would therefore expect that constructing a DateTime for November 11th, 1:30am would give an instant corresponding with the later value (i.e. 9:30am UTC).$$patch1-time-25_Developer_PatchNaturalness$$fixed erroneous loop in DateTimeZone. $$1
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch1-lang-61_Developer_PatchNaturalness$$StrBuilder uses string builder size. $$1
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_Developer_PatchNaturalness$$StrBuilder . append ( obj , width ). $$1
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch1-lang-50_Developer_PatchNaturalness$$Fix compiler warning. Fix possible NPE in FastDateFormat. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_Developer_PatchNaturalness$$Fixed bug in LocaleUtils # isAvailableLocale ( ). $$1
lang-32$$Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments$$The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.$$patch1-lang-32_Developer_PatchNaturalness$$Fix compile error. Fixed NPE in HashCodeBuilder. Fixes # 125. Fixed race condition. $$1
lang-35$$ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException$$ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException. For example, the following code compiles without a warning:  String[] sa = ArrayUtils.add(stringArray, aString);   and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception. If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.$$patch1-lang-35_Developer_PatchNaturalness$$Allow null and Object . class to be used as array type .. Allow null to be added to the array and element types .. $$1
lang-56$$FastDateFormat.mRules is not transient or serializable$$Reported by FindBugs. Either we need to make the Rule interface Serializable, or make mRules transient and add deserializing code to kick off init().$$patch1-lang-56_Developer_PatchNaturalness$$Fix the merge of one - to - one calls into conference calls. Fixing deserialization problem with FastDateFormat. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Developer_PatchNaturalness$$missing break in BooleanUtils. $$1
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Developer_PatchNaturalness$$isDigits ( numeric ) fix. $$1
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_Developer_PatchNaturalness$$StrBuilder . contains ( char ) doesn ' t compare length - > index .. StrBuilder ' s loop through the buffer to the end of a string .. $$1
lang-34$$Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments$$The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.$$patch1-lang-34_Developer_PatchNaturalness$$Remove null check. Add null check in ToStringStyle to prevent NPE .. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Developer_PatchNaturalness$$removed null check. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_Developer_PatchNaturalness$$Fix bug in StringUtils. Removed unnecessary copy of StringUtils. $$1
lang-18$$FastDateFormat formats year differently than SimpleDateFormat in Java 7$$Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.$$patch1-lang-18_Developer_PatchNaturalness$$Fix year field. $$1
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_Developer_PatchNaturalness$$formatting fixes. Handle exponent overflow in NumberUtils. $$1
lang-9$$FastDateParser does not handle unterminated quotes correctly$$FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: 'd'd' Date: d3 This should fail to parse the format and date but it actually works. The format is parsed as: Pattern: d(\p {IsNd} ++)$$patch1-lang-9_Developer_PatchNaturalness$$Allow user to specify which region to use for a date. $$1
lang-11$$RandomStringUtils throws confusing IAE when end <= start$$RandomUtils invokes Random#nextInt where n = end - start. If end <= start, then Random throws: java.lang.IllegalArgumentException: n must be positive This is confusing, and does not identify the source of the problem.$$patch1-lang-11_Developer_PatchNaturalness$$Added a throw exception if end < start. $$1
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_Developer_PatchNaturalness$$Remove deprecated API. Handle string startsWith with dash in NumberUtils. $$1
lang-29$$SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM$$Can be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681): 	... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681): 	... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681): 	at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)$$patch1-lang-29_Developer_PatchNaturalness$$Fix toJavaVersionInt ( ). $$1
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_Developer_PatchNaturalness$$Improved startsWith method. $$1
lang-42$$StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 characters$$Characters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely: import org.apache.commons.lang.*; public class J2 {     public static void main(String[] args) throws Exception {         // this is the utf8 representation of the character:         // COUNTING ROD UNIT DIGIT THREE         // in unicode         // codepoint: U+1D362         byte[] data = new byte[]  { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 } ;         //output is: &#55348;&#57186;         // should be: &#119650;         System.out.println("'" + StringEscapeUtils.escapeHtml(new String(data, "UTF8")) + "'");     } } Should be very quick to fix, feel free to drop me an email if you want a patch.$$patch1-lang-42_Developer_PatchNaturalness$$Remove backslash which prevents double entity escape. $$1
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Developer_PatchNaturalness$$set lower to the length of the string. $$1
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch1-lang-6_Developer_PatchNaturalness$$Fix bug in CharSequenceTranslator. $$1
lang-28$$StringEscapeUtils.escapeXML() can't process UTF-16 supplementary characters$$Supplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/ Currently, StringEscapeUtils.escapeXML() isn't aware of this coding scheme and treats each char as one character, which is not always right. A possible solution in class Entities would be:     public void escape(Writer writer, String str) throws IOException {         int len = str.length();         for (int i = 0; i < len; i++) {             int code = str.codePointAt;             String entityName = this.entityName(code);             if (entityName != null)  {                 writer.write('&');                 writer.write(entityName);                 writer.write(';');             }  else if (code > 0x7F)  {                     writer.write("&#");                     writer.write(code);                     writer.write(';');             }  else  {                     writer.write((char) code);             }              if (code > 0xffff)  {                     i++;             }         }     } Besides fixing escapeXML(), this will also affect HTML escaping functions. I guess that's a good thing, but please remember I have only tested escapeXML().$$patch1-lang-28_Developer_PatchNaturalness$$don ' t write entity value as long as we are using char array in the source string. $$1
lang-17$$StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.$$Hello. I use StringEscapeUtils.escapeXml(input) to escape special characters for XML. This method outputs wrong results when input contains characters in Supplementary Planes. String str1 = "\uD842\uDFB7" + "A"; String str2 = StringEscapeUtils.escapeXml(str1); // The value of str2 must be equal to the one of str1, // because str1 does not contain characters to be escaped. // However, str2 is diffrent from str1. System.out.println(URLEncoder.encode(str1, "UTF-16BE")); //%D8%42%DF%B7A System.out.println(URLEncoder.encode(str2, "UTF-16BE")); //%D8%42%DF%B7%FF%FD The cause of this problem is that the loop to translate input character by character is wrong. In CharSequenceTranslator.translate(CharSequence input, Writer out), loop counter "i" moves from 0 to Character.codePointCount(input, 0, input.length()), but it should move from 0 to input.length().$$patch1-lang-17_Developer_PatchNaturalness$$Remove unnecessary codepoint counting. $$1
lang-1$$NumberUtils does not handle Long Hex numbers$$NumberUtils.createLong() does not handle hex numbers, but createInteger() handles hex and octal. This seems odd. NumberUtils.createNumber() assumes that hex numbers can only be Integer. Again, why not handle bigger Hex numbers? == It is trivial to fix createLong() - just use Long.decode() instead of valueOf(). It's not clear why this was not done originally - the decode() method was added to both Integer and Long in Java 1.2. Fixing createNumber() is also fairly easy - if the hex string has more than 8 digits, use Long. Should we allow for leading zeros in an Integer?  If not, the length check is trivial.$$patch1-lang-1_Developer_PatchNaturalness$$Fix Issue # 140. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_Developer_PatchNaturalness$$Don ' t add backslash .. $$1
lang-19$$StringIndexOutOfBoundsException when calling unescapeHtml4("&#03")$$When calling unescapeHtml4() on the String "&#03" (or any String that contains these characters) an Exception is thrown: Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 4 	at java.lang.String.charAt(String.java:686) 	at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49) 	at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60) 	at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)$$patch1-lang-19_Developer_PatchNaturalness$$Remove translation of & sign in NumericEntityUnescaper. don ' t put a ; in the end of a string in the translator ' s range to. don ' t put semiNext = 1 in NumericEntityUnescaper. $$1
lang-26$$FastDateFormat.format() outputs incorrect week of year because locale isn't respected$$FastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. "ww") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo {     public static void main(String[] args) {         Locale.setDefault(new Locale("en", "US"));         Locale locale = new Locale("sv", "SE");          Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome         cal.set(2010, 0, 1, 12, 0, 0);         Date d = cal.getTime();         System.out.println("Target date: " + d);          FastDateFormat fdf = FastDateFormat.getInstance("EEEE', week 'ww", locale);         SimpleDateFormat sdf = new SimpleDateFormat("EEEE', week 'ww", locale);         System.out.println("FastDateFormat:   " + fdf.format(d)); // will output "FastDateFormat:   fredag, week 01"         System.out.println("SimpleDateFormat: " + sdf.format(d)); // will output "SimpleDateFormat: fredag, week 53"     } }   If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.$$patch1-lang-26_Developer_PatchNaturalness$$FastDateFormat should use the locale specified in constructor. $$1
lang-8$$FastDateFormat's "z" pattern does not respect timezone of Calendar instances passed to format()$$The work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3. The problem can be seen by this snippet:  // Always prints timezone name of machine's default timezone, ignoring TZ // set on calendar, even though the printed time itself respects calendar's TZ. Calendar myCal = Calendar.getInstance(TimeZone.getTimeZone("US/Central")); System.out.println(FastDateFormat.getInstance("h:mma z").format(myCal));   If you happen to be in US/Central, this will print the right thing, but just try it with US/Eastern, US/Pacific, etc.  It will print the time in the correct timezone, but the timezone name at the end (the "z" pattern) will always be the system default timezone.  This is a regression against commons-lang 2.x. Basically, when the "forced time zone" code was removed, the TimeZoneNameRule class stopped respecting the Calendar instance's timezone, and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long). The removal of the forced time zone stuff is surely the right thing to do (it was a mess).  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance, but rather to use the TimeZone on the Calendar instance passed into appendTo(), just like TimeZoneNumberRule does.  Presumably then for efficiency, one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezone's display name.$$patch1-lang-8_Developer_PatchNaturalness$$Remove unused field. Remove unused zone reference in TimeZoneNameRule constructor. Fix compiler error. $$1
lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)$$patch1-lang-21_Developer_PatchNaturalness$$FixedDateUtils . java. $$1
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Developer_PatchNaturalness$$allow isDigits in Strings. $$1
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_Developer_PatchNaturalness$$don ' t append QUOTE if it is escaped. $$1
lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }$$patch1-lang-38_Developer_PatchNaturalness$$This should not cause the DateTimeFormatter to not skip calendar . getTime ( ) .. $$1
lang-36$$NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal Place$$NumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g., "2." should be considered a number because new BigDecimal("2.") works fine.  This could be done by adding the code below after line 1444, which is the if (chars[i] == 'e' || chars[i] == 'E') block. if (chars[i] == '.') {     if (hasDecPoint || hasExp)  {         // two decimal points or dec in exponent            return false;     }     return foundDigit; // single trailing decimal point after non-exponent is ok }$$patch1-lang-36_Developer_PatchNaturalness$$isDigit ( ) and lastChar != '.'. Fix boolean precision thingie in NumberUtils. $$1
lang-31$$StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.$$StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00" 	private static final String CharU20000 = "\uD840\uDC00"; 	private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call: 	assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken: 	assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001)); 	assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine: 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000)); 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001)); 	assertEquals(true, StringUtils.contains(CharU20000, CharU20000)); 	assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/$$patch1-lang-31_Developer_PatchNaturalness$$Add high supplementary character to the search list. $$1
lang-65$$[lang] DateUtils.truncate method is buggy when dealing with DST switching hours$$Try to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10- 31 01:00:00 MST, which is one hour after the input hour.     // truncate 2004-10-31 01:00:00 MDT     Date oct31_01MDT = new Date(1099206000000L);         Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);     assertEquals(oct31_01MDT, result);$$patch1-lang-65_Developer_PatchNaturalness$$Fixed for YEAR and month. Fixed bug in DateUtils where negative value for field is found. Fixed erroneous loop in DateUtils. $$1
lang-62$$unescapeXml("&12345678;") should be "&12345678;"$$Following test (in EntitiesTest.java) fails:     public void testNumberOverflow() throws Exception  {         doTestUnescapeEntity("&#12345678;", "&#12345678;");         doTestUnescapeEntity("x&#12345678;y", "x&#12345678;y");         doTestUnescapeEntity("&#x12345678;", "&#x12345678;");         doTestUnescapeEntity("x&#x12345678;y", "x&#x12345678;y");     }  Maximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is.$$patch1-lang-62_Developer_PatchNaturalness$$Entity value is too large. Handle entity value is too large. $$1
lang-54$$LocaleUtils.toLocale() rejects strings with only language+variant$$LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale("fr", "", "POSIX").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code. Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.$$patch1-lang-54_Developer_PatchNaturalness$$Missing _ sign in LocaleUtils. $$1
lang-53$$Dates.round() behaves incorrectly for minutes and seconds$$Get unexpected output for rounding by minutes or seconds. public void testRound() {     Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));     testCalendar.set(2007, 6, 2, 8, 9, 50);     Date date = testCalendar.getTime();     System.out.println("Before round() " + date);     System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE)); } --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong$$patch1-lang-53_Developer_PatchNaturalness$$Fixed formatting. $$1
lang-30$$StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.$$StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00" 	private static final String CharU20000 = "\uD840\uDC00"; 	private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call: 	assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken: 	assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001)); 	assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine: 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000)); 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001)); 	assertEquals(true, StringUtils.contains(CharU20000, CharU20000)); 	assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/$$patch1-lang-30_Developer_PatchNaturalness$$Add high surrogates in StringUtils. Fix StringUtils . containsAny ( CharSequence , char [ ] ). lower high surrogates in StringUtils. fixed StringUtils . containsAny ( CharSequence , String ). Add high surrogates in searchChars. Add high surrogates support for StringUtils. added searchForHighSurrogate. $$1
lang-37$$ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed types very well$$ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed array types very well. The stack trace for  Number[] st = ArrayUtils.addAll(new Integer[] {1} , new Long[] {2L} ); starts: java.lang.ArrayStoreException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962) which is not all that obvious. It would be a lot clearer if the method threw an IlegalArgumentException or similar.$$patch1-lang-37_Developer_PatchNaturalness$$rethrow array store exception. $$1
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_Developer_PatchNaturalness$$remove null. $$1
lang-52$$StringEscapeUtils.escapeJavaScript() method did not escape '/' into '\/', it will make IE render page uncorrectly$$If Javascripts including'/', IE will parse the scripts uncorrectly, actually '/' should be escaped to '\/'. For example, document.getElementById("test").value = '<script>alert(\'aaa\');</script>';this expression will make IE render page uncorrect, it should be document.getElementById("test").value = '<script>alert(\'aaa\');<\/script>'; Btw, Spring's JavascriptEscape behavor is correct. Try  to run below codes, you will find the difference:   String s = "<script>alert('aaa');</script>";   String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);   System.out.println("Spring JS Escape : "+str);   str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);   System.out.println("Apache Common Lang JS Escape : "+ str);$$patch1-lang-52_Developer_PatchNaturalness$$Add backslash backslash. $$1
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch1-lang-55_Developer_PatchNaturalness$$Add missing stopTime if it is not running .. $$1
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_Developer_PatchNaturalness$$Handle calendars with a - 1 month max .. Fixed bug in DurationFormatUtils. $$1
lang-64$$ValuedEnum.compareTo(Object other) not typesafe - it easily could be...$$int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  is not typesafe - if the int-values are the same, it will return "0" even for two totally different sub-classes of ValuedEnum$$patch1-lang-64_Developer_PatchNaturalness$$Fix compare to valued enum. Added a method in ValuedEnum that works with the class loader. $$1
lang-46$$StringEscapeUtils.escapeJava(String) escapes '/' characters$$Commons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes '/' characters, which is not a valid "escapable" character in Java strings.  I haven't tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java "escapable" characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off, in that '/' should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase {     public void testEscapeJavaWithSlash()  {         final String input = "String with a slash (/) in it";                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters,          * which are not a valid character to escape in a Java string.            */         assertEquals( expected, actual );     } }$$patch1-lang-46_Developer_PatchNaturalness$$StringEscapeUtils now uses boolean escapes. Use proper escaping for StringEscapeUtils. Add java 1 . 5 modifier to StringEscapeUtils. StringEscapeUtils now uses Java 1 . 5. Don ' t escape backslash - escaped strings by default. Add additional escapeForwardSlash option. Don ' t escape backslash backslash when escaping backslash. $$1
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_Developer_PatchNaturalness$$Fix Eclipse warning. adding arrayPrefix. Fixed ClassUtils . getPackageName ( ) where the class name was null and the length was empty. $$1
lang-48$$EqualsBuilder don't compare BigDecimals correctly$$When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.$$patch1-lang-48_Developer_PatchNaturalness$$fixed big number case. $$1
lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }$$patch1-lang-24_Developer_PatchNaturalness$$don ' t allow L with an exponent but not with a decimal point. $$1
lang-23$$text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object)$$Findbugs: Bug: org.apache.commons.lang3.text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object) Pattern id: EQ_DOESNT_OVERRIDE_EQUALS, type: Eq, category: STYLE This class extends a class that defines an equals method and adds fields, but doesn't define an equals method itself. Thus, equality on instances of this class will ignore the identity of the subclass and the added fields. Be sure this is what is intended, and that you don't need to override the equals method. Even if you don't need to override the equals method, consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super.equals(o).$$patch1-lang-23_Developer_PatchNaturalness$$Missing constant HASH_SEED. Fix a bug in ExtendedMessageFormat . equals ( ) .. $$1
lang-4$$LookupTranslator accepts CharSequence as input, but fails to work with implementations other than String$$The core of org.apache.commons.lang3.text.translate is a HashMap<CharSequence, CharSequence> lookupMap. From the Javadoc of CharSequence (emphasis mine):  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map. The current implementation causes code such as the following to not work as expected:  CharSequence cs1 = "1 < 2"; CharSequence cs2 = CharBuffer.wrap("1 < 2".toCharArray());  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1)); System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));   ... which gives the following results (but should be identical):  1 &lt; 2 1 < 2   The problem, at a minimum, is that CharBuffer.equals is even documented in the Javadoc that:  A char buffer is not equal to any other type of object. ... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains. An obvious work-around is to instead use something along the lines of either of the following:  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString())); System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));   ... which forces everything back to a String.  However, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns.  (As such, I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.) Another option that I'm considering is to use a custom CharSequence wrapper around a char[] that implements hashCode() and equals() to work with those implemented on String.  (However, this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)$$patch1-lang-4_Developer_PatchNaturalness$$Build fix ( CharSequenceTranslator . lookupMap ). Build lookup translator from String to CharSequence. avoid NPE. $$1
lang-15$$TypeUtils.getTypeArguments() misses type arguments for partially-assigned classes$$failing test code to add to TypeUtilsTest.testGetTypeArguments():  typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); Assert.assertEquals(2, typeVarAssigns.size()); Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));   These should pass based on:   public interface This<K, V> { }  public class Other<T> implements This<String, T> { }   This case fails because the current code ignores the Other class due to its specifying its own type variables, which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.$$patch1-lang-15_Developer_PatchNaturalness$$Fix unrolling of TypeVariables in TypeUtils. TypeUtils now uses TypeUtils . getTypeVariables ( ) instead of TypeUtils . getTypeParameters (. $$1
lang-3$$Method createNumber from NumberUtils doesn't work for floating point numbers other than Float$$Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.$$patch1-lang-3_Developer_PatchNaturalness$$Fix Issue # 590. $$1
lang-12$$RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException$$In commons-lang 2.6 line 250 :  ch = chars[random.nextInt(gap) + start];  This line of code takes a random int to fetch a char in the chars array regardless of its size. (Besides start is useless here) Fixed version would be :  //ch = chars[random.nextInt(gap)%chars.length];  When user pass 0 as end or when the array is not null but empty this line ends up with an exception$$patch1-lang-12_Developer_PatchNaturalness$$Fixed NPE in RandomStringUtils such that the array is not empty .. $$1
lang-49$$infinite loop in Fraction.reduce when numerator == 0$$Summary pretty much says it all.$$patch1-lang-49_Developer_PatchNaturalness$$Fixed a bug in Fraction . reduce ( ) where the numerator = 0 would trigger an inf. $$1
lang-40$$Fix case-insensitive string handling$$String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.$$patch1-lang-40_Developer_PatchNaturalness$$Improved javadoc in StringUtils. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_Developer_PatchNaturalness$$Add 0 / width if width is not > 0. Don ' t append null string to the builder .. $$1
lang-13$$SerializationUtils throws ClassNotFoundException when cloning primitive classes$$If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest {  	 	@Test 	public void primitiveTypeClassSerialization(){ 		Class<?> primitiveType = int.class; 		 		Class<?> clone = SerializationUtils.clone(primitiveType); 		assertEquals(primitiveType, clone); 	} }   The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {             	try {             	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             	} catch (Exception e) { 		     return super.resolveClass(desc); 		}             }         }   Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) 	throws IOException, ClassNotFoundException     { 	String name = desc.getName(); 	try { 	    return Class.forName(name, false, latestUserDefinedLoader()); 	} catch (ClassNotFoundException ex) { 	    Class cl = (Class) primClasses.get(name); 	    if (cl != null) { 		return cl; 	    } else { 		throw ex; 	    } 	}     }$$patch1-lang-13_Developer_PatchNaturalness$$Added missing field. Added missing specialized implementations into SerializationUtils. Added a try catch block for primitives ( String ). $$1
lang-5$$LocaleUtils.toLocale does not parse strings starting with an underscore$$Hi, Javadocs of Locale.toString() states that "If the language is missing, the string will begin with an underbar.". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString(). The fix for the ticket 328 does not handle well the case "fr__P", which I found out during fixing the first bug. I am attaching the patch for both problems.$$patch1-lang-5_Developer_PatchNaturalness$$Missing locale info for _ to work properly. Missing closing @@. $$1
lang-14$$StringUtils equals() relies on undefined behavior$$Since the java.lang.CharSequence class was first introduced in 1.4, the JavaDoc block has contained the following note:  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. When the signature of the StringUtils equals() method was changed from equals(String, String) to equals(CharSequence, CharSequence) in R920543, the implementation still relied on calling CharSequence#equals(Object) even though, in general, the result is undefined. One example where equals(Object) returns false even though, as CharSequences, two objects represent equal sequences is when one object is an instance of javax.lang.model.element.Name and the other object is a String.$$patch1-lang-14_Developer_PatchNaturalness$$fixed compareString ( ). $$1
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_Developer_PatchNaturalness$$Fix greatestCommonDivisor overflow in Fraction class. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_SketchFix_PatchNaturalness$$Fix try / catch in minimizeExitPoints. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_SketchFix_PatchNaturalness$$Fix empty range in TimeSeries. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_SketchFix_PatchNaturalness$$Improved nullability in CategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_SketchFix_PatchNaturalness$$Fix CategoryItemRenderer to handle non - null datasets. $$0
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch1-lang-6_SketchFix_PatchNaturalness$$Don ' t reverse the changes since we ' re about to manipulate the codepoint count. $$0
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch2-lang-6_SketchFix_PatchNaturalness$$Use the writer null pointer for CharSequenceTranslator. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_DynaMoth_PatchNaturalness$$don ' t sort XYSeries by default. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_DynaMoth_PatchNaturalness$$fixed typo. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_DynaMoth_PatchNaturalness$$missing if (. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_DynaMoth_PatchNaturalness$$Fix merge conflict for end . add ( field , newdiff ). $$0
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_Elixir_PatchNaturalness$$Fix fieldUtils. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_Elixir_PatchNaturalness$$Fixed LocaleUtils # isAvailableLocale ( ). $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Elixir_PatchNaturalness$$Fix NPE triggered by nullability exception. $$1
lang-26$$FastDateFormat.format() outputs incorrect week of year because locale isn't respected$$FastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. "ww") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo {     public static void main(String[] args) {         Locale.setDefault(new Locale("en", "US"));         Locale locale = new Locale("sv", "SE");          Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome         cal.set(2010, 0, 1, 12, 0, 0);         Date d = cal.getTime();         System.out.println("Target date: " + d);          FastDateFormat fdf = FastDateFormat.getInstance("EEEE', week 'ww", locale);         SimpleDateFormat sdf = new SimpleDateFormat("EEEE', week 'ww", locale);         System.out.println("FastDateFormat:   " + fdf.format(d)); // will output "FastDateFormat:   fredag, week 01"         System.out.println("SimpleDateFormat: " + sdf.format(d)); // will output "SimpleDateFormat: fredag, week 53"     } }   If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.$$patch1-lang-26_Elixir_PatchNaturalness$$Missing locale argument. $$1
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_Elixir_PatchNaturalness$$don ' t append QUOTE if escaping is on. $$1
lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }$$patch1-lang-38_Elixir_PatchNaturalness$$Reset timeZone on parse ( ) .. $$1
lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }$$patch1-lang-24_Elixir_PatchNaturalness$$allow L with a decimal point. $$1
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_Elixir_PatchNaturalness$$Fix an issue with TimeSeries . delete ( ) where the start < end would throw an exception. Fix bug in TimeSeries . clone. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_Elixir_PatchNaturalness$$Stops bad behavior. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Elixir_PatchNaturalness$$missing closing paren in BooleanUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Elixir_PatchNaturalness$$isDigits ( numeric ) will ignore - > long. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Elixir_PatchNaturalness$$Fix parseLong ( ) where - > parseLong ( ) works. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_Elixir_PatchNaturalness$$removed loop. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch1-closure-92_PraPR_PatchNaturalness$$Fix up whitespace. $$1
closure-93$$bug with implicit namespaces across modules$$None$$patch1-closure-93_PraPR_PatchNaturalness$$remove lastIndexOf. $$1
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_PraPR_PatchNaturalness$$remove 1287 from the closure pass condition. $$1
closure-11$$Record type invalid property not reported on function with @this annotation$$None$$patch1-closure-11_PraPR_PatchNaturalness$$Fix wrong closing curly brace in object literals. $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_PraPR_PatchNaturalness$$Remove spurious check for UTF - 8 .. $$1
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_PraPR_PatchNaturalness$$Remove mayBeStringHelper from matchAll. $$1
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch1-closure-86_PraPR_PatchNaturalness$$Updated lookahead for the NEW value keyword. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_PraPR_PatchNaturalness$$Remove ' finally ' keyword from ' try / rescue '. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_PraPR_PatchNaturalness$$improve comment. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_PraPR_PatchNaturalness$$Remove the if (. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_PraPR_PatchNaturalness$$Improved performance for record types .. $$1
closure-70$$unexpected typed coverage of less than 100%$$None$$patch1-closure-70_PraPR_PatchNaturalness$$Fix jsDoc parameter definition for function parameters .. $$1
closure-14$$bogus 'missing return' warning$$None$$patch1-closure-14_PraPR_PatchNaturalness$$Fixing finally map .. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_PraPR_PatchNaturalness$$Remove redundant code. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_PraPR_PatchNaturalness$$Fix nullability assertion .. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_PraPR_PatchNaturalness$$Fix 144 bug. $$1
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_PraPR_PatchNaturalness$$Stops verbose output. $$1
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_PraPR_PatchNaturalness$$Added transition marker. $$1
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_PraPR_PatchNaturalness$$Fix partial constructor to not use iChronology directly in the partial constructor. $$1
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_PraPR_PatchNaturalness$$Removed reverseEach method from XmlConverterTest. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_PraPR_PatchNaturalness$$@@ isAvailableLocale ( ) , removed 222 from the comment. $$1
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch1-lang-6_PraPR_PatchNaturalness$$Remove excess code point in source string. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_PraPR_PatchNaturalness$$I don ' t really see a justification for doing a whitespace in a string ( changed by the. $$1
lang-26$$FastDateFormat.format() outputs incorrect week of year because locale isn't respected$$FastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. "ww") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo {     public static void main(String[] args) {         Locale.setDefault(new Locale("en", "US"));         Locale locale = new Locale("sv", "SE");          Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome         cal.set(2010, 0, 1, 12, 0, 0);         Date d = cal.getTime();         System.out.println("Target date: " + d);          FastDateFormat fdf = FastDateFormat.getInstance("EEEE', week 'ww", locale);         SimpleDateFormat sdf = new SimpleDateFormat("EEEE', week 'ww", locale);         System.out.println("FastDateFormat:   " + fdf.format(d)); // will output "FastDateFormat:   fredag, week 01"         System.out.println("SimpleDateFormat: " + sdf.format(d)); // will output "SimpleDateFormat: fredag, week 53"     } }   If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.$$patch1-lang-26_PraPR_PatchNaturalness$$Missing locale string for format ( Date ). $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_CapGen_PatchNaturalness$$fix merge issue. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_CapGen_PatchNaturalness$$Use the available locale list. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch2-lang-57_CapGen_PatchNaturalness$$Use new java . util . HashSet ( ) instead of cAvailableLocaleSet. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch3-lang-57_CapGen_PatchNaturalness$$Fixed bug in LocaleUtils. $$1
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch8-lang-59_CapGen_PatchNaturalness$$Add 5 more space for appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_CapGen_PatchNaturalness$$StrBuilder should add 5 elements for appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch6-lang-59_CapGen_PatchNaturalness$$Add some space .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch12-lang-59_CapGen_PatchNaturalness$$added more ensureCapacity. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch7-lang-59_CapGen_PatchNaturalness$$StrBuilder should add more space for appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch9-lang-59_CapGen_PatchNaturalness$$Add 4 + 4 space for appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch13-lang-59_CapGen_PatchNaturalness$$added more ensureCapacity. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch11-lang-59_CapGen_PatchNaturalness$$Add 4 + 4 ensureCapacity ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch5-lang-59_CapGen_PatchNaturalness$$added ensureCapacity ( ) for string builder. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch2-lang-59_CapGen_PatchNaturalness$$StrBuilder should add 4 + 4 entries for appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch10-lang-59_CapGen_PatchNaturalness$$Add some space for StringBuilder . appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch3-lang-59_CapGen_PatchNaturalness$$StrBuilder should add 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 +. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch4-lang-59_CapGen_PatchNaturalness$$added ensureCapacity ( ) for string builder. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_CapGen_PatchNaturalness$$don ' t escape quotes ( we ' ll check them here , but we ' re adding them. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch2-lang-43_CapGen_PatchNaturalness$$Fix lost backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch3-lang-43_CapGen_PatchNaturalness$$Missing next ( pos ) call. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_KaliA_PatchNaturalness$$Fix tryMinimizeExitPoints. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_KaliA_PatchNaturalness$$disable side effects check for functions with side effects. $$1
closure-61$$Closure removes needed code.$$None$$patch1-closure-61_KaliA_PatchNaturalness$$Allow closure trees to be expanded if they are not equals .. $$0
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_KaliA_PatchNaturalness$$Allow changes through to pass through to fix stones. $$0
closure-68$$Cryptic error message on invalid "@type function" annotation$$None$$patch1-closure-68_KaliA_PatchNaturalness$$Fix possible duplicated parse of EOF. $$0
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_KaliA_PatchNaturalness$$"add patch for "" RemoveUnusedPrototypeProperties "" to". $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_KaliA_PatchNaturalness$$Allow property types to be declared in closure constraints. $$0
closure-7$$Bad type inference with goog.isFunction and friends$$None$$patch1-closure-7_KaliA_PatchNaturalness$$Allow restricting of restricted types , fix # 771. $$0
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_KaliA_PatchNaturalness$$Allow closure to be run as a literal if ( true ). $$0
closure-127$$Break in finally block isn't optimized properly$$None$$patch1-closure-127_KaliA_PatchNaturalness$$Allow code to be removed from the map .. $$0
closure-1$$function arguments should not be optimized away$$None$$patch1-closure-1_KaliA_PatchNaturalness$$Fix days of unused vars getting deleted. $$0
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_KaliA_PatchNaturalness$$Add true condition to walk pattern. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_KaliA_PatchNaturalness$$Allow one - line ifs. $$0
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_KaliA_PatchNaturalness$$Allow 0 . 9 . 0 - > - X in Strings. $$0
closure-119$$catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode$$None$$patch1-closure-119_KaliA_PatchNaturalness$$Allow closure to be defined on non - global fields .. $$0
closure-117$$Wrong type name reported on missing property error.$$None$$patch1-closure-117_KaliA_PatchNaturalness$$Added missing return statement .. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_KaliA_PatchNaturalness$$Added patch for parseHelperCode ( ). $$0
closure-130$$arguments is moved to another scope$$None$$patch1-closure-130_KaliA_PatchNaturalness$$Fix broken patch. $$0
closure-64$$--language_in=ECMASCRIPT5_STRICT results in 1 'use strict' per input file$$None$$patch1-closure-64_KaliA_PatchNaturalness$$Allow for more freedom from the closure compiler. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_KaliA_PatchNaturalness$$Switch the default closure implementation back to the record type .. $$0
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_KaliA_PatchNaturalness$$Allow closure to resolve non - unknown types .. $$0
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_KaliA_PatchNaturalness$$Remove patch for isNameAssignedTo ( ). $$0
closure-15$$Switched order of "delete key" and "key in" statements changes semantic$$None$$patch1-closure-15_KaliA_PatchNaturalness$$Remove one more test. $$0
closure-125$$IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType$$None$$patch1-closure-125_KaliA_PatchNaturalness$$Allow false to be true case when comparison is desired. $$0
closure-122$$Inconsistent handling of non-JSDoc comments$$None$$patch1-closure-122_KaliA_PatchNaturalness$$Allow comments to be reported as valid JSDoc comments .. $$0
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_KaliA_PatchNaturalness$$Do not increment level of optimizations as per # 12. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_KaliA_PatchNaturalness$$Allow one - line ifs. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_KaliA_PatchNaturalness$$Fix null pointer check in Kali_Defects4J_Chart_1 .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_KaliA_PatchNaturalness$$Added patch to chart source. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_KaliA_PatchNaturalness$$Updated chart with the new column doesn ' t already exist .. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_TBar_PatchNaturalness$$Remove whitespaces from sourceExcerpt. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_TBar_PatchNaturalness$$Fix an issue with time series end index < startIndex. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_TBar_PatchNaturalness$$removed null check. $$1
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_TBar_PatchNaturalness$$formatting of numbers with spaces does not make much sense for number utils. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_TBar_PatchNaturalness$$Remove redundant check. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_TBar_PatchNaturalness$$Don ' t set the length of a string to 0 if the object is null .. Don ' t use the constructor of StrBuilder in some cases .. $$1
closure-66$$@enum does not type correctly$$None$$patch1-closure-66_TBar_PatchNaturalness$$Fix typo in TypeCheck . getTypedPercent. $$0
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_TBar_PatchNaturalness$$Fix the return ' s description for the current ( ) token .. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_TBar_PatchNaturalness$$Fix side effects of varargs. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_TBar_PatchNaturalness$$Fix tryMinimizeExits case .. $$0
closure-109$$Constructor types that return all or unknown fail to parse$$None$$patch1-closure-109_TBar_PatchNaturalness$$Add parseAndRecordTypeNode to the parseContextTypeExpression method in JsDocInfoParser. $$0
closure-107$$Variable names prefixed with MSG_ cause error with advanced optimizations$$None$$patch1-closure-107_TBar_PatchNaturalness$$Fix cruise - add - message - bundle. $$0
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_TBar_PatchNaturalness$$Allow side effects for function arguments , see canBeSideEffected for the corresponding // @ javadoc. $$0
closure-12$$Try/catch blocks incorporate code not inside original blocks$$None$$patch1-closure-12_TBar_PatchNaturalness$$Remove false positives in FlowSensitiveInlineVariables .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_TBar_PatchNaturalness$$Fix side effects ofcommas in functional tests. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_TBar_PatchNaturalness$$added null check in AbstractDataset . hasListener. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_TBar_PatchNaturalness$$AddOrUpdate ( double x , double y ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_TBar_PatchNaturalness$$@@ commented out previous fix. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_TBar_PatchNaturalness$$Handle isDigits ( numeric ) as well as ( exp == null ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_TBar_PatchNaturalness$$StrBuilder delete doesn ' t overwrite the capacity. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_TBar_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary copy of StringUtils. $$0
lang-18$$FastDateFormat formats year differently than SimpleDateFormat in Java 7$$Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.$$patch1-lang-18_TBar_PatchNaturalness$$FastDateFormat doesn ' t select week / month fields ( issue # 507 ). $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_TBar_PatchNaturalness$$removed expPos from str ; if it was < - 1. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_TBar_PatchNaturalness$$fixed try case. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_TBar_PatchNaturalness$$Fix null precision thingie in StringUtils. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_TBar_PatchNaturalness$$Don ' t strip backslash when creating a string in the message format. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_TBar_PatchNaturalness$$Fix bug in StringUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_TBar_PatchNaturalness$$Fix copy / paste error. $$0
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_TBar_PatchNaturalness$$@@ changed to use packageCanonicalName instead of getPackageName ( ) for inner class access. make ClassUtils . getShortCanonicalName static. $$0
lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }$$patch1-lang-24_TBar_PatchNaturalness$$allow trailing comma in NumberUtils. $$0
lang-13$$SerializationUtils throws ClassNotFoundException when cloning primitive classes$$If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest {  	 	@Test 	public void primitiveTypeClassSerialization(){ 		Class<?> primitiveType = int.class; 		 		Class<?> clone = SerializationUtils.clone(primitiveType); 		assertEquals(primitiveType, clone); 	} }   The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {             	try {             	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             	} catch (Exception e) { 		     return super.resolveClass(desc); 		}             }         }   Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) 	throws IOException, ClassNotFoundException     { 	String name = desc.getName(); 	try { 	    return Class.forName(name, false, latestUserDefinedLoader()); 	} catch (ClassNotFoundException ex) { 	    Class cl = (Class) primClasses.get(name); 	    if (cl != null) { 		return cl; 	    } else { 		throw ex; 	    } 	}     }$$patch1-lang-13_TBar_PatchNaturalness$$Remove unused resolveClass method. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_TBar_PatchNaturalness$$Fix Fraction . greatestCommonDivisor ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_DeepRepair_PatchNaturalness$$Fix BigDecimal from string startsWith ( # 77 ). $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_DeepRepair_PatchNaturalness$$FastDateParser ignores white space. $$1
lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }$$patch1-lang-24_DeepRepair_PatchNaturalness$$Allow trailing commas in NumberUtils. $$1
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_DeepRepair_PatchNaturalness$$Fix Fraction . greatestCommonDivisor ( ). $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_DeepRepair_PatchNaturalness$$Fix null pointer check in AbstractCategoryItemRenderer. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_DeepRepair_PatchNaturalness$$Fixed bug in XYSeries. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_DeepRepair_PatchNaturalness$$Remove expPos from mant string .. $$0
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_FixMiner_PatchNaturalness$$Allow recursion to go to CALL node. $$0
closure-19$$Type refining of 'this' raises IllegalArgumentException$$None$$patch1-closure-19_FixMiner_PatchNaturalness$$refined type cannot be refined .. $$0
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_FixMiner_PatchNaturalness$$fix a bug in TimeSeries . clone. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_FixMiner_PatchNaturalness$$Fix bug with AbstractDataset . hasListener. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_FixMiner_PatchNaturalness$$Fix NPE. $$0
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_FixMiner_PatchNaturalness$$Add null check in LocaleUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_FixMiner_PatchNaturalness$$Fix merge bug in DurationFormatUtils. $$0
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_ACS_PatchNaturalness$$Allow negative numbers in FieldUtils. $$1
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_ACS_PatchNaturalness$$Handle early NPE when NumberUtils . startsWith ( ) is true. $$1
lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }$$patch1-lang-24_ACS_PatchNaturalness$$Allow L with an exponent or decimal point. remove wrong java char. $$1
lang-35$$ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException$$ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException. For example, the following code compiles without a warning:  String[] sa = ArrayUtils.add(stringArray, aString);   and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception. If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.$$patch1-lang-35_ACS_PatchNaturalness$$Added a null check. Allow null to be added to the arrayUtils constructor. adding @@. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_ACS_PatchNaturalness$$match any string with spaces , fixes # 3642. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch3-closure-126_3sFix_PatchNaturalness$$Fix tryMinimizeExits. $$1
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_3sFix_PatchNaturalness$$Fix swapped arrows in closure scope. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch2-closure-21_3sFix_PatchNaturalness$$Fix maybeResultUsed for Do not drop side effects of nested closures. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch3-closure-21_3sFix_PatchNaturalness$$Fix swapped - in case of closing - > closing. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_3sFix_PatchNaturalness$$Fix try / catch block. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch2-closure-126_3sFix_PatchNaturalness$$Fix tryMinimizeExits. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_3sFix_PatchNaturalness$$Don ' t compare JSType against native object type .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_3sFix_PatchNaturalness$$Fix maybe - dead code. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch2-closure-22_3sFix_PatchNaturalness$$Fix the case of a null pointer check in a few places .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch3-closure-22_3sFix_PatchNaturalness$$Fix the case of no - op in a closure check .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_3sFix_PatchNaturalness$$Fix bug in XYSeries. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch2-chart-5_3sFix_PatchNaturalness$$Fix bug in XYSeries. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_3sFix_PatchNaturalness$$Make MonthDay partial. $$0
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_ssFix_PatchNaturalness$$removed null check. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_ssFix_PatchNaturalness$$Allow side effects for function arguments. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_ssFix_PatchNaturalness$$Fix CategoryItemRenderer . getDataset ( ) to return the first result. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_ssFix_PatchNaturalness$$removed expPos from mant string. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_RSRepairA_PatchNaturalness$$Remove unused local variable .. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_RSRepairA_PatchNaturalness$$Remove tryMinimizeExits from tryMinimizeExits. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_RSRepairA_PatchNaturalness$$@@ start = 0 ; for the better coding experience. $$1
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_RSRepairA_PatchNaturalness$$Remove one more for - loop. $$1
closure-61$$Closure removes needed code.$$None$$patch1-closure-61_RSRepairA_PatchNaturalness$$Allow null values for equals in closure trees. $$0
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_RSRepairA_PatchNaturalness$$Remove old definition of checkGlobalThisLevel from options . checkSuspiciousCode. $$0
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_RSRepairA_PatchNaturalness$$Remove unused prototype properties patch. $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_RSRepairA_PatchNaturalness$$Remove unneeded whitespace. $$0
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_RSRepairA_PatchNaturalness$$Allow one - line ifs. $$0
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_RSRepairA_PatchNaturalness$$Add one more fix to the case statement. $$0
closure-120$$Overzealous optimization confuses variables$$None$$patch1-closure-120_RSRepairA_PatchNaturalness$$Remove broke patch. $$0
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_RSRepairA_PatchNaturalness$$Fix HOOK pattern in closure situations .. $$0
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_RSRepairA_PatchNaturalness$$Removing old and unused local variable .. $$0
closure-121$$Overzealous optimization confuses variables$$None$$patch1-closure-121_RSRepairA_PatchNaturalness$$Remove obsolete comment. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_RSRepairA_PatchNaturalness$$Remove false alarms that were failing the closure compiler .. $$0
closure-130$$arguments is moved to another scope$$None$$patch1-closure-130_RSRepairA_PatchNaturalness$$Remove old if / else .. $$0
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_RSRepairA_PatchNaturalness$$Remove patch for closure parameters. $$0
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_RSRepairA_PatchNaturalness$$Remove one more test case. $$0
closure-114$$Crash on the web closure compiler$$None$$patch1-closure-114_RSRepairA_PatchNaturalness$$Removing old warning. Removing copyInformationFrom ( ) from replacements list .. $$0
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_RSRepairA_PatchNaturalness$$Do not inline errors in AbstractPeepholeOptimization . error ( ). $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_RSRepairA_PatchNaturalness$$Add a listener to the dataset ( if it is not null ). $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_RSRepairA_PatchNaturalness$$Fix - issue with the XYSeries class - patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_RSRepairA_PatchNaturalness$$Fix parseShort erro. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_RSRepairA_PatchNaturalness$$fix a minor bug in NumberUtils. $$0
lang-13$$SerializationUtils throws ClassNotFoundException when cloning primitive classes$$If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest {  	 	@Test 	public void primitiveTypeClassSerialization(){ 		Class<?> primitiveType = int.class; 		 		Class<?> clone = SerializationUtils.clone(primitiveType); 		assertEquals(primitiveType, clone); 	} }   The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {             	try {             	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());             	} catch (Exception e) { 		     return super.resolveClass(desc); 		}             }         }   Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc) 	throws IOException, ClassNotFoundException     { 	String name = desc.getName(); 	try { 	    return Class.forName(name, false, latestUserDefinedLoader()); 	} catch (ClassNotFoundException ex) { 	    Class cl = (Class) primClasses.get(name); 	    if (cl != null) { 		return cl; 	    } else { 		throw ex; 	    } 	}     }$$patch1-lang-13_RSRepairA_PatchNaturalness$$Fix possible NPE in RSRepairDefects4J_Lang_13. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_DLFix_PatchNaturalness$$Improve program minimization. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_DLFix_PatchNaturalness$$Updated function injector copy. $$1
closure-40$$smartNameRemoval causing compiler crash$$None$$patch1-closure-40_DLFix_PatchNaturalness$$Fix dead code. $$1
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_DLFix_PatchNaturalness$$Fix copy year. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_DLFix_PatchNaturalness$$Improved javadoc in LocaleUtils. $$1
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_DLFix_PatchNaturalness$$removed the unnecessary "" -- "" from NumberUtils . startsWith ( ) , it was restricting our. $$1
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_DLFix_PatchNaturalness$$Fix format. $$1
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_DLFix_PatchNaturalness$$Fix greatestCommonDivisor in Fraction copy. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_Cardumen_PatchNaturalness$$Fix swapped diffs in patch. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Cardumen_PatchNaturalness$$Add null check. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Nopol2015_PatchNaturalness$$Fix build. formatting fixes. $$1
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_Nopol2015_PatchNaturalness$$don ' t allow duplicate x values in XYSeries. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_Nopol2015_PatchNaturalness$$Fix bug in DateTimeZoneBuilder. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Nopol2015_PatchNaturalness$$removed null check. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Nopol2015_PatchNaturalness$$Handle negative exponentiblity in StringUtils . java. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_Nopol2015_PatchNaturalness$$added missing loop. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch1-closure-86_Hercules_PatchNaturalness$$fix broken patch. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Hercules_PatchNaturalness$$Fixed typo in code snippet. $$1
closure-109$$Constructor types that return all or unknown fail to parse$$None$$patch1-closure-109_Hercules_PatchNaturalness$$updated hercules patch. $$1
closure-4$$Converting from an interface type to a constructor which @implements itself causes stack overflow.$$None$$patch1-closure-4_Hercules_PatchNaturalness$$fix doubled up patch. added fix for lost brackets in closures. $$1
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_Hercules_PatchNaturalness$$disable division by zero check. disable division by zero check. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Hercules_PatchNaturalness$$Fixed nullability assertion that was accidentally made too strong. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Hercules_PatchNaturalness$$Fixed a bug in MultiplePiePlot .. $$1
time-26$$.withHourOfDay() sets hour inconsistantly on DST transition.$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.$$patch1-time-26_Hercules_PatchNaturalness$$Fixed typo in Time - 26 - Hercules .. Fixed bug in Time - 26 - Hercules .. Fixed formatting mistake .. Fixed bug in Time - 26 - Hercules .. Fixed typo in patch1. Fixed formatting mistake in convertLocalToUTC ( long , boolean , boolean , boolean , boolean ). Fixed formatting mistake in convertLocalToUTC ( long , boolean , boolean , boolean ). $$1
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_Hercules_PatchNaturalness$$Fix partial constructor to work with joda - time. $$1
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_Hercules_PatchNaturalness$$added missing patch. updated hercules bugfix. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Hercules_PatchNaturalness$$added null check in Hercules . fixed. null check in Hercules for fixed. fix null pointer check. $$1
lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }$$patch1-lang-38_Hercules_PatchNaturalness$$Fixed formatting of date with timeZone. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_Hercules_PatchNaturalness$$Fix the bug in Hercules . fixed. Fix the bug in Hercules .. $$1
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_Hercules_PatchNaturalness$$don ' t look ahead for empty lines. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_Hercules_PatchNaturalness$$Fix the try / finally blocks used in the AST .. $$0
closure-107$$Variable names prefixed with MSG_ cause error with advanced optimizations$$None$$patch1-closure-107_Hercules_PatchNaturalness$$HHH - 9733 - Set typeBasedOptimizationOptions ( ) to the right level so it. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_Hercules_PatchNaturalness$$don ' t include regexps in closures. $$0
closure-12$$Try/catch blocks incorporate code not inside original blocks$$None$$patch1-closure-12_Hercules_PatchNaturalness$$Allow apply of control flow graphs. $$0
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_Hercules_PatchNaturalness$$Fix bug in delete ( ). $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_Hercules_PatchNaturalness$$Add string comparison to zone names. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_Hercules_PatchNaturalness$$Missing addWrapPartial method from DateField . add ( ) .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Hercules_PatchNaturalness$$don ' t compare y ' to ' y '. don ' t compare Y ' to ' Y ' ( fixes # 77 ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Hercules_PatchNaturalness$$Handle isDigits ( string ) with patch 1 - Lang - 58 - Hercules . fixed. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Hercules_PatchNaturalness$$fixed year in StringUtils. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Hercules_PatchNaturalness$$Fix null - penalty in long precision spotting. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_Hercules_PatchNaturalness$$added fix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_LSRepair_PatchNaturalness$$Optimize toBoolean ( ). $$1
lang-54$$LocaleUtils.toLocale() rejects strings with only language+variant$$LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale("fr", "", "POSIX").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code. Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.$$patch1-lang-54_LSRepair_PatchNaturalness$$Remove spaces. Missing _ sign in LocaleUtils. Added missing copy of LocaleUtils. $$1
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_LSRepair_PatchNaturalness$$Fixed a bug with not throwing the clone exception. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_LSRepair_PatchNaturalness$$StrBuilder . contains ( ) now returns true if the builder contains the character. $$0
lang-29$$SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM$$Can be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681): 	... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681): 	... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681): 	at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)$$patch1-lang-29_LSRepair_PatchNaturalness$$Fix toJavaVersionInt from String to boolean. $$0
lang-62$$unescapeXml("&12345678;") should be "&12345678;"$$Following test (in EntitiesTest.java) fails:     public void testNumberOverflow() throws Exception  {         doTestUnescapeEntity("&#12345678;", "&#12345678;");         doTestUnescapeEntity("x&#12345678;y", "x&#12345678;y");         doTestUnescapeEntity("&#x12345678;", "&#x12345678;");         doTestUnescapeEntity("x&#x12345678;y", "x&#x12345678;y");     }  Maximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is.$$patch1-lang-62_LSRepair_PatchNaturalness$$Don ' t ignore entity values in HTML entities , since they are never unescaped. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch1-lang-55_LSRepair_PatchNaturalness$$Add refresh files after stop. $$0
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_LSRepair_PatchNaturalness$$Fix ClassUtils # getShortClassName ( ). $$0
lang-40$$Fix case-insensitive string handling$$String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.$$patch1-lang-40_LSRepair_PatchNaturalness$$fixed StringUtils . containsIgnoreCase ( ). $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_CoCoNut_PatchNaturalness$$Improved javadoc comment .. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_CoCoNut_PatchNaturalness$$don ' t skip building all passes when building. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_CoCoNut_PatchNaturalness$$Improved method return type for JSType . getLeastSupertype ( JSType ). $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_CoCoNut_PatchNaturalness$$Fix an issue with TimeSeries . isEmpty ( ) .. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_CoCoNut_PatchNaturalness$$Missing warning. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_CoCoNut_PatchNaturalness$$Added missing return statement. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_CoCoNut_PatchNaturalness$$removed null check. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_CoCoNut_PatchNaturalness$$FastDateParser copy ( ) didn ' t ignore whitespace in date parsing. $$1
closure-35$$assignment to object in conditional causes type error on function w/ record type return type$$None$$patch1-closure-35_kPAR_PatchNaturalness$$Make ObjectType collapseUnion if one is not null .. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_kPAR_PatchNaturalness$$Remove spurious lookahead. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_kPAR_PatchNaturalness$$Fix jstype matching of non - Record types .. $$0
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_kPAR_PatchNaturalness$$Allow inline with function calls via @ isDirectCallNodeReplacementPossible. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_kPAR_PatchNaturalness$$Don ' t allow duplicate x values in XYSeries. $$0
time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).$$patch1-time-17_kPAR_PatchNaturalness$$Fix an issue with DateTimeZone . getOffset ( ) where the difference was not an overlap. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_kPAR_PatchNaturalness$$StrBuilder should add the right padding right .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_kPAR_PatchNaturalness$$removed y as separator at the end of StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_kPAR_PatchNaturalness$$isDigits ( string ) fix. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_kPAR_PatchNaturalness$$Fix bug in StringUtils. Removed unnecessary null check .. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_kPAR_PatchNaturalness$$removed expPos. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_kPAR_PatchNaturalness$$isDigits got rid of '.'. $$0
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_kPAR_PatchNaturalness$$FastDateParser ignores unquotes in the value string. $$0
lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)$$patch1-lang-21_kPAR_PatchNaturalness$$Fixed bug for calendars with the same HOUR value. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_kPAR_PatchNaturalness$$Fix build. $$0
lang-53$$Dates.round() behaves incorrectly for minutes and seconds$$Get unexpected output for rounding by minutes or seconds. public void testRound() {     Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));     testCalendar.set(2007, 6, 2, 8, 9, 50);     Date date = testCalendar.getTime();     System.out.println("Before round() " + date);     System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE)); } --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong$$patch1-lang-53_kPAR_PatchNaturalness$$Don ' t round if ( ! round || millisecs < 500 ). $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_Jaid_PatchNaturalness$$Avoid matching against an unneeded property .. $$1
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_Jaid_PatchNaturalness$$"Fix the "" closure pass "" flag in Compiler . java". $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_Jaid_PatchNaturalness$$Fix typo in codeGenerator where ' c ' was passed through , but was accidentally ignored .. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_Jaid_PatchNaturalness$$Allow closure pass through. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Jaid_PatchNaturalness$$Remove whitespaces from sourceExcerpt .. $$1
closure-63$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-63_Jaid_PatchNaturalness$$Remove whitespaces from sourceExcerpt. $$1
closure-70$$unexpected typed coverage of less than 100%$$None$$patch1-closure-70_Jaid_PatchNaturalness$$Fix typed scope creator for parameter types .. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_Jaid_PatchNaturalness$$Fix an issue with TimeSeries . isEmptyRange ( ). $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch2-chart-9_Jaid_PatchNaturalness$$Fix an issue with time series end index < startIndex. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Jaid_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Jaid_PatchNaturalness$$missing break. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch6-lang-51_Jaid_PatchNaturalness$$missing bracket. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch5-lang-51_Jaid_PatchNaturalness$$Added missing case in BooleanUtils. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch3-lang-51_Jaid_PatchNaturalness$$missing break. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch4-lang-51_Jaid_PatchNaturalness$$missing test for Y. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Jaid_PatchNaturalness$$removed unnecessary loop. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch2-lang-33_Jaid_PatchNaturalness$$removed unnecessary copy of ClassUtils. $$1
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Jaid_PatchNaturalness$$Fixed misc problems caused by the use of substringBefore and substringAfter methods in WordUtils. $$1
lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }$$patch1-lang-38_Jaid_PatchNaturalness$$Reset the calendar time to GMT on Sunday .. $$1
lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }$$patch3-lang-38_Jaid_PatchNaturalness$$Fix null pointer check in FastDateFormat. $$1
lang-38$$DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations$$If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }$$patch4-lang-38_Jaid_PatchNaturalness$$Fix null pointer check in FastDateFormat. $$1
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch1-lang-55_Jaid_PatchNaturalness$$Add a test to make sure that no one keeps being left in StopWatch after a running state ==. $$1
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_Jaid_PatchNaturalness$$Added a missing if / else .. $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch2-closure-33_Jaid_PatchNaturalness$$Allow property types to be inferred from boolean to string .. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Jaid_PatchNaturalness$$don ' t add whitespace to source experpt. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_Jaid_PatchNaturalness$$Fix bug for empty range. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch2-chart-9_Jaid_PatchNaturalness$$Fix bug. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch3-chart-9_Jaid_PatchNaturalness$$Fix bug # 944. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Jaid_PatchNaturalness$$Fix null pointer check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_Jaid_PatchNaturalness$$Fix nullability assertion in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_Jaid_PatchNaturalness$$Fix legend item legend generation. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch1-lang-61_Jaid_PatchNaturalness$$Stop appending extra characters .. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch2-lang-61_Jaid_PatchNaturalness$$Don ' t compare string builders to buffer length - trailing space .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Jaid_PatchNaturalness$$missing if (. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch2-lang-51_Jaid_PatchNaturalness$$Fixed bug in BooleanUtils where empty string is not the case. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch3-lang-51_Jaid_PatchNaturalness$$missing if (. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch4-lang-51_Jaid_PatchNaturalness$$missing one if (. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Jaid_PatchNaturalness$$Fixed WordUtils . isEmpty ( ) .. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch2-lang-45_Jaid_PatchNaturalness$$Fixed WordUtils . isEmpty ( ) .. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch1-lang-55_Jaid_PatchNaturalness$$Add missing return statement. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch2-lang-55_Jaid_PatchNaturalness$$Reset running state to 1. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch3-lang-55_Jaid_PatchNaturalness$$Added missing return statement. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_JGenProg2015_PatchNaturalness$$Fixed issue with XYSeries . add ( ). $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_JGenProg2015_PatchNaturalness$$Fixed zero - is - max datetime field. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_AVATAR_PatchNaturalness$$Fix negative zero log in case of a - sign in JSON. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_AVATAR_PatchNaturalness$$Remove recording type properties where they are not equivalent. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_AVATAR_PatchNaturalness$$Allow side effects in function arguments .. $$1
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_AVATAR_PatchNaturalness$$Add null check in TypeCheck . java. Added missing for loop. $$1
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_AVATAR_PatchNaturalness$$Remove unused vars that are not used any more .. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_AVATAR_PatchNaturalness$$Fix CheckSideEffects . java. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_AVATAR_PatchNaturalness$$Fix tryMinimizeExitPoints. $$0
closure-108$$precondition crash: goog.scope local with aliased in the type declaration$$None$$patch1-closure-108_AVATAR_PatchNaturalness$$Fix scoped properties. $$0
closure-48$$Type checking error when replacing a function with a stub after calling.$$None$$patch1-closure-48_AVATAR_PatchNaturalness$$Fixing scope creation failure. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_AVATAR_PatchNaturalness$$Add gramps as a modifier to a name .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_AVATAR_PatchNaturalness$$Fix bug in XYSeries addOrUpdate. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_AVATAR_PatchNaturalness$$StrBuilder should add padChar + width if object is null. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_AVATAR_PatchNaturalness$$Remove backslash which prevents overflow from StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_AVATAR_PatchNaturalness$$try to create long from Javadoc. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_AVATAR_PatchNaturalness$$Fix NPE. Fix bug in StringUtils. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_AVATAR_PatchNaturalness$$remove replacementList . length ( ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_AVATAR_PatchNaturalness$$Fix typo. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_AVATAR_PatchNaturalness$$Fix Fraction . greatestCommonDivisor ( ). $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_GenPat_PatchNaturalness$$Remove spurious blank line. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_GenPat_PatchNaturalness$$Fixing the function infusion of side effects in JS stylesheet. $$1
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_GenPat_PatchNaturalness$$Added TypeCheck copy check. Added TypeCheck copy .. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_GenPat_PatchNaturalness$$added missing copy. $$1
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_GenPat_PatchNaturalness$$StrBuilder . contains ( ) now uses the same level of storage as ArrayList .. $$1
lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)$$patch1-lang-21_GenPat_PatchNaturalness$$Fixed fall through in DateUtils . java. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_GenPat_PatchNaturalness$$Fix an NPE in StrBuilder . toString ( ). $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_GenPat_PatchNaturalness$$Fix bug in TimeSeries . java. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_GenPat_PatchNaturalness$$Added zeroismaxdatetimefield copy. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_GenPat_PatchNaturalness$$StrBuilder copy ( ) {. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_GenPat_PatchNaturalness$$Fix parse error. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_GenPat_PatchNaturalness$$Fix toString method of StringUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_GenPat_PatchNaturalness$$Fix copy ( ). $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_GenPat_PatchNaturalness$$Fixed null pointer check in WordUtils. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_GenPat_PatchNaturalness$$Manchester United FC = > NumberUtils copy ( ). $$0
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_SequenceR_PatchNaturalness$$Fix typo in codeGenerator . java. $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch2-closure-73_SequenceR_PatchNaturalness$$Fix typo in codeGenerator . java. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_SequenceR_PatchNaturalness$$Fix null pointer check in AbstractCategoryItemRenderer. $$1
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch1-lang-6_SequenceR_PatchNaturalness$$Fix bug in CharSequenceTranslator. $$1
closure-92$$bug with implicit namespaces across modules$$None$$patch8-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' definition .. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch1-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' positioning .. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch6-closure-92_SequenceR_PatchNaturalness$$Fix closure closures to error code .. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch7-closure-92_SequenceR_PatchNaturalness$$Fix a warning. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch9-closure-92_SequenceR_PatchNaturalness$$Fix a warning. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch5-closure-92_SequenceR_PatchNaturalness$$Fix a warning. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch2-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' null arguments ' error. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch10-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' positioning mistake. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch3-closure-92_SequenceR_PatchNaturalness$$Fix an issue with ' . ' in ProcessClosurePrimitives . java. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch4-closure-92_SequenceR_PatchNaturalness$$Fix an issue with that damn code style error .. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_SequenceR_PatchNaturalness$$Fix a bug in the compiler ' s dependency check. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch5-closure-18_SequenceR_PatchNaturalness$$Fix a null pointer check that would trigger an NPE .. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch3-closure-18_SequenceR_PatchNaturalness$$Fix a null pointer check that would trigger an error .. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch4-closure-18_SequenceR_PatchNaturalness$$Fix null pointer check .. $$0
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_SequenceR_PatchNaturalness$$Fix typo in codeGenerator . java. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch5-closure-86_SequenceR_PatchNaturalness$$Allow for an aliased constructor to be used in a few places. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch2-closure-86_SequenceR_PatchNaturalness$$AllowImmutableValue check for value types .. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch3-closure-86_SequenceR_PatchNaturalness$$Fix bug in NodeUtil . isFunctionLike ( ). $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch4-closure-86_SequenceR_PatchNaturalness$$Add toStringMethodCall check. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_SequenceR_PatchNaturalness$$Fix negative zero logspam. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch2-closure-38_SequenceR_PatchNaturalness$$Fix negative zero logspam. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch3-closure-38_SequenceR_PatchNaturalness$$Fix negative zero presence in JSON. $$0
closure-123$$Generates code with invalid for/in left-hand assignment$$None$$patch1-closure-123_SequenceR_PatchNaturalness$$Fix the rhs context for the for - init CLAUSE token .. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_SequenceR_PatchNaturalness$$Fix an issue with TimeSeries . isEmptyRange ( ) .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_SequenceR_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_SequenceR_PatchNaturalness$$Fix null checking in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch4-chart-1_SequenceR_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$0
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch2-lang-6_SequenceR_PatchNaturalness$$Don ' t count surrogate pairs as we don ' t understand code points at the beginning of a. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Arja_PatchNaturalness$$Set the dataset on the pie chart .. $$1
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_Arja_PatchNaturalness$$Use the method provided for sorting XYSeries. $$1
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_Arja_PatchNaturalness$$Fix a bug in FieldUtils. $$1
lang-35$$ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException$$ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException. For example, the following code compiles without a warning:  String[] sa = ArrayUtils.add(stringArray, aString);   and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception. If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.$$patch1-lang-35_Arja_PatchNaturalness$$Allow null to be stored in Java ArrayUtils. Allow null to be added to the array .. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_Arja_PatchNaturalness$$Bump the buffer size for the empty string builder .. Removed unnecessary copy of StringUtils. $$1
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Arja_PatchNaturalness$$Extend word utils upper bounds. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Arja_PatchNaturalness$$Fix category item label generator on initial refresh .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch6-chart-1_Arja_PatchNaturalness$$Remove redundant return statement. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch5-chart-1_Arja_PatchNaturalness$$Remove unnecessary check for null dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_Arja_PatchNaturalness$$Fix category item renderer to reset the counts as well. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_Arja_PatchNaturalness$$Fix category item renderer to save row count in case of data series changes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch4-chart-1_Arja_PatchNaturalness$$Fix background annotations for category items. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch8-chart-12_Arja_PatchNaturalness$$Add a listener to MultiplePiePlot .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset group object , so we can use the group object to get the. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch6-chart-12_Arja_PatchNaturalness$$Add a listener to MultiplePiePlot .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch7-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset group object , so we can use it for any dataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch5-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset group option on pie plot .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch2-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch3-chart-12_Arja_PatchNaturalness$$Fixed dataExtractOrder. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch4-chart-12_Arja_PatchNaturalness$$Add a listener to MultiplePiePlot. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_Arja_PatchNaturalness$$Fixing duplicate recurrent name key in DateTimeZoneBuilder. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch6-time-11_Arja_PatchNaturalness$$Fix loop. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch7-time-11_Arja_PatchNaturalness$$Added missing debug message. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch5-time-11_Arja_PatchNaturalness$$added debug level out of zone info map. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch2-time-11_Arja_PatchNaturalness$$Fix NPE in DateTimeZoneBuilder. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch3-time-11_Arja_PatchNaturalness$$added debug output. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch4-time-11_Arja_PatchNaturalness$$Fixing duplicate recurrent name key .. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_Arja_PatchNaturalness$$Fixed zero - is - max datetime field. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch6-time-4_Arja_PatchNaturalness$$Fixed zero - is - maxDateTimeField minimization. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch7-time-4_Arja_PatchNaturalness$$Fixed the build .. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch5-time-4_Arja_PatchNaturalness$$Add an exception. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch2-time-4_Arja_PatchNaturalness$$Add an exception. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch3-time-4_Arja_PatchNaturalness$$Fix # 135. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch4-time-4_Arja_PatchNaturalness$$Fixed zero - is - max datetime field minimization. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_Arja_PatchNaturalness$$MonthDay doesn ' t wrap month - day partials in MonthDay .. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch1-lang-61_Arja_PatchNaturalness$$StrBuilder . indexOf ( String ) uses reflection to improve matching of substrings. Add more ensureCapacity ( ) for string builder. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch2-lang-61_Arja_PatchNaturalness$$StrBuilder . indexOf ( String ) uses reflection to improve matching of substrings. Add ensureCapacity ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch3-lang-61_Arja_PatchNaturalness$$StrBuilder . indexOf ( String ) uses buffer . length - > string . length. Add more ensureCapacity ( ) .. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch4-lang-61_Arja_PatchNaturalness$$StrBuilder . indexOf ( String ) uses buffer . length - > string . length. Add more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch8-lang-59_Arja_PatchNaturalness$$StrBuilder ( ) uses char[] instead of char [ ] for the char array .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_Arja_PatchNaturalness$$StrBuilder . appendFixedWidthPadRight ( ) needs buffer .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch6-lang-59_Arja_PatchNaturalness$$Add more ensureCapacity ( ) for string builder. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch7-lang-59_Arja_PatchNaturalness$$Add 4 more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch9-lang-59_Arja_PatchNaturalness$$Add more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch5-lang-59_Arja_PatchNaturalness$$StrBuilder should add 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 +. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch2-lang-59_Arja_PatchNaturalness$$StrBuilder should add 4 spaces for appendFixedWidthPadRight ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch3-lang-59_Arja_PatchNaturalness$$StrBuilder ( ) uses char[] instead of char[] .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch4-lang-59_Arja_PatchNaturalness$$StrBuilder . appendFixedWidthPadRight ( ) will reset the array. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch1-lang-50_Arja_PatchNaturalness$$Fix getDateInstance ( ). Fix cDateTimeInstanceCache . put ( key , format ) .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch6-lang-50_Arja_PatchNaturalness$$Fix null zone definition for DateInstance where it is not defined. Prevent null pattern exception from throwing an exception when pattern is null .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch5-lang-50_Arja_PatchNaturalness$$locale = null ; Add missing null check in DateInstance .. Prevents null pattern check for the date time formatter .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch2-lang-50_Arja_PatchNaturalness$$FastDateFormat should cache locale for key. Prevent null pattern exception from throwing an exception when pattern is null .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch3-lang-50_Arja_PatchNaturalness$$Fix getDateInstance ( ). Fix cache update issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch4-lang-50_Arja_PatchNaturalness$$Fix getDateInstance ( ). Prevent null pattern exception from throwing an exception when pattern is null .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Arja_PatchNaturalness$$Handle case when String is empty or null. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch2-lang-51_Arja_PatchNaturalness$$Handle case when String is empty or null. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_Arja_PatchNaturalness$$StrBuilder . contains ( ) uses the array copy constructor. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_Arja_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary padding. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch2-lang-20_Arja_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary padding. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch3-lang-20_Arja_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary copy of StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_Arja_PatchNaturalness$$removed extra chars. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch6-lang-7_Arja_PatchNaturalness$$Improve error handling for ""-- "" and "" ( areas with the same length ) - removed 0x. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch7-lang-7_Arja_PatchNaturalness$$Handle hex number format in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch5-lang-7_Arja_PatchNaturalness$$formatting fixes. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch2-lang-7_Arja_PatchNaturalness$$Remove a check for '-- '. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch4-lang-7_Arja_PatchNaturalness$$Allow null string input. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_Arja_PatchNaturalness$$Fixed NO_ISSUE in NumberUtils . createInteger ( ) .. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch2-lang-16_Arja_PatchNaturalness$$Fixed erroneous error in NumberUtils. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_Arja_PatchNaturalness$$don ' t append QUOTE to the appendTo var. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch2-lang-43_Arja_PatchNaturalness$$don ' t append QUOTE if it is backslashed. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch3-lang-43_Arja_PatchNaturalness$$don ' t skip backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch4-lang-43_Arja_PatchNaturalness$$Fix lost backslash. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_Arja_PatchNaturalness$$start = textIndex + searchList [ replaceIndex ] . length ( ). $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch1-lang-55_Arja_PatchNaturalness$$Added missing return statement. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch5-lang-55_Arja_PatchNaturalness$$Add some error code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch2-lang-55_Arja_PatchNaturalness$$Add some error code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch3-lang-55_Arja_PatchNaturalness$$Remove unnecessary assignment. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch4-lang-55_Arja_PatchNaturalness$$Fix splitState after stopTime. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_Arja_PatchNaturalness$$Fixed bug for calendar systems .. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch5-lang-63_Arja_PatchNaturalness$$Fixed formatting mistake. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch2-lang-63_Arja_PatchNaturalness$$Fix bug in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch3-lang-63_Arja_PatchNaturalness$$Remove over - aggressive add in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch4-lang-63_Arja_PatchNaturalness$$Fixed the merge bug in DurationFormatUtils. $$0
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_Arja_PatchNaturalness$$make ClassUtils . getShortCanonicalName work for 1 . 7. made ClassUtils . getPackageCanonicalName a little easier to resolve. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_Arja_PatchNaturalness$$Fix greatestCommonDivisor from Lee Butts. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch2-lang-22_Arja_PatchNaturalness$$Fix Fraction . greatestCommonDivisor ( ). $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch3-lang-22_Arja_PatchNaturalness$$Fix Fraction . greatestCommonDivisor ( ). $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch4-lang-22_Arja_PatchNaturalness$$Fix Fraction . greatestCommonDivisor ( ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_PatchSim_PatchNaturalness$$Fix NumberFormatException. $$1
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_PatchSim_PatchNaturalness$$Fix post - release build. $$1
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch1-lang-55_PatchSim_PatchNaturalness$$Fixed bug in StopWatch . stopTime. $$1
lang-24$$NumberUtils.isNumber(String)  is not right when the String is "1.1L"$$"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }$$patch1-lang-24_PatchSim_PatchNaturalness$$Allow L with an exponent or decimal point. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_PatchSim_PatchNaturalness$$Fix a bug in chart_9_TimeSeries_t. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_PatchSim_PatchNaturalness$$Improved method to append XYDataItems. $$0
time-18$$GJChronology rejects valid Julian dates$$The 2nd statement fails with "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]".  Given that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?$$patch1-time-18_PatchSim_PatchNaturalness$$Fixed incorrect patch. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_PatchSim_PatchNaturalness$$Remove debug output. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch2-time-11_PatchSim_PatchNaturalness$$Fix incorrect logic , improve stability of DateTimeZoneBuilder. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch4-time-11_PatchSim_PatchNaturalness$$Fix incorrect logic , added missing period in definition. $$0
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_PatchSim_PatchNaturalness$$Fixed misc problems caused by the string comparison. $$0
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_PatchSim_PatchNaturalness$$Fixed incorrect patching. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_PatchSim_PatchNaturalness$$Fix incorrect patch180 data. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch3-time-4_PatchSim_PatchNaturalness$$Add 0 . 5 for the getMaximumValue ( ) method , but not in the patch. $$0
time-12$$Check Calendar.ERA in LocalDate.fromCalendarFields$$None$$patch1-time-12_PatchSim_PatchNaturalness$$Fix incorrect merge. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_PatchSim_PatchNaturalness$$Fixed incorrect patch. $$0
lang-35$$ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException$$ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException. For example, the following code compiles without a warning:  String[] sa = ArrayUtils.add(stringArray, aString);   and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception. If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.$$patch1-lang-35_PatchSim_PatchNaturalness$$Added missing throw in patch192. added missing throwing check. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_PatchSim_PatchNaturalness$$Fix incorrect patch. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_PatchSim_PatchNaturalness$$Fix typo in patch. $$0
lang-53$$Dates.round() behaves incorrectly for minutes and seconds$$Get unexpected output for rounding by minutes or seconds. public void testRound() {     Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));     testCalendar.set(2007, 6, 2, 8, 9, 50);     Date date = testCalendar.getTime();     System.out.println("Before round() " + date);     System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE)); } --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong$$patch1-lang-53_PatchSim_PatchNaturalness$$Don ' t set date object in incorrect way ( minute > minute ). $$0
lang-53$$Dates.round() behaves incorrectly for minutes and seconds$$Get unexpected output for rounding by minutes or seconds. public void testRound() {     Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));     testCalendar.set(2007, 6, 2, 8, 9, 50);     Date date = testCalendar.getTime();     System.out.println("Before round() " + date);     System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE)); } --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong$$patch2-lang-53_PatchSim_PatchNaturalness$$fix wrong data. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_PatchSim_PatchNaturalness$$added missing if (. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch2-lang-39_PatchSim_PatchNaturalness$$added missing patch. $$0
lang-46$$StringEscapeUtils.escapeJava(String) escapes '/' characters$$Commons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes '/' characters, which is not a valid "escapable" character in Java strings.  I haven't tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java "escapable" characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off, in that '/' should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase {     public void testEscapeJavaWithSlash()  {         final String input = "String with a slash (/) in it";                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters,          * which are not a valid character to escape in a Java string.            */         assertEquals( expected, actual );     } }$$patch1-lang-46_PatchSim_PatchNaturalness$$don ' t escape single quote when escaping backslash. $$0
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_ConFix_PatchNaturalness$$Fix typo in codeGenerator . java. $$1
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_ConFix_PatchNaturalness$$Fix whitespace in code consumer. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_ConFix_PatchNaturalness$$Add missing import. Fix test. $$1
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_ConFix_PatchNaturalness$$fixed typo .. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_ConFix_PatchNaturalness$$missing break. $$1
lang-6$$StringIndexOutOfBoundsException in CharSequenceTranslator$$I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 	at java.lang.String.charAt(String.java:658) 	at java.lang.Character.codePointAt(Character.java:4668) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) 	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException$$patch1-lang-6_ConFix_PatchNaturalness$$Missing import. Fix bug in CharSequenceTranslator. $$1
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_ConFix_PatchNaturalness$$Fix checkSuspiciousCode. $$0
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_ConFix_PatchNaturalness$$Allow non - type annotations .. $$0
closure-89$$Compiler removes function properties that it should not$$None$$patch1-closure-89_ConFix_PatchNaturalness$$Fix CollapseProperties report. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_ConFix_PatchNaturalness$$Fix check side effects for calls to the closure context. $$0
closure-119$$catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode$$None$$patch1-closure-119_ConFix_PatchNaturalness$$Add some fix .. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_ConFix_PatchNaturalness$$Fix MinimizeExitPoints . java to include imports from confix .. Fix try / finally blocks. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_ConFix_PatchNaturalness$$Fix maybeGetSingleReturnRValue ( ). $$0
closure-108$$precondition crash: goog.scope local with aliased in the type declaration$$None$$patch1-closure-108_ConFix_PatchNaturalness$$Fix check for same name in ScopedAliases. $$0
closure-90$$@this emits warning when used with a typedef$$None$$patch1-closure-90_ConFix_PatchNaturalness$$Add missing import .. Fix TypeCheck . java. $$0
closure-79$$RuntimeException when compiling with extern prototype$$None$$patch1-closure-79_ConFix_PatchNaturalness$$Fix findbugs issue. $$0
closure-83$$Cannot see version with --version$$None$$patch1-closure-83_ConFix_PatchNaturalness$$Fix checkstyle issues. $$0
closure-125$$IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType$$None$$patch1-closure-125_ConFix_PatchNaturalness$$Add missing imports .. Fix TypeCheck . java for ES6 closures .. $$0
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_ConFix_PatchNaturalness$$Fix TypeCheck . checkForExtraProperties. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_ConFix_PatchNaturalness$$Allow non - expr results in closure closure check .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_ConFix_PatchNaturalness$$Add some missing imports. Fix bug in addOrUpdate. $$0
time-9$$Ensure there is a max/min valid offset$$DateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.$$patch1-time-9_ConFix_PatchNaturalness$$Fix bug in time9 .. fixed offset zone for configuration file. $$0
time-11$$NPE in DateTimeZoneBuilder$$When a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().  The cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler ...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in: . A better approach could be to remove the initialization and test for null:$$patch1-time-11_ConFix_PatchNaturalness$$Fix bug in tz archive. $$0
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_ConFix_PatchNaturalness$$Add withUTC suffix .. $$0
time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).$$patch1-time-17_ConFix_PatchNaturalness$$Fix bug in time zone ISO 8601 format. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_ConFix_PatchNaturalness$$Add missing import .. Fixed whitespace in ZeroIsMaxDateTimeField . getMaximumValue ( ReadablePartial instant , int [. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch1-lang-59_ConFix_PatchNaturalness$$add missing backslash. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_ConFix_PatchNaturalness$$Added missing 1111. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_ConFix_PatchNaturalness$$Fix typo in first line of text file. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_ConFix_PatchNaturalness$$Fix checkstyle. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_ConFix_PatchNaturalness$$reduce TFJ - 619 search path. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch1-lang-43_ConFix_PatchNaturalness$$Fix cruisecontrol test. Fix bug in message format. $$0
lang-31$$StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.$$StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00" 	private static final String CharU20000 = "\uD840\uDC00"; 	private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call: 	assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken: 	assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001)); 	assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine: 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000)); 	assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001)); 	assertEquals(true, StringUtils.contains(CharU20000, CharU20000)); 	assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/$$patch1-lang-31_ConFix_PatchNaturalness$$Fix bug in StringUtils. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_ConFix_PatchNaturalness$$Fix bug in StringUtils. Fix bug in StringUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_ConFix_PatchNaturalness$$Fix bug in duration format utils. Fix bug in duration format. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_ConFix_PatchNaturalness$$Fix greatestCommonDivisor result. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_jKali_PatchNaturalness$$Fix bug in closure patch. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_jKali_PatchNaturalness$$try minimize exits on finally blocks. $$1
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_jKali_PatchNaturalness$$Updated patch. $$1
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_jKali_PatchNaturalness$$Fix 0x mistake in patch. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_jKali_PatchNaturalness$$don ' t backslash backslash in regex so it won ' t be backslashed. $$1
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_jKali_PatchNaturalness$$fix bug. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_jKali_PatchNaturalness$$don ' t add extra space to the end of a line. $$0
closure-101$$--process_closure_primitives can't be set to false$$None$$patch1-closure-101_jKali_PatchNaturalness$$closure fix bug. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_jKali_PatchNaturalness$$Fix closure patching. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_jKali_PatchNaturalness$$Allow null dataset in chart. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_jKali_PatchNaturalness$$Fix bug in chart. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_jKali_PatchNaturalness$$removed expPos from mant patch. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_jKali_PatchNaturalness$$Fix false alarm in JKali patch. $$0
closure-57$$compiler crashes when  goog.provide used with non string$$None$$patch1-closure-57_SimFix_PatchNaturalness$$Fixing closure code conventions. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_SimFix_PatchNaturalness$$Allow null arguments for static closures .. $$1
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch1-lang-50_SimFix_PatchNaturalness$$Fix FastDateFormat ' s key value if locale is not null. Fix getLocaleKey exception in FastDateFormat. $$1
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_SimFix_PatchNaturalness$$Fix parse error ( l - > long ). $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_SimFix_PatchNaturalness$$removed null check. $$1
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_SimFix_PatchNaturalness$$convert string to lower case since it ' s a number. $$1
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_SimFix_PatchNaturalness$$still need more matches in StringUtils. $$1
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_SimFix_PatchNaturalness$$Fix parse error. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_SimFix_PatchNaturalness$$make str . length ( ) > upper. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_SimFix_PatchNaturalness$$Fix erroneous fallthrough in NumberUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_SimFix_PatchNaturalness$$Fix merge conflict between end and start. $$0
chart-16$$Bug propgated from v1.0.5 on to present$$The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it "Returns the number of series in the dataset (possibly zero)."  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.$$patch1-chart-16_VFix_PatchNaturalness$$Fix bug in chart 16. $$1
chart-16$$Bug propgated from v1.0.5 on to present$$The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it "Returns the number of series in the dataset (possibly zero)."  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.$$patch2-chart-16_VFix_PatchNaturalness$$Fix bug in chart - 16. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_VFix_PatchNaturalness$$Add null check. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_VFix_PatchNaturalness$$removed null check. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_VFix_PatchNaturalness$$fixed bug. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch2-lang-20_VFix_PatchNaturalness$$fixed bug. $$1
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch1-lang-39_VFix_PatchNaturalness$$fix bug. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_VFix_PatchNaturalness$$Fix bug. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch2-lang-47_VFix_PatchNaturalness$$Fix bug. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_jMutRepair_PatchNaturalness$$Fixed bug in Closure Repair fix. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_jMutRepair_PatchNaturalness$$Fix nullability assertion .. $$1
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_jMutRepair_PatchNaturalness$$Fix closure closure bug. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_jMutRepair_PatchNaturalness$$minimize the closure closure closure closure patch .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_jMutRepair_PatchNaturalness$$JSDoc info removed from closure patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_jMutRepair_PatchNaturalness$$Fix incorrect patch. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch1-lang-22_jMutRepair_PatchNaturalness$$Fix a bug in JMutRepair where abs ( u ) > v. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_GenProgA_PatchNaturalness$$Remove tryMinimizeExits from tryMinimizeExits. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_GenProgA_PatchNaturalness$$Allow side effects for closure arguments. $$1
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_GenProgA_PatchNaturalness$$"Add "" addVerboseWarnings ( ) "" to closure compiler warnings". $$0
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_GenProgA_PatchNaturalness$$Remove unused prototype properties fix .. $$0
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_GenProgA_PatchNaturalness$$Remove broken upgrade .. closure folding changes. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_GenProgA_PatchNaturalness$$Updated code. $$0
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_GenProgA_PatchNaturalness$$Remove the missing semicolon in POS signs. Remove reported code change of PeepholeFoldConstants. Updated isStrWhiteSpaceChar method .. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_GenProgA_PatchNaturalness$$Remove unneeded call to NodeTraversal . traverse ( ) .. $$0
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_GenProgA_PatchNaturalness$$Remove hard coded resolve of template types in closure context. $$0
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_GenProgA_PatchNaturalness$$Remove old and unused patch .. $$0
closure-114$$Crash on the web closure compiler$$None$$patch1-closure-114_GenProgA_PatchNaturalness$$Add generated paramName to replacements , for efficiency .. Add paramName to closure context so it can be used by filer .. $$0
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_GenProgA_PatchNaturalness$$Do not increment local variable. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_GenProgA_PatchNaturalness$$Remove stray return statement from a checksideeffects patch .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_GenProgA_PatchNaturalness$$Fix x axis issue. Fix NPE in CategoryPlot. Fix NPE in chart impl. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_GenProgA_PatchNaturalness$$Fix legends not disappearing on I + E7. Fix fire chart changed event. Add a listener to setDatasetGroup ( ) for multiple pie plot. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch1-lang-7_GenProgA_PatchNaturalness$$Fix a regression in NumberUtils. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch120-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch36-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix category plot backgrounds. Remove fireChangeEvent ( ) from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch127-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch31-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Fix CategoryPlot ' s renderer. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch118-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix CategoryPlot ' s renderers. Fix bug. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch111-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend ' s location .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch38-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch116-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Fix # 183. Remove a couple of unused files. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch129-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Extend CategoryPlot to remove listener from the existing renderer. Fix issue with the axes configuration for the year century .. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch189-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix option selection on CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch142-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove fireChangeEvent ( ) from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch54-chart-1_GenProg_PatchNaturalnessYe$$Fix label positionning. Fix pull request. Fix # 1664. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch98-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix a bug in CategoryPlot. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch145-chart-1_GenProg_PatchNaturalnessYe$$Added patch to defects4J_Chart_1. Fix # 1862. remove 1677 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch53-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category items renderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch65-chart-1_GenProg_PatchNaturalnessYe$$Fix label positionning. Fix # 1862. Remove redundant code. remove 1673 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch173-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Added missing patch. Remove redundant code. Fix issue with wrong range axis size. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch91-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove redundant code. Fix # 183. Fix issues with the categs spines plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch187-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch96-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. Remove unused variable. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch180-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch62-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed redundant call to setRenderer ( ). Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch174-chart-1_GenProg_PatchNaturalnessYe$$Add barBase and line to result. Fix NPE in CategoryPlot. Remove redundant code. Fix minor eclipse compile warning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch117-chart-1_GenProg_PatchNaturalnessYe$$Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. Fix a bug in CategoryPlot. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch128-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with the axes function not being re - added. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch110-chart-1_GenProg_PatchNaturalnessYe$$Improved null pointer check in CategoryItemRenderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch39-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix bug. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch126-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. throw exception if index is negative. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch119-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix issue with defects4J_Chart_1 .. Remove some trailing whitespace. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch121-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch37-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis not being changed by the user. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch63-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch175-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix # 1862. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch97-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix issue with domain axis selection. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch181-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch90-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix # 1862. Fix bug. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch186-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1336. Fix # 1862. Fix category axis. Fix category axes. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch64-chart-1_GenProg_PatchNaturalnessYe$$Remove potential NPE in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch172-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1796. remove 1675 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch99-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category items renderer patch. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set range zero baseline stroke. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch144-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch52-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Remove redundant code. Fix issue with defects 4J calendar plugin. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch188-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 183. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch143-chart-1_GenProg_PatchNaturalnessYe$$Remove some redundant lines. Fix # 1862. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch55-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch204-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix a problem with the axes. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch205-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch202-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with the legend ' s X axis .. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch161-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix year for data set domain axis. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch195-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. remove 1679 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch83-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix a potential NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch48-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch192-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 183. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch84-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix issue with data set range zero baseline stroke. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch166-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch70-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Added fix for NPE in CategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch46-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1349. Fix bug. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch150-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch79-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix # 1862. Fix issue with wrong parameter name. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch6-chart-1_GenProg_PatchNaturalnessYe$$Remove 1355 from CategoryPlot. Remove redundant code. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch41-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix fireChangeEvent. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch157-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix # 183. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch168-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with defects plot 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch103-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix label positionning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch104-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix issue with the legend ' s X axis .. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch24-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch132-chart-1_GenProg_PatchNaturalnessYe$$Fix a potential NPE in CategoryPlot. Fix NPE in CategoryPlot. Fix category axes. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch135-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch40-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Fix PR # 1674. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch156-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch169-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix legend generation. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch47-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch151-chart-1_GenProg_PatchNaturalnessYe$$Fix category axis location .. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch78-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch167-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1349. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch71-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix # 1359. Remove redundant code. Fix NPE in CategoryPlot. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch193-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1660. Remove 1672 from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch85-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch158-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch194-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1862. Fix issue with same dataset .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch82-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove unused variable .. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch160-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix change in CategoryPlot. Add urlText to category items renderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch49-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch22-chart-1_GenProg_PatchNaturalnessYe$$Fix # 183. Fix issue with defects4J_Chart_1 .. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch134-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix null label in CategoryPlot. Require index < 0 .. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch25-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix issue with first plot using patch. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch133-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix CategoryPlot ' s renderers. Fix issue with data set selection. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch105-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix fireChangeEvent. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch102-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch179-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix CategoryPlot ' s renderers. Fix issue with the axes configuration for the year century .. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch146-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch50-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch68-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch141-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category item renderer. Fix NPE in CategoryPlot. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch57-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Remove redundant call. Fix null label in CategoryPlot. Require index < 0 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch148-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Added patch for domain axis generation. Fix category gridline position .. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch95-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch183-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with chart 1 .. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch61-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in place. Fix a bug in CategoryPlot. Fix option selection for CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch177-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix build. Remove redundant code. Fix fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch59-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix local testing. Remove spurious return value. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch66-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed redundant call to setRenderer ( ). Fix issue with the legend ' s X axis .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch170-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix getDataset ( ). Fix # 1862. Remove redundant code. remove 1674 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch92-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix category axes. Fix # 1718. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch124-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 183. Remove redundant code. Fix issue with chart 1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch32-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. Fix category plot index calculation .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch123-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix bug in CategoryPlot. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch35-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix # 1862. Remove redundant code. added notify listener. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch115-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix fire sale. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch58-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. remove 1677 from range axes. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch185-chart-1_GenProg_PatchNaturalnessYe$$Added datasetChanged ( ) method to CategoryPlot. Remove redundant code. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch67-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch171-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Fix # 1864. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch149-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix issue with ' GenProg_Defects4J_Chart_1 '. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch60-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch176-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend ' s X axis .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch94-chart-1_GenProg_PatchNaturalnessYe$$added datasetChanged ( ) to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch182-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant line. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch69-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch140-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch56-chart-1_GenProg_PatchNaturalnessYe$$Fix category data range selection. Fix 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch178-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch147-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Removed redundant call to setRenderer ( ). Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch51-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch113-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Remove redundant code. Fix fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch114-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch122-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix legend generation. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch34-chart-1_GenProg_PatchNaturalnessYe$$Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. Remove redundant fireChangeEvent ( ) call. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch125-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix crosshair renderers. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch33-chart-1_GenProg_PatchNaturalnessYe$$Fix legend. Fix NPE in CategoryPlot. Fix change in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch207-chart-1_GenProg_PatchNaturalnessYe$$Added datasetChanged ( ) method to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch200-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove some trailing whitespace. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch208-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 183. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch201-chart-1_GenProg_PatchNaturalnessYe$$Fix issue with ' CategoryPlot ' axis. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch206-chart-1_GenProg_PatchNaturalnessYe$$Fix issue with wrong param. Remove some trailing whitespace. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch138-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1213. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch107-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Fix build. Remove redundant code. Fix bug. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch29-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch100-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix fireChangeEvent. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch109-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch136-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. remove 1677 from category plot. Remove some redundant lines. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch27-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Fix local variable warning. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch131-chart-1_GenProg_PatchNaturalnessYe$$Fix # 183. Fix category plot not listening to the existing renderer. Fix category axis fire. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch191-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Remove fireChangeEvent ( ) from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch87-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch165-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with ' add domain axis ' method. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch73-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not used .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch162-chart-1_GenProg_PatchNaturalnessYe$$Fix pull request. Fix newline. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch74-chart-1_GenProg_PatchNaturalnessYe$$Fix issue with CategoryPlot . setDataset ( int , CategoryDataset ). Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch196-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix NPE in CategoryPlot . setDataset ( ). Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch80-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix null label in CategoryPlot. Require index < 0 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch42-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1336. Fix # 1862. Fix CategoryPlot ' s renderer. Fix bug. Fix issue with wrong dataset index. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch154-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix issue with chart 1 .. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch89-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1349. Remove redundant code. Fix NPE in CategoryPlot. Fix category chart demo .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch153-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Fix # 1862. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch198-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. remove 1674 from category plot. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch26-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with the axes configuration for today ' s CategoryPlot. Remove unused variable. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch130-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch108-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category item renderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch21-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch137-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove 1679 from CategoryPlot. Fix label positionning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch28-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch101-chart-1_GenProg_PatchNaturalnessYe$$Fix a potential NPE in CategoryPlot. Fix # 1862. Fix bug. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch139-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Remove redundant code. Fix category axis location .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch106-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix # 183. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch44-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch152-chart-1_GenProg_PatchNaturalnessYe$$throw exception if index is negative. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch199-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch43-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix category axis registration. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch155-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix pull request. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch88-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch197-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in place. Fix # 1862. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch81-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 183. Fix # 1673. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch163-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch75-chart-1_GenProg_PatchNaturalnessYe$$Fix 1349. Fix legend generation. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch164-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix bug. Remove urlText = null in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch72-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove unused variable .. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch86-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 183. Remove redundant code. Fix legend generation. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_GenProg_PatchNaturalnessYe$$Improved method to remove listener from AbstractDataset. Set padding on legends. Add fix from pull request. Remove old line. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch11-chart-12_GenProg_PatchNaturalnessYe$$Fix race condition. Fix bug in JFreeChart 12. Add fix from pull request. Fix issue with deferment of subtitles. Fix bug in JFreeChart 12 .. Improved method to remove listener from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch2-chart-12_GenProg_PatchNaturalnessYe$$Improved method to remove listener from AbstractDataset. Fix # 7751. Add fix from pull request. Remove old line. Fix # 1862. Added throw exception if padding is null. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_GenProg_PatchNaturalnessYe$$Remove an overwritten throw exception if it is null. Improved method to append XYSeries items. Fix overwritten variable. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch3-chart-5_GenProg_PatchNaturalnessYe$$Remove an overwritten check. Improved method to append XYSeries items. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch36-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix NumberFormatException. fixed NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch31-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for 0x digits. Fix NumberFormatException. Fix NPE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch38-lang-7_GenProg_PatchNaturalnessYe$$Fix NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch54-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. fixed E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch53-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix E3C. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch39-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032c0. fix the build. Added patch for E3E. revert accidently change. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch30-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Handle null string in GenProg_Defects4J_Lang_7. Added patch for DoubleUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch52-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch55-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Added patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch48-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. Fix StringUtils . createDouble ( String ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch8-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for 0x digits. Fix NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch46-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch6-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Fix NPE in GenProg_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch41-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix e3c032e032c0. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch15-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Eliminate more flakiness in NumberUtils. fix the build. Added patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch12-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix NumberFormatException. formatting fixes. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch24-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix StringUtils . createDouble ( String ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch23-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NPE in GenProg_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch40-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032e. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch7-lang-7_GenProg_PatchNaturalnessYe$$Eliminate the fix of the merge conflict in NumberUtils. Fix NumberFormatException. Allow null values for exp. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch47-lang-7_GenProg_PatchNaturalnessYe$$Delete unused patch. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. fix a typo in the code. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch9-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix e3c032e032b1. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch49-lang-7_GenProg_PatchNaturalnessYe$$E3C - 11674 Fix too many for an int. Fix E3C. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch22-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032b1. Fix NPE in GenProg_Defects4J_Lang_7. Added patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch25-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for 0x digits. Fix NumberFormatException. Allow null values for exp. Ignore undefined fields in GenProg_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch13-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for 0x digits. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch14-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix NumberFormatException. Fix e3c032e032c0. Fix E3C. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch50-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch57-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. fix the build. fixed formatting. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch32-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix NumberFormatException. formatting fix. fix a bug in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch35-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch56-lang-7_GenProg_PatchNaturalnessYe$$revert accidently change. Delete old and unused local variable. Fix NumberFormatException. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch34-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for hex digits. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch33-lang-7_GenProg_PatchNaturalnessYe$$Eliminate negative hex digits in StringUtils. Eliminate more flakiness in NumberUtils. Allow null values for exp. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch11-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. fix the build. revert accidently change. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch29-lang-7_GenProg_PatchNaturalnessYe$$Ignore signs for 0x digits. Fix NumberFormatException. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch20-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. fix the build. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch18-lang-7_GenProg_PatchNaturalnessYe$$Eliminate the hex digits from the beginning of a string. Fix NumberFormatExceptions. Allow null values for exp. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch27-lang-7_GenProg_PatchNaturalnessYe$$Fix a bug in NumberUtils. Fix NumberFormatException. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch42-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix NPE in DateUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch45-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Improve patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch19-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Delete old definition file. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch26-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Eliminate more flakiness in NumberUtils. Allow null values for exp. fix the build. Added patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch21-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. Fix erroneous error in NumberUtils. Fix E3C. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch28-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Allow null values for exp. Eliminate trailing comma in NumberUtils . createDouble ( ). Added patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch17-lang-7_GenProg_PatchNaturalnessYe$$Eliminate the fix of the merge conflict in NumberUtils. Fix NumberFormatException. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch10-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. formatting fixes. Eliminate trailing comma in NumberUtils . createDouble ( ). Added patch for E3E. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch44-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Fix NumberFormatException. fix the build. Fix NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch4-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused local variable. Added patch for StringUtils . createDouble ( String ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch43-lang-7_GenProg_PatchNaturalnessYe$$Delete old and unused patch. Fix NumberFormatException. fix the build. Fix NPE in NumberUtils. Added patch for E3E. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Kali_PatchNaturalnessYe$$Revert previous patch. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Kali_PatchNaturalnessYe$$Fix error in last commit. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch120-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Added throw exception if index < 0. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch36-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. Fix # 1862. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch127-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch31-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch118-chart-1_Arja_PatchNaturalnessYe$$remove deprecated fireChangeEvent. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch111-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch38-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1796. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch116-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch129-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Add a note that the datasets are no longer used .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch189-chart-1_Arja_PatchNaturalnessYe$$Fix chart otp .. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch142-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. Fix previous patch. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch54-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch98-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch145-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. @@ 1355 removed redundant call. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch53-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch65-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch91-chart-1_Arja_PatchNaturalnessYe$$Fix category plot annoyances. Fix issue with wrong fireChangeEvent. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch187-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed redundant call. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch96-chart-1_Arja_PatchNaturalnessYe$$Remove redundant code. Fix Eclipse. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch180-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch62-chart-1_Arja_PatchNaturalnessYe$$Fix issue with chart ' s foreground domain marker removal. Fix crosshair index for chart 1 .. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch174-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch117-chart-1_Arja_PatchNaturalnessYe$$Fix pull request. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch128-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch110-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed dataset . addChangeListener ( ). Fix issue with previous pull request .. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch39-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix minor axes disappearing on histogram select. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch126-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. added datasetChanged ( ) line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch30-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch119-chart-1_Arja_PatchNaturalnessYe$$Fix null dataset crash. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch121-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1862. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch37-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix CategoryPlot not clearing the foreground domain marker map when it is not null .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch63-chart-1_Arja_PatchNaturalnessYe$$Fix issue with not - so - deprecated API in CategoryPlot. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch175-chart-1_Arja_PatchNaturalnessYe$$Fix issue with new domain crosshair plot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch97-chart-1_Arja_PatchNaturalnessYe$$Fix chart 1 .. Fix rangeGridlineStroke option not being used .. Fix pull from previous commit , fixes # 1862. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch181-chart-1_Arja_PatchNaturalnessYe$$Avoid NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch186-chart-1_Arja_PatchNaturalnessYe$$remove wrong fireChangeEvent. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch64-chart-1_Arja_PatchNaturalnessYe$$Fix category axis location for 1 . 6 . x. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch172-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Added datasetChanged ( ) to CategoryPlot. Remove a line if dataset is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch99-chart-1_Arja_PatchNaturalnessYe$$Fix category axes. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch52-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1862. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch188-chart-1_Arja_PatchNaturalnessYe$$remove redundant code. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch143-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch55-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix category plot annoyances. Removed redundant line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch203-chart-1_Arja_PatchNaturalnessYe$$Fix null column count in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch204-chart-1_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 2019. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch205-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1862. Fix # 1358. Fix crosshair dataset index issue. Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch202-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Added throw exception if orientation is null. Remove redundant clearDomainMarkers method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch161-chart-1_Arja_PatchNaturalnessYe$$Removed redundant line. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch77-chart-1_Arja_PatchNaturalnessYe$$Fix # 1349. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch195-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch83-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch48-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with previous call. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch192-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch84-chart-1_Arja_PatchNaturalnessYe$$Fix category renderer index calculation .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch166-chart-1_Arja_PatchNaturalnessYe$$Added patch for addValue ( ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch70-chart-1_Arja_PatchNaturalnessYe$$Fix - add listener to existing renderer. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch159-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Removed redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch46-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with wrong data set range axis mapping. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch150-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 183. Fix pull from previous commit , fixes # 1227. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch79-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch41-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix addChangeListener. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch157-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Fix Eclipse. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch168-chart-1_Arja_PatchNaturalnessYe$$Fix category axis selection bug. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch103-chart-1_Arja_PatchNaturalnessYe$$Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch104-chart-1_Arja_PatchNaturalnessYe$$Add listener to CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch24-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix parent month / year axes NPE. added datasetChanged ( ) to CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch132-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch23-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch135-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch40-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Add category dataset patch. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch156-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix 1355. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch169-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch47-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. remove redundant code. Fix issue with wrong fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch151-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Throw an exception if orientation is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch78-chart-1_Arja_PatchNaturalnessYe$$Fix problem with reconfigurable range axes. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch71-chart-1_Arja_PatchNaturalnessYe$$Updated self . orientation to use VERTICAL .. Fix crosshair dataset index .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch193-chart-1_Arja_PatchNaturalnessYe$$added datasetChanged ( ) to getDataset ( index ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch85-chart-1_Arja_PatchNaturalnessYe$$Fix 1349. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch158-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. @@ 1355 removed dataset . addChangeListener ( ). Fix minor issue with CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch194-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch160-chart-1_Arja_PatchNaturalnessYe$$Fix category plot annoyances. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch76-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed redundant call. Fix - add listener to existing renderer. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch49-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch22-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix build. reset rangeCrosshairValue after each renderer is added. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch134-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. @@ 1355 removed redundant call. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch25-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch133-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix crosshair dataset index issue. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch105-chart-1_Arja_PatchNaturalnessYe$$Fix category plot annoyances. Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch102-chart-1_Arja_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch179-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch50-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1336. @@ 1356 don ' t add a listener to the dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch68-chart-1_Arja_PatchNaturalnessYe$$Fix a minor issue with chart 1 .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch141-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch57-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Added datasetChanged ( ) to CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch148-chart-1_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 2019. remove deprecated call to fireChangeEvent ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch95-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch183-chart-1_Arja_PatchNaturalnessYe$$Fix chart 1 .. Fix category axes. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch61-chart-1_Arja_PatchNaturalnessYe$$Fix issue with CategoryPlot . setDataset ( ). Fix Eclipse. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch59-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1433. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch66-chart-1_Arja_PatchNaturalnessYe$$Fix pull request. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch170-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch92-chart-1_Arja_PatchNaturalnessYe$$Removed redundant line. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch124-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Add a listener to CategoryPlot. Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch32-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Remove over - aggressive dataset listener. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch123-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1336. @@ 1356 don ' t add a listener to the dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch35-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix category datasets. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch115-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch112-chart-1_Arja_PatchNaturalnessYe$$remove redundant code. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch58-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Remove redundant code. Fix category datasets. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch93-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch185-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch67-chart-1_Arja_PatchNaturalnessYe$$Fix minor axes disappearing on histogram select. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch171-chart-1_Arja_PatchNaturalnessYe$$Fix problem with resampling. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch149-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1349. Fix category plot weight changes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch60-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch176-chart-1_Arja_PatchNaturalnessYe$$Fix pull request. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch182-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke option not being used .. Fix getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch69-chart-1_Arja_PatchNaturalnessYe$$Fix crosshair dataset index .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch140-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix pull request. Fix issue with range crosshair. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch178-chart-1_Arja_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch147-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Fix a bug in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch51-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1796. Fix # 1337. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch113-chart-1_Arja_PatchNaturalnessYe$$Fix category axes. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch114-chart-1_Arja_PatchNaturalnessYe$$Fix category axes selection. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch122-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch125-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Add category dataset patch. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch207-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch200-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch209-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix category axes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch208-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix a bug in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch201-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix issue with wrong fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch206-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. Fix range zero baseline paint. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch138-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with new category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch107-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed redundant call. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch29-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix category mouse positionning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch100-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke. Fix category axis selection bug. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch109-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch136-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fixed a bug with CategoryPlot . setDataset ( int , CategoryDataset ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch27-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Add category dataset patch. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch131-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with CategoryPlot . setDataset ( ). Fix minor issue with CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch191-chart-1_Arja_PatchNaturalnessYe$$Fix problem with reconfigurable range axes. Fix category data renderer bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch87-chart-1_Arja_PatchNaturalnessYe$$Fix # 1349. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch73-chart-1_Arja_PatchNaturalnessYe$$remove redundant code. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch162-chart-1_Arja_PatchNaturalnessYe$$Avoid NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch74-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch80-chart-1_Arja_PatchNaturalnessYe$$Fix category plot range axis positioning. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch42-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix range zero baseline paint. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch154-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch89-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix pull from previous commit , fixes # 1265. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch45-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. remove deprecated call to fireChangeEvent ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch153-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. throw exception if index < 0. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch26-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch130-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1887. Fix minor axes disappearing on histogram select. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch108-chart-1_Arja_PatchNaturalnessYe$$Fix Eclipse. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch21-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Added throw exception if orientation is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch137-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch28-chart-1_Arja_PatchNaturalnessYe$$Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch101-chart-1_Arja_PatchNaturalnessYe$$Add category dataset patch. Fix category plot background for phones. Added datasetChanged ( ) to CategoryPlot. Remove a line if dataset is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch139-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix category plot annoyances. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch106-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch44-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix crosshair dataset index. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch152-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1796. @@ 1356 don ' t add a listener to the dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch199-chart-1_Arja_PatchNaturalnessYe$$Fix # 183. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch43-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix chart 1 .. Fix minor bug in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch155-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with wrong fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch88-chart-1_Arja_PatchNaturalnessYe$$Fix # 1336. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch197-chart-1_Arja_PatchNaturalnessYe$$Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Added datasetChanged ( ) to CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch81-chart-1_Arja_PatchNaturalnessYe$$Fix # 183. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch163-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke. Removed redundant line. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch164-chart-1_Arja_PatchNaturalnessYe$$Fix chart 1 .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch72-chart-1_Arja_PatchNaturalnessYe$$Add background annotations to defects plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch190-chart-1_Arja_PatchNaturalnessYe$$Set default background paint on category plot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch86-chart-1_Arja_PatchNaturalnessYe$$Fix minor issue with CategoryPlot. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch120-chart-12_Arja_PatchNaturalnessYe$$Add a notification to the legend. Updated chart with data from previous commit .. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch31-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with JFreeChart . title = title. Fix chart refresh error. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch53-chart-12_Arja_PatchNaturalnessYe$$Fix bug. Fix # 1862. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch117-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix issue with JFreeChart . title = title. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch99-chart-12_Arja_PatchNaturalnessYe$$Fix chart source. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch144-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix 1491 chart title overlay not being removed .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch55-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . borderVisible = false. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch195-chart-12_Arja_PatchNaturalnessYe$$Fix chart not removed listener. Added plot listener to array. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch79-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with JFreeChart . title = title. Fix Legends4J_Chart_12. Fix NPE in chart. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch157-chart-12_Arja_PatchNaturalnessYe$$Fix issue with legends not being removed. Fix chart not removed listener. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch168-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . title = title. Fix chart after subtitle removal. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch103-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix title disappearing on histogram select. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch40-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Improved ' removeLegend ' method. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch169-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with legends not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch47-chart-12_Arja_PatchNaturalnessYe$$Fix chart label positionning. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch78-chart-12_Arja_PatchNaturalnessYe$$Fix chart source. Remove redundant call to fireChartChanged ( ). I don ' t really see a justification for doing a chart change in JFreeChart. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch71-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . setTitle ( TextTitle ). Added plot listener to the list of listeners. Improved method to allow for listener registration in AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch193-chart-12_Arja_PatchNaturalnessYe$$Fix chart not removed listener. Fix fireChartChanged ( ). Fix bug. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch194-chart-12_Arja_PatchNaturalnessYe$$Fix 1410 chart issue. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch49-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Added a plot listener to the legend. Added plot listener to array. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch25-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix bug in chart 12. Fix fireChartChanged ( ). Added plot listener to array. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch177-chart-12_Arja_PatchNaturalnessYe$$Fix chart border in DL. Fix chart 12. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch35-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with chart not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch93-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix bug in chart 12. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch185-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Updated chart with new data. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch149-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener registration in AbstractDataset. Fix pull from defaults. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch56-chart-12_Arja_PatchNaturalnessYe$$Improved method to check if a listener is added to the list. Fix bug. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch138-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Updated chart with new data. Added throw exception if plot is null. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch100-chart-12_Arja_PatchNaturalnessYe$$Fix chart 12. Added plot listener to array. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch131-chart-12_Arja_PatchNaturalnessYe$$Improved method to check if a listener is added to the list. Fix issue with JFreeChart . title = title. Fix issue with chart not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch73-chart-12_Arja_PatchNaturalnessYe$$Added notification to subtitles .. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch162-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix issue with JFreeChart . setTitle ( TextTitle ). Fix issue with chart not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch196-chart-12_Arja_PatchNaturalnessYe$$Fix bug in chart 12. Fix chart not removed listener. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch80-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . title = title. Fix # 183. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch42-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener registration in AbstractDataset. Fix title listener for 12 .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch154-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix pull from defaults .. Fix IndexOutOfBoundsException in JFreeChart. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch45-chart-12_Arja_PatchNaturalnessYe$$Fix trouble with legends. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch86-chart-12_Arja_PatchNaturalnessYe$$Fix chart after subtitle removal. Added plot listener to set background paint. Added plot listener to array. Improved method to allow for listener removal from AbstractDataset. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch8-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Set nullText before deleting characters. remove startIndex. StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch6-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Fix NPE triggered by nullText .. StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch15-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch12-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Fix StrBuilder . length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch7-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. StrBuilder . deleteFirst ( ) can delete empty strings if buffer . length == 0. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch9-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Add patch for StringBuilder . appendNull ( ). StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch13-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. remove startIndex. StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch14-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Fix buffer handling. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch11-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Add more ensureCapacity .. StrBuilder . length ( ) now uses size - > int. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch16-lang-61_Arja_PatchNaturalnessYe$$set nullText to null on delete ( ). Add missing append ( ) patch. Fix buffer handling. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch18-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. set nullText if it is not null. StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch5-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. StrBuilder . deleteFirst ( ) now uses char [] instead of char [ ] .. StrBuilder . length - strLen = size ; patched. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch2-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. StrBuilder . deleteFirst ( ) uses buffer . length - > string . length ( ). StrBuilder patched length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch17-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Add more ensureCapacity .. StrBuilder . length - strLen = size ; patched. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch10-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. StrBuilder . length - strLen = size ; patched. $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch3-lang-61_Arja_PatchNaturalnessYe$$Fix StrBuilder . length ( ). $$0
lang-61$$StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.$$StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114) 	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188) 	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256) 	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339) 	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 	at java.lang.reflect.Method.invoke(Method.java:585) 	at junit.framework.TestCase.runTest(TestCase.java:154) 	at junit.framework.TestCase.runBare(TestCase.java:127) 	at junit.framework.TestResult 1.protect(TestResult.java:106) 	at junit.framework.TestResult.runProtected(TestResult.java:124) 	at junit.framework.TestResult.run(TestResult.java:109) 	at junit.framework.TestCase.run(TestCase.java:118) 	at junit.framework.TestSuite.runTest(TestSuite.java:208) 	at junit.framework.TestSuite.run(TestSuite.java:203) 	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)$$patch4-lang-61_Arja_PatchNaturalnessYe$$Add missing append ( ) patch. Set nullText before deleting characters. StrBuilder patched length ( ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch36-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses CAPACITY rather than arrayCopy. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch31-lang-59_Arja_PatchNaturalnessYe$$Add one more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch38-lang-59_Arja_PatchNaturalnessYe$$Fix null string handling. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch54-lang-59_Arja_PatchNaturalnessYe$$added ensureCapacity ( size + 1 ) for appendFixedWidthPadRight. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch53-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) uses new array constructor. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch65-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch62-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) now uses char [] as the indexing array is. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch39-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses char[] instead of char[] because it is not compatible. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch30-lang-59_Arja_PatchNaturalnessYe$$Add one more ensureCapacity ( ) call. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch37-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch63-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch64-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch52-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t create arrayCopy ( ) .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch55-lang-59_Arja_PatchNaturalnessYe$$StrBuilder patched ( changed ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch77-lang-59_Arja_PatchNaturalnessYe$$Fix the build .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch83-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch48-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch84-lang-59_Arja_PatchNaturalnessYe$$Add empty buffer for appendFixedWidthPadRight. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch70-lang-59_Arja_PatchNaturalnessYe$$Fix an issue with the appendFixedWidthPadRight method where the object is null .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch46-lang-59_Arja_PatchNaturalnessYe$$added expanded array structure. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch79-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should reset the StringBuilder and not use the array when creating the string. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch41-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set nullText field. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch15-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses empty array for easier building. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch12-lang-59_Arja_PatchNaturalnessYe$$Reset nullText if we have text .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch24-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch23-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch40-lang-59_Arja_PatchNaturalnessYe$$Fix an issue with null string builders .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch47-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses new array constructor. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch78-lang-59_Arja_PatchNaturalnessYe$$Fix nullText setting .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch71-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses char [] instead of char [ ] for the append of. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch85-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch9-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch82-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch76-lang-59_Arja_PatchNaturalnessYe$$Fix null string handling. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch49-lang-59_Arja_PatchNaturalnessYe$$Reset line endings. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch22-lang-59_Arja_PatchNaturalnessYe$$Fix NPE in StrBuilder . appendFixedWidthPadRight. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch25-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set nullText properly. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch13-lang-59_Arja_PatchNaturalnessYe$$Add more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch14-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch50-lang-59_Arja_PatchNaturalnessYe$$Add empty array if we can ' t append string with spaces .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch68-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set nullText properly. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch57-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch61-lang-59_Arja_PatchNaturalnessYe$$Add null check in StrBuilder. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch59-lang-59_Arja_PatchNaturalnessYe$$Fix null string handling. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch66-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) uses new char [] , not nullText. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch32-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch35-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch58-lang-59_Arja_PatchNaturalnessYe$$Add 4 more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch67-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set nullText properly. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch60-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set the nullText field. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch69-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch56-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch51-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should use a char array initially. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch34-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should use a char array initially. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch33-lang-59_Arja_PatchNaturalnessYe$$Add one more ensureCapacity ( ) call. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch11-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses buffer . length - > string . length. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch29-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set the nullText field. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch16-lang-59_Arja_PatchNaturalnessYe$$Fix buffer issue. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch20-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set nullText field. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch18-lang-59_Arja_PatchNaturalnessYe$$Fix ensureCapacity ( ) for string builders. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch27-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses a char array initially. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch73-lang-59_Arja_PatchNaturalnessYe$$Add one more ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch74-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t overwrite existing buffer .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch80-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight ( ) didn ' t set nullText properly. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch42-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses new array constructor. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch45-lang-59_Arja_PatchNaturalnessYe$$StrBuilder patched ( initially empty ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch19-lang-59_Arja_PatchNaturalnessYe$$StrBuilder . appendFixedWidthPadRight uses stringBuilder , but string is not expanding the buffer ;. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch26-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch21-lang-59_Arja_PatchNaturalnessYe$$StrBuilder patched ( initially empty ). $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch28-lang-59_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch17-lang-59_Arja_PatchNaturalnessYe$$Add more space for string builders. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch10-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should reset the array if we add null text , otherwise it will throw an NPE. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch44-lang-59_Arja_PatchNaturalnessYe$$StrBuilder should use the newLine setting for each builder object. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch43-lang-59_Arja_PatchNaturalnessYe$$Add null string if possible. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch81-lang-59_Arja_PatchNaturalnessYe$$Add one more ensureCapacity ( ) call. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch75-lang-59_Arja_PatchNaturalnessYe$$Fix lost ensureCapacity .. $$0
lang-59$$Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException$$There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.$$patch72-lang-59_Arja_PatchNaturalnessYe$$Fix the bug in StrBuilder . appendFixedWidthPadRight. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch36-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). FixDateFormat patch .. Fix merge issues. Fix file format change. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch31-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix compile error. FixDateFormat pattern not being null. Add locale override for getDateTimeInstance ( ). Fix year month format. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch118-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch111-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix timeZone argument in FastDateFormat. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch38-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch116-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove cached value. Fix ISO - 8859 - missing patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch54-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix cache update for date / time pattern. Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch98-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Allow null pattern for date time formats. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch53-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix ISO 8601 date format instance cache logic. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch65-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch91-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix ISO - 88601 date format definition. Fix getDateTimeInstance ( ). Fix override of default pattern for calendars. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch96-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix cached object in case of erroneous override. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch62-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch117-lang-50_Arja_PatchNaturalnessYe$$Put back dateTimeInstanceCache on top level. Fix getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch110-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. FixDateFormat pattern not being null. Fix merge issue. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch39-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix a bug in dateFormat. Fix week label in ISO 8601 format. Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch30-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix week ending error. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch37-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch63-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Fix cached object in case of erroneous override. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch97-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch90-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch64-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix cached object .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch99-lang-50_Arja_PatchNaturalnessYe$$Fix cache hit. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch52-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix merge issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch55-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Remove unnecessary assignment. Allow null pattern for date time formats. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch77-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch83-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). fixed compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch48-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Remove cached value. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch84-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch46-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Remove unnecessary code. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch79-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). Add timeZone to dateTimeInstanceCache. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch41-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. fixed timeZone = TimeZone . getDefault ( ) ;. Fix broken patch. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch103-lang-50_Arja_PatchNaturalnessYe$$Fix cached date / time object in case of error. Fix cached date format instance in case of erroneous override. Fix month indexing. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch15-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Allow null pattern to be cached in overriden format implementation. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch104-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch12-lang-50_Arja_PatchNaturalnessYe$$Fix cache update for month / year centuries. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch24-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix put line. Fix merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch23-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add timeZone argument. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch40-lang-50_Arja_PatchNaturalnessYe$$fixedDateFormat patch. Added patch for dateTime instance cache. Fix a bug in dateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch47-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix object equality in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch78-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch71-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix typo. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch85-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add timeZone setting for cache key. Allow null pattern for date time formats. Add a throw inside Pair. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch82-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix hash code for string equality. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch76-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix getLocale. fixed timeZone = TimeZone . getDefault ( ) ;. Fix pull request .. Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch49-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix month indexing. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch22-lang-50_Arja_PatchNaturalnessYe$$Add timeZone argument to cache file. Fix getDateTimeInstance ( ). Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch25-lang-50_Arja_PatchNaturalnessYe$$Fix timeZone cache logic. Add locale override for getDateTimeInstance ( ). Fix pull request .. Fix checkstyle issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch105-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Add timeZone argument. Fix checkstyle issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch13-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix getDateTimeInstance ( ) with locale null. Fix pull request .. Add a throw in case of same object .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch102-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch14-lang-50_Arja_PatchNaturalnessYe$$Fix cached date / time object in case of locale override. Fix getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch50-lang-50_Arja_PatchNaturalnessYe$$Fix date instance cache patch. Remove unnecessary assignment. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch68-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix merge issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch57-lang-50_Arja_PatchNaturalnessYe$$FixDateFormat pattern not found in cache. Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch95-lang-50_Arja_PatchNaturalnessYe$$fixedDateInstanceCache ( ) ;. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch61-lang-50_Arja_PatchNaturalnessYe$$Put back dateTimeInstanceCache + patch. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch59-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix ISO 8601 date format cache update position. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch66-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix ISO 8601 date format cache update .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch92-lang-50_Arja_PatchNaturalnessYe$$Fix date / time cache patch. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch32-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. FixDateObjectTest. Fix hash code for string equality. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch35-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch115-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Add locale override for getDateTimeInstance ( ). FixDateFormat patch .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch112-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix cached date format instance in case of erroneous locale override. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch58-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix cached locale for Persian and Urdu language maps .. Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch93-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix broken patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch67-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Add timeZone argument. Remove redundant patch. Fix merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch60-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Add timeZone argument. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch94-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix null locale argument in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch69-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix merge issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch56-lang-50_Arja_PatchNaturalnessYe$$FixDateFormat patch .. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch51-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. FixDateFormat pattern not being null. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch113-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Remove unused locale setting. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch114-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix compile error. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch34-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix put patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch33-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch107-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove unnecessary assignment. Allow null pattern for date time formats. Fix object type in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch29-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Add a throw in case of same object .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch100-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix pull request .. Fix ISO - 8859 - missing patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch16-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Remove redundant patch. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch109-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix getLocale. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch20-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Add locale override for getDateTimeInstance ( ). Fix ISO 8601 date format cache update .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch18-lang-50_Arja_PatchNaturalnessYe$$Fix cache hit. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch27-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix unpadded month in year field. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch87-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Remove unnecessary assignment. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch73-lang-50_Arja_PatchNaturalnessYe$$Fix date instance cache patch. Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch74-lang-50_Arja_PatchNaturalnessYe$$Fix cache hit. Fix getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch80-lang-50_Arja_PatchNaturalnessYe$$Add timeZone to dateTimeInstanceCache. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch42-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Remove unnecessary copy of DateTimeFormat instance cache key. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch5-lang-50_Arja_PatchNaturalnessYe$$Added fixedDateTimeInstanceCache + patch. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). Fix a merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch89-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. FixDateFormat patch .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch45-lang-50_Arja_PatchNaturalnessYe$$Fix DateTimeFormat instance cache logic. Allow null pattern for date time formats. Fix month indexing. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch19-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch26-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix override of pattern in configuration file. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch108-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix override of default pattern for calendars. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch21-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Reset timeZone to TimeZone . getDefault ( ) for parsing Improved performance. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch28-lang-50_Arja_PatchNaturalnessYe$$Fix date instance cache patch. Fix compile error. Fix merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch101-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch17-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. FixDateFormat pattern not being null. Allow null pattern for date time formats. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch106-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). FixDateFormat patch .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch44-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix compile error. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch43-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix a bug in dateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch88-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). FixDateTimeInstanceCache put in a place that doesn ' t have a default locale or timeZone. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch81-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix cached date format instance in case of errant ISO 639 - 2 locale mapping .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch75-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch72-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch86-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix merge conflict in FastDateFormat. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch36-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch127-lang-51_Arja_PatchNaturalnessYe$$fixed an issue with BooleanUtils . toBoolean ( ). Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch31-lang-51_Arja_PatchNaturalnessYe$$Add patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch118-lang-51_Arja_PatchNaturalnessYe$$Removed patch for BooleanUtils . toBoolean ( ) .. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch111-lang-51_Arja_PatchNaturalnessYe$$lowercased string handling. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch116-lang-51_Arja_PatchNaturalnessYe$$Fixed null string handling. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch129-lang-51_Arja_PatchNaturalnessYe$$remove patch for true / false match. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch142-lang-51_Arja_PatchNaturalnessYe$$Added missing case in StringUtils. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch54-lang-51_Arja_PatchNaturalnessYe$$add null check. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch145-lang-51_Arja_PatchNaturalnessYe$$Added booleanUtils . equalsIgnoreCase ( ). lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch53-lang-51_Arja_PatchNaturalnessYe$$add null check. toLowerCase ( ) removed previous patch. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch65-lang-51_Arja_PatchNaturalnessYe$$improve performance for strings with spaces in the code. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch91-lang-51_Arja_PatchNaturalnessYe$$Remove unnecessary booleanUtils patch. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch62-lang-51_Arja_PatchNaturalnessYe$$remove patched / removed unnecessary boolean utils class. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch117-lang-51_Arja_PatchNaturalnessYe$$remove patch. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch128-lang-51_Arja_PatchNaturalnessYe$$fixed null string handling. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch110-lang-51_Arja_PatchNaturalnessYe$$BooleanUtils patch for < = >. Removed patch for "" true "" and "" off "" .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch39-lang-51_Arja_PatchNaturalnessYe$$Updated toBoolean ( ). Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch30-lang-51_Arja_PatchNaturalnessYe$$remove patched code. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch119-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. remove null check. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch121-lang-51_Arja_PatchNaturalnessYe$$improve performance for null strings. removed patch for year in BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch37-lang-51_Arja_PatchNaturalnessYe$$Add case for string comparison. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch63-lang-51_Arja_PatchNaturalnessYe$$improve performance for empty strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch97-lang-51_Arja_PatchNaturalnessYe$$Fixed a bug in BooleanUtils. Remove over - old boolean utils pattern. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch90-lang-51_Arja_PatchNaturalnessYe$$fixed StringUtils . equalsIgnoreCase. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch64-lang-51_Arja_PatchNaturalnessYe$$Updated to match String class .. remove patched boolean utils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch99-lang-51_Arja_PatchNaturalnessYe$$removed patch for Y = > E. lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch52-lang-51_Arja_PatchNaturalnessYe$$removed patch for Y = > E. lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch143-lang-51_Arja_PatchNaturalnessYe$$Removed patch from BooleanUtils. remove patch for BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch77-lang-51_Arja_PatchNaturalnessYe$$lowercased string comparisons. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch83-lang-51_Arja_PatchNaturalnessYe$$improve performance for strings with length > = 647. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch48-lang-51_Arja_PatchNaturalnessYe$$Remove patched code. case insensitive match for "" true "" to false """. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch84-lang-51_Arja_PatchNaturalnessYe$$match regex. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch70-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch159-lang-51_Arja_PatchNaturalnessYe$$Remove patch for year in BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch46-lang-51_Arja_PatchNaturalnessYe$$Optimize equalsIgnoreCase. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch150-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch79-lang-51_Arja_PatchNaturalnessYe$$fixed null string handling. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch41-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch157-lang-51_Arja_PatchNaturalnessYe$$add patch for true in boolean utils. Removed patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch103-lang-51_Arja_PatchNaturalnessYe$$improve matching of empty strings. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch104-lang-51_Arja_PatchNaturalnessYe$$removed patch for year in BooleanUtils. IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch24-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch132-lang-51_Arja_PatchNaturalnessYe$$fixed StringUtils . equalsIgnoreCase. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch23-lang-51_Arja_PatchNaturalnessYe$$Removed an obsolete equalsIgnoreCase method. Add an exception check for isEmpty ( String ). Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch40-lang-51_Arja_PatchNaturalnessYe$$add patch for null string handling. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch156-lang-51_Arja_PatchNaturalnessYe$$removed empty string handling. lowercased string handling. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch47-lang-51_Arja_PatchNaturalnessYe$$Add an empty line check. Remove patched code. Removed patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch151-lang-51_Arja_PatchNaturalnessYe$$toLowerCase the y string. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch78-lang-51_Arja_PatchNaturalnessYe$$Add case for string ' s equalsIgnoreCase. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch85-lang-51_Arja_PatchNaturalnessYe$$BooleanUtils now uses empty string literals. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch160-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch76-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch49-lang-51_Arja_PatchNaturalnessYe$$ignore isDigit for boolean equals. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch134-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch25-lang-51_Arja_PatchNaturalnessYe$$Added ignore case for "" off "" and "" no "" .. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch102-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch146-lang-51_Arja_PatchNaturalnessYe$$improve performance for strings with length > = 647. Modified patch for StringUtils . equalsIgnoreCase. remove patched for last char. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch68-lang-51_Arja_PatchNaturalnessYe$$Add an exception check for isEmpty ( String ). lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch141-lang-51_Arja_PatchNaturalnessYe$$lowercased. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch57-lang-51_Arja_PatchNaturalnessYe$$Added missing case in StringUtils. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch148-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. patched BooleanUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch61-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. Remove over - aggressive patching of boolean utils. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch59-lang-51_Arja_PatchNaturalnessYe$$IgnoreCase Strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch66-lang-51_Arja_PatchNaturalnessYe$$lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch92-lang-51_Arja_PatchNaturalnessYe$$add patch for null string comparison. lowercased string comparisons. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch124-lang-51_Arja_PatchNaturalnessYe$$add patch for null string handling. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch123-lang-51_Arja_PatchNaturalnessYe$$Added patch for "" off "" and "" no "" .. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch35-lang-51_Arja_PatchNaturalnessYe$$add null check. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch115-lang-51_Arja_PatchNaturalnessYe$$strtolower the string. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch93-lang-51_Arja_PatchNaturalnessYe$$remove patch from source code. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch67-lang-51_Arja_PatchNaturalnessYe$$Corrected a typo in StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch149-lang-51_Arja_PatchNaturalnessYe$$removed patch for year in BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch60-lang-51_Arja_PatchNaturalnessYe$$lowercased string handling. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch94-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. Added missing case in StringUtils. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch69-lang-51_Arja_PatchNaturalnessYe$$isEmpty ( ) = > false. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch140-lang-51_Arja_PatchNaturalnessYe$$Added missing case in BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch56-lang-51_Arja_PatchNaturalnessYe$$Put back previous patch. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch147-lang-51_Arja_PatchNaturalnessYe$$improve performance for null string matches , note the patch for more readable strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch51-lang-51_Arja_PatchNaturalnessYe$$Removed patch from BooleanUtils. lowercased. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch113-lang-51_Arja_PatchNaturalnessYe$$patched by accident. removed patch for year in BooleanUtils. Removed patch for "" true "" and "" off "" .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch114-lang-51_Arja_PatchNaturalnessYe$$strtolower the string. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch34-lang-51_Arja_PatchNaturalnessYe$$Add an exception if the String is empty ( I am looking at you Dave ). toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch125-lang-51_Arja_PatchNaturalnessYe$$modified BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch33-lang-51_Arja_PatchNaturalnessYe$$lowercased string comparisons. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch138-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ) removed previous patch. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch107-lang-51_Arja_PatchNaturalnessYe$$Add exception if String is empty. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch100-lang-51_Arja_PatchNaturalnessYe$$Allow null string input. lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch136-lang-51_Arja_PatchNaturalnessYe$$lowercased string comparisons. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch18-lang-51_Arja_PatchNaturalnessYe$$Added missing case in StringUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch27-lang-51_Arja_PatchNaturalnessYe$$strtolower the string. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch131-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch73-lang-51_Arja_PatchNaturalnessYe$$Add missing case. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch80-lang-51_Arja_PatchNaturalnessYe$$Added patch for "" true "" in StringUtils. lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch42-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. removed patched / removed unnecessary booleanUtils properties. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch154-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. lowercased string comparisons. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch45-lang-51_Arja_PatchNaturalnessYe$$IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch153-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ) matches any string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch19-lang-51_Arja_PatchNaturalnessYe$$add null check. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch130-lang-51_Arja_PatchNaturalnessYe$$IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch108-lang-51_Arja_PatchNaturalnessYe$$fixed String . equalsIgnoreCase. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch21-lang-51_Arja_PatchNaturalnessYe$$fixed null string handling. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch137-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch28-lang-51_Arja_PatchNaturalnessYe$$I had left it harwired to true , but it was still possible to check string equality. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch101-lang-51_Arja_PatchNaturalnessYe$$removed null check. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch139-lang-51_Arja_PatchNaturalnessYe$$improve performance for null / empty strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch106-lang-51_Arja_PatchNaturalnessYe$$remove patch for BooleanUtils . equals. lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch44-lang-51_Arja_PatchNaturalnessYe$$Add case for string ' s equalsIgnoreCase. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch152-lang-51_Arja_PatchNaturalnessYe$$lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch43-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch155-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch88-lang-51_Arja_PatchNaturalnessYe$$add null check. IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch81-lang-51_Arja_PatchNaturalnessYe$$missing patch for null string match. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch72-lang-51_Arja_PatchNaturalnessYe$$Allow null string input. Removed patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch86-lang-51_Arja_PatchNaturalnessYe$$fixed StringUtils . equalsIgnoreCase. lowercased string to match patch. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch36-lang-58_Arja_PatchNaturalnessYe$$try StringUtils . isDigit. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch31-lang-58_Arja_PatchNaturalnessYe$$Fix regex processing. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch38-lang-58_Arja_PatchNaturalnessYe$$don ' t throw NumberFormatException if decPos < decPos. I had left it harwired to say that it was a valid number .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch39-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. start with - -. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch30-lang-58_Arja_PatchNaturalnessYe$$Add a missing patch. I had left it harwired to null .. don ' t check isEmpty ( str ) , because it seems we ' re trying to understand why. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch37-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. don ' t check isEmpty ( str ) in StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch8-lang-58_Arja_PatchNaturalnessYe$$remove exp = null ; fix for patched code. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch46-lang-58_Arja_PatchNaturalnessYe$$Allow null string input. Add an error if the string is blank .. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch6-lang-58_Arja_PatchNaturalnessYe$$Add the missing throw exception. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch41-lang-58_Arja_PatchNaturalnessYe$$Remove exp = null in numberUtils. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch15-lang-58_Arja_PatchNaturalnessYe$$Fix NPE. don ' t check isEmpty ( str ) in StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch12-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. isEmpty ( str ) fixed NHY - 1342 , fixed NHY - 1342. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch24-lang-58_Arja_PatchNaturalnessYe$$fixed String . isBlank ( ). Add a patch for formatting numbers in Avro settings. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch23-lang-58_Arja_PatchNaturalnessYe$$fix a numeric type request. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch40-lang-58_Arja_PatchNaturalnessYe$$Allow null string input. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch7-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. remove fix. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch9-lang-58_Arja_PatchNaturalnessYe$$Allow null string input. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch22-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. don ' t check isEmpty ( str ) in StringUtils. Add an error if a blank string is not a valid number. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch25-lang-58_Arja_PatchNaturalnessYe$$Remove old and unused method. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch13-lang-58_Arja_PatchNaturalnessYe$$Allow string to be parsed as a literal int. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch14-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. add null check. add isDigit to StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch32-lang-58_Arja_PatchNaturalnessYe$$fixed String . isBlank ( ). I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch35-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. Allow null to be passed. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch34-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. add null check. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch33-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch11-lang-58_Arja_PatchNaturalnessYe$$Add an error if the string is blank .. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch29-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. Add string isEmpty ( ) to isAllZeros ( ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch16-lang-58_Arja_PatchNaturalnessYe$$Add an exception if the string is null. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch20-lang-58_Arja_PatchNaturalnessYe$$add patch for isDigit. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch18-lang-58_Arja_PatchNaturalnessYe$$Add a missing patch. I had left it harwired to null .. Add a throw statement so that it can be cleaned up by the patcher .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch27-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. isDigits method patched. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch42-lang-58_Arja_PatchNaturalnessYe$$Remove old and unused method. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch5-lang-58_Arja_PatchNaturalnessYe$$Add an error if the string is blank .. don ' t throw NPE at end of definition file. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch45-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. don ' t throw NumberFormatException on isBlank ( string ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch19-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to say that it was a valid number .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch26-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch21-lang-58_Arja_PatchNaturalnessYe$$Add a throw if it is not a valid number. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch28-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to say that it was a valid number .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch17-lang-58_Arja_PatchNaturalnessYe$$Remove old and unused patch. Allow null to be passed in for numberUtils . createBigInteger ( ). start with - -. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch10-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. @ patch_1228 for StringUtils . isDigit. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch44-lang-58_Arja_PatchNaturalnessYe$$Fix 143 potential value error. fixed NHYD fixed. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch43-lang-58_Arja_PatchNaturalnessYe$$fix null string handling. I had left it harwired to null .. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch8-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch6-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( ). Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch15-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( len + 1 ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch12-lang-60_Arja_PatchNaturalnessYe$$reset nullText if it is empty string ( # 1267 ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch23-lang-60_Arja_PatchNaturalnessYe$$reset nullText on deleteFirst ( ). Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch7-lang-60_Arja_PatchNaturalnessYe$$Add more ensureCapacity .. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch9-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( size + 4 ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch22-lang-60_Arja_PatchNaturalnessYe$$Fix ensureCapacity .. Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch13-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( ). Fix buffer size increase. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch14-lang-60_Arja_PatchNaturalnessYe$$Add throw inside if / else .. fixed a small bug. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch11-lang-60_Arja_PatchNaturalnessYe$$Fix ensureCapacity .. Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch16-lang-60_Arja_PatchNaturalnessYe$$Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch20-lang-60_Arja_PatchNaturalnessYe$$Revert previous patch. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch18-lang-60_Arja_PatchNaturalnessYe$$Add missing ensureCapacity .. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch5-lang-60_Arja_PatchNaturalnessYe$$StrBuilder deleteFirst ( ) returns this if the builder is empty .. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch19-lang-60_Arja_PatchNaturalnessYe$$Fix buffer size increase. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch21-lang-60_Arja_PatchNaturalnessYe$$Add patch for nullText builder. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch17-lang-60_Arja_PatchNaturalnessYe$$Add accidently removed backslash. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch10-lang-60_Arja_PatchNaturalnessYe$$Add line separator. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch3-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( len + 1 ) if we have > 0 length. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch4-lang-60_Arja_PatchNaturalnessYe$$Add patch for letter case. Fix buffer size too large. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch9-lang-20_Arja_PatchNaturalnessYe$$Fix sunAvailable. revert accidently change. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch20-lang-20_Arja_PatchNaturalnessYe$$Fix sunAvailable = false. revert accidently change. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch5-lang-20_Arja_PatchNaturalnessYe$$Fix sunAvailable. Updated StringUtils . toString ( Object ) and friends. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch3-lang-20_Arja_PatchNaturalnessYe$$Added throw statement. revert accidently change. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch4-lang-20_Arja_PatchNaturalnessYe$$Fix NPE. remove offending null string in final form. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch36-lang-27_Arja_PatchNaturalnessYe$$Added throw exception if string is null. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch31-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Fix NPE in Arja ' s patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch38-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. fix a typo in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch54-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Allow null string input. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch53-lang-27_Arja_PatchNaturalnessYe$$formatting null values as null values are not accepted. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch65-lang-27_Arja_PatchNaturalnessYe$$Fixed NPE in StringUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch62-lang-27_Arja_PatchNaturalnessYe$$fixed ninth - month issue. removed expPos from mant string. fixed a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch39-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch37-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch63-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the extraneous space. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch64-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Fix Eclipse warning. fixed a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch52-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. try string to create double from string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch55-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the unnecessary dec string. try string to create double from string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch48-lang-27_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch8-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. don ' t put patched exception in place. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch41-lang-27_Arja_PatchNaturalnessYe$$fixed BigDecimal class name. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch15-lang-27_Arja_PatchNaturalnessYe$$removed erroneous legacy patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch12-lang-27_Arja_PatchNaturalnessYe$$throw exception if str is null. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch24-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in StringUtils. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch23-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch40-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. try string to create double from string. remove wrong symbol. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch7-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Handle null string input. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch47-lang-27_Arja_PatchNaturalnessYe$$avoid NPE. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. fix a typo in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch9-lang-27_Arja_PatchNaturalnessYe$$A blank string is not a valid number. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch49-lang-27_Arja_PatchNaturalnessYe$$fix null string handling. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch22-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Fix number parsing in Arja_Defects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch25-lang-27_Arja_PatchNaturalnessYe$$Add a patch for formatting numbers in Avro settings. removed expPos from mant string. remove expPos. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch13-lang-27_Arja_PatchNaturalnessYe$$throw exception if str is null. removed expPos from mant string. convert numeric to double for compatibility with 1 . 5. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch14-lang-27_Arja_PatchNaturalnessYe$$fixed NPE in NumberUtils. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch50-lang-27_Arja_PatchNaturalnessYe$$Remove unnecessary default value. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch61-lang-27_Arja_PatchNaturalnessYe$$Add the missing patch. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch59-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fixed syntax error in previous patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch32-lang-27_Arja_PatchNaturalnessYe$$avoid NPE. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch35-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. try Integer . decode ( str ) instead of String . create ( str ). $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch58-lang-27_Arja_PatchNaturalnessYe$$Remove unused patch. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch60-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. Handle null string input. adding mant variable to prevent compiler from giving an error message. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch56-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fix a minor typo in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch51-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. fixed a bug in NumberUtils. Fix NPE in Arja ' s patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch34-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. remove the unnecessary dec string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch33-lang-27_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch11-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove expPos. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch29-lang-27_Arja_PatchNaturalnessYe$$Handle parseDouble for StringUtils .. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch16-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. Allow trailing comma in Strings. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch20-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch18-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the unnecessary dec string. Remove exp pos from definition of Double. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch27-lang-27_Arja_PatchNaturalnessYe$$avoid NPE. fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. fixed NPE in Arja_Defects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch42-lang-27_Arja_PatchNaturalnessYe$$Allow null string input. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch5-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. removed expPos from mant string. fixed syntax error in previous patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch45-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. removed unnecessary check for integer precision thing. Remove expPos from mant string , because we ' re about to replace it with the exp. try string to create double from numeric value. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch19-lang-27_Arja_PatchNaturalnessYe$$Allow null exponent string to be parsed as a string. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch26-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the extraneous space. fix a merge conflict in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch21-lang-27_Arja_PatchNaturalnessYe$$removed exp fix. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch28-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Allow null string input. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch17-lang-27_Arja_PatchNaturalnessYe$$Fix lost backslash. Fix a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch10-lang-27_Arja_PatchNaturalnessYe$$Add null check. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch44-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fixed a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch43-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. Fixed ment = string .. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch36-lang-7_Arja_PatchNaturalnessYe$$Allow null string input. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch31-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch111-lang-7_Arja_PatchNaturalnessYe$$Fix NBFI patching. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch38-lang-7_Arja_PatchNaturalnessYe$$Eliminate the hex digits in the first place ; we ' re adding them all at the. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch98-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Added exp = null for isNaN ( ) / null .. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch65-lang-7_Arja_PatchNaturalnessYe$$parseShort was throwing an exception. Fix NPE in Arja ' s StringUtils. I don ' t really see a justification for doing a number format change in Arja ' s. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch91-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in NumberUtils. Handle early NPE for string isEmpty. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch96-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. I had left it harwired to say it was a valid number .. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch62-lang-7_Arja_PatchNaturalnessYe$$Fix NBFR patching. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch110-lang-7_Arja_PatchNaturalnessYe$$Fix NBFI patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch39-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. fix a numeric value to work with StringUtils. Added exp = null for numberUtils . createDouble ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch30-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in Arja ' s StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch37-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Added exp = 0 . 0F to NumberUtils . createFloat ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch63-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Allow negative exponents in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch97-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch90-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Handle StringUtils . isBlank ( str ) in ArjaDefects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch64-lang-7_Arja_PatchNaturalnessYe$$removed the unnecessary "" - - hexDigits - - err "" from the opengl opengl string". Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch99-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Add the missing throwing of the exception. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch52-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Added exp = null for numberUtils . createDouble ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch55-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja ' s patch. fix a numeric string to work with StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch77-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in Arja ' s patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch83-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in StringUtils. remove exp. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch48-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch84-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Add exp back. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch70-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. remove exp. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch46-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. remove backslash. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch79-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch41-lang-7_Arja_PatchNaturalnessYe$$Remove patch for 0x18e01095c1. removed expPos from str ; fix it. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch103-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Remove exp from numberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch15-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Allow one - line ifs. Fix NPE in Arja_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch104-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. fixed NPE for 1 . 7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch12-lang-7_Arja_PatchNaturalnessYe$$Fix NBFI patch. Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch24-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NBFI for ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch23-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch40-lang-7_Arja_PatchNaturalnessYe$$Allow null string input. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch47-lang-7_Arja_PatchNaturalnessYe$$removed extraneous space. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch78-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Added exp = null for numberUtils . createDouble ( String , boolean , boolean ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch71-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. fixed NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch85-lang-7_Arja_PatchNaturalnessYe$$Add missing exception check. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch82-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch76-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch49-lang-7_Arja_PatchNaturalnessYe$$Add the missing patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch22-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch25-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. adding mant variable to exp var. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch105-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja ' s StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch13-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in OE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch14-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. Handle null string input in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch50-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Handle null string input. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch68-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Handle string blank numbers in Arja ' s patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch57-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Handle "" ---- "" in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch95-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. remove expPos. Allow null string input. I am using the patch I just added. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch61-lang-7_Arja_PatchNaturalnessYe$$parseShort was throwing an exception. Allow string to be expanded into a valid number. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch59-lang-7_Arja_PatchNaturalnessYe$$removed extraneous space. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch66-lang-7_Arja_PatchNaturalnessYe$$parseShort was throwing an exception. Add the missing throwing of the exception. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch92-lang-7_Arja_PatchNaturalnessYe$$Add a throw exception if it is not a valid number. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch32-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. Handle null string input from NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch35-lang-7_Arja_PatchNaturalnessYe$$Fix NBFI patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch58-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in StringUtils. fix a numeric string to work with StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch93-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch67-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Handle null string input from JSON. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch60-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Handle null string input in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch94-lang-7_Arja_PatchNaturalnessYe$$removed the unnecessary "" - - hexDigits - - err "" from the opengl opengl string". fix a numeric string to work with StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch69-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Allow null string input. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch56-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in JSON. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch34-lang-7_Arja_PatchNaturalnessYe$$Eliminate the hex digits in the first place ; we ' re adding them all at the. fix a numeric string to work with StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch33-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in Arja ' s patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch107-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch29-lang-7_Arja_PatchNaturalnessYe$$Allow too many hex digits for an int. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch100-lang-7_Arja_PatchNaturalnessYe$$Allow null string input. fixed NPE in NumberUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch16-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch109-lang-7_Arja_PatchNaturalnessYe$$removed the unnecessary "" - - hexDigits - - err "" from the opengl opengl string". $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch20-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Fix NBFC for LIGHT_NO_MOON. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch18-lang-7_Arja_PatchNaturalnessYe$$parseShort was throwing an exception. removed the prefix removed by the patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch27-lang-7_Arja_PatchNaturalnessYe$$Add missing throw. Allow string to be expanded into float precision .. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch87-lang-7_Arja_PatchNaturalnessYe$$removed the unnecessary "" - - hexDigits - - err "" from StringUtils . parseLong ( str. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch73-lang-7_Arja_PatchNaturalnessYe$$Allow null string input. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch74-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. fix a numeric string to work with StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch80-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in OE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch42-lang-7_Arja_PatchNaturalnessYe$$parseShort was throwing an exception. Added exp = null for numberUtils . createDouble ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch5-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. Added missing exp string for float precision string. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch89-lang-7_Arja_PatchNaturalnessYe$$removed patch from string startsWith. remove mant. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch45-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in OE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch26-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. fixed NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch108-lang-7_Arja_PatchNaturalnessYe$$Fix NPE for OE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch21-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch28-lang-7_Arja_PatchNaturalnessYe$$Allow too many hex digits for an int. Allow negative exponents in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch101-lang-7_Arja_PatchNaturalnessYe$$Allow null string input. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch17-lang-7_Arja_PatchNaturalnessYe$$Eliminate the over - aggressive loop through the string .. Added missing backslash. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch106-lang-7_Arja_PatchNaturalnessYe$$Fix NBFI patch. "Revert "" move to the patch """. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch44-lang-7_Arja_PatchNaturalnessYe$$Fix NPE in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch43-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja ' s patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch88-lang-7_Arja_PatchNaturalnessYe$$fixed NPE for number utils. Remove erroneous test for isFinite ( ) and allZeros ( ). $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch81-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. Fix NBFR patch. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch75-lang-7_Arja_PatchNaturalnessYe$$removed patch from string utils. Fix NPE in OE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch72-lang-7_Arja_PatchNaturalnessYe$$removed the unnecessary "" - - hexDigits - - err "" from the opengl opengl string". Allow negative exponents in StringUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch36-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. Add a throw if it is not a blank string. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch31-lang-16_Arja_PatchNaturalnessYe$$Allow null to be passed in number utils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch38-lang-16_Arja_PatchNaturalnessYe$$Add the patch for the exponentiation of certain characters. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch54-lang-16_Arja_PatchNaturalnessYe$$Add missing patch. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch53-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. remove exp. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch65-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in Arja_Defects4J_Lang_16. revert patch. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch62-lang-16_Arja_PatchNaturalnessYe$$fixed a small bug. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch39-lang-16_Arja_PatchNaturalnessYe$$Add an exception if the string is null. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch30-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch37-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in number utils .. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch63-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. Fix exp parsing in Arja_Defects4J_Lang_16. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch64-lang-16_Arja_PatchNaturalnessYe$$fix null string handling. get fix from pull request. remove exp. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch52-lang-16_Arja_PatchNaturalnessYe$$Add missing patch. fixed syntax error in ArjaDefects4J_Lang_16. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch55-lang-16_Arja_PatchNaturalnessYe$$Fix a 13e032 error in Arja ' s NumberUtils. fixed a typo in the code. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch48-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch8-lang-16_Arja_PatchNaturalnessYe$$try string cast. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch46-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch41-lang-16_Arja_PatchNaturalnessYe$$Fix a NumberFormatException if the string length is not > = expPos. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch15-lang-16_Arja_PatchNaturalnessYe$$fix null string handling. Fix a minor issue with NumberUtils . createFloat ( str ). get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch12-lang-16_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_16. Fix typo in data .. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch24-lang-16_Arja_PatchNaturalnessYe$$Fix NumberFormatException. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch23-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. fixed a bug in NumberUtils. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch40-lang-16_Arja_PatchNaturalnessYe$$removed patch for numberUtils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch7-lang-16_Arja_PatchNaturalnessYe$$Remove patch from last commit. Fix a bug in NumberUtils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch47-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in Arja_Defects4J_Lang_16. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch9-lang-16_Arja_PatchNaturalnessYe$$get fix from pull request. try Integer . decode ( str ) instead of String . create ( str ). $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch49-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from pull request. Fix StringUtils . isNaN ( str ). $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch22-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in Arja_Defects4J_Lang_16. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch25-lang-16_Arja_PatchNaturalnessYe$$A blank string is not a valid number. "Revert "" remove "" from "" fix". get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch13-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch14-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from pull request. add patch for eequality. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch50-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. Handle null string input from NumberUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch57-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch61-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. fixed a bug in the code style. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch59-lang-16_Arja_PatchNaturalnessYe$$Add null check. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch66-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch32-lang-16_Arja_PatchNaturalnessYe$$Add number exception patch. get fix from pull request. Add a throw if it is not a blank string. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch35-lang-16_Arja_PatchNaturalnessYe$$Allow null to be parsed as a number. Fix potential NPE in NumberUtils. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch58-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. "Revert "" fix merge conflict """. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch67-lang-16_Arja_PatchNaturalnessYe$$A blank string is not a valid number. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch60-lang-16_Arja_PatchNaturalnessYe$$"Revert "" remove "" from "" fix". Fix accidentely removed patch for string literals. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch56-lang-16_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_16. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch51-lang-16_Arja_PatchNaturalnessYe$$A blank string is not a valid number. don ' t check isEmpty ( ) in NumberUtils. get fix from patch. remove exp. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch34-lang-16_Arja_PatchNaturalnessYe$$Add number exception patch. get fix from pull request. Fix NPE in NumberUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch33-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in number utils .. fix merge conflict resolution. missing patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch11-lang-16_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. get fix from pull request. Fix StringUtils . isNaN ( str ) .. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch29-lang-16_Arja_PatchNaturalnessYe$$Fix this. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch16-lang-16_Arja_PatchNaturalnessYe$$Add the patch for number utils. Fix a minor issue with NumberUtils . createFloat ( str ). get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch20-lang-16_Arja_PatchNaturalnessYe$$get fix from pull request. don ' t ignore numbers with spaces. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch18-lang-16_Arja_PatchNaturalnessYe$$adding patch for "" ---- """. get fix from patch. don ' t ignore signs in - - fixes NPE. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch27-lang-16_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. Fix potential NPE in NumberUtils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch42-lang-16_Arja_PatchNaturalnessYe$$"Revert "" update to latest compatibility """. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch45-lang-16_Arja_PatchNaturalnessYe$$get fix from pull request. remove null check in ArjaDefects4J_Lang_16. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch19-lang-16_Arja_PatchNaturalnessYe$$Fix typo in reference manual. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch26-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch21-lang-16_Arja_PatchNaturalnessYe$$Remove unused patch. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch28-lang-16_Arja_PatchNaturalnessYe$$Fix null pointer check in ArjaDefects4J_Lang_16. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch17-lang-16_Arja_PatchNaturalnessYe$$Fix 1474 patch for number utils. get fix from pull request. Handle null string input from NumberUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch10-lang-16_Arja_PatchNaturalnessYe$$Add number exception patch. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch44-lang-16_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_16. fixed a bug in NumberUtils. get fix from patch. Add a throw if it is not a blank string. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch43-lang-16_Arja_PatchNaturalnessYe$$Fix a bug in NumberUtils. get fix from pull request. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch36-lang-45_Arja_PatchNaturalnessYe$$fixed possible NPE. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch31-lang-45_Arja_PatchNaturalnessYe$$handle empty string matches for patch. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch38-lang-45_Arja_PatchNaturalnessYe$$fixed possible NPE. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch39-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch30-lang-45_Arja_PatchNaturalnessYe$$fixed a small bug. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch37-lang-45_Arja_PatchNaturalnessYe$$IgnoreCase. remove null string fix. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch8-lang-45_Arja_PatchNaturalnessYe$$throw exception if the string is empty. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch6-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. remove patch. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch41-lang-45_Arja_PatchNaturalnessYe$$throw exception if the string is empty. fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch15-lang-45_Arja_PatchNaturalnessYe$$fix a warning. update patch. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch12-lang-45_Arja_PatchNaturalnessYe$$fix a warning. fixed NPE in StringUtils. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch24-lang-45_Arja_PatchNaturalnessYe$$lowercased string contains only upper / lower case characters. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch23-lang-45_Arja_PatchNaturalnessYe$$throw exception if StringUtils . isEmpty ( str ) is true. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch40-lang-45_Arja_PatchNaturalnessYe$$remove null string fix. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch7-lang-45_Arja_PatchNaturalnessYe$$remove backslash. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch9-lang-45_Arja_PatchNaturalnessYe$$fixed possible NPE. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch22-lang-45_Arja_PatchNaturalnessYe$$fix a warning. add null check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch25-lang-45_Arja_PatchNaturalnessYe$$Fix null parameter check. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch13-lang-45_Arja_PatchNaturalnessYe$$fixed a small bug. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch14-lang-45_Arja_PatchNaturalnessYe$$fix a warning. Fix StringUtils . length ( ) > = 0. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch32-lang-45_Arja_PatchNaturalnessYe$$remove empty string handling. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch35-lang-45_Arja_PatchNaturalnessYe$$avoid empty string handling. fix a warning. add empty check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch34-lang-45_Arja_PatchNaturalnessYe$$fix a warning. add empty check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch33-lang-45_Arja_PatchNaturalnessYe$$fixed null string handling. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch11-lang-45_Arja_PatchNaturalnessYe$$fix a warning. avoid empty string handling. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch29-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. add empty check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch16-lang-45_Arja_PatchNaturalnessYe$$fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch20-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove patch for substrings with length ( ). $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch18-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch27-lang-45_Arja_PatchNaturalnessYe$$remove a redundant check. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch42-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch5-lang-45_Arja_PatchNaturalnessYe$$IgnoreCase. fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch19-lang-45_Arja_PatchNaturalnessYe$$fix a warning. convert string to lower case as is the case. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch26-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch21-lang-45_Arja_PatchNaturalnessYe$$avoid NPE when StringUtils . isEmpty ( str ) is set upper = - 1. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch28-lang-45_Arja_PatchNaturalnessYe$$fix a warning. Fix removed - > upper case. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch17-lang-45_Arja_PatchNaturalnessYe$$fix a warning. IgnoreCase. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch10-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove patch from string utils. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch4-lang-45_Arja_PatchNaturalnessYe$$throw exception if the string is empty. fix a warning. add empty string check. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch36-lang-43_Arja_PatchNaturalnessYe$$Remove unused patch. Fix the format definition for the next // line. don ' t use the registry for the message. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch31-lang-43_Arja_PatchNaturalnessYe$$Missing patch. Fix an issue with the pattern being followed by another Grails message .. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch38-lang-43_Arja_PatchNaturalnessYe$$Fix unrereadable format elements. fix # 59. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch54-lang-43_Arja_PatchNaturalnessYe$$don ' t skip backslash - escaped string. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch98-lang-43_Arja_PatchNaturalnessYe$$Fix unrereadable format elements. don ' t append QUOTE to the appendTo buffer , as we don ' t need it. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch53-lang-43_Arja_PatchNaturalnessYe$$The registry object was not being set in the constructor .. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch65-lang-43_Arja_PatchNaturalnessYe$$setting registry. don ' t append QUOTE to the appendTo buffer , as we don ' t need it. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch91-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. Fix format description not found in message striper. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch96-lang-43_Arja_PatchNaturalnessYe$$Fix compile error. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch62-lang-43_Arja_PatchNaturalnessYe$$missing return statement. Fix an issue with the pattern ' s pattern after it has been read .. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch39-lang-43_Arja_PatchNaturalnessYe$$Reset the pattern for the next ( ) method in ExtendedMessageFormat. don ' t increment index of pattern after backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch30-lang-43_Arja_PatchNaturalnessYe$$missing patch. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch37-lang-43_Arja_PatchNaturalnessYe$$fix lost ParsePosition. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch63-lang-43_Arja_PatchNaturalnessYe$$don ' t apply the pattern if it wasn ' t defined in the superclass .. Reset lost registry reference. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch97-lang-43_Arja_PatchNaturalnessYe$$Fix registry field. don ' t increment index of pattern after backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch90-lang-43_Arja_PatchNaturalnessYe$$don ' t apply message format twice. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch64-lang-43_Arja_PatchNaturalnessYe$$missing break. fix # 59. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch99-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. don ' t skip backslash which prevents appending to the end of a string. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch52-lang-43_Arja_PatchNaturalnessYe$$Fix unreFindable format elements. don ' t include backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch55-lang-43_Arja_PatchNaturalnessYe$$Fix mails. don ' t append QUOTE to dest array ; fix # 1796. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch77-lang-43_Arja_PatchNaturalnessYe$$Fix NPE for @ ArjaDefects4J_Lang_43. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch83-lang-43_Arja_PatchNaturalnessYe$$don ' t apply message formats if registry is null. Fix the format definition so that it doesn ' t become an error in the code. don ' t skip backslash - escaped symbols. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch48-lang-43_Arja_PatchNaturalnessYe$$missing from last commit. don ' t append QUOTE to dest array ; fix # 183. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch84-lang-43_Arja_PatchNaturalnessYe$$Fix registry field. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch46-lang-43_Arja_PatchNaturalnessYe$$don ' t skip backslash and quote in message format. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch79-lang-43_Arja_PatchNaturalnessYe$$Fix mails. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch41-lang-43_Arja_PatchNaturalnessYe$$Fix NPE. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch15-lang-43_Arja_PatchNaturalnessYe$$Fix registry field. Fix # 156. don ' t increment pos . getIndex ( ) for quote. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch12-lang-43_Arja_PatchNaturalnessYe$$Fix registry field. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch24-lang-43_Arja_PatchNaturalnessYe$$missing patch. don ' t increment index of pattern after backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch23-lang-43_Arja_PatchNaturalnessYe$$don ' t include backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch40-lang-43_Arja_PatchNaturalnessYe$$setting registry. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch47-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. Fix mails. don ' t skip backslash which prevents appending to the end of a string. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch78-lang-43_Arja_PatchNaturalnessYe$$Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch71-lang-43_Arja_PatchNaturalnessYe$$Remove unused patch. don ' t append QUOTE to dest array ; fix # 1473. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch85-lang-43_Arja_PatchNaturalnessYe$$missing patch. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch82-lang-43_Arja_PatchNaturalnessYe$$fix missing patch. Fix an issue with missing format descriptions in the pattern. don ' t increment index of pattern after backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch76-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch49-lang-43_Arja_PatchNaturalnessYe$$Fix the build. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch22-lang-43_Arja_PatchNaturalnessYe$$missing patch. Fix the format definition of ' QUOTE '. don ' t use the registry for the message. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch25-lang-43_Arja_PatchNaturalnessYe$$Fix lost registry reference. don ' t append QUOTE to dest array ; fix # 183. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch13-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition so that it doesn ' t become an error in the code. Fix the over - aggressive loop. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch14-lang-43_Arja_PatchNaturalnessYe$$Fix the bug. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch50-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition of ' QUOTE '. Reset the registry object as well. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch68-lang-43_Arja_PatchNaturalnessYe$$missing patch. Fix the pattern for the second time. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch57-lang-43_Arja_PatchNaturalnessYe$$don ' t apply message format twice. Fix the format definition for the next // line. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch95-lang-43_Arja_PatchNaturalnessYe$$fix lost toPattern ; changed to match superclass. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch61-lang-43_Arja_PatchNaturalnessYe$$don ' t append non - WS after backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch59-lang-43_Arja_PatchNaturalnessYe$$Fix # 141. don ' t apply the pattern if it wasn ' t defined in the superclass .. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch66-lang-43_Arja_PatchNaturalnessYe$$Fix an issue with missing backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch92-lang-43_Arja_PatchNaturalnessYe$$fix lost pos. don ' t append QUOTE to dest array ; fix # 183. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch32-lang-43_Arja_PatchNaturalnessYe$$missing from last commit. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch35-lang-43_Arja_PatchNaturalnessYe$$Fix the pattern for the second time. don ' t skip backslash which prevents appending to the end of a string. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch58-lang-43_Arja_PatchNaturalnessYe$$fix missing patch. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch93-lang-43_Arja_PatchNaturalnessYe$$missing patch. don ' t append QUOTE to dest array ; fix # 1796. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch67-lang-43_Arja_PatchNaturalnessYe$$missing patch. don ' t append QUOTE to the appendTo buffer , as we don ' t need it. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch60-lang-43_Arja_PatchNaturalnessYe$$Fix registry field. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch94-lang-43_Arja_PatchNaturalnessYe$$Fix NPE. don ' t append QUOTE to dest array ; fix # 419. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch69-lang-43_Arja_PatchNaturalnessYe$$Allow format descriptions to be found by parsing. don ' t include backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch56-lang-43_Arja_PatchNaturalnessYe$$setting registry. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch51-lang-43_Arja_PatchNaturalnessYe$$don ' t append QUOTE to the appendTo buffer , as we don ' t need it. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch34-lang-43_Arja_PatchNaturalnessYe$$Fix format string striping. don ' t apply patch , now that we use applyPattern method , as I ' m getting. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch33-lang-43_Arja_PatchNaturalnessYe$$Fix bug. don ' t append QUOTE to the appendTo buffer , as we don ' t need it. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch11-lang-43_Arja_PatchNaturalnessYe$$Fix cruise ( this . registry = registry ). Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch29-lang-43_Arja_PatchNaturalnessYe$$Fix registry field. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch16-lang-43_Arja_PatchNaturalnessYe$$missing patch. don ' t append QUOTE if escaping is on. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch20-lang-43_Arja_PatchNaturalnessYe$$Fix ParsePosition. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch18-lang-43_Arja_PatchNaturalnessYe$$don ' t apply message formats if registry is null. Fix the format definition for the next // line. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch27-lang-43_Arja_PatchNaturalnessYe$$Fix bug in message format. don ' t append QUOTE to dest array ; fix # 183. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch87-lang-43_Arja_PatchNaturalnessYe$$missing from last commit. missing break. don ' t include backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch73-lang-43_Arja_PatchNaturalnessYe$$Fix the pattern for the second time. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch74-lang-43_Arja_PatchNaturalnessYe$$Reset the index of the message format definition so it parses. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch42-lang-43_Arja_PatchNaturalnessYe$$Missing patch. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch89-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. Fix mails. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch2-lang-43_Arja_PatchNaturalnessYe$$Fix NPE for @ ArjaDefects4J_Lang_43. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch45-lang-43_Arja_PatchNaturalnessYe$$missing patch. Fix an issue with missing format descriptions in the pattern. don ' t include backslash. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch19-lang-43_Arja_PatchNaturalnessYe$$missing patch. Fix the format definition for the next // line. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch26-lang-43_Arja_PatchNaturalnessYe$$Fix NPE. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch21-lang-43_Arja_PatchNaturalnessYe$$don ' t apply message formats if registry is null. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch28-lang-43_Arja_PatchNaturalnessYe$$don ' t apply message formats if registry is null. Fix the format definition of ' QUOTE '. Fix the bug. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch17-lang-43_Arja_PatchNaturalnessYe$$Fix NPE. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch10-lang-43_Arja_PatchNaturalnessYe$$Fix NPE in pattern .. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch44-lang-43_Arja_PatchNaturalnessYe$$fix lost ParsePosition. Fix the bug. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch43-lang-43_Arja_PatchNaturalnessYe$$Remove unused call to toPattern if registry is null. Fix the format definition of ' QUOTE '. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch88-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. validate format count after patch. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch81-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. The patch for the year would prevent the pattern being parsed by the parser from being appended to. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch75-lang-43_Arja_PatchNaturalnessYe$$don ' t apply the pattern if it wasn ' t defined in the superclass .. $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch72-lang-43_Arja_PatchNaturalnessYe$$Missing patch. Move to next ( pos ). $$0
lang-43$$ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes$$When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }$$patch86-lang-43_Arja_PatchNaturalnessYe$$Fix the format definition for the next // line. Fix message format change. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch30-lang-39_Arja_PatchNaturalnessYe$$Added throw exception if search and replace array lengths do not match. revert accidently change. remove a for loop. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch48-lang-39_Arja_PatchNaturalnessYe$$removed unnecessary check for null / non - empty text fields. remove a for loop. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch15-lang-39_Arja_PatchNaturalnessYe$$remove accidently leftover from StringUtils. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch47-lang-39_Arja_PatchNaturalnessYe$$remove unused patch. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch123-lang-39_Arja_PatchNaturalnessYe$$throw exception if timeToLive < 0. remove a unused variable. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch56-lang-39_Arja_PatchNaturalnessYe$$revert accidently change for StringUtils. remove a for loop. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch27-lang-39_Arja_PatchNaturalnessYe$$revert accidently change. remove a redundant line. $$0
lang-39$$StringUtils replaceEach - Bug or Missing Documentation$$The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {  	@Test 	public void replaceEach(){ 		String original = "Hello World!"; 		String[] searchList = {"Hello", "World"}; 		String[] replacementList = {"Greetings", null}; 		String result = StringUtils.replaceEach(original, searchList, replacementList); 		assertEquals("Greetings !", result); 		//perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even 		//assertEquals("Greetings null!", result); 	}  	 }$$patch86-lang-39_Arja_PatchNaturalnessYe$$removed unnecessary check for null / non - empty text fields. reset replaceIndex. remove a for loop. fixed NPE and NPE in StringUtils. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch8-lang-55_Arja_PatchNaturalnessYe$$StopWatch should reset splitState after each split. Remove unnecessary code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch6-lang-55_Arja_PatchNaturalnessYe$$Fix bug. Remove unnecessary code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch12-lang-55_Arja_PatchNaturalnessYe$$StopWatch should reset the stop time if already stopped. Remove unused variable. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch7-lang-55_Arja_PatchNaturalnessYe$$Remove unnecessary code. Added missing patch. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch9-lang-55_Arja_PatchNaturalnessYe$$StopWatch should not be reset before being restarted. Remove unnecessary code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch13-lang-55_Arja_PatchNaturalnessYe$$Add patch for Stopwatch . reset ( ) .. Remove unnecessary code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch11-lang-55_Arja_PatchNaturalnessYe$$Fix start time. Add a fix for the merge of Avro settings into the workflow .. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch5-lang-55_Arja_PatchNaturalnessYe$$StopWatch should set startTime before being restarted. Remove unnecessary code. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch10-lang-55_Arja_PatchNaturalnessYe$$Reset stop time to - 1 , I think it ' s better for testing. Remove unused variable. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch3-lang-55_Arja_PatchNaturalnessYe$$Remove unnecessary line. Add an error if a Stopwatch is stopped after the initial time. $$0
lang-55$$StopWatch: suspend() acts as split(), if followed by stop()$$In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?$$patch4-lang-55_Arja_PatchNaturalnessYe$$Remove unnecessary line. Fix # 205. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch120-lang-63_Arja_PatchNaturalnessYe$$remove patch. removed two - times add ( field , old ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch36-lang-63_Arja_PatchNaturalnessYe$$remove patch. Remove over - aggressive fix. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch127-lang-63_Arja_PatchNaturalnessYe$$fix for month - > hour. Remove fixed patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch31-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch118-lang-63_Arja_PatchNaturalnessYe$$was asking for M in the format. fix bug. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch111-lang-63_Arja_PatchNaturalnessYe$$revert accidently change. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch38-lang-63_Arja_PatchNaturalnessYe$$Add fix for leap year. Add fix for leap year. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch116-lang-63_Arja_PatchNaturalnessYe$$fixed too - old test. remove patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch129-lang-63_Arja_PatchNaturalnessYe$$fixed too - old pattern. Remove patch for day / week. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch189-lang-63_Arja_PatchNaturalnessYe$$Fix duration format mistake. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch142-lang-63_Arja_PatchNaturalnessYe$$Ignore non - calendar days for now .. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch54-lang-63_Arja_PatchNaturalnessYe$$Remove M from the end of the month string. fixed erroneous changes in duration format. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch98-lang-63_Arja_PatchNaturalnessYe$$fix for month - > hour. Ignore H = 0 ( fix provided by @ rmb938 ). removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch145-lang-63_Arja_PatchNaturalnessYe$$remove patch. remove patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch53-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict in DurationFormatUtils. remove patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch65-lang-63_Arja_PatchNaturalnessYe$$remove patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch173-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split sentence. Remove accidential modification. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch91-lang-63_Arja_PatchNaturalnessYe$$removed fixed minute / hour delay. remove months = = 0. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch187-lang-63_Arja_PatchNaturalnessYe$$Ignore H .. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch96-lang-63_Arja_PatchNaturalnessYe$$Add months / years back. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch180-lang-63_Arja_PatchNaturalnessYe$$remove patch. Remove over - aggressive fix. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch62-lang-63_Arja_PatchNaturalnessYe$$fixed typo. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch174-lang-63_Arja_PatchNaturalnessYe$$fix # 1796. fix removed minute and year from end of month / year log. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch117-lang-63_Arja_PatchNaturalnessYe$$remove loop. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch110-lang-63_Arja_PatchNaturalnessYe$$Add fix for leap year. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch39-lang-63_Arja_PatchNaturalnessYe$$fixed erroneous test case. Remove over - aggressive fix. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch126-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. Add missing token. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch30-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch119-lang-63_Arja_PatchNaturalnessYe$$fix broken ut. removed fixed minute / hours offset. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch121-lang-63_Arja_PatchNaturalnessYe$$Remove redundant patch. Add one year to the end of the month in classic duration format. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch37-lang-63_Arja_PatchNaturalnessYe$$fixed typo in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch175-lang-63_Arja_PatchNaturalnessYe$$fix for calendar year in classic pattern. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch97-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch181-lang-63_Arja_PatchNaturalnessYe$$was going to fix the build. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch90-lang-63_Arja_PatchNaturalnessYe$$fix for month - > hour. fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch186-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch64-lang-63_Arja_PatchNaturalnessYe$$Ignore modifier from end - to - end time. Add end of year fix. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch99-lang-63_Arja_PatchNaturalnessYe$$Add fix for month name calculation. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch144-lang-63_Arja_PatchNaturalnessYe$$fix for leap year in definition time. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch52-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split sentence. Add fix for leap year. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch188-lang-63_Arja_PatchNaturalnessYe$$Remove the oversampling of the duration format parser. remove patch. fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch143-lang-63_Arja_PatchNaturalnessYe$$removed fixed minute / hour delay. Add end of year fix. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch55-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. Remove redundant patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch203-lang-63_Arja_PatchNaturalnessYe$$Put back the duration formatUtils until it is fix .. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch204-lang-63_Arja_PatchNaturalnessYe$$Ignore minutes / hours in the end of month value. removed fixed minute offset. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch205-lang-63_Arja_PatchNaturalnessYe$$remove months = = 0. Remove fixed patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch202-lang-63_Arja_PatchNaturalnessYe$$fixed EAP. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch220-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split sentence. fix for month - first. fix bug. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch218-lang-63_Arja_PatchNaturalnessYe$$Remove months = = 0. Remove over - aggressive fix. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch211-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch216-lang-63_Arja_PatchNaturalnessYe$$Remove patch for endDate. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch217-lang-63_Arja_PatchNaturalnessYe$$Added fix for lost minute / second delay in duration format. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch210-lang-63_Arja_PatchNaturalnessYe$$Ignore H . 264 in DurationFormatUtils. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch219-lang-63_Arja_PatchNaturalnessYe$$Ignore minutes / m in the same month / year definition. Add one year to the end of the month in classic duration format. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch221-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch161-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split sentence. Remove fixed patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch77-lang-63_Arja_PatchNaturalnessYe$$Add H = > 60. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch195-lang-63_Arja_PatchNaturalnessYe$$fixed year ending delay. Remove patch for week ending. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch83-lang-63_Arja_PatchNaturalnessYe$$Remove years from the duration format. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch48-lang-63_Arja_PatchNaturalnessYe$$Add missing MMS offset for days / week. remove patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch192-lang-63_Arja_PatchNaturalnessYe$$removed fixed syntax error. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch84-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch166-lang-63_Arja_PatchNaturalnessYe$$Remove patched duration format utils. removed unnecessary add ( ) in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch70-lang-63_Arja_PatchNaturalnessYe$$fix the issue of not adding M. fixed typo. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch159-lang-63_Arja_PatchNaturalnessYe$$fix # 773. Remove fixed patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch46-lang-63_Arja_PatchNaturalnessYe$$remove patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch150-lang-63_Arja_PatchNaturalnessYe$$remove patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch79-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch41-lang-63_Arja_PatchNaturalnessYe$$Add the month value for the duration format. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch157-lang-63_Arja_PatchNaturalnessYe$$removed unnecessary add ( ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch168-lang-63_Arja_PatchNaturalnessYe$$remove patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch103-lang-63_Arja_PatchNaturalnessYe$$remove loop. fixed syntax error. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch104-lang-63_Arja_PatchNaturalnessYe$$fix bug. remove patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch24-lang-63_Arja_PatchNaturalnessYe$$Remove fixed patch. fix bug. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch132-lang-63_Arja_PatchNaturalnessYe$$removed fixed minute / hour delay. remove patch. removed two - times add ( field , old ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch23-lang-63_Arja_PatchNaturalnessYe$$fix broken patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch135-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch40-lang-63_Arja_PatchNaturalnessYe$$fixed erroneous test. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch156-lang-63_Arja_PatchNaturalnessYe$$remove patched minute / hours. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch169-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch47-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch151-lang-63_Arja_PatchNaturalnessYe$$Fix year overflow in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch78-lang-63_Arja_PatchNaturalnessYe$$Added fix for # 774. fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch167-lang-63_Arja_PatchNaturalnessYe$$Ignore H + H in DurationFormatUtils. Added missing minutes. Add missing minutes and hours to fix. fix merge conflict in DurationFormatUtils. fixed merge conflict in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch71-lang-63_Arja_PatchNaturalnessYe$$Fix the bug of teenager year range .. fix removed patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch193-lang-63_Arja_PatchNaturalnessYe$$Ignore patterns with wrong value for month / year. remove patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch85-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch158-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch194-lang-63_Arja_PatchNaturalnessYe$$fix for month - first. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch82-lang-63_Arja_PatchNaturalnessYe$$fix merge issue. fix bug. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch160-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. removed fixed minute / hours delay. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch76-lang-63_Arja_PatchNaturalnessYe$$Remove patch for not having minutes in the same time frame. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch49-lang-63_Arja_PatchNaturalnessYe$$fix for leap year. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch134-lang-63_Arja_PatchNaturalnessYe$$fix # 274. Fix format string for years = 0. fix merge conflict resolution. removed unnecessary add ( ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch25-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch133-lang-63_Arja_PatchNaturalnessYe$$fix # 434. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch105-lang-63_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 2019. Remove patch for week ending. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch102-lang-63_Arja_PatchNaturalnessYe$$fix bug. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch179-lang-63_Arja_PatchNaturalnessYe$$fix removed patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch146-lang-63_Arja_PatchNaturalnessYe$$fixed wrong end date. revert accidently change. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch50-lang-63_Arja_PatchNaturalnessYe$$fixed for 1 . 5. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch68-lang-63_Arja_PatchNaturalnessYe$$Ignore minutes / hours in the end of month value. fix removed minute increments. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch141-lang-63_Arja_PatchNaturalnessYe$$Ignore H + H in DurationFormatUtils. remove loop. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch57-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split sentence. fixed typo in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch148-lang-63_Arja_PatchNaturalnessYe$$fixed minute / hour offset. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch95-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. fix for leap year in definition time. remove patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch183-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. Remove over - aggressive fix. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch61-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch177-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch59-lang-63_Arja_PatchNaturalnessYe$$Add missing minutes and hours back. Add end of year fix. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch66-lang-63_Arja_PatchNaturalnessYe$$reduce number of days in first month of year. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch170-lang-63_Arja_PatchNaturalnessYe$$fixed a bug in the diff script. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch92-lang-63_Arja_PatchNaturalnessYe$$fixedEndDate = fixedStartDate = fixedEndDate. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch184-lang-63_Arja_PatchNaturalnessYe$$Add fix for month name calculation. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch124-lang-63_Arja_PatchNaturalnessYe$$removed fixed minute / hour delay. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch32-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split in ISO 8601 duration format. Add the missing seconds as part of the duration format fix. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch123-lang-63_Arja_PatchNaturalnessYe$$fixed month ending. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch35-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. was going to fix the build. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch115-lang-63_Arja_PatchNaturalnessYe$$fix for leap year. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch112-lang-63_Arja_PatchNaturalnessYe$$fix bug. Add one year to the end of the month in classic duration format. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch93-lang-63_Arja_PatchNaturalnessYe$$fixed too - old pattern. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch185-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch67-lang-63_Arja_PatchNaturalnessYe$$fixed typo in DurationFormatUtils. Remove patch for endDate. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch171-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. Remove patch for calendar year. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch149-lang-63_Arja_PatchNaturalnessYe$$revert patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch60-lang-63_Arja_PatchNaturalnessYe$$remove patch. removed extraneous line. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch176-lang-63_Arja_PatchNaturalnessYe$$removed fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch94-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. fix merge conflict in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch182-lang-63_Arja_PatchNaturalnessYe$$fixed too - old pattern. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch69-lang-63_Arja_PatchNaturalnessYe$$fix bug. remove loop. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch140-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch56-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch178-lang-63_Arja_PatchNaturalnessYe$$Remove fixed minute / second mistake. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch147-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. Fix years count. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch51-lang-63_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 283. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch113-lang-63_Arja_PatchNaturalnessYe$$Ignore minutes / hours in the end of month value. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch114-lang-63_Arja_PatchNaturalnessYe$$fixed typo in DurationFormatUtils. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch122-lang-63_Arja_PatchNaturalnessYe$$Fix duration format mistake. Remove fixed patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch34-lang-63_Arja_PatchNaturalnessYe$$Remove the oversampling of the duration format parser. fixed merge conflict in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch125-lang-63_Arja_PatchNaturalnessYe$$Remove the oversampling of the duration format parser. fix bug. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch33-lang-63_Arja_PatchNaturalnessYe$$fix removed minute increments. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch207-lang-63_Arja_PatchNaturalnessYe$$remove backwards incompatible change. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch200-lang-63_Arja_PatchNaturalnessYe$$Ignore modifier from end - to - end time. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch209-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. Remove patch for minute / second. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch208-lang-63_Arja_PatchNaturalnessYe$$Remove patch for endDate. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch201-lang-63_Arja_PatchNaturalnessYe$$Remove redundant patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch206-lang-63_Arja_PatchNaturalnessYe$$reduce and correct the duration in the case of month - first. fix bug. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch223-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch215-lang-63_Arja_PatchNaturalnessYe$$fix for leap year. fixed syntax error. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch212-lang-63_Arja_PatchNaturalnessYe$$Add end of month to fix # 33. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch213-lang-63_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 283. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch214-lang-63_Arja_PatchNaturalnessYe$$fixed erroneous test. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch222-lang-63_Arja_PatchNaturalnessYe$$Add missing patch. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch138-lang-63_Arja_PatchNaturalnessYe$$Ignore minutes / hours in the end of month value. Remove fixed / unused variable. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch107-lang-63_Arja_PatchNaturalnessYe$$fix bug. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch29-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict in DurationFormatUtils. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch100-lang-63_Arja_PatchNaturalnessYe$$Ignore H + H in DurationFormatUtils. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch109-lang-63_Arja_PatchNaturalnessYe$$Ignore H .. remove patch. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch136-lang-63_Arja_PatchNaturalnessYe$$remove loop. reduce HOUR_OF_DAY by one month. fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch27-lang-63_Arja_PatchNaturalnessYe$$fixed hours , fix from pull request. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch131-lang-63_Arja_PatchNaturalnessYe$$fix for patch 1833. fixed syntax error. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch191-lang-63_Arja_PatchNaturalnessYe$$Ignore H . 264 in DurationFormatUtils. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch87-lang-63_Arja_PatchNaturalnessYe$$Add fix for month name calculation. Remove over - aggressive fix. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch165-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. fixed month - > year in configuration. Ignore H = 0 ( fix provided by @ rmb938 ). removed unnecessary add ( ) in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch73-lang-63_Arja_PatchNaturalnessYe$$fixed year ending. removed fixed minute / hours offset. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch162-lang-63_Arja_PatchNaturalnessYe$$Add H = > 60. fix for month - first. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch74-lang-63_Arja_PatchNaturalnessYe$$removed fixed syntax error. Remove patch for endDate. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch196-lang-63_Arja_PatchNaturalnessYe$$Fix ISO 8601 duration format. removed fixed minute / hours delay. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch80-lang-63_Arja_PatchNaturalnessYe$$removed test for same day / month. fixed syntax error. fixed legitimization. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch42-lang-63_Arja_PatchNaturalnessYe$$remove patch. revert patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch154-lang-63_Arja_PatchNaturalnessYe$$Remove redundant code. fixed syntax error in DurationFormatUtils. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch89-lang-63_Arja_PatchNaturalnessYe$$Add hours / minutes to months number. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch45-lang-63_Arja_PatchNaturalnessYe$$Fix reverseEach. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch153-lang-63_Arja_PatchNaturalnessYe$$Fix duration format mistake. remove minute = 0 ; patch = 0 ;. fixed legitimization. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch198-lang-63_Arja_PatchNaturalnessYe$$fix disabled patch for minute / hour. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch26-lang-63_Arja_PatchNaturalnessYe$$fix for month - first. fixed syntax error. revert patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch130-lang-63_Arja_PatchNaturalnessYe$$Remove redundant patch. Ignore H . 264 in DurationFormatUtils. removed fixed minute offset. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch108-lang-63_Arja_PatchNaturalnessYe$$Ignore modifier from end - to - end time. fix merge conflict resolution. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch137-lang-63_Arja_PatchNaturalnessYe$$Fix week ending. fixed erroneous legacy change. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch28-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split in ISO 8601 duration format. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch101-lang-63_Arja_PatchNaturalnessYe$$removed fixed minute / hours offset. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch139-lang-63_Arja_PatchNaturalnessYe$$reduce HOUR_OF_DAY by one month. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch106-lang-63_Arja_PatchNaturalnessYe$$Remove M from the end of the month estimates. removed unnecessary add ( ) in DurationFormatUtils. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch44-lang-63_Arja_PatchNaturalnessYe$$removed fixed minute / hours delay. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch152-lang-63_Arja_PatchNaturalnessYe$$fix for month - > year. Remove useless assignment. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch3-lang-63_Arja_PatchNaturalnessYe$$Add fix for month name calculation. Remove fixed minute / hour offset. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch199-lang-63_Arja_PatchNaturalnessYe$$remove minute = 0 ; patch = > minute. remove patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch43-lang-63_Arja_PatchNaturalnessYe$$remove backwards incompatible change. Add missing minutes and hours back. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch155-lang-63_Arja_PatchNaturalnessYe$$fix disabled loop. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch88-lang-63_Arja_PatchNaturalnessYe$$fix merge conflict resolution. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch197-lang-63_Arja_PatchNaturalnessYe$$I don ' t really see a justification for doing a split sentence. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch81-lang-63_Arja_PatchNaturalnessYe$$reverse the changes. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch163-lang-63_Arja_PatchNaturalnessYe$$fixed syntax error in DurationFormatUtils. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch75-lang-63_Arja_PatchNaturalnessYe$$Add end of year fix. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch164-lang-63_Arja_PatchNaturalnessYe$$Add missing value. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch72-lang-63_Arja_PatchNaturalnessYe$$Added missing minutes to the duration format test. removed patch. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch190-lang-63_Arja_PatchNaturalnessYe$$fix disabled month value for ISO 8601 duration format. removed a redundant call to add ( field , value ). $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch86-lang-63_Arja_PatchNaturalnessYe$$Added fix for lost seconds / minutes in DurationFormatUtils. remove patch. removed patch. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch47-lang-22_Arja_PatchNaturalnessYe$$Fix # 1796. remove patch for 1 . 7 . 0 - > 1 . 7 . 0. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch78-lang-22_Arja_PatchNaturalnessYe$$Fix greatestCommonDivisor patch. Fix string comparison in Fraction . equals ( ). $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch82-lang-22_Arja_PatchNaturalnessYe$$remove patch for 1 . 6. Fix string comparison between 0 . 1 and 1 . 2. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch22-lang-22_Arja_PatchNaturalnessYe$$fix a numeric equality bug in Fraction. remove patch for 1 . 6. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch51-lang-22_Arja_PatchNaturalnessYe$$remove 582 , as it is not applicable. fixed a small bug. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch16-lang-22_Arja_PatchNaturalnessYe$$Add missing toProperString. remove 583 , as it is not maintained by OpenJDK .. $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch87-lang-22_Arja_PatchNaturalnessYe$$Fix Fraction patch. Fix string comparison in Fraction . equals ( ). $$0
lang-22$$org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)$$The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java 	// additional test cases 	public void testReducedFactory_int_int() { 		// ... 		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); 		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); 		assertEquals(1, f.getDenominator());  	public void testReduce() { 		// ... 		f = Fraction.getFraction(Integer.MIN_VALUE, 2); 		result = f.reduce(); 		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator()); 		assertEquals(1, result.getDenominator());$$patch72-lang-22_Arja_PatchNaturalnessYe$$Add missing toProperString. Fix accidental conversion of inf to int. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch8-chart-1_RSRepair_PatchNaturalnessYe$$Fix category axes. Fix category space rendering in RSRepair_Defects4J_Chart_1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch6-chart-1_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch15-chart-1_RSRepair_PatchNaturalnessYe$$@@ fix colspan error. Fix RSRepair_Defects4J_Chart_1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch12-chart-1_RSRepair_PatchNaturalnessYe$$Fix RSRepair_Defects4J_Chart_1 .. @@ removed return result from last fix. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch7-chart-1_RSRepair_PatchNaturalnessYe$$Fix possible NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch13-chart-1_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch14-chart-1_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch11-chart-1_RSRepair_PatchNaturalnessYe$$Fix minor bug. @@ removed patched line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch16-chart-1_RSRepair_PatchNaturalnessYe$$Remove null check in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch5-chart-1_RSRepair_PatchNaturalnessYe$$Fix bug in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_RSRepair_PatchNaturalnessYe$$Fix category space for rect in RSRepair_Defects4J_Chart_1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch10-chart-1_RSRepair_PatchNaturalnessYe$$Fix category data after last fix. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_RSRepair_PatchNaturalnessYe$$Fix category plot plot. @@ - Remove break line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch4-chart-1_RSRepair_PatchNaturalnessYe$$Remove null check in RSRepair_Defects4J_Chart_1. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_RSRepair_PatchNaturalnessYe$$Corrected a typo in StringUtils. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch8-lang-7_RSRepair_PatchNaturalnessYe$$Fix newline in RSRepair_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch6-lang-7_RSRepair_PatchNaturalnessYe$$removed patch from previous commit , fixes NPE. revert accidently change. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch12-lang-7_RSRepair_PatchNaturalnessYe$$Fix null in RSRepair_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch7-lang-7_RSRepair_PatchNaturalnessYe$$Fix NPE. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch9-lang-7_RSRepair_PatchNaturalnessYe$$Fix newline in RSRepair_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch11-lang-7_RSRepair_PatchNaturalnessYe$$don ' t allow signs in numbers. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch2-lang-7_RSRepair_PatchNaturalnessYe$$Fix null string handling. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch10-lang-7_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch3-lang-7_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Lang_7. $$0
lang-7$$NumberUtils#createNumber - bad behaviour for leading "--"$$NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.$$patch4-lang-7_RSRepair_PatchNaturalnessYe$$removed unused var. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_RSRepair_PatchNaturalnessYe$$Extend StringBuffer to take all string length. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch8-lang-63_RSRepair_PatchNaturalnessYe$$Fix bug in fix month / end of month .. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch1-lang-63_RSRepair_PatchNaturalnessYe$$fix bug. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch6-lang-63_RSRepair_PatchNaturalnessYe$$Fix for leap year. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch15-lang-63_RSRepair_PatchNaturalnessYe$$fix # 435. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch12-lang-63_RSRepair_PatchNaturalnessYe$$Fix for bug 6841215 - Fix for Persian and Urdu language maps .. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch9-lang-63_RSRepair_PatchNaturalnessYe$$fix # 435. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch13-lang-63_RSRepair_PatchNaturalnessYe$$Add fix for bug fix. Updated fix for # 443. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch11-lang-63_RSRepair_PatchNaturalnessYe$$fix empty end fix. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch16-lang-63_RSRepair_PatchNaturalnessYe$$fix # 435. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch5-lang-63_RSRepair_PatchNaturalnessYe$$fix # 435. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch2-lang-63_RSRepair_PatchNaturalnessYe$$Remove years from the duration format. fix # 434. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch17-lang-63_RSRepair_PatchNaturalnessYe$$fix # 435. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch10-lang-63_RSRepair_PatchNaturalnessYe$$Fix bug in fix_defects4J_Lang_63. $$0
lang-63$$DurationFormatUtils returns wrong result$$DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);$$patch4-lang-63_RSRepair_PatchNaturalnessYe$$Remove useless assignment. Fix for bug fix. $$0
mockito-32$$Mockito can't create mock on public class that extends package-private class$$Even if it can't be implemented, I think that mockito should throw some normal exception at time of creation. In my variant on first creation it returns wrong-working mock (invokes real method instead of stubbed). On second creation throws exception that doesn't really connected with problem. Everything works fine if you mock package-private parent.$$patch1-mockito-32_Developer_PatchNaturalness$$added missing import. "Revert "" Mockito . spy ( ) "" was trying to fix the build". $$1
mockito-35$$possible NPE exception when class cannot be mocked via PowerMockito$$In version 1.10.5, the catch block needs to guard against a null proxyInstance.$$patch1-mockito-35_Developer_PatchNaturalness$$fixed the build. fixed nullability assertion. Fix nullability assertion. $$1
mockito-34$$Source files should not be put in binary JAR$$Source files (*.java) should not be put into binary mockito-core.jar. It stupefies Idea to show decompiled file even when source jar is available.$$patch1-mockito-34_Developer_PatchNaturalness$$Fix accidental suppressing of captures from javadoc. $$1
mockito-33$$ArgumentCaptor.fromClass's return type should match a parameterized type$$ArgumentCaptor.fromClass's return type should match a parameterized type. I.e. the expression ArgumentCaptor.fromClass(Class<S>) should be of type ArgumentCaptor<U> where S is a subtype of U. It should type check.$$patch1-mockito-33_Developer_PatchNaturalness$$Improved javadoc in InvocationMatcher. $$1
mockito-20$$Allow convenient spying on abstract classes.$$Mockito is easy to use when the test needs to provide canned values for a certain method. But it gets harder when a canned value isn't sufficient.$$patch1-mockito-20_Developer_PatchNaturalness$$fixed bytebuddy mock maker. fixed name. $$1
mockito-18$$Return empty value for Iterables.$$I expect an Iterable to be mocked by default with an empty Iterable. I understand from the initial issue this behavior would be introduced in Mockito 2, but beta-8 still returns null. Could we return null for Iterables ?$$patch1-mockito-18_Developer_PatchNaturalness$$added ArrayList < Object > to returnsEmptyValues if Iterable is not collection ( remove it ). $$1
mockito-27$$Exception when stubbing more than once with when...thenThrow$$If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction.$$patch1-mockito-27_Developer_PatchNaturalness$$removed unused defaultAnswer. $$1
mockito-9$$Problem spying on abstract classes$$There's a problem with spying on abstract classes when the real implementation calls out to the abstract method.$$patch1-mockito-9_Developer_PatchNaturalness$$added missing import. made the compiler and the build happy. $$1
mockito-11$$Fixed DelegatingMethod.equals() so that it's easier to extend Mockito by custom verification modes$$Currently if you create a DelegatingMethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.Method (without explicitly stating such). This has a knock on effect on the evaluation of InvocationImpl.equals() which at runtime may be using a DelegatingMethod in its .equals().$$patch1-mockito-11_Developer_PatchNaturalness$$added equals ( ) to DelegatingMethod. $$1
mockito-7$$Deep stubbing with generic responses in the call chain is not working$$Deep stubbing will throw an Exception if multiple generics occur in the call chain. For instance, consider having a mock myMock1 that provides a function that returns a generic T. If T also has a function that returns a generic, an Exception with the message "Raw extraction not supported for : 'null'" will be thrown. I think, the issue is that further generics are not possible to be mocked by ReturnsDeepStubsSerializationFallback since the GenericMetadataSupport is "closed" at this point.$$patch1-mockito-7_Developer_PatchNaturalness$$Fix generic metadata support. $$1
mockito-29$$fixed a verify() call example in @Captor javadoc.$$None$$patch1-mockito-29_Developer_PatchNaturalness$$added nullability note. $$1
mockito-16$$Make org.mockito.asm.signature package optional in Import-Packages.$$None$$patch1-mockito-16_Developer_PatchNaturalness$$added resetOngoingStubbing back. added missing semicolon. added missing capitalization. $$1
mockito-6$$Argument matcher anyXxx() (i.e. anyString(), anyList()) should not match nulls$$Note that the function is called with an integer (not a string), and still the mocked function return the value which it should return only when a string is passed. The same works when using anyBoolean() or any other methof from any* family.$$patch1-mockito-6_Developer_PatchNaturalness$$fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. removed unused return type for anyListOf ( ). fixed the build. removed unused return type for anySetOf ( ). Improved javadoc in Matchers. fixed accidental suppressing of errors. fixed the build. fixed leak in Matchers. $$1
mockito-28$$nicer textual printing of typed parameters$$When matchers fail but yield the same toString(), Mockito prints extra type information. However, the type information is awkwardly printed for Strings. I've encountered this issue while working on removing hard dependency to hamcrest.$$patch1-mockito-28_Developer_PatchNaturalness$$removed injected mock. $$1
mockito-17$$Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError).$$If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a VerifyError or a NoClassDefFoundError.$$patch1-mockito-17_Developer_PatchNaturalness$$removed unused import. added serializable setting to MockUtil. made serializable. fixed serialization of Serializable. $$1
mockito-1$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.$$patch1-mockito-1_Developer_PatchNaturalness$$Corrected method name. $$1
mockito-10$$RETURNS_DEEP_STUBS automatically tries to create serializable mocks$$You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue' do not implement Serializable AND do not have a no-arg constructor.$$patch1-mockito-10_Developer_PatchNaturalness$$added missing import. added deep stub mock. added default serialization setting. $$1
mockito-19$$InjectMocks injects mock into wrong field.$$When using @InjectMocks on some Android TextViews, the mock is injected into the wrong field.  We have two fields, txtGateView & txtNextStep in a class, and our test mocks out txtNextStep, then tried to inject. This field is injected wrong. From our quick testing, the name txtNextView doesn't matter, that can be changed. But both txtGateView and txtGateLabel messed things up. If we mock out both fields, it works correctly.$$patch1-mockito-19_Developer_PatchNaturalness$$added missing order. added support for field in configuration. added missing fields in last commit. fixed failing test. added support for field types in configuration. added missing fields configuration. added support for fieldList in configuration. added missing import. added support for field parameters on final Mock candidates. $$1
mockito-26$$use @InjectMocks for final fields.$$I'm trying to upgrade the mockito version that we're using (1.8.5) to a newer version but there is a problem with @InjectMocks which since 1.9.0 doesn't inject into final field anymore.$$patch1-mockito-26_Developer_PatchNaturalness$$added default constructor to Primitives. $$1
mockito-8$$1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.$$None$$patch1-mockito-8_Developer_PatchNaturalness$$Removed unnecessary else condition. $$1
mockito-21$$Allow convenient spying on abstract classes.$$Mockito is easy to use when the test needs to provide canned values for a certain method. But it gets harder when a canned value isn't sufficient.$$patch1-mockito-21_Developer_PatchNaturalness$$added missing semicolon. fixed paramsMatch ( ). $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_Developer_PatchNaturalness$$fixed NPE in ArgumentMatchingTool. $$1
mockito-36$$Make Mockito JUnit rule easier to use$$Mockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.$$patch1-mockito-36_Developer_PatchNaturalness$$removed unused import. can ' t call real method on interface. $$1
mockito-31$$Failing tests on Windows machine$$None$$patch1-mockito-31_Developer_PatchNaturalness$$added missing import. added missing closing paren in method name. $$1
mockito-30$$Failing tests on Windows machine$$None$$patch1-mockito-30_Developer_PatchNaturalness$$added missing source formatting. SmartNullPointerException should never throw anything. $$1
mockito-37$$Make Mockito JUnit rule easier to use$$Mockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.$$patch1-mockito-37_Developer_PatchNaturalness$$fixed failing test. $$1
mockito-24$$fix some rawtype warnings in tests.$$None$$patch1-mockito-24_Developer_PatchNaturalness$$fixed bug. $$1
mockito-23$$WrongTypeOfReturnValue when abstract class have two abstract method.$$This is strange behavior, because the method lol() should not be called, but when I delete one abstract method everything is good.$$patch1-mockito-23_Developer_PatchNaturalness$$fixed the build. fixed NPE in last commit. made serializable. deepStubs support. made serializable. $$1
mockito-4$$java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String$$Exception throws on verifyZeroInteractions when using mock with default answer.$$patch1-mockito-4_Developer_PatchNaturalness$$removed accidental whitespace. Fix left over text. Fix newly introduced API in Reporter. $$1
mockito-15$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.$$patch1-mockito-15_Developer_PatchNaturalness$$added missing import. fixed failing test. $$1
mockito-3$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.$$patch1-mockito-3_Developer_PatchNaturalness$$added missing captureFrom ( ) for parameter matcher. added unique method to InvocationMatcher. $$1
mockito-12$$ArgumentCaptor no longer working for varargs$$When upgrading 1.10.8, the verify passes, but the getValue() fails with this error. One other piece of info came to light as a result of creating the MCVE - the test works fine if the Date is the only element passed for bindVariables. That is, remove "var1" from target and test code, then the test runs fine under 1.9.5 and 1.10.8. Also, it doesn't matter that the captor is for a Date. The same issue occurs if the parameter is of another type, such as Integer.$$patch1-mockito-12_Developer_PatchNaturalness$$added getRawType to GenericMaster. $$1
mockito-2$$Mockito.after() method accepts negative timeperiods and subsequent verifications always pass$$None$$patch1-mockito-2_Developer_PatchNaturalness$$added missing import. Missing validateInput. allow negative durations in Timer. $$1
mockito-13$$fix proposal for #114$$None$$patch1-mockito-13_Developer_PatchNaturalness$$fixed possible NPE in MockAwareVerificationMode. $$1
mockito-5$$Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError)$$If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a VerifyError or a NoClassDefFoundError.$$patch1-mockito-5_Developer_PatchNaturalness$$Fixed the build for javadoc stylesheet. $$1
mockito-14$$fix proposal for #114$$None$$patch1-mockito-14_Developer_PatchNaturalness$$added missing import. fixed the build. added missing import. added missing new method body. $$1
mockito-22$$Can not Return deep stubs from generic method that returns generic type.$$if I try to mock a generic method which a generic returntype, where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you don't use deep stubs and a raw Supplier mock to pass around it works:$$patch1-mockito-22_Developer_PatchNaturalness$$added a null check. $$1
mockito-25$$Null Pointer when invoking Whitebox.invokeMethod() with null one of the params null.$$None$$patch1-mockito-25_Developer_PatchNaturalness$$added missing import. added missing import. added missing return type for deep mocking. deep stub support. added helper method for building deep stubs. $$1
mockito-29$$fixed a verify() call example in @Captor javadoc.$$None$$patch1-mockito-29_PraPR_PatchNaturalness$$Fix appendQuoting ( ). $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_PraPR_PatchNaturalness$$Fix toStringEquals with null arg. $$1
mockito-10$$RETURNS_DEEP_STUBS automatically tries to create serializable mocks$$You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue' do not implement Serializable AND do not have a no-arg constructor.$$patch1-mockito-10_KaliA_PatchNaturalness$$fix merge conflict resolution. $$0
mockito-29$$fixed a verify() call example in @Captor javadoc.$$None$$patch1-mockito-29_CoCoNut_PatchNaturalness$$Fix appendText ( ) with null values .. $$1
mockito-8$$1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.$$None$$patch1-mockito-8_CoCoNut_PatchNaturalness$$Fix contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ). $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_CoCoNut_PatchNaturalness$$Fix toStringEquals in ArgumentMatchingTool. $$1
mockito-22$$Can not Return deep stubs from generic method that returns generic type.$$if I try to mock a generic method which a generic returntype, where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you don't use deep stubs and a raw Supplier mock to pass around it works:$$patch1-mockito-22_GenPat_PatchNaturalness$$added a bit more tidying of the areEqual method. $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_GenPat_PatchNaturalness$$Add null check in ArgumentMatchingTool. $$0
