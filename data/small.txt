math-34$$ListPopulation Iterator allows you to remove chromosomes from the population.$$Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list. Before returning the iterator we should wrap it in an unmodifiable list.$$patch1-math-34_HDRepair_PatchNaturalness$$Fix ListPopulation . iterator ( ). $$1
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_HDRepair_PatchNaturalness$$fixed erroneous loop. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_HDRepair_PatchNaturalness$$Fix NaN - > org . apache . commons . math3 . complex . Complex. $$1
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_HDRepair_PatchNaturalness$$fixed typo .. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_HDRepair_PatchNaturalness$$Use availableLocaleList ( ) instead of cAvailableLocaleSet. $$1
closure-61$$Closure removes needed code.$$None$$patch1-closure-61_Developer_PatchNaturalness$$Fix regexp global references for Math namespaces .. $$1
closure-95$$Use @public tag to prevent compression of symbol names$$None$$patch1-closure-95_Developer_PatchNaturalness$$Fix false positives in TypedScopeCreator. $$1
closure-132$$if statement$$None$$patch1-closure-132_Developer_PatchNaturalness$$don ' t mayEffectMutableState ( lhs ) if lhs is a literal if its side effects. $$1
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_Developer_PatchNaturalness$$"Fix for CB - 7044 "" Compiler does not disable "" GlobalThisLevel . is. $$1
closure-92$$bug with implicit namespaces across modules$$None$$patch1-closure-92_Developer_PatchNaturalness$$Fix code indexing .. $$1
closure-66$$@enum does not type correctly$$None$$patch1-closure-66_Developer_PatchNaturalness$$"Enable "" typeable = false """. $$1
closure-104$$Typos in externs/html5.js$$None$$patch1-closure-104_Developer_PatchNaturalness$$JSType . isNoType ( ) doesn ' t return any type when union type is no. $$1
closure-50$$Optimisation: convert array.join(",") to array.join()$$None$$patch1-closure-50_Developer_PatchNaturalness$$Fix PeepholeReplaceKnownMethods case .. Added reportCodeChange ( ) to replaceKnownMethods case .. $$1
closure-68$$Cryptic error message on invalid "@type function" annotation$$None$$patch1-closure-68_Developer_PatchNaturalness$$Fix the indentation of jsdoc info .. Restore look ahead to the beginning of array or object .. Restore look ahead to the generics compiler error that was spotted by the previous fix .. $$1
closure-103$$Compiler gives false error with respect to unreachable code$$None$$patch1-closure-103_Developer_PatchNaturalness$$Fix an issue with that damn type when checking for properties on objects with properties on them .. Add INSTANCEOF to control flow analysis .. $$1
closure-57$$compiler crashes when  goog.provide used with non string$$None$$patch1-closure-57_Developer_PatchNaturalness$$Fix CodingConvention. $$1
closure-32$$Preserve doesn't preserve whitespace at start of line$$None$$patch1-closure-32_Developer_PatchNaturalness$$Fix the JSDoc info parser ' s line start char .. Reset lineStartChar after each token .. Reset lineStartChar after PRESERVE .. Remove whitespace in JsDocInfoParser. $$1
closure-35$$assignment to object in conditional causes type error on function w/ record type return type$$None$$patch1-closure-35_Developer_PatchNaturalness$$Don ' t define the declared properties of record types as defined in the JSDoc .. $$1
closure-102$$compiler assumes that 'arguments' can be shadowed$$None$$patch1-closure-102_Developer_PatchNaturalness$$Fix jscomp warnings. $$1
closure-69$$Compiler should warn/error when instance methods are operated on$$None$$patch1-closure-69_Developer_PatchNaturalness$$Added missing report in TypeCheck .. $$1
closure-56$$Last warning or error in output is truncated$$None$$patch1-closure-56_Developer_PatchNaturalness$$Don ' t return null if end of file is reached. $$1
closure-105$$Array Join Munged Incorrectly$$None$$patch1-closure-105_Developer_PatchNaturalness$$Allow one - line ifs. Allow null string folding. $$1
closure-51$$-0.0 becomes 0 even in whitespace mode$$None$$patch1-closure-51_Developer_PatchNaturalness$$Fix negative zero log10. Add a method for testing negative zero numbers .. $$1
closure-58$$Online CC bug: report java error.$$None$$patch1-closure-58_Developer_PatchNaturalness$$Fix dead code .. $$1
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_Developer_PatchNaturalness$$Reset unread token on getRemainingJSDocLine ( ) .. $$1
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_Developer_PatchNaturalness$$Add an EXPR_RESULT to the usage list of properties in Java 8 .. $$1
closure-94$$closure-compiler @define annotation does not allow line to be split on 80 characters.$$None$$patch1-closure-94_Developer_PatchNaturalness$$Added define value validation for bit operators .. $$1
closure-60$$void function () {}(); wrongly identified as having no side effects$$None$$patch1-closure-60_Developer_PatchNaturalness$$Allow false / TRUE literals in boolean type arguments .. Allow vars to be used as side effects in JSF. $$1
closure-34$$StackOverflowError exception when running closure compiler (javascript attached)$$None$$patch1-closure-34_Developer_PatchNaturalness$$Fix unrollBinaryOperator. Fix cc issue. Fix appendOp ( ) with comma .. $$1
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_Developer_PatchNaturalness$$Avoid matching against an unreferenced type .. $$1
closure-20$$String conversion optimization is incorrect$$None$$patch1-closure-20_Developer_PatchNaturalness$$AllowImmutableValue to be used as a literal in PeepholeSubstituteAlternateSyntax. $$1
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_Developer_PatchNaturalness$$Don ' t do closure pass if closure pass is used .. $$1
closure-27$$Error trying to build try-catch block (AST)$$None$$patch1-closure-27_Developer_PatchNaturalness$$Add static method to create a block node from StatementStore .. try / finally body must be blocks , not labels .. Allow try / catch to be used as a try / catch statement. $$1
closure-9$$Compiler fails to find amd module in a subdirectory$$None$$patch1-closure-9_Developer_PatchNaturalness$$Fix DOS script for modules .. Remove normalizeSourceName from moduleName so it can be used as a source filename .. $$1
closure-11$$Record type invalid property not reported on function with @this annotation$$None$$patch1-closure-11_Developer_PatchNaturalness$$Remove unnecessary return statement in TypeCheck . java. $$1
closure-7$$Bad type inference with goog.isFunction and friends$$None$$patch1-closure-7_Developer_PatchNaturalness$$Don ' t filter out subtypes of "" function "" if the receiver is a prototype type .". $$1
closure-29$$closure compiler screws up a perfectly valid isFunction() implementation$$None$$patch1-closure-29_Developer_PatchNaturalness$$Add Set < String > .. Fix blacklisting of invalid properties in object literals. Add valid properties to inline object literals. $$1
closure-16$$JSCompiler does not recursively resolve typedefs$$None$$patch1-closure-16_Developer_PatchNaturalness$$Added check for null check in AliasedTypeNode constructor .. Fix scoped aliasing. $$1
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_Developer_PatchNaturalness$$Fix PrepareAst . java. $$1
closure-42$$Simple "Whitespace only" compression removing "each" keyword from "for each (var x in arr)" loop$$None$$patch1-closure-42_Developer_PatchNaturalness$$Add an error if an for - loop is to be used as a standard for ( / ). $$1
closure-89$$Compiler removes function properties that it should not$$None$$patch1-closure-89_Developer_PatchNaturalness$$Allow namespaces for functions .. Add a check forHosedThisReferences. $$1
closure-116$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-116_Developer_PatchNaturalness$$Allow side effects for functions with a return value. Allow side effects in function arguments .. $$1
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_Developer_PatchNaturalness$$Add an internal class to RemoveUnusedVars that can be used as an escape value .. Allow maybeEscaped to be used in assignments where vars are referenced elsewhere. Allow vars to be used as aliased in assignments .. $$1
closure-111$$goog.isArray doesn't hint compiler$$None$$patch1-closure-111_Developer_PatchNaturalness$$Allow array types in closure reverse implementation .. $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_Developer_PatchNaturalness$$Fix typo in codeGenerator where negative latin characters were passed .. $$1
closure-118$$Prototype method incorrectly removed$$None$$patch1-closure-118_Developer_PatchNaturalness$$Allow backslash. $$1
closure-87$$IE8 error: Object doesn't support this action$$None$$patch1-closure-87_Developer_PatchNaturalness$$fixing an issue with isExpressionNode ( ). $$1
closure-127$$Break in finally block isn't optimized properly$$None$$patch1-closure-127_Developer_PatchNaturalness$$Remove node from the unreachable code elimination list .. $$1
closure-80$$Unexpected expression nodeDELPROP 1$$None$$patch1-closure-80_Developer_PatchNaturalness$$improve NodeUtil. Allow delPROP to be used as a literal in simple operators .. $$1
closure-74$$Obvious optimizations don't works in "inline if"$$None$$patch1-closure-74_Developer_PatchNaturalness$$Fix swapped node types in PeepholeFoldConstants .. Fix NOT folding const type .. $$1
closure-120$$Overzealous optimization confuses variables$$None$$patch1-closure-120_Developer_PatchNaturalness$$Fix scoped functions .. $$1
closure-6$$better 'this' type checking$$None$$patch1-closure-6_Developer_PatchNaturalness$$Remove a redundant check .. Remove an unnecessary empty line. Remove a redundant call to registerMismatch ( ) in TypeValidator . expectCanAssignTo ( ). $$1
closure-28$$constant functions not inlined aggressively enough$$None$$patch1-closure-28_Developer_PatchNaturalness$$Add a method for adding constant to inline cost estimate .. $$1
closure-17$$@const dumps type cast information$$None$$patch1-closure-17_Developer_PatchNaturalness$$Don ' t evaluate type - casts in TypedScopeCreator .. $$1
closure-1$$function arguments should not be optimized away$$None$$patch1-closure-1_Developer_PatchNaturalness$$Do not remove unused vars if closure compiler doesn ' t remove globals .. $$1
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_Developer_PatchNaturalness$$Allow mayBeString matchers for regexps. $$1
closure-19$$Type refining of 'this' raises IllegalArgumentException$$None$$patch1-closure-19_Developer_PatchNaturalness$$Fix this case so that it can be refined quickly into the CFG .. $$1
closure-26$$ProcessCommonJSModules module exports failures when checkTypes enabled$$None$$patch1-closure-26_Developer_PatchNaturalness$$Add a field to track modules that export rights of js files .. Do not emit module exports if already emitted .. Add modulesWithExports . add ( moduleName ) to commonJS modules so that it gets. $$1
closure-8$$Obfuscated code triggers TypeError in Firefox$$None$$patch1-closure-8_Developer_PatchNaturalness$$Fix isNamedParameter check. $$1
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_Developer_PatchNaturalness$$Fix CheckSideEffects . java. Disable side - effects check for commas as compiler will infer them. $$1
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_Developer_PatchNaturalness$$Allow null string input.  improve isStrWhiteSpaceChar method. $$1
closure-81$$An unnamed function statement statements should generate a parse error$$None$$patch1-closure-81_Developer_PatchNaturalness$$Add an error if an unnamed function statement is found .. $$1
closure-121$$Overzealous optimization confuses variables$$None$$patch1-closure-121_Developer_PatchNaturalness$$Fix inline vars that are referenced in same ' on demand ' scope .. $$1
closure-119$$catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode$$None$$patch1-closure-119_Developer_PatchNaturalness$$Handle catch / else .. $$1
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch1-closure-86_Developer_PatchNaturalness$$Fix NodeUtil . hasLocalResult for cases where the value was never aliased from inside the. $$1
closure-72$$Internal Compiler Error on Bullet$$None$$patch1-closure-72_Developer_PatchNaturalness$$don ' t remove unused labels by default. Fix RenameLabels for functions with a label name .. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_Developer_PatchNaturalness$$Remove tryMinimizeExitPoints from minimizeExitPoints. $$1
closure-44$$alert(/ / / / /)$$None$$patch1-closure-44_Developer_PatchNaturalness$$Allow forward slash in DIV syntax. $$1
closure-110$$Allow @private top-level functions in goog.scope$$None$$patch1-closure-110_Developer_PatchNaturalness$$Add an error if n . next is not a child of the parent node .. Add isFunctionDecl to declarations in scope. Allow the variadic value to be null in assignments .. Fixing the scoped function definition for NAME .. Fix the scope name for ScopedAliases. fix the scope compiler error. $$1
closure-43$$@lends does not work unless class is defined beforehand$$None$$patch1-closure-43_Developer_PatchNaturalness$$Add a field to store object literals in case of closure compiler error .. Fix memory leak in TypedScopeCreator. Fix lends name for ObjectLit scope creation .. $$1
closure-128$$The compiler quotes the "0" keys in object literals$$None$$patch1-closure-128_Developer_PatchNaturalness$$Fix isSimpleNumber ( ) check for 0. $$1
closure-88$$Incorrect assignment removal from expression in simple mode.$$None$$patch1-closure-88_Developer_PatchNaturalness$$Add a check for isVariableReadBeforeKill ( ) in DeadAssignmentsElimination .. $$1
closure-117$$Wrong type name reported on missing property error.$$None$$patch1-closure-117_Developer_PatchNaturalness$$Fix dereferenced type names for GETPROP .. Remove dereference check for non - constructor fields .. $$1
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_Developer_PatchNaturalness$$Add missing - sign in negative zero - bit code consumer .. $$1
closure-36$$goog.addSingletonGetter prevents unused class removal$$None$$patch1-closure-36_Developer_PatchNaturalness$$Don ' t inline singleton getter methods .. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_Developer_PatchNaturalness$$"Fix the "" skipAllPasses "" flag .". $$1
closure-131$$unicode characters in property names result in invalid output$$None$$patch1-closure-131_Developer_PatchNaturalness$$Allow ' s . charAt ( 0 ) ' to be tokenized by the JavaScript compiler .. $$1
closure-91$$support @lends annotation$$None$$patch1-closure-91_Developer_PatchNaturalness$$Fix check for isObjectLitKey ( ). $$1
closure-65$$String escaping mishandles null byte$$None$$patch1-closure-65_Developer_PatchNaturalness$$Fix CodeGenerator . java. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Developer_PatchNaturalness$$Remove whitespaces from sourceExcerpt. $$1
closure-96$$Missing type-checks for var_args notation$$None$$patch1-closure-96_Developer_PatchNaturalness$$Fix var_args function definition .. $$1
closure-109$$Constructor types that return all or unknown fail to parse$$None$$patch1-closure-109_Developer_PatchNaturalness$$Added missing closing < / > tag in JsDocInfoParser. $$1
closure-100$$Only assignment to "this" issues a "dangerous use of the global this object" warning.$$None$$patch1-closure-100_Developer_PatchNaturalness$$Allow non - partial match in CheckGlobalThis. CheckGlobalThis now reports a THIS with a property access. $$1
closure-54$$Prototype methods can't be used from the constructor in case prototype is explicitly defined.$$None$$patch1-closure-54_Developer_PatchNaturalness$$"fix false alarm in "" Hide "" toolwindow / window type". Remove old prototype from FunctionType . prototype .. Fix the scope compiler warning that gtasks stylesheet stylesheet changed hands .. $$1
closure-107$$Variable names prefixed with MSG_ cause error with advanced optimizations$$None$$patch1-closure-107_Developer_PatchNaturalness$$shut off i18n warnings. $$1
closure-98$$bad variable inlining in closure$$None$$patch1-closure-98_Developer_PatchNaturalness$$Fix for loop references in JSF .. Fix the boolean flags of ReferenceCollectingCallback .. Fix broken reference check .. $$1
closure-53$$compiler-20110811 crashes with index(1) must be less than size(1)$$None$$patch1-closure-53_Developer_PatchNaturalness$$Allow object literals to be replaced with object literals .. Fix object literals going into an empty stream .. $$1
closure-30$$Combining temporary strings are over-optimized in advanced build$$None$$patch1-closure-30_Developer_PatchNaturalness$$Add an unused flag in Definition .. Fix a bug in mustBeReachingVariableDef. Do not mark unknown dependencies as error in mustBeReachingVariableDef .. Fix flow - sensitive inline vars traversal bug. $$1
closure-37$$incomplete function definition crashes the compiler when ideMode is enabled$$None$$patch1-closure-37_Developer_PatchNaturalness$$Added a check for the ide mode property on function bodies .. Add a check for ' body . isBlock ( ) ' at the end of a branch statement. $$1
closure-39$$externExport with @typedef can generate invalid externs$$None$$patch1-closure-39_Developer_PatchNaturalness$$Don ' t use toStringHelper for prototype properties .. Fix toString ( ) of PrototypeObjectType. $$1
closure-106$$Exception thrown from com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties$$None$$patch1-closure-106_Developer_PatchNaturalness$$Allow one - line ifs. The JSDocInfoBuilder does not parse documentation unless populated .. $$1
closure-99$$Prototypes declared with quotes produce a JSC_USED_GLOBAL_THIS warning.$$None$$patch1-closure-99_Developer_PatchNaturalness$$Add isInterface check to fix check for goog . isFunction ( ). Fix CheckGlobalThis . checkGlobalThis ( ) to only traverse the left side if it '. $$1
closure-52$$Converts string properties into numbers in literal object definitions$$None$$patch1-closure-52_Developer_PatchNaturalness$$Fix false positives in getSimpleNumber ( ). $$1
closure-101$$--process_closure_primitives can't be set to false$$None$$patch1-closure-101_Developer_PatchNaturalness$$Fix CommandLineRunner closure pass flag .. $$1
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_Developer_PatchNaturalness$$Allow functions with a parent to be reduced to only uses .. $$1
closure-97$$Unsigned Shift Right (>>>) bug operating on negative numbers$$None$$patch1-closure-97_Developer_PatchNaturalness$$Fix PeepholeFoldConstants case .. $$1
closure-108$$precondition crash: goog.scope local with aliased in the type declaration$$None$$patch1-closure-108_Developer_PatchNaturalness$$Add injectedDecls to declarations in declarations map .. reinitialized vars as injectedDecls is no longer needed. Add $ injectedDecls . add ( newDecl ) to the list of injected declarations .. Fix scoped vars for declarations that are never processed .. $$1
closure-130$$arguments is moved to another scope$$None$$patch1-closure-130_Developer_PatchNaturalness$$"fix for Eclipse "" inExterns "" check". $$1
closure-64$$--language_in=ECMASCRIPT5_STRICT results in 1 'use strict' per input file$$None$$patch1-closure-64_Developer_PatchNaturalness$$Fix an issue with ' use strict ' for compiler .. Added missing semicolon .. $$1
closure-90$$@this emits warning when used with a typedef$$None$$patch1-closure-90_Developer_PatchNaturalness$$Allow null values in function types. Don ' t warn about non - object types .. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_Developer_PatchNaturalness$$Remove equivalent methods from JSType . getLeastSupertype ( ). $$1
closure-79$$RuntimeException when compiling with extern prototype$$None$$patch1-closure-79_Developer_PatchNaturalness$$Add report of var changes in jscomp stylesheet. Add traverseRoots ( ) to the compiler ' s normalize tree .. $$1
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_Developer_PatchNaturalness$$Allow template types to be included in inferred .. $$1
closure-41$$In ADVANCED mode, Compiler fails to warn about overridden methods with different signatures.$$None$$patch1-closure-41_Developer_PatchNaturalness$$Fix copy / paste error in function type builder .. Add missing varargs parameter .. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_Developer_PatchNaturalness$$Allow functions to be run in side effects only from returns .. Remove canBeSideEffected check for function arguments .. $$1
closure-83$$Cannot see version with --version$$None$$patch1-closure-83_Developer_PatchNaturalness$$Catch the exception in CommandLineRunner . parseArguments ( ) .. $$1
closure-77$$\0 \x00 and \u0000 are translated to null character$$None$$patch1-closure-77_Developer_PatchNaturalness$$Fix CodeGenerator . java. $$1
closure-123$$Generates code with invalid for/in left-hand assignment$$None$$patch1-closure-123_Developer_PatchNaturalness$$Fix rhs context for ' in ' operator. $$1
closure-48$$Type checking error when replacing a function with a stub after calling.$$None$$patch1-closure-48_Developer_PatchNaturalness$$Fixing inferred = false for function declarations .. $$1
closure-70$$unexpected typed coverage of less than 100%$$None$$patch1-closure-70_Developer_PatchNaturalness$$Fix swapped arguments in TypedScopeCreator. $$1
closure-84$$Invalid left-hand side of assignment not detected$$None$$patch1-closure-84_Developer_PatchNaturalness$$Add an error if an invalid assignment target is found .. Add an error if we can ' t find a valid assignment target in a function / array .. Fix a bug in validAssignmentTarget ( ). $$1
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_Developer_PatchNaturalness$$Remove an unnecessary loop in ExploitAssigns. $$1
closure-24$$goog.scope doesn't properly check declared functions$$None$$patch1-closure-24_Developer_PatchNaturalness$$Fix scoped alias parsing .. Fix an issue with ' bad parameters ' report from ScopedAliases .. $$1
closure-23$$tryFoldArrayAccess does not check for side effects$$None$$patch1-closure-23_Developer_PatchNaturalness$$Fix PeepholeFoldConstants search for side effects. $$1
closure-4$$Converting from an interface type to a constructor which @implements itself causes stack overflow.$$None$$patch1-closure-4_Developer_PatchNaturalness$$Do not count ` undefined ` and ` undefined ` as cycles in JSType declarations. Do not detect cycles of named types .. $$1
closure-15$$Switched order of "delete key" and "key in" statements changes semantic$$None$$patch1-closure-15_Developer_PatchNaturalness$$Add ability to delete vars in CFG node for DexProp. $$1
closure-3$$optimization fails with variable in catch clause$$None$$patch1-closure-3_Developer_PatchNaturalness$$Fix inline vars canInline with given scope .. Fix canInline .. Add case for FlowSensitiveInlineVariables where the var is used instead of var . parent . var. $$1
closure-12$$Try/catch blocks incorporate code not inside original blocks$$None$$patch1-closure-12_Developer_PatchNaturalness$$Fix bug in MaybeReachingVariableUse . hasExceptionHandler. $$1
closure-85$$Reproduceable crash with switch statement$$None$$patch1-closure-85_Developer_PatchNaturalness$$Stops codeElimination . tryRemoveUnconditionalBranching ( ) at the end. Remove tryRemoveUnconditionalBranching from UnreachableCodeElimination . java. Added a few more code reductions. $$1
closure-71$$no warnings when @private prop is redeclared on subclass$$None$$patch1-closure-71_Developer_PatchNaturalness$$Fix override of non - global properties .. $$1
closure-125$$IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType$$None$$patch1-closure-125_Developer_PatchNaturalness$$Fix TypeCheck . hasInstanceType. $$1
closure-76$$Assignments within conditions are sometimes incorrectly removed$$None$$patch1-closure-76_Developer_PatchNaturalness$$fix the for cycles so they are ignored by the for cycles .. Stops ' die ' on dead  assignments for now .. Missing variable legitimization for AND / OR .. Remove the check for isVariableReadBeforeKill from dead assignments evaluator .. $$1
closure-82$$.indexOf fails to produce missing property warning$$None$$patch1-closure-82_Developer_PatchNaturalness$$Add to the isEmptyType check for isFunctionType. $$1
closure-49$$Incorrect output if a function is assigned to a variable, and the function contains a variable with the same name$$None$$patch1-closure-49_Developer_PatchNaturalness$$Remove function declarations that are never used .. Move the varargs and local variable declarations to the nameStack .. Add LP token to MakeDeclaredNamesUnique , that is , it ' s done in the same. $$1
closure-122$$Inconsistent handling of non-JSDoc comments$$None$$patch1-closure-122_Developer_PatchNaturalness$$Improved regex to match javadoc comments .. $$1
closure-40$$smartNameRemoval causing compiler crash$$None$$patch1-closure-40_Developer_PatchNaturalness$$Fix possible NPE for class - def .. $$1
closure-114$$Crash on the web closure compiler$$None$$patch1-closure-114_Developer_PatchNaturalness$$Fix an issue with ' = ' vs . ' < - ' usage in NameAnalyzer .. $$1
closure-47$$Original source line numbers are one-based in source maps.$$None$$patch1-closure-47_Developer_PatchNaturalness$$Fix source map generation for v1 or v2. Fix map indexing bug in V3 sourcemap due to bad sourcemap indexing .. $$1
closure-113$$Bug in require calls processing$$None$$patch1-closure-113_Developer_PatchNaturalness$$Stops ' provided ' check for broken requires .. $$1
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_Developer_PatchNaturalness$$Fix PeepholeFoldConstants case .. $$1
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_Developer_PatchNaturalness$$Fix TypeCheck . java. $$1
closure-13$$true/false are not always replaced for !0/!1$$None$$patch1-closure-13_Developer_PatchNaturalness$$Fix PeepholeOptimizationsPass. $$1
closure-5$$Compiler ignores 'delete' statements, can break functionality.$$None$$patch1-closure-5_Developer_PatchNaturalness$$Allow delete properties to be inlined if they ' re used as arguments .. $$1
closure-14$$bogus 'missing return' warning$$None$$patch1-closure-14_Developer_PatchNaturalness$$Fix finally map .. $$1
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_Developer_PatchNaturalness$$Allow ' + ' after ' + ' in a for - loop. $$1
closure-25$$anonymous object type inference behavior is different when calling constructors$$None$$patch1-closure-25_Developer_PatchNaturalness$$Remove children in constructor definition .. Remove backwardsInferenceFromCallSite ( n , constructor ) from TypeInference . java. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_Developer_PatchNaturalness$$Fix an issue with time series end index < startIndex. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_Developer_PatchNaturalness$$added p2 . getPathIterator ( null ) to fix looping over PathIterator. $$1
chart-16$$Bug propgated from v1.0.5 on to present$$The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it "Returns the number of series in the dataset (possibly zero)."  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.$$patch1-chart-16_Developer_PatchNaturalness$$Fix an issue with DefaultIntervalCategoryDataset . seriesKeys setter not being used .. Fix bug in DefaultIntervalCategoryDataset. $$1
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_Developer_PatchNaturalness$$deep clone TimeSeries ( super . clone ( ) , this . data ). $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Developer_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Developer_PatchNaturalness$$Set the dataset before using it in MultiplePiePlot .. $$1
chart-2$$Bugs in DatasetUtilities.iterateRangeBounds() methods$$None$$patch1-chart-2_Developer_PatchNaturalness$$Fix NaN values in XY dataset. Fix NaN values in y axis. $$1
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_Developer_PatchNaturalness$$Allow duplicate x values for XYSeries. $$1
math-59$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case "testMinMaxFloat()" because that has a bug too - it tests doubles, not floats.$$patch1-math-59_Developer_PatchNaturalness$$Fix NaN in FastMath . max ( a , b ). $$1
math-104$$Special functions not very accurate$$The Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy, as this is what I'd expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.$$patch1-math-104_Developer_PatchNaturalness$$Updating default gamma value to 10e - 15. $$1
math-68$$LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it$$LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.$$patch1-math-68_Developer_PatchNaturalness$$Added null convergence checker to avoid tuning errors. Fix initial state of the jacobian matrix .. Fix the case of one less pointValuePair. Fix variable initialization. Fix the case for using the vectorial convergence checker. $$1
math-103$$ConvergenceException in normal CDF$$NormalDistributionImpl::cumulativeProbability(double x) throws ConvergenceException if x deviates too much from the mean. For example, when x=+/-100, mean=0, sd=1. Of course the value of the CDF is hard to evaluate in these cases, but effectively it should be either zero or one.$$patch1-math-103_Developer_PatchNaturalness$$Fix max iterations reached in NormalDistributionImpl. $$1
math-35$$Need range checks for elitismRate in ElitisticListPopulation constructors.$$There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.$$patch1-math-35_Developer_PatchNaturalness$$ElitisticListPopulation should set the elitism rate before setting the population .. Set the elitism rate before setting the population .. $$1
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_Developer_PatchNaturalness$$reduce error in SimplexTableau. $$1
math-9$$Line.revert() is imprecise$$Line.revert() only maintains ~10 digits for the direction. This becomes an issue when the line's position is evaluated far from the origin. A simple fix would be to use Vector3D.negate() for the direction. Also, is there a reason why Line is not immutable? It is just comprised of two vectors.$$patch1-math-9_Developer_PatchNaturalness$$revert line direction. $$1
math-11$$MultivariateNormalDistribution.density(double[]) returns wrong value when the dimension is odd$$To reproduce:  Assert.assertEquals(0.398942280401433, new MultivariateNormalDistribution(new double[]{0}, new double[][]{{1}}).density(new double[]{0}), 1e-15);$$patch1-math-11_Developer_PatchNaturalness$$Fix Error. $$1
math-42$$Negative value with restrictNonNegative$$Problem: commons-math-2.2 SimplexSolver. A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver.optimize(function, constraints, GoalType.MINIMIZE, true); Function 1 * x + 1 * y + 0 Constraints: 1 * x + 0 * y = 1 Result: x = 1; y = -1; Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.$$patch1-math-42_Developer_PatchNaturalness$$Fix the case for a null objective function row .. $$1
math-45$$Integer overflow in OpenMapRealMatrix$$computeKey() has an integer overflow. Since it is a sparse matrix, this is quite easily encountered long before heap space is exhausted. The attached code demonstrates the problem, which could potentially be a security vulnerability (for example, if one was to use this matrix to store access control information). Workaround: never create an OpenMapRealMatrix with more cells than are addressable with an int.$$patch1-math-45_Developer_PatchNaturalness$$Add one throw. $$1
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_Developer_PatchNaturalness$$Added a message to the error message. $$1
math-87$$Basic variable is not found correctly in simplex tableau$$The last patch to SimplexTableau caused an automated test suite I'm running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code. SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable, which is incorrect - the entry should have a value equal to 1.$$patch1-math-87_Developer_PatchNaturalness$$epsilon = 1 . 0 ; fixed a small bug in the code. $$1
math-17$$Dfp Dfp.multiply(int x) does not comply with the general contract FieldElement.multiply(int n)$$In class org.apache.commons.math3.Dfp,  the method multiply(int n) is limited to 0 <= n <= 9999. This is not consistent with the general contract of FieldElement.multiply(int n), where there should be no limitation on the values of n.$$patch1-math-17_Developer_PatchNaturalness$$Fix Dfp multiply. $$1
math-1$$Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exception$$An overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction.  For example: double d = 0.5000000001; Fraction f = new Fraction(d, 10); Patch with unit test on way.$$patch1-math-1_Developer_PatchNaturalness$$Don ' t log if q2 > maxDenominator. $$1
math-10$$DerivativeStructure.atan2(y,x) does not handle special cases properly$$The four special cases +/-0 for both x and y should give the same values as Math.atan2 and FastMath.atan2. However, they give NaN for the value in all cases.$$patch1-math-10_Developer_PatchNaturalness$$Add 0 / - 0 value to the result column. $$1
math-19$$Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness function$$If you give large values as lower/upper bounds (for example -Double.MAX_VALUE as a lower bound), the optimizer can call the fitness function with parameters set to NaN.  My guess is this is due to FitnessFunction.encode/decode generating NaN when normalizing/denormalizing parameters.  For example, if the difference between the lower and upper bound is greater than Double.MAX_VALUE, encode could divide infinity by infinity.$$patch1-math-19_Developer_PatchNaturalness$$Add missing exception message. $$1
math-75$$In stat.Frequency, getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)$$Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  {@link #getPct(Comparable)}  as of 2.0      */     @Deprecated     public double getPct(Object v)  {         return getCumPct((Comparable<?>) v);     }$$patch1-math-75_Developer_PatchNaturalness$$Fix getFrequency ( Object ) to return precise value instead of getCumPct ( Object ). $$1
math-72$$Brent solver returns the wrong value if either bracket endpoint is root$$The solve(final UnivariateRealFunction f, final double min, final double max, final double initial) function returns yMin or yMax if min or max are deemed to be roots, respectively, instead of min or max.$$patch1-math-72_Developer_PatchNaturalness$$Fix error in BrentSolver. Fix error in BrentSolver. $$1
math-44$$Incomplete reinitialization with some events handling$$I get a bug with event handling: I track 2 events that occur in the same step, when the first one is accepted, it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I can't give my context, which is rather large, but I tried a patch that works for me, unfortunately it breaks the unit tests.$$patch1-math-44_Developer_PatchNaturalness$$Fix double - precision move from OpenJDK .. Fix double - packaging. Fix an issue with the intermittent double - callback. $$1
math-43$$Statistics.setVarianceImpl makes getStandardDeviation produce NaN$$Invoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use "population variance" for(int i : scores) {   stats.addValue(i); } double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());$$patch1-math-43_Developer_PatchNaturalness$$Fix minor bug in SummaryStatistics. $$1
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_Developer_PatchNaturalness$$removed a redundant line. $$1
math-36$$BigFraction.doubleValue() returns Double.NaN for large numerators or denominators$$The current implementation of doubleValue() divides numerator.doubleValue() / denominator.doubleValue().  BigInteger.doubleValue() fails for any number greater than Double.MAX_VALUE.  So if the user has 308-digit numerator or denominator, the resulting quotient fails, even in cases where the result would be well inside Double's range. I have a patch to fix it, if I can figure out how to attach it here I will.$$patch1-math-36_Developer_PatchNaturalness$$Add exponent shift to BigFraction precision. Don ' t allow NaN values in BigFraction precision range .. $$1
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch1-math-31_Developer_PatchNaturalness$$Remove unused fields. Fix Precision . equals ( dN , 0 . 0 , small ) .. update continuos integration. $$1
math-91$$Fraction.comparTo returns 0 for some differente fractions$$If two different fractions evaluate to the same double due to limited precision, the compareTo methode returns 0 as if they were identical.  // value is roughly PI - 3.07e-18 Fraction pi1 = new Fraction(1068966896, 340262731);  // value is roughly PI + 1.936e-17 Fraction pi2 = new Fraction( 411557987, 131002976);  System.out.println(pi1.doubleValue() - pi2.doubleValue()); // exactly 0.0 due to limited IEEE754 precision System.out.println(pi1.compareTo(pi2)); // display 0 instead of a negative value$$patch1-math-91_Developer_PatchNaturalness$$Fix compareTo ( Fraction ). $$1
math-65$$weight versus sigma in AbstractLeastSquares$$In AbstractLeastSquares, residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS(), these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation, it should multiply the square of the residual even in the computation of the chi2.  Once corrected, getRMS() can even reduce  public double getRMS()  {return Math.sqrt(getChiSquare()/rows);}$$patch1-math-65_Developer_PatchNaturalness$$Remove unnecessary loop. Fix residualsWeights .. $$1
math-30$$Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets$$When performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets), intermediate integer values used in calculateAsymptoticPValue can overflow, leading to invalid results, such as p-values of NaN, or incorrect calculations. Attached is a patch, including a test, and a fix, which modifies the affected code to use doubles$$patch1-math-30_Developer_PatchNaturalness$$removed int because it was too large. $$1
math-99$$MathUtils.gcd(Integer.MIN_VALUE, 0) should throw an Exception instead of returning Integer.MIN_VALUE$$The gcd method should throw an Exception for gcd(Integer.MIN_VALUE, 0), like for gcd(Integer.MIN_VALUE, Integer.MIN_VALUE). The method should only return nonnegative results.$$patch1-math-99_Developer_PatchNaturalness$$Add one exception. Add a throw if we can ' t find the gcd ( ) method. $$1
math-55$$Vector3D.crossProduct is sensitive to numerical cancellation$$Cross product implementation uses the naive formulas (y1 z2 - y2 z1, ...). These formulas fail when vectors are almost colinear, like in the following example:  Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1); Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1); System.out.println(Vector3D.crossProduct(v1, v2));   The previous code displays  { -1, 2, 0 }  instead of the correct answer  { -1, 2, 1 }$$patch1-math-55_Developer_PatchNaturalness$$Fix cross product error in Vector3D .. updated version of Vector3D .. $$1
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_Developer_PatchNaturalness$$Add missing period. $$1
math-64$$Inconsistent result from Levenberg-Marquardt$$Levenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair.  However, the class holds the optimum point, the vector of the objective function, the cost and residuals.  The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost$$patch1-math-64_Developer_PatchNaturalness$$Added missing fields. Fix the jacobian reduction error in LevenbergMarquardtOptimizer . java. Update the QTy function to 1 . 0 . 1. Fix the bug in LevenbergMarquardtOptimizer . java. Added updateResidualsAndCost ( ) if the orthotol is not reached .. Fix a bug in the LevenbergMarquardtOptimizer . determineLMParameter ( ) method where. Remove unused variable. Fixes a false reporting of convergence. Fix a bug in the LevenbergMarquardtOptimizer . java. Remove a redundant check. $$1
math-46$$Division by zero$$In class Complex, division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO, otherwise the result should be INF. See here.$$patch1-math-46_Developer_PatchNaturalness$$Fix MATH - 657. Fix divide by zero error in Complex . doubleValue ( ). $$1
math-41$$One of Variance.evaluate() methods does not work correctly$$The method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[] values, double[] weights, double mean, int begin, int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.$$patch1-math-41_Developer_PatchNaturalness$$Fix the for - loop of Variance , added missing begin / length. $$1
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_Developer_PatchNaturalness$$Added a missing import. Using a single threaded approach to improve performance. $$1
math-24$$"BrentOptimizer" not always reporting the best point$$BrentOptimizer (package "o.a.c.m.optimization.univariate") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.$$patch1-math-24_Developer_PatchNaturalness$$Fix a redundant line. Set isMinim = false in BrentOptimizer. $$1
math-23$$"BrentOptimizer" not always reporting the best point$$BrentOptimizer (package "o.a.c.m.optimization.univariate") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.$$patch1-math-23_Developer_PatchNaturalness$$Fix error in Brent optimization .. Fix a redundant line. Set isMinim = true in BrentOptimizer. $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_Developer_PatchNaturalness$$Fixed a crash in SubLine . intersection ( ) .. $$1
math-3$$ArrayIndexOutOfBoundsException in MathArrays.linearCombination$$When MathArrays.linearCombination is passed arguments with length 1, it throws an ArrayOutOfBoundsException. This is caused by this line: double prodHighNext = prodHigh[1]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.$$patch1-math-3_Developer_PatchNaturalness$$Revert to scalar multiplication .. $$1
math-12$$GammaDistribution cloning broken$$Serializing a GammaDistribution and deserializing it, does not result in a cloned distribution that produces the same samples. Cause: GammaDistribution inherits from AbstractRealDistribution, which implements Serializable. AbstractRealDistribution has random, in which we have a Well19937c instance, which inherits from AbstractWell. AbstractWell implements Serializable. AbstractWell inherits from BitsStreamGenerator, which is not Serializable, but does have a private field 'nextGaussian'. Solution: Make BitStreamGenerator implement Serializable as well. This probably affects other distributions as well.$$patch1-math-12_Developer_PatchNaturalness$$Remove unused import. Fixed serialization issue in BitsStreamGenerator. $$1
math-47$$Division by zero$$In class Complex, division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO, otherwise the result should be INF. See here.$$patch1-math-47_Developer_PatchNaturalness$$Fixing the build. Add the isZero check. Fix divide by zero error in Complex . java. Fix divide by zero error in Complex .. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_Developer_PatchNaturalness$$Fix NaN - > INF in Complex. $$1
math-25$$"HarmonicFitter.ParameterGuesser" sometimes fails to return sensible values$$The inner class "ParameterGuesser" in "HarmonicFitter" (package "o.a.c.m.optimization.fitting") fails to compute a usable guess for the "amplitude" parameter.$$patch1-math-25_Developer_PatchNaturalness$$Add a throw if the 2 == 0 denominator is not sufficient to work properly .. $$1
time-20$$Errors creating/parsing dates with specific time zones.$$The results are out of 572 time zones 130 fail and 30 throw exceptions.  The failures are the most interesting. When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka. When I take that id and create a date time with it its time zone id is America/Adak. It is like there are multiple list of time zones in Joda time and they are out of sync.$$patch1-time-20_Developer_PatchNaturalness$$Fix DateTimeParserBuilder # parseInto ( ) where the best id was not found .. $$1
time-18$$GJChronology rejects valid Julian dates$$The 2nd statement fails with "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]".  Given that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?$$patch1-time-18_Developer_PatchNaturalness$$Fixed a bug in GJChronology . getDateTimeMillis + ( year , monthOfYear. $$1
time-27$$Different behaviour of PeriodFormatter$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.$$patch1-time-27_Developer_PatchNaturalness$$Fix extra parsing when PeriodFormatter . iAfterParser and PeriodFormatter . iAfterPrinter are not. $$1
time-9$$Ensure there is a max/min valid offset$$DateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.$$patch1-time-9_Developer_PatchNaturalness$$Add the MAX_MILLIS constant to DateTimeZone .. Fix hoursOffset value out of range .. throw exception if offset is out of range. $$1
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_Developer_PatchNaturalness$$Fix DateTimeFormatter year parser bug. $$1
time-6$$Questionable behaviour of GJChronology when dates pass 1BC$$I expect the following test to pass:  However, I never provided "0" for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?$$patch1-time-6_Developer_PatchNaturalness$$Throw an exception if we run into an errant year. ConvertByWeekyear to year if gap was crossed .. convert weekyear to gregorian. $$1
time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).$$patch1-time-17_Developer_PatchNaturalness$$Fix an overlap between twoUTC - > GMT. $$1
time-1$$Partial.with fails with NPE$$Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.$$patch1-time-1_Developer_PatchNaturalness$$Fix errors found by previous fix .. Remove useless compareTo ( ) method. $$1
time-10$$Days#daysBetween throw exception for MonthDay with 29 February$$Is there a way to avoid this happening? I understand fiddling around with the leap year, you're bound to get issues.$$patch1-time-10_Developer_PatchNaturalness$$Added START_1972 to BaseSingleFieldPeriod. Fix # 109 , merge issues with Chronology. $$1
time-26$$.withHourOfDay() sets hour inconsistantly on DST transition.$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.$$patch1-time-26_Developer_PatchNaturalness$$Fixed a bug in DateTimeZone . convertLocalToUTC ( long , boolean ). $$1
time-8$$DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hour$$DateTimeZone.forOffsetHoursMinutes(h,m) cannot handle negative offset < 1 hour like -0:30 due to argument range checking. I used forOffsetMillis() instead.  This should probably be mentioned in the documentation or negative minutes be accepted.$$patch1-time-8_Developer_PatchNaturalness$$Fix errors. $$1
time-24$$Incorrect date parsed when week and month used together$$It should print 2011-01-03 but it is printing 2010-01-04.$$patch1-time-24_Developer_PatchNaturalness$$Don ' t reset fields on parse ( ) .. $$1
time-23$$Incorrect mapping of the MET time zone$$This timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time.$$patch1-time-23_Developer_PatchNaturalness$$Fixed bug in DateTimeZone. ISO 639 - 2 ( Australia / New_York ). $$1
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_Developer_PatchNaturalness$$Fix partial constructor to validate values with chronoology. $$1
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_Developer_PatchNaturalness$$Add an error if safeMultiply ( long , int ) overflows a long. $$1
time-3$$addDays(0) changes value of MutableDateTime$$Upon DST transition from summer to winter time zone, adding the amount of zero days to a mutable date time object changes the value of the object. The methods addMonths and addYears show the same problem; addSeconds, addMinutes and addHours are ok.  I have tested with version 2.3. However, if I repeat the test with Joda 1.5.2, the invocation of addDays(0) does not change the date's value.$$patch1-time-3_Developer_PatchNaturalness$$Fixed # 7751. Add years to MutableDateTime. Add weekyears ( ). Fix month - wise operation .. Add weeks method to MutableDateTime. Adding missing method to MutableDateTime # addDays ( ). Add hours to MutableDateTime. Adding minutes to MutableDateTime. Add seconds to MutableDateTime. AddMillis ( ) where the chrono doesn ' t take an 0 or less precision .. $$1
time-12$$Check Calendar.ERA in LocalDate.fromCalendarFields$$None$$patch1-time-12_Developer_PatchNaturalness$$Add the era to the LocalDateTime object .. Handle years in era BC .. Add the era value as a dependency of LocalDate .. Handle years in era BC .. $$1
time-2$$Partial.with fails with NPE$$Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.$$patch1-time-2_Developer_PatchNaturalness$$Fix compareTo ( ) of UnsupportedDurationField. Fix a typo in Partial . java. Added missing break in Partial where duration field is null. $$1
time-13$$Negative millis display incorrectly in Period.toString$$The last line should produce "PT-0.100S" instead of "PT0.100S".$$patch1-time-13_Developer_PatchNaturalness$$prepare 0 . 5 + for the abs value. Parser should print digits without spaces ( fixes # 507 ). Handle calendar year year input format change. $$1
time-5$$none standard PeriodType without year throws exception$$I tried to get a Period only for months and weeks with following code:  This throws following exception:  Even removing the year component with .withYearsRemoved() throws the same exception:$$patch1-time-5_Developer_PatchNaturalness$$Fix bug in Period # withMonths. $$1
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_Developer_PatchNaturalness$$Fix bug # 1216162 , year field added after month - of - year. $$1
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch1-lang-50_Developer_PatchNaturalness$$Fix compiler warning. Fix possible NPE in FastDateFormat. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_Developer_PatchNaturalness$$Fixed bug in LocaleUtils # isAvailableLocale ( ). $$1
lang-32$$Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments$$The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.$$patch1-lang-32_Developer_PatchNaturalness$$Fix compile error. Fixed NPE in HashCodeBuilder. Fixes # 125. Fixed race condition. $$1
lang-56$$FastDateFormat.mRules is not transient or serializable$$Reported by FindBugs. Either we need to make the Rule interface Serializable, or make mRules transient and add deserializing code to kick off init().$$patch1-lang-56_Developer_PatchNaturalness$$Fix the merge of one - to - one calls into conference calls. Fixing deserialization problem with FastDateFormat. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Developer_PatchNaturalness$$missing break in BooleanUtils. $$1
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Developer_PatchNaturalness$$isDigits ( numeric ) fix. $$1
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_Developer_PatchNaturalness$$StrBuilder . contains ( char ) doesn ' t compare length - > index .. StrBuilder ' s loop through the buffer to the end of a string .. $$1
lang-34$$Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments$$The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.$$patch1-lang-34_Developer_PatchNaturalness$$Remove null check. Add null check in ToStringStyle to prevent NPE .. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Developer_PatchNaturalness$$removed null check. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_Developer_PatchNaturalness$$Fix bug in StringUtils. Removed unnecessary copy of StringUtils. $$1
lang-18$$FastDateFormat formats year differently than SimpleDateFormat in Java 7$$Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.$$patch1-lang-18_Developer_PatchNaturalness$$Fix year field. $$1
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_Developer_PatchNaturalness$$formatting fixes. Handle exponent overflow in NumberUtils. $$1
lang-9$$FastDateParser does not handle unterminated quotes correctly$$FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: 'd'd' Date: d3 This should fail to parse the format and date but it actually works. The format is parsed as: Pattern: d(\p {IsNd} ++)$$patch1-lang-9_Developer_PatchNaturalness$$Allow user to specify which region to use for a date. $$1
lang-11$$RandomStringUtils throws confusing IAE when end <= start$$RandomUtils invokes Random#nextInt where n = end - start. If end <= start, then Random throws: java.lang.IllegalArgumentException: n must be positive This is confusing, and does not identify the source of the problem.$$patch1-lang-11_Developer_PatchNaturalness$$Added a throw exception if end < start. $$1
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_Developer_PatchNaturalness$$Improved startsWith method. $$1
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Developer_PatchNaturalness$$set lower to the length of the string. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_Developer_PatchNaturalness$$Don ' t add backslash .. $$1
lang-19$$StringIndexOutOfBoundsException when calling unescapeHtml4("&#03")$$When calling unescapeHtml4() on the String "&#03" (or any String that contains these characters) an Exception is thrown: Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 4 	at java.lang.String.charAt(String.java:686) 	at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49) 	at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88) 	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60) 	at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)$$patch1-lang-19_Developer_PatchNaturalness$$Remove translation of & sign in NumericEntityUnescaper. don ' t put a ; in the end of a string in the translator ' s range to. don ' t put semiNext = 1 in NumericEntityUnescaper. $$1
lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)$$patch1-lang-21_Developer_PatchNaturalness$$FixedDateUtils . java. $$1
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Developer_PatchNaturalness$$allow isDigits in Strings. $$1
lang-65$$[lang] DateUtils.truncate method is buggy when dealing with DST switching hours$$Try to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10- 31 01:00:00 MST, which is one hour after the input hour.     // truncate 2004-10-31 01:00:00 MDT     Date oct31_01MDT = new Date(1099206000000L);         Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);     assertEquals(oct31_01MDT, result);$$patch1-lang-65_Developer_PatchNaturalness$$Fixed for YEAR and month. Fixed bug in DateUtils where negative value for field is found. Fixed erroneous loop in DateUtils. $$1
lang-37$$ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed types very well$$ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed array types very well. The stack trace for  Number[] st = ArrayUtils.addAll(new Integer[] {1} , new Long[] {2L} ); starts: java.lang.ArrayStoreException 	at java.lang.System.arraycopy(Native Method) 	at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962) which is not all that obvious. It would be a lot clearer if the method threw an IlegalArgumentException or similar.$$patch1-lang-37_Developer_PatchNaturalness$$rethrow array store exception. $$1
lang-64$$ValuedEnum.compareTo(Object other) not typesafe - it easily could be...$$int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  is not typesafe - if the int-values are the same, it will return "0" even for two totally different sub-classes of ValuedEnum$$patch1-lang-64_Developer_PatchNaturalness$$Fix compare to valued enum. Added a method in ValuedEnum that works with the class loader. $$1
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_Developer_PatchNaturalness$$Fix Eclipse warning. adding arrayPrefix. Fixed ClassUtils . getPackageName ( ) where the class name was null and the length was empty. $$1
lang-48$$EqualsBuilder don't compare BigDecimals correctly$$When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.$$patch1-lang-48_Developer_PatchNaturalness$$fixed big number case. $$1
lang-3$$Method createNumber from NumberUtils doesn't work for floating point numbers other than Float$$Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.$$patch1-lang-3_Developer_PatchNaturalness$$Fix Issue # 590. $$1
lang-12$$RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException$$In commons-lang 2.6 line 250 :  ch = chars[random.nextInt(gap) + start];  This line of code takes a random int to fetch a char in the chars array regardless of its size. (Besides start is useless here) Fixed version would be :  //ch = chars[random.nextInt(gap)%chars.length];  When user pass 0 as end or when the array is not null but empty this line ends up with an exception$$patch1-lang-12_Developer_PatchNaturalness$$Fixed NPE in RandomStringUtils such that the array is not empty .. $$1
lang-49$$infinite loop in Fraction.reduce when numerator == 0$$Summary pretty much says it all.$$patch1-lang-49_Developer_PatchNaturalness$$Fixed a bug in Fraction . reduce ( ) where the numerator = 0 would trigger an inf. $$1
lang-40$$Fix case-insensitive string handling$$String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.$$patch1-lang-40_Developer_PatchNaturalness$$Improved javadoc in StringUtils. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_Developer_PatchNaturalness$$Add 0 / width if width is not > 0. Don ' t append null string to the builder .. $$1
lang-5$$LocaleUtils.toLocale does not parse strings starting with an underscore$$Hi, Javadocs of Locale.toString() states that "If the language is missing, the string will begin with an underbar.". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString(). The fix for the ticket 328 does not handle well the case "fr__P", which I found out during fixing the first bug. I am attaching the patch for both problems.$$patch1-lang-5_Developer_PatchNaturalness$$Missing locale info for _ to work properly. Missing closing @@. $$1
mockito-32$$Mockito can't create mock on public class that extends package-private class$$Even if it can't be implemented, I think that mockito should throw some normal exception at time of creation. In my variant on first creation it returns wrong-working mock (invokes real method instead of stubbed). On second creation throws exception that doesn't really connected with problem. Everything works fine if you mock package-private parent.$$patch1-mockito-32_Developer_PatchNaturalness$$added missing import. "Revert "" Mockito . spy ( ) "" was trying to fix the build". $$1
mockito-35$$possible NPE exception when class cannot be mocked via PowerMockito$$In version 1.10.5, the catch block needs to guard against a null proxyInstance.$$patch1-mockito-35_Developer_PatchNaturalness$$fixed the build. fixed nullability assertion. Fix nullability assertion. $$1
mockito-34$$Source files should not be put in binary JAR$$Source files (*.java) should not be put into binary mockito-core.jar. It stupefies Idea to show decompiled file even when source jar is available.$$patch1-mockito-34_Developer_PatchNaturalness$$Fix accidental suppressing of captures from javadoc. $$1
mockito-33$$ArgumentCaptor.fromClass's return type should match a parameterized type$$ArgumentCaptor.fromClass's return type should match a parameterized type. I.e. the expression ArgumentCaptor.fromClass(Class<S>) should be of type ArgumentCaptor<U> where S is a subtype of U. It should type check.$$patch1-mockito-33_Developer_PatchNaturalness$$Improved javadoc in InvocationMatcher. $$1
mockito-20$$Allow convenient spying on abstract classes.$$Mockito is easy to use when the test needs to provide canned values for a certain method. But it gets harder when a canned value isn't sufficient.$$patch1-mockito-20_Developer_PatchNaturalness$$fixed bytebuddy mock maker. fixed name. $$1
mockito-18$$Return empty value for Iterables.$$I expect an Iterable to be mocked by default with an empty Iterable. I understand from the initial issue this behavior would be introduced in Mockito 2, but beta-8 still returns null. Could we return null for Iterables ?$$patch1-mockito-18_Developer_PatchNaturalness$$added ArrayList < Object > to returnsEmptyValues if Iterable is not collection ( remove it ). $$1
mockito-27$$Exception when stubbing more than once with when...thenThrow$$If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction.$$patch1-mockito-27_Developer_PatchNaturalness$$removed unused defaultAnswer. $$1
mockito-9$$Problem spying on abstract classes$$There's a problem with spying on abstract classes when the real implementation calls out to the abstract method.$$patch1-mockito-9_Developer_PatchNaturalness$$added missing import. made the compiler and the build happy. $$1
mockito-11$$Fixed DelegatingMethod.equals() so that it's easier to extend Mockito by custom verification modes$$Currently if you create a DelegatingMethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.Method (without explicitly stating such). This has a knock on effect on the evaluation of InvocationImpl.equals() which at runtime may be using a DelegatingMethod in its .equals().$$patch1-mockito-11_Developer_PatchNaturalness$$added equals ( ) to DelegatingMethod. $$1
mockito-29$$fixed a verify() call example in @Captor javadoc.$$None$$patch1-mockito-29_Developer_PatchNaturalness$$added nullability note. $$1
mockito-16$$Make org.mockito.asm.signature package optional in Import-Packages.$$None$$patch1-mockito-16_Developer_PatchNaturalness$$added resetOngoingStubbing back. added missing semicolon. added missing capitalization. $$1
mockito-6$$Argument matcher anyXxx() (i.e. anyString(), anyList()) should not match nulls$$Note that the function is called with an integer (not a string), and still the mocked function return the value which it should return only when a string is passed. The same works when using anyBoolean() or any other methof from any* family.$$patch1-mockito-6_Developer_PatchNaturalness$$fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. fixed the build. removed unused return type for anyListOf ( ). fixed the build. removed unused return type for anySetOf ( ). Improved javadoc in Matchers. fixed accidental suppressing of errors. fixed the build. fixed leak in Matchers. $$1
mockito-28$$nicer textual printing of typed parameters$$When matchers fail but yield the same toString(), Mockito prints extra type information. However, the type information is awkwardly printed for Strings. I've encountered this issue while working on removing hard dependency to hamcrest.$$patch1-mockito-28_Developer_PatchNaturalness$$removed injected mock. $$1
mockito-17$$Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError).$$If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a VerifyError or a NoClassDefFoundError.$$patch1-mockito-17_Developer_PatchNaturalness$$removed unused import. added serializable setting to MockUtil. made serializable. fixed serialization of Serializable. $$1
mockito-10$$RETURNS_DEEP_STUBS automatically tries to create serializable mocks$$You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue' do not implement Serializable AND do not have a no-arg constructor.$$patch1-mockito-10_Developer_PatchNaturalness$$added missing import. added deep stub mock. added default serialization setting. $$1
mockito-19$$InjectMocks injects mock into wrong field.$$When using @InjectMocks on some Android TextViews, the mock is injected into the wrong field.  We have two fields, txtGateView & txtNextStep in a class, and our test mocks out txtNextStep, then tried to inject. This field is injected wrong. From our quick testing, the name txtNextView doesn't matter, that can be changed. But both txtGateView and txtGateLabel messed things up. If we mock out both fields, it works correctly.$$patch1-mockito-19_Developer_PatchNaturalness$$added missing order. added support for field in configuration. added missing fields in last commit. fixed failing test. added support for field types in configuration. added missing fields configuration. added support for fieldList in configuration. added missing import. added support for field parameters on final Mock candidates. $$1
mockito-26$$use @InjectMocks for final fields.$$I'm trying to upgrade the mockito version that we're using (1.8.5) to a newer version but there is a problem with @InjectMocks which since 1.9.0 doesn't inject into final field anymore.$$patch1-mockito-26_Developer_PatchNaturalness$$added default constructor to Primitives. $$1
mockito-8$$1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.$$None$$patch1-mockito-8_Developer_PatchNaturalness$$Removed unnecessary else condition. $$1
mockito-21$$Allow convenient spying on abstract classes.$$Mockito is easy to use when the test needs to provide canned values for a certain method. But it gets harder when a canned value isn't sufficient.$$patch1-mockito-21_Developer_PatchNaturalness$$added missing semicolon. fixed paramsMatch ( ). $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_Developer_PatchNaturalness$$fixed NPE in ArgumentMatchingTool. $$1
mockito-36$$Make Mockito JUnit rule easier to use$$Mockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.$$patch1-mockito-36_Developer_PatchNaturalness$$removed unused import. can ' t call real method on interface. $$1
mockito-31$$Failing tests on Windows machine$$None$$patch1-mockito-31_Developer_PatchNaturalness$$added missing import. added missing closing paren in method name. $$1
mockito-30$$Failing tests on Windows machine$$None$$patch1-mockito-30_Developer_PatchNaturalness$$added missing source formatting. SmartNullPointerException should never throw anything. $$1
mockito-37$$Make Mockito JUnit rule easier to use$$Mockito JUnit rule easier to use by avoiding the need to pass test instance. Make it compatible with JUnit 4.7+ instead of 4.9+.$$patch1-mockito-37_Developer_PatchNaturalness$$fixed failing test. $$1
mockito-24$$fix some rawtype warnings in tests.$$None$$patch1-mockito-24_Developer_PatchNaturalness$$fixed bug. $$1
mockito-23$$WrongTypeOfReturnValue when abstract class have two abstract method.$$This is strange behavior, because the method lol() should not be called, but when I delete one abstract method everything is good.$$patch1-mockito-23_Developer_PatchNaturalness$$fixed the build. fixed NPE in last commit. made serializable. deepStubs support. made serializable. $$1
mockito-4$$java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String$$Exception throws on verifyZeroInteractions when using mock with default answer.$$patch1-mockito-4_Developer_PatchNaturalness$$removed accidental whitespace. Fix left over text. Fix newly introduced API in Reporter. $$1
mockito-2$$Mockito.after() method accepts negative timeperiods and subsequent verifications always pass$$None$$patch1-mockito-2_Developer_PatchNaturalness$$added missing import. Missing validateInput. allow negative durations in Timer. $$1
mockito-13$$fix proposal for #114$$None$$patch1-mockito-13_Developer_PatchNaturalness$$fixed possible NPE in MockAwareVerificationMode. $$1
mockito-5$$Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError)$$If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a VerifyError or a NoClassDefFoundError.$$patch1-mockito-5_Developer_PatchNaturalness$$Fixed the build for javadoc stylesheet. $$1
mockito-14$$fix proposal for #114$$None$$patch1-mockito-14_Developer_PatchNaturalness$$added missing import. fixed the build. added missing import. added missing new method body. $$1
mockito-22$$Can not Return deep stubs from generic method that returns generic type.$$if I try to mock a generic method which a generic returntype, where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you don't use deep stubs and a raw Supplier mock to pass around it works:$$patch1-mockito-22_Developer_PatchNaturalness$$added a null check. $$1
mockito-25$$Null Pointer when invoking Whitebox.invokeMethod() with null one of the params null.$$None$$patch1-mockito-25_Developer_PatchNaturalness$$added missing import. added missing import. added missing return type for deep mocking. deep stub support. added helper method for building deep stubs. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_SketchFix_PatchNaturalness$$Fix try / catch in minimizeExitPoints. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_SketchFix_PatchNaturalness$$Fix empty range in TimeSeries. $$1
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_SketchFix_PatchNaturalness$$reduce error in SimplexTableau. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_SketchFix_PatchNaturalness$$Improved nullability in CategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_SketchFix_PatchNaturalness$$Fix CategoryItemRenderer to handle non - null datasets. $$0
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_SketchFix_PatchNaturalness$$Fix minor bug in SimplexSolver . compareTo ( double , double , double , double ) .. Added minRatioPositions . size ( ) == 0 ? null : minRatioPositions. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_SketchFix_PatchNaturalness$$fixed erroneous loop. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch2-math-70_SketchFix_PatchNaturalness$$fixed erroneous loop. fixed a bug in BisectionSolver. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_DynaMoth_PatchNaturalness$$don ' t sort XYSeries by default. $$0
math-41$$One of Variance.evaluate() methods does not work correctly$$The method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[] values, double[] weights, double mean, int begin, int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.$$patch1-math-41_DynaMoth_PatchNaturalness$$Fix the var test .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_DynaMoth_PatchNaturalness$$missing if (. $$0
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_Elixir_PatchNaturalness$$Fix fieldUtils. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_Elixir_PatchNaturalness$$Fixed LocaleUtils # isAvailableLocale ( ). $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Elixir_PatchNaturalness$$Fix NPE triggered by nullability exception. $$1
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_Elixir_PatchNaturalness$$Fix an issue with TimeSeries . delete ( ) where the start < end would throw an exception. Fix bug in TimeSeries . clone. $$0
math-104$$Special functions not very accurate$$The Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy, as this is what I'd expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.$$patch1-math-104_Elixir_PatchNaturalness$$reduce gamma term max iterations. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_Elixir_PatchNaturalness$$changed BrentSolver to solve with provided initial guess. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_Elixir_PatchNaturalness$$Fix MathUtils . equals. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Elixir_PatchNaturalness$$missing closing paren in BooleanUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Elixir_PatchNaturalness$$isDigits ( numeric ) will ignore - > long. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Elixir_PatchNaturalness$$Fix parseLong ( ) where - > parseLong ( ) works. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch1-closure-92_PraPR_PatchNaturalness$$Fix up whitespace. $$1
closure-93$$bug with implicit namespaces across modules$$None$$patch1-closure-93_PraPR_PatchNaturalness$$remove lastIndexOf. $$1
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_PraPR_PatchNaturalness$$remove 1287 from the closure pass condition. $$1
closure-11$$Record type invalid property not reported on function with @this annotation$$None$$patch1-closure-11_PraPR_PatchNaturalness$$Fix wrong closing curly brace in object literals. $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_PraPR_PatchNaturalness$$Remove spurious check for UTF - 8 .. $$1
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_PraPR_PatchNaturalness$$Remove mayBeStringHelper from matchAll. $$1
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch1-closure-86_PraPR_PatchNaturalness$$Updated lookahead for the NEW value keyword. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_PraPR_PatchNaturalness$$Remove ' finally ' keyword from ' try / rescue '. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_PraPR_PatchNaturalness$$improve comment. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_PraPR_PatchNaturalness$$Remove the if (. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_PraPR_PatchNaturalness$$Improved performance for record types .. $$1
closure-70$$unexpected typed coverage of less than 100%$$None$$patch1-closure-70_PraPR_PatchNaturalness$$Fix jsDoc parameter definition for function parameters .. $$1
closure-14$$bogus 'missing return' warning$$None$$patch1-closure-14_PraPR_PatchNaturalness$$Fixing finally map .. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_PraPR_PatchNaturalness$$Remove redundant code. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_PraPR_PatchNaturalness$$Fix nullability assertion .. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_PraPR_PatchNaturalness$$Fix 144 bug. $$1
math-59$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case "testMinMaxFloat()" because that has a bug too - it tests doubles, not floats.$$patch1-math-59_PraPR_PatchNaturalness$$Fix 3481 test. $$1
math-34$$ListPopulation Iterator allows you to remove chromosomes from the population.$$Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list. Before returning the iterator we should wrap it in an unmodifiable list.$$patch1-math-34_PraPR_PatchNaturalness$$Fix # 12. $$1
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_PraPR_PatchNaturalness$$Removing epsilon from tableau test .. $$1
math-75$$In stat.Frequency, getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)$$Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  {@link #getPct(Comparable)}  as of 2.0      */     @Deprecated     public double getPct(Object v)  {         return getCumPct((Comparable<?>) v);     }$$patch1-math-75_PraPR_PatchNaturalness$$Fix an issue with getPct that was being too verbose .. $$1
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_PraPR_PatchNaturalness$$fixed a typo in solve ( ). $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_PraPR_PatchNaturalness$$Extend the definition of INF .. $$1
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_PraPR_PatchNaturalness$$Added transition marker. $$1
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_PraPR_PatchNaturalness$$Fix partial constructor to not use iChronology directly in the partial constructor. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_PraPR_PatchNaturalness$$@@ isAvailableLocale ( ) , removed 222 from the comment. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_PraPR_PatchNaturalness$$I don ' t really see a justification for doing a whitespace in a string ( changed by the. $$1
mockito-29$$fixed a verify() call example in @Captor javadoc.$$None$$patch1-mockito-29_PraPR_PatchNaturalness$$Fix appendQuoting ( ). $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_PraPR_PatchNaturalness$$Fix toStringEquals with null arg. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_CapGen_PatchNaturalness$$fix merge issue. $$1
math-65$$weight versus sigma in AbstractLeastSquares$$In AbstractLeastSquares, residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS(), these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation, it should multiply the square of the residual even in the computation of the chi2.  Once corrected, getRMS() can even reduce  public double getRMS()  {return Math.sqrt(getChiSquare()/rows);}$$patch1-math-65_CapGen_PatchNaturalness$$Fix residualsWeights .. $$1
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_CapGen_PatchNaturalness$$Fix a bug in MathUtils . equals ( double , double , int ). $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_CapGen_PatchNaturalness$$Use the available locale list. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch2-lang-57_CapGen_PatchNaturalness$$Use new java . util . HashSet ( ) instead of cAvailableLocaleSet. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch3-lang-57_CapGen_PatchNaturalness$$Fixed bug in LocaleUtils. $$1
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch8-math-63_CapGen_PatchNaturalness$$Add missing MathUtils . equals ( double ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_CapGen_PatchNaturalness$$Fix MathUtils . equals ( double , double , int ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch6-math-63_CapGen_PatchNaturalness$$Fix MathUtils . equals ( double , double ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch7-math-63_CapGen_PatchNaturalness$$Fix MathUtils . equals ( double , double ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch5-math-63_CapGen_PatchNaturalness$$Fix MathUtils . equals ( double , double ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch2-math-63_CapGen_PatchNaturalness$$Fix a bug in MathUtils . equals. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch3-math-63_CapGen_PatchNaturalness$$Fix MathUtils . equals ( double , double ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch4-math-63_CapGen_PatchNaturalness$$Add missing MathUtils . equals ( ). $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_CapGen_PatchNaturalness$$Add a isNaN check. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch2-math-5_CapGen_PatchNaturalness$$Add the missing isNaN in Complex . isNaN ( ) .. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch3-math-5_CapGen_PatchNaturalness$$Add the isNaN check. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_KaliA_PatchNaturalness$$Fix tryMinimizeExitPoints. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_KaliA_PatchNaturalness$$disable side effects check for functions with side effects. $$1
closure-61$$Closure removes needed code.$$None$$patch1-closure-61_KaliA_PatchNaturalness$$Allow closure trees to be expanded if they are not equals .. $$0
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_KaliA_PatchNaturalness$$Allow changes through to pass through to fix stones. $$0
closure-68$$Cryptic error message on invalid "@type function" annotation$$None$$patch1-closure-68_KaliA_PatchNaturalness$$Fix possible duplicated parse of EOF. $$0
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_KaliA_PatchNaturalness$$"add patch for "" RemoveUnusedPrototypeProperties "" to". $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_KaliA_PatchNaturalness$$Allow property types to be declared in closure constraints. $$0
closure-7$$Bad type inference with goog.isFunction and friends$$None$$patch1-closure-7_KaliA_PatchNaturalness$$Allow restricting of restricted types , fix # 771. $$0
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_KaliA_PatchNaturalness$$Allow closure to be run as a literal if ( true ). $$0
closure-127$$Break in finally block isn't optimized properly$$None$$patch1-closure-127_KaliA_PatchNaturalness$$Allow code to be removed from the map .. $$0
closure-1$$function arguments should not be optimized away$$None$$patch1-closure-1_KaliA_PatchNaturalness$$Fix days of unused vars getting deleted. $$0
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_KaliA_PatchNaturalness$$Add true condition to walk pattern. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_KaliA_PatchNaturalness$$Allow one - line ifs. $$0
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_KaliA_PatchNaturalness$$Allow 0 . 9 . 0 - > - X in Strings. $$0
closure-119$$catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode$$None$$patch1-closure-119_KaliA_PatchNaturalness$$Allow closure to be defined on non - global fields .. $$0
closure-117$$Wrong type name reported on missing property error.$$None$$patch1-closure-117_KaliA_PatchNaturalness$$Added missing return statement .. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_KaliA_PatchNaturalness$$Added patch for parseHelperCode ( ). $$0
closure-130$$arguments is moved to another scope$$None$$patch1-closure-130_KaliA_PatchNaturalness$$Fix broken patch. $$0
closure-64$$--language_in=ECMASCRIPT5_STRICT results in 1 'use strict' per input file$$None$$patch1-closure-64_KaliA_PatchNaturalness$$Allow for more freedom from the closure compiler. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_KaliA_PatchNaturalness$$Switch the default closure implementation back to the record type .. $$0
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_KaliA_PatchNaturalness$$Allow closure to resolve non - unknown types .. $$0
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_KaliA_PatchNaturalness$$Remove patch for isNameAssignedTo ( ). $$0
closure-15$$Switched order of "delete key" and "key in" statements changes semantic$$None$$patch1-closure-15_KaliA_PatchNaturalness$$Remove one more test. $$0
closure-125$$IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType$$None$$patch1-closure-125_KaliA_PatchNaturalness$$Allow false to be true case when comparison is desired. $$0
closure-122$$Inconsistent handling of non-JSDoc comments$$None$$patch1-closure-122_KaliA_PatchNaturalness$$Allow comments to be reported as valid JSDoc comments .. $$0
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_KaliA_PatchNaturalness$$Do not increment level of optimizations as per # 12. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_KaliA_PatchNaturalness$$Allow one - line ifs. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_KaliA_PatchNaturalness$$Fix null pointer check in Kali_Defects4J_Chart_1 .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_KaliA_PatchNaturalness$$Added patch to chart source. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_KaliA_PatchNaturalness$$Updated chart with the new column doesn ' t already exist .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch1-math-31_KaliA_PatchNaturalness$$Missing patch. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_KaliA_PatchNaturalness$$Fix a bug in MultiDirectional .. $$0
mockito-10$$RETURNS_DEEP_STUBS automatically tries to create serializable mocks$$You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue' do not implement Serializable AND do not have a no-arg constructor.$$patch1-mockito-10_KaliA_PatchNaturalness$$fix merge conflict resolution. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_TBar_PatchNaturalness$$Remove whitespaces from sourceExcerpt. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_TBar_PatchNaturalness$$Fix an issue with time series end index < startIndex. $$1
math-11$$MultivariateNormalDistribution.density(double[]) returns wrong value when the dimension is odd$$To reproduce:  Assert.assertEquals(0.398942280401433, new MultivariateNormalDistribution(new double[]{0}, new double[][]{{1}}).density(new double[]{0}), 1e-15);$$patch1-math-11_TBar_PatchNaturalness$$Fix MultivariateNormalDistribution precision thingie in 1 . 6 . 2. $$1
math-65$$weight versus sigma in AbstractLeastSquares$$In AbstractLeastSquares, residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS(), these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation, it should multiply the square of the residual even in the computation of the chi2.  Once corrected, getRMS() can even reduce  public double getRMS()  {return Math.sqrt(getChiSquare()/rows);}$$patch1-math-65_TBar_PatchNaturalness$$Fix ColorConvertor .. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_TBar_PatchNaturalness$$removed null check. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_TBar_PatchNaturalness$$Remove redundant check. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_TBar_PatchNaturalness$$Don ' t set the length of a string to 0 if the object is null .. Don ' t use the constructor of StrBuilder in some cases .. $$1
closure-66$$@enum does not type correctly$$None$$patch1-closure-66_TBar_PatchNaturalness$$Fix typo in TypeCheck . getTypedPercent. $$0
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_TBar_PatchNaturalness$$Fix the return ' s description for the current ( ) token .. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_TBar_PatchNaturalness$$Fix side effects of varargs. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_TBar_PatchNaturalness$$Fix tryMinimizeExits case .. $$0
closure-109$$Constructor types that return all or unknown fail to parse$$None$$patch1-closure-109_TBar_PatchNaturalness$$Add parseAndRecordTypeNode to the parseContextTypeExpression method in JsDocInfoParser. $$0
closure-107$$Variable names prefixed with MSG_ cause error with advanced optimizations$$None$$patch1-closure-107_TBar_PatchNaturalness$$Fix cruise - add - message - bundle. $$0
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_TBar_PatchNaturalness$$Allow side effects for function arguments , see canBeSideEffected for the corresponding // @ javadoc. $$0
closure-12$$Try/catch blocks incorporate code not inside original blocks$$None$$patch1-closure-12_TBar_PatchNaturalness$$Remove false positives in FlowSensitiveInlineVariables .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_TBar_PatchNaturalness$$Fix side effects ofcommas in functional tests. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_TBar_PatchNaturalness$$added null check in AbstractDataset . hasListener. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_TBar_PatchNaturalness$$AddOrUpdate ( double x , double y ). $$0
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_TBar_PatchNaturalness$$Fix a bug in the linear tableau test .. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_TBar_PatchNaturalness$$Add missing equals method. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_TBar_PatchNaturalness$$Fix a typo in MultiDirectional .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_TBar_PatchNaturalness$$@@ commented out previous fix. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_TBar_PatchNaturalness$$Handle isDigits ( numeric ) as well as ( exp == null ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_TBar_PatchNaturalness$$StrBuilder delete doesn ' t overwrite the capacity. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_TBar_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary copy of StringUtils. $$0
lang-18$$FastDateFormat formats year differently than SimpleDateFormat in Java 7$$Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.$$patch1-lang-18_TBar_PatchNaturalness$$FastDateFormat doesn ' t select week / month fields ( issue # 507 ). $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_TBar_PatchNaturalness$$removed expPos from str ; if it was < - 1. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_TBar_PatchNaturalness$$fixed try case. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_TBar_PatchNaturalness$$Fix null precision thingie in StringUtils. $$0
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_TBar_PatchNaturalness$$@@ changed to use packageCanonicalName instead of getPackageName ( ) for inner class access. make ClassUtils . getShortCanonicalName static. $$0
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_DeepRepair_PatchNaturalness$$FastDateParser ignores white space. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_DeepRepair_PatchNaturalness$$Fix null pointer check in AbstractCategoryItemRenderer. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_DeepRepair_PatchNaturalness$$Fixed bug in XYSeries. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_DeepRepair_PatchNaturalness$$Remove expPos from mant string .. $$0
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_FixMiner_PatchNaturalness$$Allow recursion to go to CALL node. $$0
closure-19$$Type refining of 'this' raises IllegalArgumentException$$None$$patch1-closure-19_FixMiner_PatchNaturalness$$refined type cannot be refined .. $$0
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_FixMiner_PatchNaturalness$$fix a bug in TimeSeries . clone. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_FixMiner_PatchNaturalness$$Fix bug with AbstractDataset . hasListener. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_FixMiner_PatchNaturalness$$Fix a bug in MathUtils . equals. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_FixMiner_PatchNaturalness$$Fix a typo in MultiDirectional .. $$0
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_FixMiner_PatchNaturalness$$Add null check in LocaleUtils. $$0
math-35$$Need range checks for elitismRate in ElitisticListPopulation constructors.$$There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.$$patch1-math-35_ACS_PatchNaturalness$$ElitisticListPopulation can throw exception if elitism rate is too high. ElitisticListPopulation ( ) throws outOfRangeException if elitismRate is not 1 .. $$1
math-99$$MathUtils.gcd(Integer.MIN_VALUE, 0) should throw an Exception instead of returning Integer.MIN_VALUE$$The gcd method should throw an Exception for gcd(Integer.MIN_VALUE, 0), like for gcd(Integer.MIN_VALUE, Integer.MIN_VALUE). The method should only return nonnegative results.$$patch1-math-99_ACS_PatchNaturalness$$Fix divide by zero error in MathUtils. Add a throw if it wasn ' t possible to do this .. $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_ACS_PatchNaturalness$$Added missing if (. Added missing if (. $$1
math-3$$ArrayIndexOutOfBoundsException in MathArrays.linearCombination$$When MathArrays.linearCombination is passed arguments with length 1, it throws an ArrayOutOfBoundsException. This is caused by this line: double prodHighNext = prodHigh[1]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.$$patch1-math-3_ACS_PatchNaturalness$$Added missing if (. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_ACS_PatchNaturalness$$Add 0 . 0 equals to Complex. $$1
math-25$$"HarmonicFitter.ParameterGuesser" sometimes fails to return sensible values$$The inner class "ParameterGuesser" in "HarmonicFitter" (package "o.a.c.m.optimization.fitting") fails to compute a usable guess for the "amplitude" parameter.$$patch1-math-25_ACS_PatchNaturalness$$Added throw if c2 == 0 . 0 to HarmonicFitter . java. $$1
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_ACS_PatchNaturalness$$Allow negative numbers in FieldUtils. $$1
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_ACS_PatchNaturalness$$Added a throw if the initial value is not greater than 0 . 0. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch3-closure-126_3sFix_PatchNaturalness$$Fix tryMinimizeExits. $$1
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_3sFix_PatchNaturalness$$Fix swapped arrows in closure scope. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch2-closure-21_3sFix_PatchNaturalness$$Fix maybeResultUsed for Do not drop side effects of nested closures. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch3-closure-21_3sFix_PatchNaturalness$$Fix swapped - in case of closing - > closing. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_3sFix_PatchNaturalness$$Fix try / catch block. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch2-closure-126_3sFix_PatchNaturalness$$Fix tryMinimizeExits. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_3sFix_PatchNaturalness$$Don ' t compare JSType against native object type .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_3sFix_PatchNaturalness$$Fix maybe - dead code. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch2-closure-22_3sFix_PatchNaturalness$$Fix the case of a null pointer check in a few places .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch3-closure-22_3sFix_PatchNaturalness$$Fix the case of no - op in a closure check .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_3sFix_PatchNaturalness$$Fix bug in XYSeries. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch2-chart-5_3sFix_PatchNaturalness$$Fix bug in XYSeries. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_3sFix_PatchNaturalness$$Added support for provided yInitial and yMax. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch2-math-73_3sFix_PatchNaturalness$$BrentSolver now uses provided initial guess. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch3-math-73_3sFix_PatchNaturalness$$Added support for variable yInitial in BrentSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_3sFix_PatchNaturalness$$Added missing @@. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_3sFix_PatchNaturalness$$Fix isNaN in complex comparison output. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch2-math-5_3sFix_PatchNaturalness$$Fix isNaN. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_3sFix_PatchNaturalness$$Make MonthDay partial. $$0
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_ssFix_PatchNaturalness$$removed null check. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_ssFix_PatchNaturalness$$Allow side effects for function arguments. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_ssFix_PatchNaturalness$$Fix CategoryItemRenderer . getDataset ( ) to return the first result. $$0
math-30$$Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets$$When performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets), intermediate integer values used in calculateAsymptoticPValue can overflow, leading to invalid results, such as p-values of NaN, or incorrect calculations. Attached is a patch, including a test, and a fix, which modifies the affected code to use doubles$$patch1-math-30_ssFix_PatchNaturalness$$Add ( double ) cast to avoid warning ( varU = ( double ) n1n2. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_ssFix_PatchNaturalness$$removed expPos from mant string. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_RSRepairA_PatchNaturalness$$Remove unused local variable .. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_RSRepairA_PatchNaturalness$$Remove tryMinimizeExits from tryMinimizeExits. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_RSRepairA_PatchNaturalness$$@@ start = 0 ; for the better coding experience. $$1
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_RSRepairA_PatchNaturalness$$Remove one more for - loop. $$1
closure-61$$Closure removes needed code.$$None$$patch1-closure-61_RSRepairA_PatchNaturalness$$Allow null values for equals in closure trees. $$0
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_RSRepairA_PatchNaturalness$$Remove old definition of checkGlobalThisLevel from options . checkSuspiciousCode. $$0
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_RSRepairA_PatchNaturalness$$Remove unused prototype properties patch. $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_RSRepairA_PatchNaturalness$$Remove unneeded whitespace. $$0
closure-129$$Casting a function before calling it produces bad code and breaks plugin code$$None$$patch1-closure-129_RSRepairA_PatchNaturalness$$Allow one - line ifs. $$0
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_RSRepairA_PatchNaturalness$$Add one more fix to the case statement. $$0
closure-120$$Overzealous optimization confuses variables$$None$$patch1-closure-120_RSRepairA_PatchNaturalness$$Remove broke patch. $$0
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_RSRepairA_PatchNaturalness$$Fix HOOK pattern in closure situations .. $$0
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_RSRepairA_PatchNaturalness$$Removing old and unused local variable .. $$0
closure-121$$Overzealous optimization confuses variables$$None$$patch1-closure-121_RSRepairA_PatchNaturalness$$Remove obsolete comment. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_RSRepairA_PatchNaturalness$$Remove false alarms that were failing the closure compiler .. $$0
closure-130$$arguments is moved to another scope$$None$$patch1-closure-130_RSRepairA_PatchNaturalness$$Remove old if / else .. $$0
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_RSRepairA_PatchNaturalness$$Remove patch for closure parameters. $$0
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_RSRepairA_PatchNaturalness$$Remove one more test case. $$0
closure-114$$Crash on the web closure compiler$$None$$patch1-closure-114_RSRepairA_PatchNaturalness$$Removing old warning. Removing copyInformationFrom ( ) from replacements list .. $$0
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_RSRepairA_PatchNaturalness$$Do not inline errors in AbstractPeepholeOptimization . error ( ). $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_RSRepairA_PatchNaturalness$$Add a listener to the dataset ( if it is not null ). $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_RSRepairA_PatchNaturalness$$Fix - issue with the XYSeries class - patch. $$0
math-103$$ConvergenceException in normal CDF$$NormalDistributionImpl::cumulativeProbability(double x) throws ConvergenceException if x deviates too much from the mean. For example, when x=+/-100, mean=0, sd=1. Of course the value of the CDF is hard to evaluate in these cases, but effectively it should be either zero or one.$$patch1-math-103_RSRepairA_PatchNaturalness$$Gamma function returns NaN on NaN input. Removing rethrowing of max iterations exceeded exception. $$0
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_RSRepairA_PatchNaturalness$$remove column to drop from list of columns to avoid duplicates. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_RSRepairA_PatchNaturalness$$Fixed a bug in MultiDirectional .. Removed a redundant line. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_RSRepairA_PatchNaturalness$$fix a minor bug in NumberUtils. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_DLFix_PatchNaturalness$$Improve program minimization. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_DLFix_PatchNaturalness$$Updated function injector copy. $$1
closure-40$$smartNameRemoval causing compiler crash$$None$$patch1-closure-40_DLFix_PatchNaturalness$$Fix dead code. $$1
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_DLFix_PatchNaturalness$$Using the copy of SimplexTableau , it is better for testing. $$1
math-41$$One of Variance.evaluate() methods does not work correctly$$The method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[] values, double[] weights, double mean, int begin, int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.$$patch1-math-41_DLFix_PatchNaturalness$$Added missing range in Variance copy constructor. $$1
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_DLFix_PatchNaturalness$$Fix copy year. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_DLFix_PatchNaturalness$$Improved javadoc in LocaleUtils. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_Cardumen_PatchNaturalness$$Fix swapped diffs in patch. $$1
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_Cardumen_PatchNaturalness$$Added missing throws. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Cardumen_PatchNaturalness$$Add null check. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_Cardumen_PatchNaturalness$$Fixed erroneous Brent algorithm. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_Cardumen_PatchNaturalness$$Fix bug in Controllers / Websocket Session. Added missing lexicographically ordered comparison to equals ( ) .. Added missing javadoc. updated factorialDouble. Added missing patch. Fix bug in MathUtils . equalsIncludingNaN. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_Cardumen_PatchNaturalness$$Fix NaN in Object . equals ( ). $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Nopol2015_PatchNaturalness$$Fix build. formatting fixes. $$1
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_Nopol2015_PatchNaturalness$$don ' t allow duplicate x values in XYSeries. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Nopol2015_PatchNaturalness$$removed null check. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Nopol2015_PatchNaturalness$$Handle negative exponentiblity in StringUtils . java. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch1-closure-86_Hercules_PatchNaturalness$$fix broken patch. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Hercules_PatchNaturalness$$Fixed typo in code snippet. $$1
closure-109$$Constructor types that return all or unknown fail to parse$$None$$patch1-closure-109_Hercules_PatchNaturalness$$updated hercules patch. $$1
closure-4$$Converting from an interface type to a constructor which @implements itself causes stack overflow.$$None$$patch1-closure-4_Hercules_PatchNaturalness$$fix doubled up patch. added fix for lost brackets in closures. $$1
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_Hercules_PatchNaturalness$$disable division by zero check. disable division by zero check. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Hercules_PatchNaturalness$$Fixed nullability assertion that was accidentally made too strong. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Hercules_PatchNaturalness$$Fixed a bug in MultiplePiePlot .. $$1
math-59$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case "testMinMaxFloat()" because that has a bug too - it tests doubles, not floats.$$patch1-math-59_Hercules_PatchNaturalness$$Fix float . max ( a , b ). $$1
math-35$$Need range checks for elitismRate in ElitisticListPopulation constructors.$$There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.$$patch1-math-35_Hercules_PatchNaturalness$$added fix .. ElitisticListPopulation constructor should set the elitism rate before setting the population .. $$1
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_Hercules_PatchNaturalness$$Updated patch1 - Math - 33 - Hercules . fixed. $$1
math-75$$In stat.Frequency, getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)$$Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  {@link #getPct(Comparable)}  as of 2.0      */     @Deprecated     public double getPct(Object v)  {         return getCumPct((Comparable<?>) v);     }$$patch1-math-75_Hercules_PatchNaturalness$$Fix getOwnPct return type. $$1
math-43$$Statistics.setVarianceImpl makes getStandardDeviation produce NaN$$Invoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use "population variance" for(int i : scores) {   stats.addValue(i); } double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());$$patch1-math-43_Hercules_PatchNaturalness$$updated hercules patch. Fix bug in secondMoment of mean implementation. fixed case. $$1
math-46$$Division by zero$$In class Complex, division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO, otherwise the result should be INF. See here.$$patch1-math-46_Hercules_PatchNaturalness$$Add fix from MATH - 657. Fix typo in MATH - 657. $$1
math-24$$"BrentOptimizer" not always reporting the best point$$BrentOptimizer (package "o.a.c.m.optimization.univariate") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.$$patch1-math-24_Hercules_PatchNaturalness$$Using the best function to reduce the total number of tests for a fixed situation .. Fix the patch. $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_Hercules_PatchNaturalness$$added fix. added fix. $$1
math-25$$"HarmonicFitter.ParameterGuesser" sometimes fails to return sensible values$$The inner class "ParameterGuesser" in "HarmonicFitter" (package "o.a.c.m.optimization.fitting") fails to compute a usable guess for the "amplitude" parameter.$$patch1-math-25_Hercules_PatchNaturalness$$Add a throw if the pair of arguments are not compatible with 1 . 0 .. $$1
time-26$$.withHourOfDay() sets hour inconsistantly on DST transition.$$When the hour of day is set to the ambiguous hour on the daylight to standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the daylight hour or the standard hour for all time zones? I can't find anything that documents this behavior.  My test code below returns different results for different time zones. The very last assertion fails on the Australia time zone cutover.$$patch1-time-26_Hercules_PatchNaturalness$$Fixed typo in Time - 26 - Hercules .. Fixed bug in Time - 26 - Hercules .. Fixed formatting mistake .. Fixed bug in Time - 26 - Hercules .. Fixed typo in patch1. Fixed formatting mistake in convertLocalToUTC ( long , boolean , boolean , boolean , boolean ). Fixed formatting mistake in convertLocalToUTC ( long , boolean , boolean , boolean ). $$1
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_Hercules_PatchNaturalness$$Fix partial constructor to work with joda - time. $$1
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_Hercules_PatchNaturalness$$added missing patch. updated hercules bugfix. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Hercules_PatchNaturalness$$added null check in Hercules . fixed. null check in Hercules for fixed. fix null pointer check. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_Hercules_PatchNaturalness$$Fix the bug in Hercules . fixed. Fix the bug in Hercules .. $$1
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_Hercules_PatchNaturalness$$don ' t look ahead for empty lines. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_Hercules_PatchNaturalness$$Fix the try / finally blocks used in the AST .. $$0
closure-107$$Variable names prefixed with MSG_ cause error with advanced optimizations$$None$$patch1-closure-107_Hercules_PatchNaturalness$$HHH - 9733 - Set typeBasedOptimizationOptions ( ) to the right level so it. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_Hercules_PatchNaturalness$$don ' t include regexps in closures. $$0
closure-12$$Try/catch blocks incorporate code not inside original blocks$$None$$patch1-closure-12_Hercules_PatchNaturalness$$Allow apply of control flow graphs. $$0
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_Hercules_PatchNaturalness$$Fix bug in delete ( ). $$0
math-104$$Special functions not very accurate$$The Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy, as this is what I'd expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.$$patch1-math-104_Hercules_PatchNaturalness$$fixed too high epsilon delay in java 1 . 0 Math. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_Hercules_PatchNaturalness$$update hercules fixed spot. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_Hercules_PatchNaturalness$$Fix bug in equals. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_Hercules_PatchNaturalness$$Missing addWrapPartial method from DateField . add ( ) .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Hercules_PatchNaturalness$$don ' t compare y ' to ' y '. don ' t compare Y ' to ' Y ' ( fixes # 77 ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_Hercules_PatchNaturalness$$Handle isDigits ( string ) with patch 1 - Lang - 58 - Hercules . fixed. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Hercules_PatchNaturalness$$fixed year in StringUtils. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Hercules_PatchNaturalness$$Fix null - penalty in long precision spotting. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_LSRepair_PatchNaturalness$$Optimize toBoolean ( ). $$1
chart-17$$cloning of TimeSeries$$It's just a minor bug!  When I clone a TimeSeries which has no items, I get an IllegalArgumentException ("Requires start <= end"). But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.$$patch1-chart-17_LSRepair_PatchNaturalness$$Fixed a bug with not throwing the clone exception. $$0
math-11$$MultivariateNormalDistribution.density(double[]) returns wrong value when the dimension is odd$$To reproduce:  Assert.assertEquals(0.398942280401433, new MultivariateNormalDistribution(new double[]{0}, new double[][]{{1}}).density(new double[]{0}), 1e-15);$$patch1-math-11_LSRepair_PatchNaturalness$$Fix density method. $$0
math-99$$MathUtils.gcd(Integer.MIN_VALUE, 0) should throw an Exception instead of returning Integer.MIN_VALUE$$The gcd method should throw an Exception for gcd(Integer.MIN_VALUE, 0), like for gcd(Integer.MIN_VALUE, Integer.MIN_VALUE). The method should only return nonnegative results.$$patch1-math-99_LSRepair_PatchNaturalness$$Fix a bug in MathUtils . gcd ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_LSRepair_PatchNaturalness$$StrBuilder . contains ( ) now returns true if the builder contains the character. $$0
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_LSRepair_PatchNaturalness$$Fix ClassUtils # getShortClassName ( ). $$0
lang-40$$Fix case-insensitive string handling$$String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.$$patch1-lang-40_LSRepair_PatchNaturalness$$fixed StringUtils . containsIgnoreCase ( ). $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_CoCoNut_PatchNaturalness$$Improved javadoc comment .. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_CoCoNut_PatchNaturalness$$don ' t skip building all passes when building. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_CoCoNut_PatchNaturalness$$Improved method return type for JSType . getLeastSupertype ( JSType ). $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_CoCoNut_PatchNaturalness$$Fix an issue with TimeSeries . isEmpty ( ) .. $$1
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_CoCoNut_PatchNaturalness$$Missing warning. $$1
math-34$$ListPopulation Iterator allows you to remove chromosomes from the population.$$Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list. Before returning the iterator we should wrap it in an unmodifiable list.$$patch1-math-34_CoCoNut_PatchNaturalness$$added iterator on non - empty chromosomes list. $$1
math-30$$Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets$$When performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets), intermediate integer values used in calculateAsymptoticPValue can overflow, leading to invalid results, such as p-values of NaN, or incorrect calculations. Attached is a patch, including a test, and a fix, which modifies the affected code to use doubles$$patch1-math-30_CoCoNut_PatchNaturalness$$long not int ( not long ). $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_CoCoNut_PatchNaturalness$$Added missing return statement. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_CoCoNut_PatchNaturalness$$removed null check. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_CoCoNut_PatchNaturalness$$FastDateParser copy ( ) didn ' t ignore whitespace in date parsing. $$1
mockito-29$$fixed a verify() call example in @Captor javadoc.$$None$$patch1-mockito-29_CoCoNut_PatchNaturalness$$Fix appendText ( ) with null values .. $$1
mockito-8$$1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound.$$None$$patch1-mockito-8_CoCoNut_PatchNaturalness$$Fix contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ). $$1
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_CoCoNut_PatchNaturalness$$Fix toStringEquals in ArgumentMatchingTool. $$1
closure-35$$assignment to object in conditional causes type error on function w/ record type return type$$None$$patch1-closure-35_kPAR_PatchNaturalness$$Make ObjectType collapseUnion if one is not null .. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_kPAR_PatchNaturalness$$Remove spurious lookahead. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_kPAR_PatchNaturalness$$Fix jstype matching of non - Record types .. $$0
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_kPAR_PatchNaturalness$$Allow inline with function calls via @ isDirectCallNodeReplacementPossible. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_kPAR_PatchNaturalness$$Don ' t allow duplicate x values in XYSeries. $$0
math-104$$Special functions not very accurate$$The Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy, as this is what I'd expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.$$patch1-math-104_kPAR_PatchNaturalness$$Fix default edge case .. $$0
math-42$$Negative value with restrictNonNegative$$Problem: commons-math-2.2 SimplexSolver. A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver.optimize(function, constraints, GoalType.MINIMIZE, true); Function 1 * x + 1 * y + 0 Constraints: 1 * x + 0 * y = 1 Result: x = 1; y = -1; Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.$$patch1-math-42_kPAR_PatchNaturalness$$Fix hash code for SimplexTableau class. $$0
math-43$$Statistics.setVarianceImpl makes getStandardDeviation produce NaN$$Invoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:  int[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use "population variance" for(int i : scores) {   stats.addValue(i); } double sd = stats.getStandardDeviation(); System.out.println(sd);   A workaround suggested by Mikkel is:    double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());$$patch1-math-43_kPAR_PatchNaturalness$$Added missing if / else .. Fix secondMoment increment .. Fix minor bug in SummaryStatistics. $$0
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_kPAR_PatchNaturalness$$Fix a bug in the tableau test .. $$0
time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).$$patch1-time-17_kPAR_PatchNaturalness$$Fix an issue with DateTimeZone . getOffset ( ) where the difference was not an overlap. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_kPAR_PatchNaturalness$$removed y as separator at the end of StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_kPAR_PatchNaturalness$$isDigits ( string ) fix. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_kPAR_PatchNaturalness$$Fix bug in StringUtils. Removed unnecessary null check .. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_kPAR_PatchNaturalness$$removed expPos. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_kPAR_PatchNaturalness$$isDigits got rid of '.'. $$0
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_kPAR_PatchNaturalness$$FastDateParser ignores unquotes in the value string. $$0
lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)$$patch1-lang-21_kPAR_PatchNaturalness$$Fixed bug for calendars with the same HOUR value. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_kPAR_PatchNaturalness$$Fix build. $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_Jaid_PatchNaturalness$$Avoid matching against an unneeded property .. $$1
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_Jaid_PatchNaturalness$$"Fix the "" closure pass "" flag in Compiler . java". $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_Jaid_PatchNaturalness$$Fix typo in codeGenerator where ' c ' was passed through , but was accidentally ignored .. $$1
closure-31$$Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY$$None$$patch1-closure-31_Jaid_PatchNaturalness$$Allow closure pass through. $$1
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Jaid_PatchNaturalness$$Remove whitespaces from sourceExcerpt .. $$1
closure-63$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-63_Jaid_PatchNaturalness$$Remove whitespaces from sourceExcerpt. $$1
closure-70$$unexpected typed coverage of less than 100%$$None$$patch1-closure-70_Jaid_PatchNaturalness$$Fix typed scope creator for parameter types .. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_Jaid_PatchNaturalness$$Fix an issue with TimeSeries . isEmptyRange ( ). $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch2-chart-9_Jaid_PatchNaturalness$$Fix an issue with time series end index < startIndex. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Jaid_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_Jaid_PatchNaturalness$$Add the inverse of Complex . INF to check for 0 . 0 precision .. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch2-math-5_Jaid_PatchNaturalness$$Add the inverse of Complex . INF as well .. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch3-math-5_Jaid_PatchNaturalness$$Fixed a minor typo in Complex . reciprocal ( ). $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Jaid_PatchNaturalness$$missing break. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch6-lang-51_Jaid_PatchNaturalness$$missing bracket. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch5-lang-51_Jaid_PatchNaturalness$$Added missing case in BooleanUtils. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch3-lang-51_Jaid_PatchNaturalness$$missing break. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch4-lang-51_Jaid_PatchNaturalness$$missing test for Y. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_Jaid_PatchNaturalness$$removed unnecessary loop. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch2-lang-33_Jaid_PatchNaturalness$$removed unnecessary copy of ClassUtils. $$1
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Jaid_PatchNaturalness$$Fixed misc problems caused by the use of substringBefore and substringAfter methods in WordUtils. $$1
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch1-closure-33_Jaid_PatchNaturalness$$Added a missing if / else .. $$0
closure-33$$weird object literal invalid property error on unrelated object prototype$$None$$patch2-closure-33_Jaid_PatchNaturalness$$Allow property types to be inferred from boolean to string .. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_Jaid_PatchNaturalness$$don ' t add whitespace to source experpt. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_Jaid_PatchNaturalness$$Fix bug for empty range. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch2-chart-9_Jaid_PatchNaturalness$$Fix bug. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch3-chart-9_Jaid_PatchNaturalness$$Fix bug # 944. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Jaid_PatchNaturalness$$Fix null pointer check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_Jaid_PatchNaturalness$$Fix nullability assertion in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_Jaid_PatchNaturalness$$Fix legend item legend generation. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Jaid_PatchNaturalness$$missing if (. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch2-lang-51_Jaid_PatchNaturalness$$Fixed bug in BooleanUtils where empty string is not the case. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch3-lang-51_Jaid_PatchNaturalness$$missing if (. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch4-lang-51_Jaid_PatchNaturalness$$missing one if (. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Jaid_PatchNaturalness$$Fixed WordUtils . isEmpty ( ) .. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch2-lang-45_Jaid_PatchNaturalness$$Fixed WordUtils . isEmpty ( ) .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_JGenProg2015_PatchNaturalness$$Fixed issue with XYSeries . add ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_JGenProg2015_PatchNaturalness$$changed 28 .. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_JGenProg2015_PatchNaturalness$$Fixed zero - is - max datetime field. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_AVATAR_PatchNaturalness$$Fix negative zero log in case of a - sign in JSON. $$1
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_AVATAR_PatchNaturalness$$Remove recording type properties where they are not equivalent. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_AVATAR_PatchNaturalness$$Allow side effects in function arguments .. $$1
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_AVATAR_PatchNaturalness$$Add null check in TypeCheck . java. Added missing for loop. $$1
math-59$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case "testMinMaxFloat()" because that has a bug too - it tests doubles, not floats.$$patch1-math-59_AVATAR_PatchNaturalness$$Fix typo in FastMath . exp ( x ). Fix NaN in FastMath . max ( a , b ). $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_AVATAR_PatchNaturalness$$Add null check in SubLine. Add null check in SubLine , closes # 77. $$1
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_AVATAR_PatchNaturalness$$Remove unused vars that are not used any more .. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_AVATAR_PatchNaturalness$$Fix CheckSideEffects . java. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_AVATAR_PatchNaturalness$$Fix tryMinimizeExitPoints. $$0
closure-108$$precondition crash: goog.scope local with aliased in the type declaration$$None$$patch1-closure-108_AVATAR_PatchNaturalness$$Fix scoped properties. $$0
closure-48$$Type checking error when replacing a function with a stub after calling.$$None$$patch1-closure-48_AVATAR_PatchNaturalness$$Fixing scope creation failure. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_AVATAR_PatchNaturalness$$Add gramps as a modifier to a name .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_AVATAR_PatchNaturalness$$Fix bug in XYSeries addOrUpdate. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_AVATAR_PatchNaturalness$$Remove backslash which prevents overflow from StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_AVATAR_PatchNaturalness$$try to create long from Javadoc. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_AVATAR_PatchNaturalness$$Fix NPE. Fix bug in StringUtils. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_GenPat_PatchNaturalness$$Remove spurious blank line. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_GenPat_PatchNaturalness$$Fixing the function infusion of side effects in JS stylesheet. $$1
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_GenPat_PatchNaturalness$$Added TypeCheck copy check. Added TypeCheck copy .. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_GenPat_PatchNaturalness$$added missing copy. $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_GenPat_PatchNaturalness$$added null check in subLine copy. $$1
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_GenPat_PatchNaturalness$$StrBuilder . contains ( ) now uses the same level of storage as ArrayList .. $$1
lang-21$$DateUtils.isSameLocalTime does not work correct$$Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)$$patch1-lang-21_GenPat_PatchNaturalness$$Fixed fall through in DateUtils . java. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_GenPat_PatchNaturalness$$Fix an NPE in StrBuilder . toString ( ). $$1
mockito-22$$Can not Return deep stubs from generic method that returns generic type.$$if I try to mock a generic method which a generic returntype, where the returntype is derived from the generic type of the method using deep stubs I get a ClassCastException when calling when on it. When you don't use deep stubs and a raw Supplier mock to pass around it works:$$patch1-mockito-22_GenPat_PatchNaturalness$$added a bit more tidying of the areEqual method. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_GenPat_PatchNaturalness$$Fix bug in TimeSeries . java. $$0
math-72$$Brent solver returns the wrong value if either bracket endpoint is root$$The solve(final UnivariateRealFunction f, final double min, final double max, final double initial) function returns yMin or yMax if min or max are deemed to be roots, respectively, instead of min or max.$$patch1-math-72_GenPat_PatchNaturalness$$Fix the bit between the two functions. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_GenPat_PatchNaturalness$$Added zeroismaxdatetimefield copy. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_GenPat_PatchNaturalness$$Fix parse error. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_GenPat_PatchNaturalness$$Fix toString method of StringUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_GenPat_PatchNaturalness$$Fix copy ( ). $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_GenPat_PatchNaturalness$$Fixed null pointer check in WordUtils. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_GenPat_PatchNaturalness$$Manchester United FC = > NumberUtils copy ( ). $$0
mockito-38$$Generate change list separated by types using labels$$As discussed on the mailing list instead of one big list of "Improvements" the change list for the release is divided into change types based on labels. It is required to specify which labels should be considered separately. Some other labels can be excluded (like "question" or "refactoring"). There is also headerForOtherChanges method to override default "Other" header.$$patch1-mockito-38_GenPat_PatchNaturalness$$Add null check in ArgumentMatchingTool. $$0
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_SequenceR_PatchNaturalness$$Fix typo in codeGenerator . java. $$1
closure-73$$Codepoint U+007f appears raw in output$$None$$patch2-closure-73_SequenceR_PatchNaturalness$$Fix typo in codeGenerator . java. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_SequenceR_PatchNaturalness$$Fix null pointer check in AbstractCategoryItemRenderer. $$1
math-75$$In stat.Frequency, getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)$$Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  {@link #getPct(Comparable)}  as of 2.0      */     @Deprecated     public double getPct(Object v)  {         return getCumPct((Comparable<?>) v);     }$$patch1-math-75_SequenceR_PatchNaturalness$$Fix getFrequency ( Object ) to return precise value instead of getCumPct ( Object ). $$1
math-30$$Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets$$When performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets), intermediate integer values used in calculateAsymptoticPValue can overflow, leading to invalid results, such as p-values of NaN, or incorrect calculations. Attached is a patch, including a test, and a fix, which modifies the affected code to use doubles$$patch1-math-30_SequenceR_PatchNaturalness$$changed int to double .. $$1
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_SequenceR_PatchNaturalness$$NaN - > Complex . INF. $$1
closure-92$$bug with implicit namespaces across modules$$None$$patch8-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' definition .. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch1-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' positioning .. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch6-closure-92_SequenceR_PatchNaturalness$$Fix closure closures to error code .. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch7-closure-92_SequenceR_PatchNaturalness$$Fix a warning. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch9-closure-92_SequenceR_PatchNaturalness$$Fix a warning. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch5-closure-92_SequenceR_PatchNaturalness$$Fix a warning. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch2-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' null arguments ' error. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch10-closure-92_SequenceR_PatchNaturalness$$Fix closure closures ' positioning mistake. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch3-closure-92_SequenceR_PatchNaturalness$$Fix an issue with ' . ' in ProcessClosurePrimitives . java. $$0
closure-92$$bug with implicit namespaces across modules$$None$$patch4-closure-92_SequenceR_PatchNaturalness$$Fix an issue with that damn code style error .. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch1-closure-18_SequenceR_PatchNaturalness$$Fix a bug in the compiler ' s dependency check. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch5-closure-18_SequenceR_PatchNaturalness$$Fix a null pointer check that would trigger an NPE .. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch3-closure-18_SequenceR_PatchNaturalness$$Fix a null pointer check that would trigger an error .. $$0
closure-18$$Dependency sorting with closurePass set to false no longer works.$$None$$patch4-closure-18_SequenceR_PatchNaturalness$$Fix null pointer check .. $$0
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_SequenceR_PatchNaturalness$$Fix typo in codeGenerator . java. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch5-closure-86_SequenceR_PatchNaturalness$$Allow for an aliased constructor to be used in a few places. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch2-closure-86_SequenceR_PatchNaturalness$$AllowImmutableValue check for value types .. $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch3-closure-86_SequenceR_PatchNaturalness$$Fix bug in NodeUtil . isFunctionLike ( ). $$0
closure-86$$side-effects analysis incorrectly removing function calls with side effects$$None$$patch4-closure-86_SequenceR_PatchNaturalness$$Add toStringMethodCall check. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_SequenceR_PatchNaturalness$$Fix negative zero logspam. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch2-closure-38_SequenceR_PatchNaturalness$$Fix negative zero logspam. $$0
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch3-closure-38_SequenceR_PatchNaturalness$$Fix negative zero presence in JSON. $$0
closure-123$$Generates code with invalid for/in left-hand assignment$$None$$patch1-closure-123_SequenceR_PatchNaturalness$$Fix the rhs context for the for - init CLAUSE token .. $$0
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_SequenceR_PatchNaturalness$$Fix an issue with TimeSeries . isEmptyRange ( ) .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_SequenceR_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_SequenceR_PatchNaturalness$$Fix null checking in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch4-chart-1_SequenceR_PatchNaturalness$$Fix nullability note in AbstractCategoryItemRenderer. $$0
math-59$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f$$FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f. This is because the wrong variable is returned. The bug was not detected by the test case "testMinMaxFloat()" because that has a bug too - it tests doubles, not floats.$$patch1-math-59_SequenceR_PatchNaturalness$$Fix NaN handling in FastMath . max ( ). $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_SequenceR_PatchNaturalness$$Fix a bug in MathUtils . equals. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Arja_PatchNaturalness$$Set the dataset on the pie chart .. $$1
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_Arja_PatchNaturalness$$Use the method provided for sorting XYSeries. $$1
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_Arja_PatchNaturalness$$Added verifyBracketing to BrentSolver. $$1
time-15$$possibly a bug in org.joda.time.field.FieldUtils.safeMultiply$$It seems to me that as currently written in joda-time-2.1.jar org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar) doesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.  The attached file demonstrates what I think is the bug and suggests a patch.  I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant.$$patch1-time-15_Arja_PatchNaturalness$$Fix a bug in FieldUtils. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_Arja_PatchNaturalness$$Bump the buffer size for the empty string builder .. Removed unnecessary copy of StringUtils. $$1
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_Arja_PatchNaturalness$$Extend word utils upper bounds. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_Arja_PatchNaturalness$$Fix category item label generator on initial refresh .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch6-chart-1_Arja_PatchNaturalness$$Remove redundant return statement. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch5-chart-1_Arja_PatchNaturalness$$Remove unnecessary check for null dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_Arja_PatchNaturalness$$Fix category item renderer to reset the counts as well. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_Arja_PatchNaturalness$$Fix category item renderer to save row count in case of data series changes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch4-chart-1_Arja_PatchNaturalness$$Fix background annotations for category items. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch8-chart-12_Arja_PatchNaturalness$$Add a listener to MultiplePiePlot .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset group object , so we can use the group object to get the. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch6-chart-12_Arja_PatchNaturalness$$Add a listener to MultiplePiePlot .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch7-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset group object , so we can use it for any dataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch5-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset group option on pie plot .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch2-chart-12_Arja_PatchNaturalness$$Add a listener to the dataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch3-chart-12_Arja_PatchNaturalness$$Fixed dataExtractOrder. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch4-chart-12_Arja_PatchNaturalness$$Add a listener to MultiplePiePlot. $$0
math-68$$LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it$$LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.$$patch1-math-68_Arja_PatchNaturalness$$Fix a regression in LevenbergMarquardtOptimizer . java. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch1-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch6-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction . log. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch7-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch5-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch2-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch3-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch4-math-31_Arja_PatchNaturalness$$Missing throw in ContinuedFraction .. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_Arja_PatchNaturalness$$Fixed zero - is - max datetime field. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch6-time-4_Arja_PatchNaturalness$$Fixed zero - is - maxDateTimeField minimization. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch7-time-4_Arja_PatchNaturalness$$Fixed the build .. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch5-time-4_Arja_PatchNaturalness$$Add an exception. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch2-time-4_Arja_PatchNaturalness$$Add an exception. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch3-time-4_Arja_PatchNaturalness$$Fix # 135. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch4-time-4_Arja_PatchNaturalness$$Fixed zero - is - max datetime field minimization. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_Arja_PatchNaturalness$$MonthDay doesn ' t wrap month - day partials in MonthDay .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch1-lang-50_Arja_PatchNaturalness$$Fix getDateInstance ( ). Fix cDateTimeInstanceCache . put ( key , format ) .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch6-lang-50_Arja_PatchNaturalness$$Fix null zone definition for DateInstance where it is not defined. Prevent null pattern exception from throwing an exception when pattern is null .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch5-lang-50_Arja_PatchNaturalness$$locale = null ; Add missing null check in DateInstance .. Prevents null pattern check for the date time formatter .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch2-lang-50_Arja_PatchNaturalness$$FastDateFormat should cache locale for key. Prevent null pattern exception from throwing an exception when pattern is null .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch3-lang-50_Arja_PatchNaturalness$$Fix getDateInstance ( ). Fix cache update issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch4-lang-50_Arja_PatchNaturalness$$Fix getDateInstance ( ). Prevent null pattern exception from throwing an exception when pattern is null .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Arja_PatchNaturalness$$Handle case when String is empty or null. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch2-lang-51_Arja_PatchNaturalness$$Handle case when String is empty or null. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_Arja_PatchNaturalness$$StrBuilder . contains ( ) uses the array copy constructor. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_Arja_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary padding. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch2-lang-20_Arja_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary padding. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch3-lang-20_Arja_PatchNaturalness$$Removed unnecessary copy of StringUtils. Removed unnecessary copy of StringUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_Arja_PatchNaturalness$$Fixed NO_ISSUE in NumberUtils . createInteger ( ) .. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch2-lang-16_Arja_PatchNaturalness$$Fixed erroneous error in NumberUtils. $$0
lang-41$$ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.$$A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));$$patch1-lang-41_Arja_PatchNaturalness$$make ClassUtils . getShortCanonicalName work for 1 . 7. made ClassUtils . getPackageCanonicalName a little easier to resolve. $$0
math-35$$Need range checks for elitismRate in ElitisticListPopulation constructors.$$There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.$$patch1-math-35_PatchSim_PatchNaturalness$$Missing license header. ElitisticListPopulation can throw exception if elitismRate is not 1 . 0. ElitisticListPopulation constructor should throw exception if elitismRate is not 1 . 0. $$1
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_PatchSim_PatchNaturalness$$Added back missing betas. $$1
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_PatchSim_PatchNaturalness$$Fix NumberFormatException. $$1
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_PatchSim_PatchNaturalness$$Fix post - release build. $$1
chart-9$$Error on TimeSeries createCopy() method$$The test case at the end fails with :  java.lang.IllegalArgumentException: Requires start <= end.  The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7$$patch1-chart-9_PatchSim_PatchNaturalness$$Fix a bug in chart_9_TimeSeries_t. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_PatchSim_PatchNaturalness$$Improved method to append XYDataItems. $$0
math-104$$Special functions not very accurate$$The Gamma and Beta functions return values in double precision but the default epsilon is set to 10e-9. I think that the default should be set to the highest possible accuracy, as this is what I'd expect to be returned by a double precision routine. Note that the erf function already uses a call to Gamma.regularizedGammaP with an epsilon of 1.0e-15.$$patch1-math-104_PatchSim_PatchNaturalness$$Fix incorrect patch. $$0
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_PatchSim_PatchNaturalness$$Added a test to see if the dataset is not sufficiently large and not too large .. $$0
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch2-math-33_PatchSim_PatchNaturalness$$Add missing column to drop from tableau if it is too large. $$0
math-42$$Negative value with restrictNonNegative$$Problem: commons-math-2.2 SimplexSolver. A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver.optimize(function, constraints, GoalType.MINIMIZE, true); Function 1 * x + 1 * y + 0 Constraints: 1 * x + 0 * y = 1 Result: x = 1; y = -1; Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.$$patch1-math-42_PatchSim_PatchNaturalness$$Add missing column to drop from matrix. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-73_PatchSim_PatchNaturalness$$update error message. $$0
math-87$$Basic variable is not found correctly in simplex tableau$$The last patch to SimplexTableau caused an automated test suite I'm running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code. SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable, which is incorrect - the entry should have a value equal to 1.$$patch1-math-87_PatchSim_PatchNaturalness$$Fix a bug in the Math_87_SimplexTableau_t example .. $$0
math-87$$Basic variable is not found correctly in simplex tableau$$The last patch to SimplexTableau caused an automated test suite I'm running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code. SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable, which is incorrect - the entry should have a value equal to 1.$$patch2-math-87_PatchSim_PatchNaturalness$$restrict to non - negative alternatives. $$0
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_PatchSim_PatchNaturalness$$removed test code. $$0
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch2-math-88_PatchSim_PatchNaturalness$$added check for erroneous division. $$0
math-41$$One of Variance.evaluate() methods does not work correctly$$The method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[] values, double[] weights, double mean, int begin, int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.$$patch1-math-41_PatchSim_PatchNaturalness$$Added missing if (. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_PatchSim_PatchNaturalness$$removed incorrect patch. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch2-math-84_PatchSim_PatchNaturalness$$Add a return statement so the contract can be used .. $$0
math-24$$"BrentOptimizer" not always reporting the best point$$BrentOptimizer (package "o.a.c.m.optimization.univariate") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.$$patch1-math-24_PatchSim_PatchNaturalness$$Missing in previous patch. $$0
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_PatchSim_PatchNaturalness$$Fix NPE in Line . intersection ( ). $$0
time-18$$GJChronology rejects valid Julian dates$$The 2nd statement fails with "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]".  Given that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?$$patch1-time-18_PatchSim_PatchNaturalness$$Fixed incorrect patch. $$0
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_PatchSim_PatchNaturalness$$Fixed misc problems caused by the string comparison. $$0
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_PatchSim_PatchNaturalness$$Fixed incorrect patching. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_PatchSim_PatchNaturalness$$Fix incorrect patch180 data. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch3-time-4_PatchSim_PatchNaturalness$$Add 0 . 5 for the getMaximumValue ( ) method , but not in the patch. $$0
time-12$$Check Calendar.ERA in LocalDate.fromCalendarFields$$None$$patch1-time-12_PatchSim_PatchNaturalness$$Fix incorrect merge. $$0
time-14$$Unable to add days to a MonthDay set to the ISO leap date$$It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.$$patch1-time-14_PatchSim_PatchNaturalness$$Fixed incorrect patch. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_PatchSim_PatchNaturalness$$Fix incorrect patch. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_PatchSim_PatchNaturalness$$Fix typo in patch. $$0
closure-73$$Codepoint U+007f appears raw in output$$None$$patch1-closure-73_ConFix_PatchNaturalness$$Fix typo in codeGenerator . java. $$1
closure-38$$Identifier minus a negative number needs a space between the "-"s$$None$$patch1-closure-38_ConFix_PatchNaturalness$$Fix whitespace in code consumer. $$1
chart-11$$JCommon 1.0.12 ShapeUtilities.equal(path1,path2)$$The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.$$patch1-chart-11_ConFix_PatchNaturalness$$Add missing import. Fix test. $$1
math-33$$SimplexSolver gives bad results$$Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0 in a simple test problem. It works well in commons-math-2.2.$$patch1-math-33_ConFix_PatchNaturalness$$Fix missing import. reduce maxUlps to epsilon. $$1
math-75$$In stat.Frequency, getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)$$Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change Frequency.java    /**  Returns the percentage of values that are equal to v @deprecated replaced by  {@link #getPct(Comparable)}  as of 2.0      */     @Deprecated     public double getPct(Object v)  {         return getCumPct((Comparable<?>) v);     }$$patch1-math-75_ConFix_PatchNaturalness$$Add missing import .. Fix getFrequency ( Object ) to return 1 , not 2. $$1
math-30$$Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets$$When performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets), intermediate integer values used in calculateAsymptoticPValue can overflow, leading to invalid results, such as p-values of NaN, or incorrect calculations. Attached is a patch, including a test, and a fix, which modifies the affected code to use doubles$$patch1-math-30_ConFix_PatchNaturalness$$Fix warning. $$1
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_ConFix_PatchNaturalness$$updated imports. Added missing closing parenthesis .. $$1
time-19$$Inconsistent interpretation of ambiguous time during DST$$The inconsistency appears for timezone Europe/London.  These three DateTime objects should all represent the same moment in time even if they are ambiguous. Now, it always returns the earlier instant (summer time) during an overlap.$$patch1-time-19_ConFix_PatchNaturalness$$fixed typo .. $$1
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_ConFix_PatchNaturalness$$missing break. $$1
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_ConFix_PatchNaturalness$$Fix checkSuspiciousCode. $$0
closure-133$$Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */$$None$$patch1-closure-133_ConFix_PatchNaturalness$$Allow non - type annotations .. $$0
closure-89$$Compiler removes function properties that it should not$$None$$patch1-closure-89_ConFix_PatchNaturalness$$Fix CollapseProperties report. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_ConFix_PatchNaturalness$$Fix check side effects for calls to the closure context. $$0
closure-119$$catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode$$None$$patch1-closure-119_ConFix_PatchNaturalness$$Add some fix .. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_ConFix_PatchNaturalness$$Fix MinimizeExitPoints . java to include imports from confix .. Fix try / finally blocks. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_ConFix_PatchNaturalness$$Fix maybeGetSingleReturnRValue ( ). $$0
closure-108$$precondition crash: goog.scope local with aliased in the type declaration$$None$$patch1-closure-108_ConFix_PatchNaturalness$$Fix check for same name in ScopedAliases. $$0
closure-90$$@this emits warning when used with a typedef$$None$$patch1-closure-90_ConFix_PatchNaturalness$$Add missing import .. Fix TypeCheck . java. $$0
closure-79$$RuntimeException when compiling with extern prototype$$None$$patch1-closure-79_ConFix_PatchNaturalness$$Fix findbugs issue. $$0
closure-83$$Cannot see version with --version$$None$$patch1-closure-83_ConFix_PatchNaturalness$$Fix checkstyle issues. $$0
closure-125$$IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType$$None$$patch1-closure-125_ConFix_PatchNaturalness$$Add missing imports .. Fix TypeCheck . java for ES6 closures .. $$0
closure-2$$combining @interface and multiple @extends can crash compiler$$None$$patch1-closure-2_ConFix_PatchNaturalness$$Fix TypeCheck . checkForExtraProperties. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_ConFix_PatchNaturalness$$Allow non - expr results in closure closure check .. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_ConFix_PatchNaturalness$$Add some missing imports. Fix bug in addOrUpdate. $$0
math-42$$Negative value with restrictNonNegative$$Problem: commons-math-2.2 SimplexSolver. A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver.optimize(function, constraints, GoalType.MINIMIZE, true); Function 1 * x + 1 * y + 0 Constraints: 1 * x + 0 * y = 1 Result: x = 1; y = -1; Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.$$patch1-math-42_ConFix_PatchNaturalness$$Fix a bug in the similarity function. $$0
math-44$$Incomplete reinitialization with some events handling$$I get a bug with event handling: I track 2 events that occur in the same step, when the first one is accepted, it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I can't give my context, which is rather large, but I tried a patch that works for me, unfortunately it breaks the unit tests.$$patch1-math-44_ConFix_PatchNaturalness$$Fix load / load of confix classes. Fix typo in EventState. $$0
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_ConFix_PatchNaturalness$$Fix warning. Fix a bug in the similarity function. $$0
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_ConFix_PatchNaturalness$$Fix bug in MathUtils . equals. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_ConFix_PatchNaturalness$$Fix typo in MultiDirectional .. $$0
math-3$$ArrayIndexOutOfBoundsException in MathArrays.linearCombination$$When MathArrays.linearCombination is passed arguments with length 1, it throws an ArrayOutOfBoundsException. This is caused by this line: double prodHighNext = prodHigh[1]; linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.$$patch1-math-3_ConFix_PatchNaturalness$$Fix MathArrays . prodHigh to work with bit 64 .. $$0
time-9$$Ensure there is a max/min valid offset$$DateTimeZone does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.$$patch1-time-9_ConFix_PatchNaturalness$$Fix bug in time9 .. fixed offset zone for configuration file. $$0
time-7$$DateTimeFormat.parseInto sometimes miscalculates year (2.2)$$The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999.$$patch1-time-7_ConFix_PatchNaturalness$$Add withUTC suffix .. $$0
time-17$$Bug on withLaterOffsetAtOverlap method$$On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all ).$$patch1-time-17_ConFix_PatchNaturalness$$Fix bug in time zone ISO 8601 format. $$0
time-4$$Constructing invalid Partials$$Partials can be constructed by invoking a constructor Partial(DateTimeFieldType[], int[]) or by merging together a set of partials using with, each constructed by calling Partial(DateTimeFieldType, int). However, the above doesn't work in all cases: I suppose the Partials should not allow to be constructed in either case. Is that right?  There's also a related issue (probably stems from the fact that the Partial is invalid):$$patch1-time-4_ConFix_PatchNaturalness$$Add missing import .. Fixed whitespace in ZeroIsMaxDateTimeField . getMaximumValue ( ReadablePartial instant , int [. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch1-lang-60_ConFix_PatchNaturalness$$Added missing 1111. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_ConFix_PatchNaturalness$$Fix typo in first line of text file. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_ConFix_PatchNaturalness$$reduce TFJ - 619 search path. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_jKali_PatchNaturalness$$Fix bug in closure patch. $$1
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_jKali_PatchNaturalness$$try minimize exits on finally blocks. $$1
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_jKali_PatchNaturalness$$Updated patch. $$1
lang-10$$FastDateParser does not handle white-space properly$$The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.$$patch1-lang-10_jKali_PatchNaturalness$$don ' t backslash backslash in regex so it won ' t be backslashed. $$1
closure-45$$Assignment removed when used as an expression result to Array.push$$None$$patch1-closure-45_jKali_PatchNaturalness$$fix bug. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_jKali_PatchNaturalness$$don ' t add extra space to the end of a line. $$0
closure-101$$--process_closure_primitives can't be set to false$$None$$patch1-closure-101_jKali_PatchNaturalness$$closure fix bug. $$0
closure-46$$ClassCastException during TypeCheck pass$$None$$patch1-closure-46_jKali_PatchNaturalness$$Fix closure patching. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_jKali_PatchNaturalness$$Allow null dataset in chart. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_jKali_PatchNaturalness$$Fix bug in chart. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_jKali_PatchNaturalness$$removed expPos from mant patch. $$0
closure-57$$compiler crashes when  goog.provide used with non string$$None$$patch1-closure-57_SimFix_PatchNaturalness$$Fixing closure code conventions. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_SimFix_PatchNaturalness$$Allow null arguments for static closures .. $$1
math-35$$Need range checks for elitismRate in ElitisticListPopulation constructors.$$There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.$$patch1-math-35_SimFix_PatchNaturalness$$Add a exception check. Add a exception check. $$1
math-63$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard. If nobody objects, I'm going to make the changes.$$patch1-math-63_SimFix_PatchNaturalness$$Fix MathUtils . equals ( double , double , int ). $$1
math-41$$One of Variance.evaluate() methods does not work correctly$$The method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[] values, double[] weights, double mean, int begin, int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset. Similar method in Mean class seems to work. I did not check other methods taking the part of the array; they may have the same problem. Workaround: I had to shrink my arrays and use the method without the length.$$patch1-math-41_SimFix_PatchNaturalness$$Fix the for loop. $$1
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch1-lang-50_SimFix_PatchNaturalness$$Fix FastDateFormat ' s key value if locale is not null. Fix getLocaleKey exception in FastDateFormat. $$1
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch1-lang-58_SimFix_PatchNaturalness$$Fix parse error ( l - > long ). $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_SimFix_PatchNaturalness$$removed null check. $$1
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch1-lang-16_SimFix_PatchNaturalness$$convert string to lower case since it ' s a number. $$1
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_SimFix_PatchNaturalness$$Fixed a bug in the linear search results. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_SimFix_PatchNaturalness$$Fix parse error. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_SimFix_PatchNaturalness$$make str . length ( ) > upper. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_SimFix_PatchNaturalness$$Fix erroneous fallthrough in NumberUtils. $$0
chart-16$$Bug propgated from v1.0.5 on to present$$The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it "Returns the number of series in the dataset (possibly zero)."  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.$$patch1-chart-16_VFix_PatchNaturalness$$Fix bug in chart 16. $$1
chart-16$$Bug propgated from v1.0.5 on to present$$The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it "Returns the number of series in the dataset (possibly zero)."  The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.$$patch2-chart-16_VFix_PatchNaturalness$$Fix bug in chart - 16. $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch1-math-4_VFix_PatchNaturalness$$added missing if (. $$1
math-4$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations. The attached patch fixes both implementations and adds the required test cases.$$patch2-math-4_VFix_PatchNaturalness$$Add null check in patch2. $$1
lang-57$$NullPointerException in isAvailableLocale(Locale)$$FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.$$patch1-lang-57_VFix_PatchNaturalness$$Add null check. $$1
lang-33$$ClassUtils.toClass(Object[]) throws NPE on null array element$$see summary$$patch1-lang-33_VFix_PatchNaturalness$$removed null check. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch1-lang-20_VFix_PatchNaturalness$$fixed bug. $$1
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch2-lang-20_VFix_PatchNaturalness$$fixed bug. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch1-lang-47_VFix_PatchNaturalness$$Fix bug. $$1
lang-47$$StrBuilder appendFixedWidth does not handle nulls$$Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.$$patch2-lang-47_VFix_PatchNaturalness$$Fix bug. $$1
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_VFix_PatchNaturalness$$Added a fix for null constraint. $$0
closure-62$$Column-indicating caret is sometimes not in error output$$None$$patch1-closure-62_jMutRepair_PatchNaturalness$$Fixed bug in Closure Repair fix. $$1
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_jMutRepair_PatchNaturalness$$Fix nullability assertion .. $$1
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_jMutRepair_PatchNaturalness$$Fix closure closure bug. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_jMutRepair_PatchNaturalness$$minimize the closure closure closure closure patch .. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_jMutRepair_PatchNaturalness$$JSDoc info removed from closure patch. $$0
math-88$$Simplex Solver arrives at incorrect solution$$I have reduced the problem reported to me down to a minimal test case which I will attach.$$patch1-math-88_jMutRepair_PatchNaturalness$$added fixed case for tableau sizes. $$0
math-84$$MultiDirectional optimzation loops forver if started at the correct solution$$MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution. see the attached test case (testMultiDirectionalCorrectStart) as an example.$$patch1-math-84_jMutRepair_PatchNaturalness$$added a missing if / else. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch1-lang-27_jMutRepair_PatchNaturalness$$Fix incorrect patch. $$0
closure-126$$Break in finally block isn't optimized properly$$None$$patch1-closure-126_GenProgA_PatchNaturalness$$Remove tryMinimizeExits from tryMinimizeExits. $$1
closure-115$$Erroneous optimization in ADVANCED_OPTIMIZATIONS mode$$None$$patch1-closure-115_GenProgA_PatchNaturalness$$Allow side effects for closure arguments. $$1
closure-59$$Cannot exclude globalThis checks through command line$$None$$patch1-closure-59_GenProgA_PatchNaturalness$$"Add "" addVerboseWarnings ( ) "" to closure compiler warnings". $$0
closure-67$$Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function$$None$$patch1-closure-67_GenProgA_PatchNaturalness$$Remove unused prototype properties fix .. $$0
closure-10$$Wrong code generated if mixing types in ternary operator$$None$$patch1-closure-10_GenProgA_PatchNaturalness$$Remove broken upgrade .. closure folding changes. $$0
closure-21$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-21_GenProgA_PatchNaturalness$$Updated code. $$0
closure-75$$closure compiled swfobject error$$None$$patch1-closure-75_GenProgA_PatchNaturalness$$Remove the missing semicolon in POS signs. Remove reported code change of PeepholeFoldConstants. Updated isStrWhiteSpaceChar method .. $$0
closure-55$$Exception when emitting code containing getters$$None$$patch1-closure-55_GenProgA_PatchNaturalness$$Remove unneeded call to NodeTraversal . traverse ( ) .. $$0
closure-112$$Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown$$None$$patch1-closure-112_GenProgA_PatchNaturalness$$Remove hard coded resolve of template types in closure context. $$0
closure-124$$Different output from RestAPI and command line jar$$None$$patch1-closure-124_GenProgA_PatchNaturalness$$Remove old and unused patch .. $$0
closure-114$$Crash on the web closure compiler$$None$$patch1-closure-114_GenProgA_PatchNaturalness$$Add generated paramName to replacements , for efficiency .. Add paramName to closure context so it can be used by filer .. $$0
closure-78$$division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR$$None$$patch1-closure-78_GenProgA_PatchNaturalness$$Do not increment local variable. $$0
closure-22$$Classify non-rightmost expressions as problematic$$None$$patch1-closure-22_GenProgA_PatchNaturalness$$Remove stray return statement from a checksideeffects patch .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch1-chart-1_GenProgA_PatchNaturalness$$Fix x axis issue. Fix NPE in CategoryPlot. Fix NPE in chart impl. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_GenProgA_PatchNaturalness$$Fix legends not disappearing on I + E7. Fix fire chart changed event. Add a listener to setDatasetGroup ( ) for multiple pie plot. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch1-math-31_GenProgA_PatchNaturalness$$Add logm value to FDistribution . getNumericalVariance ( ). Fix merge conflict in MathIllegalStateException. Missing return from patch 1 . 0. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch120-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch36-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix category plot backgrounds. Remove fireChangeEvent ( ) from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch127-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch31-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Fix CategoryPlot ' s renderer. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch118-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix CategoryPlot ' s renderers. Fix bug. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch111-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend ' s location .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch38-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch116-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Fix # 183. Remove a couple of unused files. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch129-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Extend CategoryPlot to remove listener from the existing renderer. Fix issue with the axes configuration for the year century .. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch189-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix option selection on CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch142-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove fireChangeEvent ( ) from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch54-chart-1_GenProg_PatchNaturalnessYe$$Fix label positionning. Fix pull request. Fix # 1664. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch98-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix a bug in CategoryPlot. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch145-chart-1_GenProg_PatchNaturalnessYe$$Added patch to defects4J_Chart_1. Fix # 1862. remove 1677 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch53-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category items renderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch65-chart-1_GenProg_PatchNaturalnessYe$$Fix label positionning. Fix # 1862. Remove redundant code. remove 1673 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch173-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Added missing patch. Remove redundant code. Fix issue with wrong range axis size. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch91-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove redundant code. Fix # 183. Fix issues with the categs spines plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch187-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch96-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. Remove unused variable. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch180-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch62-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed redundant call to setRenderer ( ). Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch174-chart-1_GenProg_PatchNaturalnessYe$$Add barBase and line to result. Fix NPE in CategoryPlot. Remove redundant code. Fix minor eclipse compile warning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch117-chart-1_GenProg_PatchNaturalnessYe$$Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. Fix a bug in CategoryPlot. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch128-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with the axes function not being re - added. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch110-chart-1_GenProg_PatchNaturalnessYe$$Improved null pointer check in CategoryItemRenderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch39-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix bug. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch126-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. throw exception if index is negative. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch119-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix issue with defects4J_Chart_1 .. Remove some trailing whitespace. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch121-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch37-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis not being changed by the user. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch63-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch175-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix # 1862. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch97-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix issue with domain axis selection. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch181-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch90-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix # 1862. Fix bug. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch186-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1336. Fix # 1862. Fix category axis. Fix category axes. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch64-chart-1_GenProg_PatchNaturalnessYe$$Remove potential NPE in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch172-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1796. remove 1675 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch99-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category items renderer patch. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set range zero baseline stroke. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch144-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch52-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 1862. Remove redundant code. Fix issue with defects 4J calendar plugin. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch188-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 183. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch143-chart-1_GenProg_PatchNaturalnessYe$$Remove some redundant lines. Fix # 1862. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch55-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch204-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix a problem with the axes. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch205-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch202-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with the legend ' s X axis .. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch161-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix year for data set domain axis. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch195-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. remove 1679 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch83-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix a potential NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch48-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch192-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix # 183. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch84-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix issue with data set range zero baseline stroke. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch166-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch70-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Added fix for NPE in CategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch46-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1349. Fix bug. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch150-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch79-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix # 1862. Fix issue with wrong parameter name. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch6-chart-1_GenProg_PatchNaturalnessYe$$Remove 1355 from CategoryPlot. Remove redundant code. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch41-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix fireChangeEvent. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch157-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix # 183. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch168-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with defects plot 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch103-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix label positionning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch104-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix issue with the legend ' s X axis .. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch24-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove redundant call to fireChangeEvent ( ) in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch132-chart-1_GenProg_PatchNaturalnessYe$$Fix a potential NPE in CategoryPlot. Fix NPE in CategoryPlot. Fix category axes. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch135-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch40-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Fix PR # 1674. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch156-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch169-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix legend generation. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch47-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch151-chart-1_GenProg_PatchNaturalnessYe$$Fix category axis location .. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch78-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch167-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1349. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch71-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix # 1359. Remove redundant code. Fix NPE in CategoryPlot. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch193-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1660. Remove 1672 from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch85-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch158-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch194-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Fix # 1862. Fix issue with same dataset .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch82-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove unused variable .. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch160-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix change in CategoryPlot. Add urlText to category items renderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch49-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1862. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch22-chart-1_GenProg_PatchNaturalnessYe$$Fix # 183. Fix issue with defects4J_Chart_1 .. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch134-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix null label in CategoryPlot. Require index < 0 .. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch25-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix issue with first plot using patch. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch133-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix CategoryPlot ' s renderers. Fix issue with data set selection. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch105-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix fireChangeEvent. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch102-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch179-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix CategoryPlot ' s renderers. Fix issue with the axes configuration for the year century .. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch146-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch50-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Remove redundant code. Fix Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col Col. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch68-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch141-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category item renderer. Fix NPE in CategoryPlot. Remove redundant code. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch57-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Remove redundant call. Fix null label in CategoryPlot. Require index < 0 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch148-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Added patch for domain axis generation. Fix category gridline position .. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch95-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch183-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with chart 1 .. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch61-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in place. Fix a bug in CategoryPlot. Fix option selection for CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch177-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix build. Remove redundant code. Fix fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch59-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Fix local testing. Remove spurious return value. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch66-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed redundant call to setRenderer ( ). Fix issue with the legend ' s X axis .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch170-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix getDataset ( ). Fix # 1862. Remove redundant code. remove 1674 from category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch92-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix category axes. Fix # 1718. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch124-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 183. Remove redundant code. Fix issue with chart 1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch32-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix bug. Fix category plot index calculation .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch123-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix bug in CategoryPlot. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch35-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix # 1862. Remove redundant code. added notify listener. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch115-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix fire sale. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch58-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. remove 1677 from range axes. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch185-chart-1_GenProg_PatchNaturalnessYe$$Added datasetChanged ( ) method to CategoryPlot. Remove redundant code. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch67-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch171-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Fix # 1864. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch149-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix issue with ' GenProg_Defects4J_Chart_1 '. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch60-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Removed a redundant call to remove a redundant call to remove a redundant call to remove a redundant. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch176-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with the legend ' s X axis .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch94-chart-1_GenProg_PatchNaturalnessYe$$added datasetChanged ( ) to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch182-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant line. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch69-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch140-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 1862. Fix issue with domain axis selection. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch56-chart-1_GenProg_PatchNaturalnessYe$$Fix category data range selection. Fix 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch178-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch147-chart-1_GenProg_PatchNaturalnessYe$$Remove urlText from AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Removed redundant call to setRenderer ( ). Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch51-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch113-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Remove redundant code. Fix fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch114-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch122-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Fix legend generation. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch34-chart-1_GenProg_PatchNaturalnessYe$$Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. Remove redundant fireChangeEvent ( ) call. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch125-chart-1_GenProg_PatchNaturalnessYe$$Remove null check. Fix crosshair renderers. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch33-chart-1_GenProg_PatchNaturalnessYe$$Fix legend. Fix NPE in CategoryPlot. Fix change in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch207-chart-1_GenProg_PatchNaturalnessYe$$Added datasetChanged ( ) method to CategoryPlot. Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch200-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove some trailing whitespace. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch208-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 183. Remove redundant code. Fix issue with ' add domain axis ' method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch201-chart-1_GenProg_PatchNaturalnessYe$$Fix issue with ' CategoryPlot ' axis. Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch206-chart-1_GenProg_PatchNaturalnessYe$$Fix issue with wrong param. Remove some trailing whitespace. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch138-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1213. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch107-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Fix build. Remove redundant code. Fix bug. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch29-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch100-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix fireChangeEvent. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch109-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with domain axis not being changed by the end of categorical axes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch136-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. remove 1677 from category plot. Remove some redundant lines. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch27-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Fix local variable warning. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch131-chart-1_GenProg_PatchNaturalnessYe$$Fix # 183. Fix category plot not listening to the existing renderer. Fix category axis fire. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch191-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix NPE in CategoryPlot. Remove redundant code. Remove fireChangeEvent ( ) from CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch87-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in AbstractCategoryItemRenderer. Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch165-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with ' add domain axis ' method. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch73-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not used .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch162-chart-1_GenProg_PatchNaturalnessYe$$Fix pull request. Fix newline. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch74-chart-1_GenProg_PatchNaturalnessYe$$Fix issue with CategoryPlot . setDataset ( int , CategoryDataset ). Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch196-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix NPE in CategoryPlot . setDataset ( ). Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch80-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix null label in CategoryPlot. Require index < 0 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch42-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1336. Fix # 1862. Fix CategoryPlot ' s renderer. Fix bug. Fix issue with wrong dataset index. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch154-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix issue with chart 1 .. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch89-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1349. Remove redundant code. Fix NPE in CategoryPlot. Fix category chart demo .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch153-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot . setDataset ( ). Fix # 1862. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch198-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. remove 1674 from category plot. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch26-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with the axes configuration for today ' s CategoryPlot. Remove unused variable. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch130-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Fix issue with domain axis selection. Remove some lines that were not left unlinked , fixed opengl opengl opengl opengl opengl opengl opengl opengl. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch108-chart-1_GenProg_PatchNaturalnessYe$$Add urlText to category item renderer. Fix NPE in CategoryPlot. Fix NPE in CategoryPlot. Remove redundant code. Fix issue with data set definition. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch21-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix local variable warning. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch137-chart-1_GenProg_PatchNaturalnessYe$$Remove redundant code. Remove 1679 from CategoryPlot. Fix label positionning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch28-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch101-chart-1_GenProg_PatchNaturalnessYe$$Fix a potential NPE in CategoryPlot. Fix # 1862. Fix bug. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch139-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Remove redundant code. Fix category axis location .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch106-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix # 183. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch44-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch152-chart-1_GenProg_PatchNaturalnessYe$$throw exception if index is negative. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch199-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix # 1862. Remove redundant code. Fix issue with domain axis selection. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch43-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Fix category axis registration. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch155-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix NPE in CategoryPlot . setDataset ( ). Remove redundant code. Fix pull request. Remove urlText from AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch88-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch197-chart-1_GenProg_PatchNaturalnessYe$$Remove null check in place. Fix # 1862. Remove redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch81-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 183. Fix # 1673. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch163-chart-1_GenProg_PatchNaturalnessYe$$Fix a bug in CategoryPlot. throw exception if index is negative. Remove null check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch75-chart-1_GenProg_PatchNaturalnessYe$$Fix 1349. Fix legend generation. Fix NPE in chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch164-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove redundant code. Fix bug. Remove urlText = null in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch72-chart-1_GenProg_PatchNaturalnessYe$$Fix # 1862. Remove unused variable .. Fix issue with domain axis selection. Remove null check in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch86-chart-1_GenProg_PatchNaturalnessYe$$Fix NPE in chart 1. Fix # 183. Remove redundant code. Fix legend generation. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch1-chart-12_GenProg_PatchNaturalnessYe$$Improved method to remove listener from AbstractDataset. Set padding on legends. Add fix from pull request. Remove old line. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch11-chart-12_GenProg_PatchNaturalnessYe$$Fix race condition. Fix bug in JFreeChart 12. Add fix from pull request. Fix issue with deferment of subtitles. Fix bug in JFreeChart 12 .. Improved method to remove listener from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch2-chart-12_GenProg_PatchNaturalnessYe$$Improved method to remove listener from AbstractDataset. Fix # 7751. Add fix from pull request. Remove old line. Fix # 1862. Added throw exception if padding is null. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch1-chart-5_GenProg_PatchNaturalnessYe$$Remove an overwritten throw exception if it is null. Improved method to append XYSeries items. Fix overwritten variable. $$0
chart-5$$XYSeries.addOrUpdate() should add if duplicates are allowed$$I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data.$$patch3-chart-5_GenProg_PatchNaturalnessYe$$Remove an overwritten check. Improved method to append XYSeries items. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch36-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Set default function value accuracy to 1 . 0e - 15. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch31-math-73_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing ( min , max , f ) to BrentSolver. Fix broken patch. revert 284 if we go into reverse workflow. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch38-math-73_GenProg_PatchNaturalnessYe$$BrentSolver was setting the initial value to 0 , but it was not good enough. I had left it harwired to verifySequence. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch54-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15. Clarify solution with provided initial guess. Fix swapped line endings. Fix error in BrentSolver .. Fix erroneous test case. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch53-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Reversing verifySequence with provided initial guess. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch65-math-73_GenProg_PatchNaturalnessYe$$BrentSolver does not clear the result flag at the end of each test. Added patch to verifyBracketing ( min , max , f ). Added patch for 1 . 5 * dx. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch62-math-73_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing ( min , max , f ). Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch39-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case with the new method .. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch30-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15 .. Clarify solution with provided initial guess. Fix swapped line endings. Fix erroneous patch in BrentSolver. Fix Tehran ' s patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch37-math-73_GenProg_PatchNaturalnessYe$$Clarify BrentSolver with better error handling. Fix swapped line. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch63-math-73_GenProg_PatchNaturalnessYe$$Fix a warning. BrentSolver was setting the initial value to 0 , but it was not good enough. Updated police script. Fix broken patch. Fix error in BrentSolver .. Add a patch for inverse quadratic interpolation. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch64-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15. updated BrentSolver. Fix swapped line. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch52-math-73_GenProg_PatchNaturalnessYe$$Clarify BrentSolver with better error handling. updated BrentSolver. Fix broken patch. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch55-math-73_GenProg_PatchNaturalnessYe$$Fix a warning. Clarify a use case for BrentSolver as well. Add a checkResultComputed ( ) to the BrentSolver class .. Fix broken patch. Add a patch for inverse quadratic interpolation. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch48-math-73_GenProg_PatchNaturalnessYe$$Remove a clearResult ( ) from the functional tests. Set default function value accuracy from 1 . 0e - 15 ( # 77 ). Reversing verifySequence with provided initial guess. Fix broken patch. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch70-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15 .. Clarify solution with provided initial guess. Fix swapped line. Fix error in BrentSolver .. Fix Tehran ' s patch. Fix a warning. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch8-math-73_GenProg_PatchNaturalnessYe$$Fix erroneous test. Reset the computed result of the BrentSolver as well. Fix swapped line endings. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch46-math-73_GenProg_PatchNaturalnessYe$$Clarify BrentSolver with variable variable. Added patch to make it work reliably outside of brackets. Fix broken patch. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch6-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Added patch for full Brent solver. Fix broken patch. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch41-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case with the new method .. Set default function value accuracy to 0 .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch15-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case with the new method .. I had left it harwired to verifySequence. Fix broken patch. BrentSolver now uses 1 . 0 x1 , not the x0 .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch12-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15. Fix swapped line. Fix error in BrentSolver .. Fix erroneous test case. Fix erroneous variable. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch24-math-73_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value of the bracketing function. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch23-math-73_GenProg_PatchNaturalnessYe$$BrentSolver was setting the result of a previous resolve ( ) call. Fix broken patch. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch40-math-73_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyInterval ( min , max , f ) to BrentSolver. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch47-math-73_GenProg_PatchNaturalnessYe$$Fix erroneous test. Added verifySequence ( ) to GenProg_Defects4J_Math_. Fix broken patch. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch71-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch9-math-73_GenProg_PatchNaturalnessYe$$Clarify BrentSolver with better error handling. Add a checkResultComputed ( ) to the genProg_Defects4J_. Fix swapped line. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch49-math-73_GenProg_PatchNaturalnessYe$$Added verifyInterval ( min , max , f ) to BrentSolver. Improved the overall solution of BrentSolver .. Fix swapped line. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch22-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy from 1 . 0e - 15 .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch25-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). changed name of BrentSolver. Fix broken patch. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch13-math-73_GenProg_PatchNaturalnessYe$$BrentSolver does not clear the result before attempting to use it. Added verifyBracketing ( min , max , f ). updated BrentSolver. Fix case. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch14-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case for BrentSolver as well. Add a checkResultComputed ( ) to the genProg_Defects4J_. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch50-math-73_GenProg_PatchNaturalnessYe$$Clarify variable names as unused in BrentSolver. Added verifySequence ( ) to GenProg_Defects4J_Math_. Fix broken patch. Fix erroneous test case. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch68-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). updated BrentSolver. Fix broken patch. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch57-math-73_GenProg_PatchNaturalnessYe$$Fix a warning. Set default function value accuracy to 1 . 0e - 15. Clarify solution with provided initial guess. Fix broken patch. Fix erroneous variable update in BrentSolver . java. Add inverse quadratic interpolation fix. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch61-math-73_GenProg_PatchNaturalnessYe$$Fix a warning. Set default function value accuracy to 1 . 0e - 15. Fix swapped line endings. Fix error in BrentSolver .. Add inverse quadratic interpolation patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch59-math-73_GenProg_PatchNaturalnessYe$$I was confused , sorry. Set default function value accuracy to 1 . 0e - 15. Clarify solution with provided initial guess. Fix broken patch. Fix erroneous variable update in BrentSolver . java. Fix erroneous inverse quadratic interpolation patch. Fix a warning. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch66-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy from 1 . 0e - 15 .. Reversing verifySequence with provided initial guess. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch32-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch35-math-73_GenProg_PatchNaturalnessYe$$BrentSolver was setting the min / max brackets so it is good enough .. Set default function value accuracy to 0 .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch58-math-73_GenProg_PatchNaturalnessYe$$BrentSolver was failing in 1 . 6 . 2. I had left it harwired to verifySequence. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch67-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case .. Add a throw exception if the function to solve is null. Fix broken patch. revert 288 if we run out of time .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch60-math-73_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing ( min , max , f ). I had left it harwired to verifySequence. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch69-math-73_GenProg_PatchNaturalnessYe$$BrentSolver was setting the initial value to 0 , but it was not good enough. I had left it harwired to verifySequence. Fix broken patch. revert accidently change to the old one. Set resultComputed as false in UnivariateRealSolverImpl . verifySequence. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch56-math-73_GenProg_PatchNaturalnessYe$$Clarify BrentSolver with better accuracy. Add a verifySequence method. Fix swapped line. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch51-math-73_GenProg_PatchNaturalnessYe$$fixed NPE in UnivariateRealSolverImpl . verifySequence. BrentSolver does not update the. Fix broken patch. revert wrong patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch34-math-73_GenProg_PatchNaturalnessYe$$Fix erroneous test case. updated BrentSolver. Fix broken patch. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch33-math-73_GenProg_PatchNaturalnessYe$$Fix variable definition. Added verifyBracketing ( min , max , f ) to BrentSolver. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch11-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to BrentSolver . java. Clarify a use case .. Add back missing patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch29-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15. I had left it harwired to verifySequence. revert accidently change to the x1 - 0 . 5 * tolerance .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch16-math-73_GenProg_PatchNaturalnessYe$$BrentSolver doesn ' t clear the result before attempting to use it. Added patch to verifyBracketing ( min , max , f ). updated BrentSolver. Set resultComputed as true for BrentSolver .. Fix erroneous test case. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch20-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). removed a redundant patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch18-math-73_GenProg_PatchNaturalnessYe$$I had left it as a previous solution so I could make a new one .. updated BrentSolver. Fix swapped line endings. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch27-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case for BrentSolver as well. Improved the overall solution of BrentSolver .. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch73-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Added a throw exception if the provided function to solve is null. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch74-math-73_GenProg_PatchNaturalnessYe$$Set curried value of BrentSolver as the function value accuracy is maintained through the patched value. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch42-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy from 1 . 0e - 15 .. Added patch for 1 . 5 * dx. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch45-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ) to BrentSolver. Fix broken patch. revert accidently change to the x1 - 0 . 5 * tolerance .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch19-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy from the patched data. revert accidently change to the x1 - 0 . 5 * tolerance .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch26-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy from 1 . 0e - 15 .. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch21-math-73_GenProg_PatchNaturalnessYe$$Clarify a use case for BrentSolver as well. Add a checkResultComputed ( ) to the genProg_Defects4J_. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch28-math-73_GenProg_PatchNaturalnessYe$$I had left it in wrong place .. Added verifyBracketing ( min , max , f ). Add verifySequence to BrentSolver. BrentSolver now uses 1 . 0 x1 , not the x0 .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch17-math-73_GenProg_PatchNaturalnessYe$$Forgot to clear the result before attempting to verify the sequence. Added verifyBracketing ( min , max , f ). Reversing verifySequence. Fix swapped line endings. Fix erroneous test. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch10-math-73_GenProg_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15. Clarify solution with provided initial guess. Fix broken patch. Fix error in BrentSolver .. Fix erroneous test case. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch44-math-73_GenProg_PatchNaturalnessYe$$Added verifyInterval ( min , max , f ) to BrentSolver. Add a checkResultComputed ( ) to the BrentSolver class .. Fix broken patch. Added patch for BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch4-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ) to BrentSolver. Fix broken patch. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch43-math-73_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). changed verifySequence. revert accidently change to the old one. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch75-math-73_GenProg_PatchNaturalnessYe$$BrentSolver does not perform bracketing correctly .. Add a throw exception if the function to solve is null. Fix broken patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch72-math-73_GenProg_PatchNaturalnessYe$$Added a clearResult ( ) so that the function can be used as a final value. Add a check for null function to solve. Fix broken patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch31-math-31_GenProg_PatchNaturalnessYe$$Fix a small bug. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch38-math-31_GenProg_PatchNaturalnessYe$$updated continous fraction patch. Missing backslash. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch116-math-31_GenProg_PatchNaturalnessYe$$Missing patch .. Missing context for format string .. Fix continousFraction . floor ( ) = > 1 . 5. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch91-math-31_GenProg_PatchNaturalnessYe$$Add localization message for MathIllegalStateException. Fix a bug in ContinuedFraction where NAN is not greater than 0 . 5. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch96-math-31_GenProg_PatchNaturalnessYe$$Missing patch. Fix a missing var. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch117-math-31_GenProg_PatchNaturalnessYe$$Fix continousFraction . floor ( ) where it ' s not possible to express inversely. Add localization message for MathIllegalStateException. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch110-math-31_GenProg_PatchNaturalnessYe$$Missing context for format string .. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch30-math-31_GenProg_PatchNaturalnessYe$$updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch83-math-31_GenProg_PatchNaturalnessYe$$Add logm value to numericalVariance , too .. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch46-math-31_GenProg_PatchNaturalnessYe$$Add localization message for MathIllegalStateException. Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch41-math-31_GenProg_PatchNaturalnessYe$$fixed formatting. Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch104-math-31_GenProg_PatchNaturalnessYe$$Add localization message for MathIllegalStateException. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch40-math-31_GenProg_PatchNaturalnessYe$$Add localization message for MathIllegalStateException. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch47-math-31_GenProg_PatchNaturalnessYe$$Add localization message for MathIllegalStateException. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch82-math-31_GenProg_PatchNaturalnessYe$$Missing MissingContextExceptionListener. Fix a minor typo in ContinuedFraction. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch49-math-31_GenProg_PatchNaturalnessYe$$Throw an exception if the numeratorDegreesOfFreedom is not strictly positive. Fix numerical variance being calculated in patched manner .. Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch22-math-31_GenProg_PatchNaturalnessYe$$updated continous fraction patch. Fix accidental variable warning. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch105-math-31_GenProg_PatchNaturalnessYe$$Add localization message for MathIllegalStateException. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch50-math-31_GenProg_PatchNaturalnessYe$$Fix a small bug. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch61-math-31_GenProg_PatchNaturalnessYe$$Missing patch .. Fix a missing continuedFraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch67-math-31_GenProg_PatchNaturalnessYe$$Fix a small bug. Fix a missing continuedFraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch29-math-31_GenProg_PatchNaturalnessYe$$Missing patch for message getter for GenProg_Defects4J_Math_31. updated continous fraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch100-math-31_GenProg_PatchNaturalnessYe$$Added patch for MathIllegalStateException. Fix continousFraction . floor ( ) where it ' s not possible to express inversely. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch20-math-31_GenProg_PatchNaturalnessYe$$Missing patch. Missing backslash. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch42-math-31_GenProg_PatchNaturalnessYe$$Fix a minor typo in ContinuedFraction. fixed ExceptionContext . getMessage. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch89-math-31_GenProg_PatchNaturalnessYe$$Missing patch. Added patch for denominator and freedom .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch17-math-31_GenProg_PatchNaturalnessYe$$Fix continousFraction . floor ( ) = > 1 . 5. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch44-math-31_GenProg_PatchNaturalnessYe$$Fix continousFraction . pow ( n ) to log1 = 1 ;. Missing context for format string .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch4-math-31_GenProg_PatchNaturalnessYe$$Add a localization message for MathIllegalStateException. Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch88-math-31_GenProg_PatchNaturalnessYe$$Fix continousFraction . pow ( n ) to log1 = 1 ;. Missing patch .. Missing context for format string .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch86-math-31_GenProg_PatchNaturalnessYe$$Remove path from fmt . getLocalizedMessage ( ). Fix continousFraction . floor ( ) = > 1 . 5. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch31-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch38-math-70_GenProg_PatchNaturalnessYe$$fixed a small bug in BisectionSolver. fixed erroneous test. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch37-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed a small bug. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch8-math-70_GenProg_PatchNaturalnessYe$$fixed a small bug. fixed bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch46-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous build. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch6-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. updated bisection solver with updated maximal iterations. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch12-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver . solve ( ) .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch24-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch23-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch40-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. Set default function value accuracy across the full range of solutions .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch7-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch47-math-70_GenProg_PatchNaturalnessYe$$fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch49-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed N4G test. Set result to 0 in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch22-math-70_GenProg_PatchNaturalnessYe$$fixed N4G problem. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch25-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in the bisection solver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch13-math-70_GenProg_PatchNaturalnessYe$$fixed N4G problem. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch50-math-70_GenProg_PatchNaturalnessYe$$fixed n4g1 patch. fixed erroneous build. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch32-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous build. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch35-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch51-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch34-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch33-math-70_GenProg_PatchNaturalnessYe$$fixed N4G problem. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch29-math-70_GenProg_PatchNaturalnessYe$$fixed NPE in BisectionSolver . solve ( ) .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch16-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous build. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch20-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch27-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous build. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch42-math-70_GenProg_PatchNaturalnessYe$$fixed NPE in BisectionSolver . solve ( ) .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch5-math-70_GenProg_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver . solve ( ) .. fixed bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch45-math-70_GenProg_PatchNaturalnessYe$$fixed N4G problem. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch21-math-70_GenProg_PatchNaturalnessYe$$fixed N4G problem. Fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch28-math-70_GenProg_PatchNaturalnessYe$$fixed a small bug in BisectionSolver. fixed erroneous test. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch17-math-70_GenProg_PatchNaturalnessYe$$fixed N4G problem. fixed bug in BisectionSolver. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch10-math-70_GenProg_PatchNaturalnessYe$$fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch44-math-70_GenProg_PatchNaturalnessYe$$fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch43-math-70_GenProg_PatchNaturalnessYe$$fixed erroneous loop. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_Kali_PatchNaturalnessYe$$Revert previous patch. $$0
lang-44$$NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.$$Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.$$patch1-lang-44_Kali_PatchNaturalnessYe$$Fix error in last commit. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch120-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Added throw exception if index < 0. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch36-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. Fix # 1862. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch127-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch31-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch118-chart-1_Arja_PatchNaturalnessYe$$remove deprecated fireChangeEvent. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch111-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch38-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1796. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch116-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch129-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Add a note that the datasets are no longer used .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch189-chart-1_Arja_PatchNaturalnessYe$$Fix chart otp .. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch142-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. Fix previous patch. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch54-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch98-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch145-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. @@ 1355 removed redundant call. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch53-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch65-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch91-chart-1_Arja_PatchNaturalnessYe$$Fix category plot annoyances. Fix issue with wrong fireChangeEvent. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch187-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed redundant call. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch96-chart-1_Arja_PatchNaturalnessYe$$Remove redundant code. Fix Eclipse. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch180-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch62-chart-1_Arja_PatchNaturalnessYe$$Fix issue with chart ' s foreground domain marker removal. Fix crosshair index for chart 1 .. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch174-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch117-chart-1_Arja_PatchNaturalnessYe$$Fix pull request. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch128-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch110-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed dataset . addChangeListener ( ). Fix issue with previous pull request .. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch39-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix minor axes disappearing on histogram select. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch126-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. added datasetChanged ( ) line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch30-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch119-chart-1_Arja_PatchNaturalnessYe$$Fix null dataset crash. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch121-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1862. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch37-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix CategoryPlot not clearing the foreground domain marker map when it is not null .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch63-chart-1_Arja_PatchNaturalnessYe$$Fix issue with not - so - deprecated API in CategoryPlot. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch175-chart-1_Arja_PatchNaturalnessYe$$Fix issue with new domain crosshair plot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch97-chart-1_Arja_PatchNaturalnessYe$$Fix chart 1 .. Fix rangeGridlineStroke option not being used .. Fix pull from previous commit , fixes # 1862. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch181-chart-1_Arja_PatchNaturalnessYe$$Avoid NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch186-chart-1_Arja_PatchNaturalnessYe$$remove wrong fireChangeEvent. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch64-chart-1_Arja_PatchNaturalnessYe$$Fix category axis location for 1 . 6 . x. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch172-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Added datasetChanged ( ) to CategoryPlot. Remove a line if dataset is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch99-chart-1_Arja_PatchNaturalnessYe$$Fix category axes. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch52-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1862. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch188-chart-1_Arja_PatchNaturalnessYe$$remove redundant code. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch143-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch55-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix category plot annoyances. Removed redundant line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch203-chart-1_Arja_PatchNaturalnessYe$$Fix null column count in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch204-chart-1_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 2019. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch205-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1862. Fix # 1358. Fix crosshair dataset index issue. Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch202-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Added throw exception if orientation is null. Remove redundant clearDomainMarkers method. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch161-chart-1_Arja_PatchNaturalnessYe$$Removed redundant line. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch77-chart-1_Arja_PatchNaturalnessYe$$Fix # 1349. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch195-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch83-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch48-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with previous call. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch192-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch84-chart-1_Arja_PatchNaturalnessYe$$Fix category renderer index calculation .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch166-chart-1_Arja_PatchNaturalnessYe$$Added patch for addValue ( ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch70-chart-1_Arja_PatchNaturalnessYe$$Fix - add listener to existing renderer. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch159-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Removed redundant code. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch46-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with wrong data set range axis mapping. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch150-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 183. Fix pull from previous commit , fixes # 1227. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch79-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch41-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix addChangeListener. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch157-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Fix Eclipse. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch168-chart-1_Arja_PatchNaturalnessYe$$Fix category axis selection bug. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch103-chart-1_Arja_PatchNaturalnessYe$$Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch104-chart-1_Arja_PatchNaturalnessYe$$Add listener to CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch24-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix parent month / year axes NPE. added datasetChanged ( ) to CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch132-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch23-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch135-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Fix NPE in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch40-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Add category dataset patch. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch156-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix 1355. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch169-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch47-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. remove redundant code. Fix issue with wrong fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch151-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Throw an exception if orientation is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch78-chart-1_Arja_PatchNaturalnessYe$$Fix problem with reconfigurable range axes. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch71-chart-1_Arja_PatchNaturalnessYe$$Updated self . orientation to use VERTICAL .. Fix crosshair dataset index .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch193-chart-1_Arja_PatchNaturalnessYe$$added datasetChanged ( ) to getDataset ( index ). Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch85-chart-1_Arja_PatchNaturalnessYe$$Fix 1349. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch158-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. @@ 1355 removed dataset . addChangeListener ( ). Fix minor issue with CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch194-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch160-chart-1_Arja_PatchNaturalnessYe$$Fix category plot annoyances. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch76-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed redundant call. Fix - add listener to existing renderer. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch49-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch22-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix build. reset rangeCrosshairValue after each renderer is added. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch134-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. @@ 1355 removed redundant call. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch25-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch133-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix crosshair dataset index issue. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch105-chart-1_Arja_PatchNaturalnessYe$$Fix category plot annoyances. Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch102-chart-1_Arja_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch179-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch50-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1336. @@ 1356 don ' t add a listener to the dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch68-chart-1_Arja_PatchNaturalnessYe$$Fix a minor issue with chart 1 .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch141-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch57-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Added datasetChanged ( ) to CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch148-chart-1_Arja_PatchNaturalnessYe$$Fix for Persian and Urdu language maps # 2019. remove deprecated call to fireChangeEvent ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch95-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch183-chart-1_Arja_PatchNaturalnessYe$$Fix chart 1 .. Fix category axes. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch61-chart-1_Arja_PatchNaturalnessYe$$Fix issue with CategoryPlot . setDataset ( ). Fix Eclipse. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch59-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer . getLegendItems ( ). Fix # 1433. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch66-chart-1_Arja_PatchNaturalnessYe$$Fix pull request. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch170-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch92-chart-1_Arja_PatchNaturalnessYe$$Removed redundant line. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch124-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Add a listener to CategoryPlot. Fix # 183. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch32-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Remove over - aggressive dataset listener. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch123-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1336. @@ 1356 don ' t add a listener to the dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch35-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix category datasets. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch115-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch112-chart-1_Arja_PatchNaturalnessYe$$remove redundant code. Fix category data renderer NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch58-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Remove redundant code. Fix category datasets. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch93-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch185-chart-1_Arja_PatchNaturalnessYe$$Fix # 1796. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch67-chart-1_Arja_PatchNaturalnessYe$$Fix minor axes disappearing on histogram select. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch171-chart-1_Arja_PatchNaturalnessYe$$Fix problem with resampling. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch149-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1349. Fix category plot weight changes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch60-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch176-chart-1_Arja_PatchNaturalnessYe$$Fix pull request. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch182-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke option not being used .. Fix getLegendItems ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch69-chart-1_Arja_PatchNaturalnessYe$$Fix crosshair dataset index .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch140-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix pull request. Fix issue with range crosshair. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch178-chart-1_Arja_PatchNaturalnessYe$$Fix a bug in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch147-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. Fix a bug in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch51-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1796. Fix # 1337. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch113-chart-1_Arja_PatchNaturalnessYe$$Fix category axes. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch114-chart-1_Arja_PatchNaturalnessYe$$Fix category axes selection. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch122-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch125-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Add category dataset patch. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch207-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1349. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch200-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch209-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix category axes. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch208-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix a bug in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch201-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix issue with wrong fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch206-chart-1_Arja_PatchNaturalnessYe$$Fix category data renderer NPE. Fix range zero baseline paint. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch138-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with new category plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch107-chart-1_Arja_PatchNaturalnessYe$$@@ 1355 removed redundant call. Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch29-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix category mouse positionning. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch100-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke. Fix category axis selection bug. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch109-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch136-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fixed a bug with CategoryPlot . setDataset ( int , CategoryDataset ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch27-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Add category dataset patch. Fix category plot background for phones. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch131-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with CategoryPlot . setDataset ( ). Fix minor issue with CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch191-chart-1_Arja_PatchNaturalnessYe$$Fix problem with reconfigurable range axes. Fix category data renderer bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch87-chart-1_Arja_PatchNaturalnessYe$$Fix # 1349. Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Fix NPE. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch73-chart-1_Arja_PatchNaturalnessYe$$remove redundant code. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch162-chart-1_Arja_PatchNaturalnessYe$$Avoid NPE in CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch74-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch80-chart-1_Arja_PatchNaturalnessYe$$Fix category plot range axis positioning. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch42-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix range zero baseline paint. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch154-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix pull request. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch89-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix pull from previous commit , fixes # 1265. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch45-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. remove deprecated call to fireChangeEvent ( ). $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch153-chart-1_Arja_PatchNaturalnessYe$$Fix NPE. throw exception if index < 0. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch26-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch130-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix # 1887. Fix minor axes disappearing on histogram select. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch108-chart-1_Arja_PatchNaturalnessYe$$Fix Eclipse. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch21-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Added throw exception if orientation is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch137-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with chart 1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch28-chart-1_Arja_PatchNaturalnessYe$$Fix bug. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch101-chart-1_Arja_PatchNaturalnessYe$$Add category dataset patch. Fix category plot background for phones. Added datasetChanged ( ) to CategoryPlot. Remove a line if dataset is null. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch139-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix category plot annoyances. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch106-chart-1_Arja_PatchNaturalnessYe$$Fix # 1862. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch44-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix crosshair dataset index. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch152-chart-1_Arja_PatchNaturalnessYe$$Fix NPE in AbstractCategoryItemRenderer. Fix # 1796. @@ 1356 don ' t add a listener to the dataset. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch199-chart-1_Arja_PatchNaturalnessYe$$Fix # 183. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch43-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix chart 1 .. Fix minor bug in CategoryPlot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch155-chart-1_Arja_PatchNaturalnessYe$$Remove null check in place. Fix issue with wrong fireChangeEvent. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch88-chart-1_Arja_PatchNaturalnessYe$$Fix # 1336. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch197-chart-1_Arja_PatchNaturalnessYe$$Fix a minor issue with CategoryPlot . setRenderer ( int , CategoryItemRenderer , boolean ). Added datasetChanged ( ) to CategoryPlot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch81-chart-1_Arja_PatchNaturalnessYe$$Fix # 183. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch163-chart-1_Arja_PatchNaturalnessYe$$Fix rangeGridlineStroke. Removed redundant line. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch164-chart-1_Arja_PatchNaturalnessYe$$Fix chart 1 .. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch72-chart-1_Arja_PatchNaturalnessYe$$Add background annotations to defects plot. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch190-chart-1_Arja_PatchNaturalnessYe$$Set default background paint on category plot. Remove null check in place. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch86-chart-1_Arja_PatchNaturalnessYe$$Fix minor issue with CategoryPlot. Fix NPE in AbstractCategoryItemRenderer. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch120-chart-12_Arja_PatchNaturalnessYe$$Add a notification to the legend. Updated chart with data from previous commit .. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch31-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with JFreeChart . title = title. Fix chart refresh error. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch53-chart-12_Arja_PatchNaturalnessYe$$Fix bug. Fix # 1862. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch117-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix issue with JFreeChart . title = title. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch99-chart-12_Arja_PatchNaturalnessYe$$Fix chart source. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch144-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix 1491 chart title overlay not being removed .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch55-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . borderVisible = false. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch195-chart-12_Arja_PatchNaturalnessYe$$Fix chart not removed listener. Added plot listener to array. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch79-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with JFreeChart . title = title. Fix Legends4J_Chart_12. Fix NPE in chart. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch157-chart-12_Arja_PatchNaturalnessYe$$Fix issue with legends not being removed. Fix chart not removed listener. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch168-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . title = title. Fix chart after subtitle removal. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch103-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix title disappearing on histogram select. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch40-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Improved ' removeLegend ' method. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch169-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with legends not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch47-chart-12_Arja_PatchNaturalnessYe$$Fix chart label positionning. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch78-chart-12_Arja_PatchNaturalnessYe$$Fix chart source. Remove redundant call to fireChartChanged ( ). I don ' t really see a justification for doing a chart change in JFreeChart. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch71-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . setTitle ( TextTitle ). Added plot listener to the list of listeners. Improved method to allow for listener registration in AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch193-chart-12_Arja_PatchNaturalnessYe$$Fix chart not removed listener. Fix fireChartChanged ( ). Fix bug. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch194-chart-12_Arja_PatchNaturalnessYe$$Fix 1410 chart issue. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch49-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Added a plot listener to the legend. Added plot listener to array. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch25-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix bug in chart 12. Fix fireChartChanged ( ). Added plot listener to array. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch177-chart-12_Arja_PatchNaturalnessYe$$Fix chart border in DL. Fix chart 12. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch35-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Fix issue with chart not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch93-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix bug in chart 12. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch185-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Updated chart with new data. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch149-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener registration in AbstractDataset. Fix pull from defaults. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch56-chart-12_Arja_PatchNaturalnessYe$$Improved method to check if a listener is added to the list. Fix bug. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch138-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener removal from AbstractDataset. Updated chart with new data. Added throw exception if plot is null. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch100-chart-12_Arja_PatchNaturalnessYe$$Fix chart 12. Added plot listener to array. Improved method to allow for listener removal from AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch131-chart-12_Arja_PatchNaturalnessYe$$Improved method to check if a listener is added to the list. Fix issue with JFreeChart . title = title. Fix issue with chart not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch73-chart-12_Arja_PatchNaturalnessYe$$Added notification to subtitles .. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch162-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix issue with JFreeChart . setTitle ( TextTitle ). Fix issue with chart not being removed. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch196-chart-12_Arja_PatchNaturalnessYe$$Fix bug in chart 12. Fix chart not removed listener. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch80-chart-12_Arja_PatchNaturalnessYe$$Fix issue with JFreeChart . title = title. Fix # 183. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch42-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener registration in AbstractDataset. Fix title listener for 12 .. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch154-chart-12_Arja_PatchNaturalnessYe$$Improved method to allow for listener to be added to AbstractDataset. Fix pull from defaults .. Fix IndexOutOfBoundsException in JFreeChart. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch45-chart-12_Arja_PatchNaturalnessYe$$Fix trouble with legends. Improved method to allow for listener to be added to AbstractDataset. $$0
chart-12$$Fix for MultiplePiePlot$$When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.$$patch86-chart-12_Arja_PatchNaturalnessYe$$Fix chart after subtitle removal. Added plot listener to set background paint. Added plot listener to array. Improved method to allow for listener removal from AbstractDataset. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch120-math-73_Arja_PatchNaturalnessYe$$added patch for parallel solve. Added verifyBracketing method to BrentSolver. Fix erroneous patching of BrentSolver .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch36-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Reset the iterator count as well. revert accidently change. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch127-math-73_Arja_PatchNaturalnessYe$$Remove erroneous test. Added verifyBracketing method to BrentSolver. Fix error in BrentSolver . setResult ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch31-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Restore accidentally removed patch. Set result computed as true in isSequence ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch118-math-73_Arja_PatchNaturalnessYe$$Added patch to prevent reIterationCount increase .. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch111-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch38-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Restore accidentally removed patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch116-math-73_Arja_PatchNaturalnessYe$$Fix a typo in JSON. Added verifyBracketing method to BrentSolver. revert accidently change. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch129-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch54-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Added patch for 1 . 8 . 0 - > 1 . 8 . 0. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch98-math-73_Arja_PatchNaturalnessYe$$Set max value to 0 before attempting to set result. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch53-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Add a fix for the case where the step is too fast. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch65-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous patching of BrentSolver .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch96-math-73_Arja_PatchNaturalnessYe$$BrentSolver patch was not re - setable. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch62-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. BrentSolver didn ' t update the iter count. Add back missing patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch117-math-73_Arja_PatchNaturalnessYe$$Fix NPE in UnivariateRealSolverImpl . verifyInterval. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch110-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix error in BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch39-math-73_Arja_PatchNaturalnessYe$$Remove erroneous test. BrentSolver does not verify bracketing. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch126-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch30-math-73_Arja_PatchNaturalnessYe$$added patch. Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch119-math-73_Arja_PatchNaturalnessYe$$Reset the iteration count as well in case of a split ( ). Added patch for full Brent solver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch121-math-73_Arja_PatchNaturalnessYe$$added patch for parallel solve. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch37-math-73_Arja_PatchNaturalnessYe$$Remove erroneous test. Added verifyBracketing method to BrentSolver. Fix a typo in JSON. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch63-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Reset the iterator count as well. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch97-math-73_Arja_PatchNaturalnessYe$$added patch for PR. Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch90-math-73_Arja_PatchNaturalnessYe$$added patch for PR. changed erroneously handle cornering in BrentSolver. Add a fix for the case where the step is too fast. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch64-math-73_Arja_PatchNaturalnessYe$$Fix a typo in JSON. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch99-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Added patch for 1 . 5 * x1 .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch52-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch55-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. Added verifyBracketing method to BrentSolver. Reset the iteration count as well in case of a split ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch48-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Set function value accuracy to default , as it is done with the default function value accuracy. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch84-math-73_Arja_PatchNaturalnessYe$$Added patch to try and reduce parallel solve. BrentSolver does not verify bracketing. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch70-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. Fix erroneous patching of BrentSolver .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch46-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous variable. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch79-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. revert patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch41-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. revert accidently change. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch103-math-73_Arja_PatchNaturalnessYe$$changed max value of BrentSolver to verify bracketing. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch15-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous variable. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch104-math-73_Arja_PatchNaturalnessYe$$Fix warning. Added verifyBracketing method to BrentSolver. Reset the iterator count as well. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch24-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Add a patch for bisection fix. Set result computed as true in isSequence ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch23-math-73_Arja_PatchNaturalnessYe$$BrentSolver now uses f . value ( max ) instead of f . value ( min ) for. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch40-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous patching of BrentSolver .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch47-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Added patch to prevent erroneous solution from being able to bracket root .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch78-math-73_Arja_PatchNaturalnessYe$$Reset the iteration count as well in case of a split ( ). Fix a typo in JSON. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch71-math-73_Arja_PatchNaturalnessYe$$Reset the result computed as well. Added patch to try and solve the problem. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch85-math-73_Arja_PatchNaturalnessYe$$Remove erroneous test. Added verifyBracketing method to BrentSolver. Added missing patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch82-math-73_Arja_PatchNaturalnessYe$$added patch for PR. Added verifyBracketing method to BrentSolver. Add missing patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch76-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Set old delta to 0 . 5 * dx if the inverse quadratic interpolator gives a value. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch49-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix error in BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch22-math-73_Arja_PatchNaturalnessYe$$workflow improvements - added verifySequence ( ) to the BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch25-math-73_Arja_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Remove erroneous test. Added verifyBracketing method to BrentSolver. Set result computed as true in isSequence ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch105-math-73_Arja_PatchNaturalnessYe$$Reset the iteration count as well in case of a split ( ). Added verifyBracketing method to BrentSolver. Fix erroneous patching of BrentSolver .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch13-math-73_Arja_PatchNaturalnessYe$$Fix a typo in JSON. Remove erroneous test. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch102-math-73_Arja_PatchNaturalnessYe$$Set resultComputed to false in UnivariateRealSolverImpl . verifyInterval. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch14-math-73_Arja_PatchNaturalnessYe$$Remove erroneous test. Added verifyBracketing method to BrentSolver. Added patch for 1 . 5 ( minor ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch50-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. BrentSolver does not verify bracketing. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch68-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Reset the marker after the patch was patched .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch57-math-73_Arja_PatchNaturalnessYe$$added patch for parallel solve. Added verifyBracketing method to BrentSolver. Fix erroneous variable. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch95-math-73_Arja_PatchNaturalnessYe$$Fix a typo in JSON. added patch for PR. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch61-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. Added verifyBracketing method to BrentSolver. Add a patch for bisection fix. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch59-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix warning. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch66-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch92-math-73_Arja_PatchNaturalnessYe$$Fix warning. BrentSolver does not verify bracketing. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch124-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. revert patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch32-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch123-math-73_Arja_PatchNaturalnessYe$$Fix # 183. Added verifyBracketing method to BrentSolver. revert patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch35-math-73_Arja_PatchNaturalnessYe$$workflow improvements. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch115-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Add patch for easing of quadratic inverse search .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch112-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix inverted quadratic integration patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch58-math-73_Arja_PatchNaturalnessYe$$Fix error in BrentSolver .. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch93-math-73_Arja_PatchNaturalnessYe$$Added back the computed result of the BrentSolver. Added verifyBracketing method to BrentSolver. Add patch for easing of quadratic inverse search .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch67-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. Remove erroneous test. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch60-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Add patch for easing of arc. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch94-math-73_Arja_PatchNaturalnessYe$$Reset the iteration count as well in case of a split ( ). Added verifyBracketing method to BrentSolver. revert accidently change. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch69-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. Add patch for easing of parallel multi - line error .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch56-math-73_Arja_PatchNaturalnessYe$$changed variable name. Reset the iterator count as well. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch51-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous test case. Fix warning. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch113-math-73_Arja_PatchNaturalnessYe$$Set result computed as true in isSequence ( ). Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch114-math-73_Arja_PatchNaturalnessYe$$Fix warning. Remove erroneous test. Added verifyBracketing method to BrentSolver. Fix erroneous test case. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch122-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch34-math-73_Arja_PatchNaturalnessYe$$Added patch for full Brent solver. Set functionValueAccuracy to defaultFunctionValueAccuracy. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch125-math-73_Arja_PatchNaturalnessYe$$added patch for PR. BrentSolver now uses verifyBracketing ( ) , not just fixing the bracketing. Fix erroneous variable. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch33-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing ( ) to function value evaluator. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch107-math-73_Arja_PatchNaturalnessYe$$I had left it as is done in previous patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch29-math-73_Arja_PatchNaturalnessYe$$I had left it wrong .. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch100-math-73_Arja_PatchNaturalnessYe$$Set result computed as true in isSequence ( ). Added verifyBracketing method to BrentSolver. Fix erroneous integration with BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch16-math-73_Arja_PatchNaturalnessYe$$BrentSolver now uses verifyBracketing ( ) , not just fixing the bracketing. Fix erroneous test case. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch109-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Reset the iterator count as well. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch20-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch18-math-73_Arja_PatchNaturalnessYe$$added patch to increase iteration count. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch27-math-73_Arja_PatchNaturalnessYe$$Set function value accuracy to 0 .. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch87-math-73_Arja_PatchNaturalnessYe$$Set result computed as true in isSequence ( ). Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch73-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix erroneous variable. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch74-math-73_Arja_PatchNaturalnessYe$$added patch for parallel solve. Added verifyBracketing method to BrentSolver. revert patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch80-math-73_Arja_PatchNaturalnessYe$$Reset the iteration count as well in case of a split ( ). Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch42-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Added patch to prevent erroneous solution from being solved .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch89-math-73_Arja_PatchNaturalnessYe$$Added patch for PR # 1818. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch45-math-73_Arja_PatchNaturalnessYe$$added patch for parallel solve. Added patch for full Brent solver. revert accidently change for now .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch19-math-73_Arja_PatchNaturalnessYe$$Fix # 183. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch26-math-73_Arja_PatchNaturalnessYe$$BrentSolver now uses verifyBracketing ( ) , not just fixing the bracketing. revert patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch130-math-73_Arja_PatchNaturalnessYe$$BrentSolver patched. Added verifyBracketing method to BrentSolver. Add patch for easing of arc. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch108-math-73_Arja_PatchNaturalnessYe$$Fix warning. added patch. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch21-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix error in BrentSolver . setResult ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch101-math-73_Arja_PatchNaturalnessYe$$Reset the iteration count as well in case of a split ( ). Fix a typo in JSON. Added verifyBracketing method to BrentSolver. Fix erroneous patching of BrentSolver .. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch17-math-73_Arja_PatchNaturalnessYe$$Added patch to verifySequence ( ). Added verifyBracketing ( ) to function value evaluator. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch106-math-73_Arja_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch44-math-73_Arja_PatchNaturalnessYe$$changed param. Reset the iteration count as well in case of a split ( ). $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch43-math-73_Arja_PatchNaturalnessYe$$Added more iterations to the BrentSolver so it can be fixed by adding back the updated function. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch88-math-73_Arja_PatchNaturalnessYe$$Fix error in BrentSolver .. Added verifyBracketing method to BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch81-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Add a patch for bisection fix. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch75-math-73_Arja_PatchNaturalnessYe$$Added patch for full Brent solver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch72-math-73_Arja_PatchNaturalnessYe$$Added verifyBracketing method to BrentSolver. Fix error in BrentSolver. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch86-math-73_Arja_PatchNaturalnessYe$$Remove broken patch. changed variable name. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch39-math-31_Arja_PatchNaturalnessYe$$Added missing patch. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch30-math-31_Arja_PatchNaturalnessYe$$Revert previous fix. revert accidently change for 1 . 0 contemplative division. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch37-math-31_Arja_PatchNaturalnessYe$$Add missing msgArguments = new ArrayList < Object > ( len ). revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch48-math-31_Arja_PatchNaturalnessYe$$Revert previous patch. revert accidently change to continuedFraction where hN is NaN. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch8-math-31_Arja_PatchNaturalnessYe$$Add a line break if we don ' t have any text left in the string. revert accidently change to continuedFraction where hN is NaN. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch6-math-31_Arja_PatchNaturalnessYe$$revert accidently change for continued fractions. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch15-math-31_Arja_PatchNaturalnessYe$$Missing patch. Missing patch for message method. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch12-math-31_Arja_PatchNaturalnessYe$$revert accidently change for 1 . 0 contemplative division. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch23-math-31_Arja_PatchNaturalnessYe$$Add a localization message for MathIllegalStateException. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch40-math-31_Arja_PatchNaturalnessYe$$Missing patch. revert accidently change to continuedFraction where hN is NaN. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch47-math-31_Arja_PatchNaturalnessYe$$Missing context map in message patterns to avoid NPE in RTP constructor. Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch9-math-31_Arja_PatchNaturalnessYe$$Added patch for numerical variance. revert accidently change to continuedFraction where hN is NaN. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch49-math-31_Arja_PatchNaturalnessYe$$Revert previous fix. revert accidently change to continuedFraction where hN is NaN. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch13-math-31_Arja_PatchNaturalnessYe$$revert accidently change to continuedFraction where hN is NaN. Missing patch .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch14-math-31_Arja_PatchNaturalnessYe$$revert accidently change for 1 . 0 contibutor. Fix numerical variance .. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch32-math-31_Arja_PatchNaturalnessYe$$Missing patch. Add a line break if we don ' t have any text left in the string. revert accidently change for now. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch35-math-31_Arja_PatchNaturalnessYe$$Expose original exception context string .. revert accidently change for now. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch34-math-31_Arja_PatchNaturalnessYe$$Fix FDistribution . getSolverAbsoluteAccuracy ( ). Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch33-math-31_Arja_PatchNaturalnessYe$$Add patch for denominatorDF > 2. Missing return from patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch29-math-31_Arja_PatchNaturalnessYe$$Missing patch. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch20-math-31_Arja_PatchNaturalnessYe$$Allow for more message patterns in case of error. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch18-math-31_Arja_PatchNaturalnessYe$$revert accidently change to continuedFraction where hN is NaN. Missing patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch42-math-31_Arja_PatchNaturalnessYe$$Add patch for denominatorDF > 2. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch5-math-31_Arja_PatchNaturalnessYe$$Set exception context to empty string ( fix # 134 ). revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch45-math-31_Arja_PatchNaturalnessYe$$Revert previous patch. revert accidently change for continued fractions. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch19-math-31_Arja_PatchNaturalnessYe$$Fix getNumericalVariance. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch26-math-31_Arja_PatchNaturalnessYe$$Add localization message for ARITHMETIC_EXCEPTION. revert accidently change to continuedFraction where it was not possible to set a precision thing. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch21-math-31_Arja_PatchNaturalnessYe$$Missing patch .. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch28-math-31_Arja_PatchNaturalnessYe$$Revert previous patch. revert accidently change for 1 . 0 contibutor. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch17-math-31_Arja_PatchNaturalnessYe$$revert accidently change for 1 . 0 contibutor. Reset the ExceptionContext as well. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch10-math-31_Arja_PatchNaturalnessYe$$revert accidently change for 1 . 0 contibutor. Revert previous patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch43-math-31_Arja_PatchNaturalnessYe$$revert accidently change for 1 . 0 contemplative_fraction. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch31-math-70_Arja_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver. "Revert "" fix a small bug in BisectionSolver """. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch54-math-70_Arja_PatchNaturalnessYe$$updated intro patch. Reverted the changes related to bisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch65-math-70_Arja_PatchNaturalnessYe$$updated solve ( ) method. Fix error in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch91-math-70_Arja_PatchNaturalnessYe$$fixed a merge conflict in BisectionSolver. I had left it harwired to allow for partial nashorn support .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch96-math-70_Arja_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver. fixed erroneous test. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch62-math-70_Arja_PatchNaturalnessYe$$fixed a small bug. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch30-math-70_Arja_PatchNaturalnessYe$$Set default function value accuracy after running fixed tests .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch90-math-70_Arja_PatchNaturalnessYe$$I had left it harwired to say that we can merge a couple of solutions together. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch55-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch77-math-70_Arja_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver. fixed erroneous test. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch83-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. "Revert "" Increased maximal iterations for bisection solver to fix cruise (. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch84-math-70_Arja_PatchNaturalnessYe$$fixed a typo in BisectionSolver . solve ( ). fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch70-math-70_Arja_PatchNaturalnessYe$$fixed a small bug. Re - computed the bisection solver with fixed erroneous data. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch46-math-70_Arja_PatchNaturalnessYe$$updated solve ( ) method. fixed maxIter = max ; patched. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch1-math-70_Arja_PatchNaturalnessYe$$fixed a small bug. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch79-math-70_Arja_PatchNaturalnessYe$$fixed a typo in BisectionSolver . solve ( ). fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch15-math-70_Arja_PatchNaturalnessYe$$fixed a typo in BisectionSolver . solve ( ). Set functionValueAccuracy to defaultFunctionValueAccuracy. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch24-math-70_Arja_PatchNaturalnessYe$$Increasing max iterations for bisection solver .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch40-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed a bug in BisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch78-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. Set function value accuracy to default value accuracy. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch85-math-70_Arja_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver. fixed erroneous loop. added i = 0 ; patched. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch82-math-70_Arja_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver. "Revert "" Fixed a small bug in BisectionSolver . computedValue ( ) """. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch22-math-70_Arja_PatchNaturalnessYe$$updated solve ( ) method. Set function value accuracy to default value accuracy. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch50-math-70_Arja_PatchNaturalnessYe$$Reset the function value accuracy after running the bisectionSolver .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch68-math-70_Arja_PatchNaturalnessYe$$fixed a minor bug in BisectionSolver. Set function value accuracy to default when min = max = 0. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch57-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed maxIter = max ; patched. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch66-math-70_Arja_PatchNaturalnessYe$$I had left it harwired to allow for correct bracketing. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch35-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. Reset function value accuracy after maximal iterations reached the default max .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch60-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. fixed erroneous test. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch56-math-70_Arja_PatchNaturalnessYe$$fixed a minor issue with bisectionSolver. Reverted the changes related to bisectionSolver. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch34-math-70_Arja_PatchNaturalnessYe$$fixed a bug in BisectionSolver. updated patch. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch100-math-70_Arja_PatchNaturalnessYe$$updated solve ( ) method. fixed a small bug. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch16-math-70_Arja_PatchNaturalnessYe$$set result of bisectionSolver. updated intro patch. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch20-math-70_Arja_PatchNaturalnessYe$$updated solve ( ) method. fixed erroneous loop. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch73-math-70_Arja_PatchNaturalnessYe$$updated intro patch. Set maximalIterationCount as well. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch89-math-70_Arja_PatchNaturalnessYe$$updated intro patch. Set default function value accuracy. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch26-math-70_Arja_PatchNaturalnessYe$$fixed a typo in BisectionSolver . solve ( ). Set default function value accuracy when using fixed maxIterCount. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch44-math-70_Arja_PatchNaturalnessYe$$updated intro patch. fixed erroneous test. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch3-math-70_Arja_PatchNaturalnessYe$$fixed a small bug. I had left it harwired to allow for partial nashorn support .. $$0
math-70$$BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException$$Method      BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial)   invokes      BisectionSolver.solve(double min, double max)  which throws NullPointerException, as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f, double min, double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5); NullPointerException will be thrown.$$patch86-math-70_Arja_PatchNaturalnessYe$$updated intro patch. Set iterationCount as well as maximalIterationCount. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch1-math-5_Arja_PatchNaturalnessYe$$Fixed a bug in Complex . reciprocal ( ). $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch15-math-5_Arja_PatchNaturalnessYe$$Extend reciprocal to fix max claims. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch12-math-5_Arja_PatchNaturalnessYe$$Fix potential inf special case for complex type in code. Removed unnecessary equals implementation. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch14-math-5_Arja_PatchNaturalnessYe$$Fixed a minor typo in Complex . reciprocal ( ). Removed unnecessary equals implementation. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch16-math-5_Arja_PatchNaturalnessYe$$Fix potential inf special case for complex type in code. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch5-math-5_Arja_PatchNaturalnessYe$$Revert back to NaN since it ' s defined in the old one. Fix toString ( ) of Complex. $$0
math-5$$Complex.ZERO.reciprocal() returns NaN but should return INF.$$Complex.ZERO.reciprocal() returns NaN but should return INF. Class: org.apache.commons.math3.complex.Complex; Method: reciprocal() @version  Id: Complex.java 1416643 2012-12-03 19:37:14Z tn$$patch2-math-5_Arja_PatchNaturalnessYe$$fix a minor infinity in Complex . reciprocal ( ). Removed unnecessary equals implementation. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch36-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). FixDateFormat patch .. Fix merge issues. Fix file format change. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch31-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix compile error. FixDateFormat pattern not being null. Add locale override for getDateTimeInstance ( ). Fix year month format. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch118-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch111-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix timeZone argument in FastDateFormat. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch38-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch116-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove cached value. Fix ISO - 8859 - missing patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch54-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix cache update for date / time pattern. Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch98-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Allow null pattern for date time formats. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch53-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix ISO 8601 date format instance cache logic. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch65-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch91-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix ISO - 88601 date format definition. Fix getDateTimeInstance ( ). Fix override of default pattern for calendars. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch96-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix cached object in case of erroneous override. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch62-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch117-lang-50_Arja_PatchNaturalnessYe$$Put back dateTimeInstanceCache on top level. Fix getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch110-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. FixDateFormat pattern not being null. Fix merge issue. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch39-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix a bug in dateFormat. Fix week label in ISO 8601 format. Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch30-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix week ending error. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch37-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch63-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Fix cached object in case of erroneous override. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch97-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch90-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch64-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix cached object .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch99-lang-50_Arja_PatchNaturalnessYe$$Fix cache hit. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch52-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix merge issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch55-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Remove unnecessary assignment. Allow null pattern for date time formats. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch77-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch83-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). fixed compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch48-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Remove cached value. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch84-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch46-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Remove unnecessary code. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch79-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). Add timeZone to dateTimeInstanceCache. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch41-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. fixed timeZone = TimeZone . getDefault ( ) ;. Fix broken patch. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch103-lang-50_Arja_PatchNaturalnessYe$$Fix cached date / time object in case of error. Fix cached date format instance in case of erroneous override. Fix month indexing. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch15-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Allow null pattern to be cached in overriden format implementation. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch104-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch12-lang-50_Arja_PatchNaturalnessYe$$Fix cache update for month / year centuries. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch24-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix put line. Fix merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch23-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add timeZone argument. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch40-lang-50_Arja_PatchNaturalnessYe$$fixedDateFormat patch. Added patch for dateTime instance cache. Fix a bug in dateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch47-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix object equality in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch78-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch71-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix typo. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch85-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add timeZone setting for cache key. Allow null pattern for date time formats. Add a throw inside Pair. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch82-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix hash code for string equality. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch76-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix getLocale. fixed timeZone = TimeZone . getDefault ( ) ;. Fix pull request .. Fix week ending error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch49-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix month indexing. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch22-lang-50_Arja_PatchNaturalnessYe$$Add timeZone argument to cache file. Fix getDateTimeInstance ( ). Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch25-lang-50_Arja_PatchNaturalnessYe$$Fix timeZone cache logic. Add locale override for getDateTimeInstance ( ). Fix pull request .. Fix checkstyle issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch105-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Add timeZone argument. Fix checkstyle issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch13-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix getDateTimeInstance ( ) with locale null. Fix pull request .. Add a throw in case of same object .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch102-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch14-lang-50_Arja_PatchNaturalnessYe$$Fix cached date / time object in case of locale override. Fix getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch50-lang-50_Arja_PatchNaturalnessYe$$Fix date instance cache patch. Remove unnecessary assignment. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch68-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix merge issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch57-lang-50_Arja_PatchNaturalnessYe$$FixDateFormat pattern not found in cache. Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch95-lang-50_Arja_PatchNaturalnessYe$$fixedDateInstanceCache ( ) ;. Fix getDateTimeInstance ( ). Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch61-lang-50_Arja_PatchNaturalnessYe$$Put back dateTimeInstanceCache + patch. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch59-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix ISO 8601 date format cache update position. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch66-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix ISO 8601 date format cache update .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch92-lang-50_Arja_PatchNaturalnessYe$$Fix date / time cache patch. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch32-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. FixDateObjectTest. Fix hash code for string equality. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch35-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix put line. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch115-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Add locale override for getDateTimeInstance ( ). FixDateFormat patch .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch112-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix cached date format instance in case of erroneous locale override. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch58-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix cached locale for Persian and Urdu language maps .. Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch93-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix broken patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch67-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Add timeZone argument. Remove redundant patch. Fix merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch60-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Add timeZone argument. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch94-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix null locale argument in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch69-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix merge issue. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch56-lang-50_Arja_PatchNaturalnessYe$$FixDateFormat patch .. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch51-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. FixDateFormat pattern not being null. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch113-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Remove unused locale setting. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch114-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix compile error. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch34-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix put patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch33-lang-50_Arja_PatchNaturalnessYe$$Fix compile error. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch107-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove unnecessary assignment. Allow null pattern for date time formats. Fix object type in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch29-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Add a throw in case of same object .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch100-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix pull request .. Fix ISO - 8859 - missing patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch16-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Remove redundant patch. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch109-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix getLocale. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch20-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Add locale override for getDateTimeInstance ( ). Fix ISO 8601 date format cache update .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch18-lang-50_Arja_PatchNaturalnessYe$$Fix cache hit. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch27-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix unpadded month in year field. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch87-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Remove unnecessary assignment. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch73-lang-50_Arja_PatchNaturalnessYe$$Fix date instance cache patch. Fix compile error. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch74-lang-50_Arja_PatchNaturalnessYe$$Fix cache hit. Fix getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch80-lang-50_Arja_PatchNaturalnessYe$$Add timeZone to dateTimeInstanceCache. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch42-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Remove unnecessary copy of DateTimeFormat instance cache key. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch5-lang-50_Arja_PatchNaturalnessYe$$Added fixedDateTimeInstanceCache + patch. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). Fix a merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch89-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. FixDateFormat patch .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch45-lang-50_Arja_PatchNaturalnessYe$$Fix DateTimeFormat instance cache logic. Allow null pattern for date time formats. Fix month indexing. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch19-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Add locale override for getDateTimeInstance ( ). Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch26-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix override of pattern in configuration file. Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch108-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix override of default pattern for calendars. Fix pull request .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch21-lang-50_Arja_PatchNaturalnessYe$$Add patch for dateTime instance cache. Reset timeZone to TimeZone . getDefault ( ) for parsing Improved performance. Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch28-lang-50_Arja_PatchNaturalnessYe$$Fix date instance cache patch. Fix compile error. Fix merge conflict in FastDateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch101-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. Fix getDateTimeInstance ( ). Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch17-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache breaking. FixDateFormat pattern not being null. Allow null pattern for date time formats. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch106-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). FixDateFormat patch .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch44-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix compile error. Add locale override for getDateTimeInstance ( ). $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch43-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix a bug in dateFormat. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch88-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). FixDateTimeInstanceCache put in a place that doesn ' t have a default locale or timeZone. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch81-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix cached date format instance in case of errant ISO 639 - 2 locale mapping .. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch75-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Fix merge issues. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch72-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Fix getDateTimeInstance ( ). Remove redundant patch. $$0
lang-50$$FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change$$The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.$$patch86-lang-50_Arja_PatchNaturalnessYe$$Added patch for dateTime instance cache. Remove redundant patch. Fix merge conflict in FastDateFormat. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch36-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch127-lang-51_Arja_PatchNaturalnessYe$$fixed an issue with BooleanUtils . toBoolean ( ). Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch31-lang-51_Arja_PatchNaturalnessYe$$Add patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch118-lang-51_Arja_PatchNaturalnessYe$$Removed patch for BooleanUtils . toBoolean ( ) .. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch111-lang-51_Arja_PatchNaturalnessYe$$lowercased string handling. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch116-lang-51_Arja_PatchNaturalnessYe$$Fixed null string handling. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch129-lang-51_Arja_PatchNaturalnessYe$$remove patch for true / false match. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch142-lang-51_Arja_PatchNaturalnessYe$$Added missing case in StringUtils. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch54-lang-51_Arja_PatchNaturalnessYe$$add null check. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch145-lang-51_Arja_PatchNaturalnessYe$$Added booleanUtils . equalsIgnoreCase ( ). lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch53-lang-51_Arja_PatchNaturalnessYe$$add null check. toLowerCase ( ) removed previous patch. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch65-lang-51_Arja_PatchNaturalnessYe$$improve performance for strings with spaces in the code. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch91-lang-51_Arja_PatchNaturalnessYe$$Remove unnecessary booleanUtils patch. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch62-lang-51_Arja_PatchNaturalnessYe$$remove patched / removed unnecessary boolean utils class. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch117-lang-51_Arja_PatchNaturalnessYe$$remove patch. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch128-lang-51_Arja_PatchNaturalnessYe$$fixed null string handling. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch110-lang-51_Arja_PatchNaturalnessYe$$BooleanUtils patch for < = >. Removed patch for "" true "" and "" off "" .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch39-lang-51_Arja_PatchNaturalnessYe$$Updated toBoolean ( ). Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch30-lang-51_Arja_PatchNaturalnessYe$$remove patched code. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch119-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. remove null check. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch121-lang-51_Arja_PatchNaturalnessYe$$improve performance for null strings. removed patch for year in BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch37-lang-51_Arja_PatchNaturalnessYe$$Add case for string comparison. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch63-lang-51_Arja_PatchNaturalnessYe$$improve performance for empty strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch97-lang-51_Arja_PatchNaturalnessYe$$Fixed a bug in BooleanUtils. Remove over - old boolean utils pattern. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch90-lang-51_Arja_PatchNaturalnessYe$$fixed StringUtils . equalsIgnoreCase. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch64-lang-51_Arja_PatchNaturalnessYe$$Updated to match String class .. remove patched boolean utils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch99-lang-51_Arja_PatchNaturalnessYe$$removed patch for Y = > E. lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch52-lang-51_Arja_PatchNaturalnessYe$$removed patch for Y = > E. lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch143-lang-51_Arja_PatchNaturalnessYe$$Removed patch from BooleanUtils. remove patch for BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch77-lang-51_Arja_PatchNaturalnessYe$$lowercased string comparisons. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch83-lang-51_Arja_PatchNaturalnessYe$$improve performance for strings with length > = 647. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch48-lang-51_Arja_PatchNaturalnessYe$$Remove patched code. case insensitive match for "" true "" to false """. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch84-lang-51_Arja_PatchNaturalnessYe$$match regex. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch70-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch159-lang-51_Arja_PatchNaturalnessYe$$Remove patch for year in BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch46-lang-51_Arja_PatchNaturalnessYe$$Optimize equalsIgnoreCase. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch150-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch79-lang-51_Arja_PatchNaturalnessYe$$fixed null string handling. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch41-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch157-lang-51_Arja_PatchNaturalnessYe$$add patch for true in boolean utils. Removed patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch103-lang-51_Arja_PatchNaturalnessYe$$improve matching of empty strings. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch104-lang-51_Arja_PatchNaturalnessYe$$removed patch for year in BooleanUtils. IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch24-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch132-lang-51_Arja_PatchNaturalnessYe$$fixed StringUtils . equalsIgnoreCase. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch23-lang-51_Arja_PatchNaturalnessYe$$Removed an obsolete equalsIgnoreCase method. Add an exception check for isEmpty ( String ). Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch40-lang-51_Arja_PatchNaturalnessYe$$add patch for null string handling. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch156-lang-51_Arja_PatchNaturalnessYe$$removed empty string handling. lowercased string handling. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch47-lang-51_Arja_PatchNaturalnessYe$$Add an empty line check. Remove patched code. Removed patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch151-lang-51_Arja_PatchNaturalnessYe$$toLowerCase the y string. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch78-lang-51_Arja_PatchNaturalnessYe$$Add case for string ' s equalsIgnoreCase. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch85-lang-51_Arja_PatchNaturalnessYe$$BooleanUtils now uses empty string literals. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch160-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch76-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch49-lang-51_Arja_PatchNaturalnessYe$$ignore isDigit for boolean equals. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch134-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch25-lang-51_Arja_PatchNaturalnessYe$$Added ignore case for "" off "" and "" no "" .. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch102-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch146-lang-51_Arja_PatchNaturalnessYe$$improve performance for strings with length > = 647. Modified patch for StringUtils . equalsIgnoreCase. remove patched for last char. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch68-lang-51_Arja_PatchNaturalnessYe$$Add an exception check for isEmpty ( String ). lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch141-lang-51_Arja_PatchNaturalnessYe$$lowercased. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch57-lang-51_Arja_PatchNaturalnessYe$$Added missing case in StringUtils. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch148-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. patched BooleanUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch61-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. Remove over - aggressive patching of boolean utils. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch59-lang-51_Arja_PatchNaturalnessYe$$IgnoreCase Strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch66-lang-51_Arja_PatchNaturalnessYe$$lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch92-lang-51_Arja_PatchNaturalnessYe$$add patch for null string comparison. lowercased string comparisons. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch124-lang-51_Arja_PatchNaturalnessYe$$add patch for null string handling. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch123-lang-51_Arja_PatchNaturalnessYe$$Added patch for "" off "" and "" no "" .. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch35-lang-51_Arja_PatchNaturalnessYe$$add null check. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch115-lang-51_Arja_PatchNaturalnessYe$$strtolower the string. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch93-lang-51_Arja_PatchNaturalnessYe$$remove patch from source code. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch67-lang-51_Arja_PatchNaturalnessYe$$Corrected a typo in StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch149-lang-51_Arja_PatchNaturalnessYe$$removed patch for year in BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch60-lang-51_Arja_PatchNaturalnessYe$$lowercased string handling. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch94-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. Added missing case in StringUtils. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch69-lang-51_Arja_PatchNaturalnessYe$$isEmpty ( ) = > false. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch140-lang-51_Arja_PatchNaturalnessYe$$Added missing case in BooleanUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch56-lang-51_Arja_PatchNaturalnessYe$$Put back previous patch. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch147-lang-51_Arja_PatchNaturalnessYe$$improve performance for null string matches , note the patch for more readable strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch51-lang-51_Arja_PatchNaturalnessYe$$Removed patch from BooleanUtils. lowercased. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch113-lang-51_Arja_PatchNaturalnessYe$$patched by accident. removed patch for year in BooleanUtils. Removed patch for "" true "" and "" off "" .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch114-lang-51_Arja_PatchNaturalnessYe$$strtolower the string. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch34-lang-51_Arja_PatchNaturalnessYe$$Add an exception if the String is empty ( I am looking at you Dave ). toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch125-lang-51_Arja_PatchNaturalnessYe$$modified BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch33-lang-51_Arja_PatchNaturalnessYe$$lowercased string comparisons. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch138-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ) removed previous patch. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch107-lang-51_Arja_PatchNaturalnessYe$$Add exception if String is empty. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch100-lang-51_Arja_PatchNaturalnessYe$$Allow null string input. lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch136-lang-51_Arja_PatchNaturalnessYe$$lowercased string comparisons. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch18-lang-51_Arja_PatchNaturalnessYe$$Added missing case in StringUtils. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch27-lang-51_Arja_PatchNaturalnessYe$$strtolower the string. toLowerCase ( ). $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch131-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch73-lang-51_Arja_PatchNaturalnessYe$$Add missing case. Removed unnecessary patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch80-lang-51_Arja_PatchNaturalnessYe$$Added patch for "" true "" in StringUtils. lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch42-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. removed patched / removed unnecessary booleanUtils properties. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch154-lang-51_Arja_PatchNaturalnessYe$$updated BooleanUtils. lowercased string comparisons. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch45-lang-51_Arja_PatchNaturalnessYe$$IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch153-lang-51_Arja_PatchNaturalnessYe$$toLowerCase ( ) matches any string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch19-lang-51_Arja_PatchNaturalnessYe$$add null check. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch130-lang-51_Arja_PatchNaturalnessYe$$IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch108-lang-51_Arja_PatchNaturalnessYe$$fixed String . equalsIgnoreCase. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch21-lang-51_Arja_PatchNaturalnessYe$$fixed null string handling. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch137-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch28-lang-51_Arja_PatchNaturalnessYe$$I had left it harwired to true , but it was still possible to check string equality. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch101-lang-51_Arja_PatchNaturalnessYe$$removed null check. lowercased string to match actual string. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch139-lang-51_Arja_PatchNaturalnessYe$$improve performance for null / empty strings. Removed unnecessary if / else .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch106-lang-51_Arja_PatchNaturalnessYe$$remove patch for BooleanUtils . equals. lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch44-lang-51_Arja_PatchNaturalnessYe$$Add case for string ' s equalsIgnoreCase. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch152-lang-51_Arja_PatchNaturalnessYe$$lowercase affix. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch43-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch155-lang-51_Arja_PatchNaturalnessYe$$lowercased string to match their definition. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch88-lang-51_Arja_PatchNaturalnessYe$$add null check. IgnoreCase string ' s value .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch81-lang-51_Arja_PatchNaturalnessYe$$missing patch for null string match. lowercased string to match patch. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch72-lang-51_Arja_PatchNaturalnessYe$$Allow null string input. Removed patch for StringUtils. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch86-lang-51_Arja_PatchNaturalnessYe$$fixed StringUtils . equalsIgnoreCase. lowercased string to match patch. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch36-lang-58_Arja_PatchNaturalnessYe$$try StringUtils . isDigit. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch31-lang-58_Arja_PatchNaturalnessYe$$Fix regex processing. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch38-lang-58_Arja_PatchNaturalnessYe$$don ' t throw NumberFormatException if decPos < decPos. I had left it harwired to say that it was a valid number .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch39-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. start with - -. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch30-lang-58_Arja_PatchNaturalnessYe$$Add a missing patch. I had left it harwired to null .. don ' t check isEmpty ( str ) , because it seems we ' re trying to understand why. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch37-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. don ' t check isEmpty ( str ) in StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch8-lang-58_Arja_PatchNaturalnessYe$$remove exp = null ; fix for patched code. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch46-lang-58_Arja_PatchNaturalnessYe$$Allow null string input. Add an error if the string is blank .. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch6-lang-58_Arja_PatchNaturalnessYe$$Add the missing throw exception. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch41-lang-58_Arja_PatchNaturalnessYe$$Remove exp = null in numberUtils. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch15-lang-58_Arja_PatchNaturalnessYe$$Fix NPE. don ' t check isEmpty ( str ) in StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch12-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. isEmpty ( str ) fixed NHY - 1342 , fixed NHY - 1342. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch24-lang-58_Arja_PatchNaturalnessYe$$fixed String . isBlank ( ). Add a patch for formatting numbers in Avro settings. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch23-lang-58_Arja_PatchNaturalnessYe$$fix a numeric type request. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch40-lang-58_Arja_PatchNaturalnessYe$$Allow null string input. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch7-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. remove fix. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch9-lang-58_Arja_PatchNaturalnessYe$$Allow null string input. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch22-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. don ' t check isEmpty ( str ) in StringUtils. Add an error if a blank string is not a valid number. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch25-lang-58_Arja_PatchNaturalnessYe$$Remove old and unused method. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch13-lang-58_Arja_PatchNaturalnessYe$$Allow string to be parsed as a literal int. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch14-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. add null check. add isDigit to StringUtils. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch32-lang-58_Arja_PatchNaturalnessYe$$fixed String . isBlank ( ). I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch35-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. Allow null to be passed. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch34-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. add null check. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch33-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch11-lang-58_Arja_PatchNaturalnessYe$$Add an error if the string is blank .. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch29-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. Add string isEmpty ( ) to isAllZeros ( ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch16-lang-58_Arja_PatchNaturalnessYe$$Add an exception if the string is null. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch20-lang-58_Arja_PatchNaturalnessYe$$add patch for isDigit. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch18-lang-58_Arja_PatchNaturalnessYe$$Add a missing patch. I had left it harwired to null .. Add a throw statement so that it can be cleaned up by the patcher .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch27-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. isDigits method patched. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch42-lang-58_Arja_PatchNaturalnessYe$$Remove old and unused method. I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch5-lang-58_Arja_PatchNaturalnessYe$$Add an error if the string is blank .. don ' t throw NPE at end of definition file. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch45-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. don ' t throw NumberFormatException on isBlank ( string ). $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch19-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to say that it was a valid number .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch26-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. Fix isAllZeros for Persian and Urdu language maps .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch21-lang-58_Arja_PatchNaturalnessYe$$Add a throw if it is not a valid number. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch28-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to say that it was a valid number .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch17-lang-58_Arja_PatchNaturalnessYe$$Remove old and unused patch. Allow null to be passed in for numberUtils . createBigInteger ( ). start with - -. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch10-lang-58_Arja_PatchNaturalnessYe$$I had left it harwired to null .. @ patch_1228 for StringUtils . isDigit. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch44-lang-58_Arja_PatchNaturalnessYe$$Fix 143 potential value error. fixed NHYD fixed. I had left it harwired to null .. $$0
lang-58$$NumberUtils.createNumber throws NumberFormatException for one digit long$$NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"$$patch43-lang-58_Arja_PatchNaturalnessYe$$fix null string handling. I had left it harwired to null .. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch8-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch6-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( ). Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch15-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( len + 1 ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch12-lang-60_Arja_PatchNaturalnessYe$$reset nullText if it is empty string ( # 1267 ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch23-lang-60_Arja_PatchNaturalnessYe$$reset nullText on deleteFirst ( ). Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch7-lang-60_Arja_PatchNaturalnessYe$$Add more ensureCapacity .. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch9-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( size + 4 ). Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch22-lang-60_Arja_PatchNaturalnessYe$$Fix ensureCapacity .. Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch13-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( ). Fix buffer size increase. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch14-lang-60_Arja_PatchNaturalnessYe$$Add throw inside if / else .. fixed a small bug. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch11-lang-60_Arja_PatchNaturalnessYe$$Fix ensureCapacity .. Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch16-lang-60_Arja_PatchNaturalnessYe$$Fix buffer size > = length ( ). $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch20-lang-60_Arja_PatchNaturalnessYe$$Revert previous patch. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch18-lang-60_Arja_PatchNaturalnessYe$$Add missing ensureCapacity .. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch5-lang-60_Arja_PatchNaturalnessYe$$StrBuilder deleteFirst ( ) returns this if the builder is empty .. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch19-lang-60_Arja_PatchNaturalnessYe$$Fix buffer size increase. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch21-lang-60_Arja_PatchNaturalnessYe$$Add patch for nullText builder. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch17-lang-60_Arja_PatchNaturalnessYe$$Add accidently removed backslash. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch10-lang-60_Arja_PatchNaturalnessYe$$Add line separator. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch3-lang-60_Arja_PatchNaturalnessYe$$added ensureCapacity ( len + 1 ) if we have > 0 length. Fix buffer size too large. $$0
lang-60$$StrBuilder contains usages of thisBuf.length when they should use size$$While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.$$patch4-lang-60_Arja_PatchNaturalnessYe$$Add patch for letter case. Fix buffer size too large. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch9-lang-20_Arja_PatchNaturalnessYe$$Fix sunAvailable. revert accidently change. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch20-lang-20_Arja_PatchNaturalnessYe$$Fix sunAvailable = false. revert accidently change. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch5-lang-20_Arja_PatchNaturalnessYe$$Fix sunAvailable. Updated StringUtils . toString ( Object ) and friends. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch3-lang-20_Arja_PatchNaturalnessYe$$Added throw statement. revert accidently change. $$0
lang-20$$StringUtils.join throws NPE when toString returns null for one of objects in collection$$Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress$$patch4-lang-20_Arja_PatchNaturalnessYe$$Fix NPE. remove offending null string in final form. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch36-lang-27_Arja_PatchNaturalnessYe$$Added throw exception if string is null. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch31-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Fix NPE in Arja ' s patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch38-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. fix a typo in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch54-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Allow null string input. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch53-lang-27_Arja_PatchNaturalnessYe$$formatting null values as null values are not accepted. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch65-lang-27_Arja_PatchNaturalnessYe$$Fixed NPE in StringUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch62-lang-27_Arja_PatchNaturalnessYe$$fixed ninth - month issue. removed expPos from mant string. fixed a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch39-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch37-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch63-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the extraneous space. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch64-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Fix Eclipse warning. fixed a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch52-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. try string to create double from string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch55-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the unnecessary dec string. try string to create double from string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch48-lang-27_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch8-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. don ' t put patched exception in place. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch41-lang-27_Arja_PatchNaturalnessYe$$fixed BigDecimal class name. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch15-lang-27_Arja_PatchNaturalnessYe$$removed erroneous legacy patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch12-lang-27_Arja_PatchNaturalnessYe$$throw exception if str is null. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch24-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in StringUtils. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch23-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch40-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. try string to create double from string. remove wrong symbol. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch7-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Handle null string input. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch47-lang-27_Arja_PatchNaturalnessYe$$avoid NPE. removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. fix a typo in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch9-lang-27_Arja_PatchNaturalnessYe$$A blank string is not a valid number. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch49-lang-27_Arja_PatchNaturalnessYe$$fix null string handling. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch22-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Fix number parsing in Arja_Defects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch25-lang-27_Arja_PatchNaturalnessYe$$Add a patch for formatting numbers in Avro settings. removed expPos from mant string. remove expPos. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch13-lang-27_Arja_PatchNaturalnessYe$$throw exception if str is null. removed expPos from mant string. convert numeric to double for compatibility with 1 . 5. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch14-lang-27_Arja_PatchNaturalnessYe$$fixed NPE in NumberUtils. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch50-lang-27_Arja_PatchNaturalnessYe$$Remove unnecessary default value. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch61-lang-27_Arja_PatchNaturalnessYe$$Add the missing patch. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch59-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fixed syntax error in previous patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch32-lang-27_Arja_PatchNaturalnessYe$$avoid NPE. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch35-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. try Integer . decode ( str ) instead of String . create ( str ). $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch58-lang-27_Arja_PatchNaturalnessYe$$Remove unused patch. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch60-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. Handle null string input. adding mant variable to prevent compiler from giving an error message. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch56-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fix a minor typo in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch51-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not needed. fixed a bug in NumberUtils. Fix NPE in Arja ' s patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch34-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. remove the unnecessary dec string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch33-lang-27_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch11-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove expPos. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch29-lang-27_Arja_PatchNaturalnessYe$$Handle parseDouble for StringUtils .. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch16-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. Allow trailing comma in Strings. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch20-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. fixed NPE in ArjaDefects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch18-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the unnecessary dec string. Remove exp pos from definition of Double. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch27-lang-27_Arja_PatchNaturalnessYe$$avoid NPE. fixed NPE in Arja_Defects4J_Lang_27. removed expPos from mant string. fixed NPE in Arja_Defects4J_Lang_27. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch42-lang-27_Arja_PatchNaturalnessYe$$Allow null string input. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch5-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. removed expPos from mant string. fixed syntax error in previous patch. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch45-lang-27_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. removed unnecessary check for integer precision thing. Remove expPos from mant string , because we ' re about to replace it with the exp. try string to create double from numeric value. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch19-lang-27_Arja_PatchNaturalnessYe$$Allow null exponent string to be parsed as a string. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch26-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. remove the extraneous space. fix a merge conflict in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch21-lang-27_Arja_PatchNaturalnessYe$$removed exp fix. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch28-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. Allow null string input. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch17-lang-27_Arja_PatchNaturalnessYe$$Fix lost backslash. Fix a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch10-lang-27_Arja_PatchNaturalnessYe$$Add null check. removed expPos from mant string. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch44-lang-27_Arja_PatchNaturalnessYe$$Remove expPos from mant string , as it ' s not accessible from native code. fixed a bug in NumberUtils. $$0
lang-27$$NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in$$NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".$$patch43-lang-27_Arja_PatchNaturalnessYe$$removed expPos from mant string. Fixed ment = string .. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch36-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. Add a throw if it is not a blank string. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch31-lang-16_Arja_PatchNaturalnessYe$$Allow null to be passed in number utils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch38-lang-16_Arja_PatchNaturalnessYe$$Add the patch for the exponentiation of certain characters. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch54-lang-16_Arja_PatchNaturalnessYe$$Add missing patch. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch53-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. remove exp. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch65-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in Arja_Defects4J_Lang_16. revert patch. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch62-lang-16_Arja_PatchNaturalnessYe$$fixed a small bug. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch39-lang-16_Arja_PatchNaturalnessYe$$Add an exception if the string is null. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch30-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch37-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in number utils .. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch63-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. Fix exp parsing in Arja_Defects4J_Lang_16. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch64-lang-16_Arja_PatchNaturalnessYe$$fix null string handling. get fix from pull request. remove exp. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch52-lang-16_Arja_PatchNaturalnessYe$$Add missing patch. fixed syntax error in ArjaDefects4J_Lang_16. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch55-lang-16_Arja_PatchNaturalnessYe$$Fix a 13e032 error in Arja ' s NumberUtils. fixed a typo in the code. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch48-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch8-lang-16_Arja_PatchNaturalnessYe$$try string cast. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch46-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch41-lang-16_Arja_PatchNaturalnessYe$$Fix a NumberFormatException if the string length is not > = expPos. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch15-lang-16_Arja_PatchNaturalnessYe$$fix null string handling. Fix a minor issue with NumberUtils . createFloat ( str ). get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch12-lang-16_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_16. Fix typo in data .. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch24-lang-16_Arja_PatchNaturalnessYe$$Fix NumberFormatException. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch23-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. fixed a bug in NumberUtils. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch40-lang-16_Arja_PatchNaturalnessYe$$removed patch for numberUtils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch7-lang-16_Arja_PatchNaturalnessYe$$Remove patch from last commit. Fix a bug in NumberUtils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch47-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in Arja_Defects4J_Lang_16. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch9-lang-16_Arja_PatchNaturalnessYe$$get fix from pull request. try Integer . decode ( str ) instead of String . create ( str ). $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch49-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from pull request. Fix StringUtils . isNaN ( str ). $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch22-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in Arja_Defects4J_Lang_16. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch25-lang-16_Arja_PatchNaturalnessYe$$A blank string is not a valid number. "Revert "" remove "" from "" fix". get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch13-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch14-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from pull request. add patch for eequality. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch50-lang-16_Arja_PatchNaturalnessYe$$get fix from patch. Handle null string input from NumberUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch57-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch61-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. fixed a bug in the code style. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch59-lang-16_Arja_PatchNaturalnessYe$$Add null check. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch66-lang-16_Arja_PatchNaturalnessYe$$throw exception if str is null. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch32-lang-16_Arja_PatchNaturalnessYe$$Add number exception patch. get fix from pull request. Add a throw if it is not a blank string. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch35-lang-16_Arja_PatchNaturalnessYe$$Allow null to be parsed as a number. Fix potential NPE in NumberUtils. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch58-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. "Revert "" fix merge conflict """. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch67-lang-16_Arja_PatchNaturalnessYe$$A blank string is not a valid number. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch60-lang-16_Arja_PatchNaturalnessYe$$"Revert "" remove "" from "" fix". Fix accidentely removed patch for string literals. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch56-lang-16_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_16. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch51-lang-16_Arja_PatchNaturalnessYe$$A blank string is not a valid number. don ' t check isEmpty ( ) in NumberUtils. get fix from patch. remove exp. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch34-lang-16_Arja_PatchNaturalnessYe$$Add number exception patch. get fix from pull request. Fix NPE in NumberUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch33-lang-16_Arja_PatchNaturalnessYe$$Fix NPE in number utils .. fix merge conflict resolution. missing patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch11-lang-16_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. get fix from pull request. Fix StringUtils . isNaN ( str ) .. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch29-lang-16_Arja_PatchNaturalnessYe$$Fix this. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch16-lang-16_Arja_PatchNaturalnessYe$$Add the patch for number utils. Fix a minor issue with NumberUtils . createFloat ( str ). get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch20-lang-16_Arja_PatchNaturalnessYe$$get fix from pull request. don ' t ignore numbers with spaces. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch18-lang-16_Arja_PatchNaturalnessYe$$adding patch for "" ---- """. get fix from patch. don ' t ignore signs in - - fixes NPE. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch27-lang-16_Arja_PatchNaturalnessYe$$fixed a bug in NumberUtils. Fix potential NPE in NumberUtils. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch42-lang-16_Arja_PatchNaturalnessYe$$"Revert "" update to latest compatibility """. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch45-lang-16_Arja_PatchNaturalnessYe$$get fix from pull request. remove null check in ArjaDefects4J_Lang_16. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch19-lang-16_Arja_PatchNaturalnessYe$$Fix typo in reference manual. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch26-lang-16_Arja_PatchNaturalnessYe$$Allow null string input. get fix from patch. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch21-lang-16_Arja_PatchNaturalnessYe$$Remove unused patch. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch28-lang-16_Arja_PatchNaturalnessYe$$Fix null pointer check in ArjaDefects4J_Lang_16. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch17-lang-16_Arja_PatchNaturalnessYe$$Fix 1474 patch for number utils. get fix from pull request. Handle null string input from NumberUtils. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch10-lang-16_Arja_PatchNaturalnessYe$$Add number exception patch. get fix from pull request. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch44-lang-16_Arja_PatchNaturalnessYe$$fixed NPE in Arja_Defects4J_Lang_16. fixed a bug in NumberUtils. get fix from patch. Add a throw if it is not a blank string. $$0
lang-16$$NumberUtils does not handle upper-case hex: 0X and -0X$$NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.$$patch43-lang-16_Arja_PatchNaturalnessYe$$Fix a bug in NumberUtils. get fix from pull request. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch36-lang-45_Arja_PatchNaturalnessYe$$fixed possible NPE. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch31-lang-45_Arja_PatchNaturalnessYe$$handle empty string matches for patch. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch38-lang-45_Arja_PatchNaturalnessYe$$fixed possible NPE. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch39-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch30-lang-45_Arja_PatchNaturalnessYe$$fixed a small bug. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch37-lang-45_Arja_PatchNaturalnessYe$$IgnoreCase. remove null string fix. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch8-lang-45_Arja_PatchNaturalnessYe$$throw exception if the string is empty. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch6-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. remove patch. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch41-lang-45_Arja_PatchNaturalnessYe$$throw exception if the string is empty. fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch15-lang-45_Arja_PatchNaturalnessYe$$fix a warning. update patch. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch12-lang-45_Arja_PatchNaturalnessYe$$fix a warning. fixed NPE in StringUtils. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch24-lang-45_Arja_PatchNaturalnessYe$$lowercased string contains only upper / lower case characters. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch23-lang-45_Arja_PatchNaturalnessYe$$throw exception if StringUtils . isEmpty ( str ) is true. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch40-lang-45_Arja_PatchNaturalnessYe$$remove null string fix. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch7-lang-45_Arja_PatchNaturalnessYe$$remove backslash. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch9-lang-45_Arja_PatchNaturalnessYe$$fixed possible NPE. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch22-lang-45_Arja_PatchNaturalnessYe$$fix a warning. add null check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch25-lang-45_Arja_PatchNaturalnessYe$$Fix null parameter check. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch13-lang-45_Arja_PatchNaturalnessYe$$fixed a small bug. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch14-lang-45_Arja_PatchNaturalnessYe$$fix a warning. Fix StringUtils . length ( ) > = 0. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch32-lang-45_Arja_PatchNaturalnessYe$$remove empty string handling. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch35-lang-45_Arja_PatchNaturalnessYe$$avoid empty string handling. fix a warning. add empty check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch34-lang-45_Arja_PatchNaturalnessYe$$fix a warning. add empty check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch33-lang-45_Arja_PatchNaturalnessYe$$fixed null string handling. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch11-lang-45_Arja_PatchNaturalnessYe$$fix a warning. avoid empty string handling. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch29-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. add empty check. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch16-lang-45_Arja_PatchNaturalnessYe$$fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch20-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove patch for substrings with length ( ). $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch18-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch27-lang-45_Arja_PatchNaturalnessYe$$remove a redundant check. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch42-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch5-lang-45_Arja_PatchNaturalnessYe$$IgnoreCase. fix a warning. remove null string if it is not found. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch19-lang-45_Arja_PatchNaturalnessYe$$fix a warning. convert string to lower case as is the case. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch26-lang-45_Arja_PatchNaturalnessYe$$remove patch. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch21-lang-45_Arja_PatchNaturalnessYe$$avoid NPE when StringUtils . isEmpty ( str ) is set upper = - 1. fix a warning. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch28-lang-45_Arja_PatchNaturalnessYe$$fix a warning. Fix removed - > upper case. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch17-lang-45_Arja_PatchNaturalnessYe$$fix a warning. IgnoreCase. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch10-lang-45_Arja_PatchNaturalnessYe$$fix a warning. remove patch from string utils. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch4-lang-45_Arja_PatchNaturalnessYe$$throw exception if the string is empty. fix a warning. add empty string check. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch8-chart-1_RSRepair_PatchNaturalnessYe$$Fix category axes. Fix category space rendering in RSRepair_Defects4J_Chart_1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch6-chart-1_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch15-chart-1_RSRepair_PatchNaturalnessYe$$@@ fix colspan error. Fix RSRepair_Defects4J_Chart_1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch12-chart-1_RSRepair_PatchNaturalnessYe$$Fix RSRepair_Defects4J_Chart_1 .. @@ removed return result from last fix. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch7-chart-1_RSRepair_PatchNaturalnessYe$$Fix possible NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch13-chart-1_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch14-chart-1_RSRepair_PatchNaturalnessYe$$Fix NPE in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch11-chart-1_RSRepair_PatchNaturalnessYe$$Fix minor bug. @@ removed patched line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch16-chart-1_RSRepair_PatchNaturalnessYe$$Remove null check in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch5-chart-1_RSRepair_PatchNaturalnessYe$$Fix bug in RSRepair_Defects4J_Chart_1. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch2-chart-1_RSRepair_PatchNaturalnessYe$$Fix category space for rect in RSRepair_Defects4J_Chart_1 .. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch10-chart-1_RSRepair_PatchNaturalnessYe$$Fix category data after last fix. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch3-chart-1_RSRepair_PatchNaturalnessYe$$Fix category plot plot. @@ - Remove break line. $$0
chart-1$$Potential NPE in AbstractCategoryItemRender.getLegendItems()$$Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java. The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read "if (dataset == null)", not "if (dataset != null)".$$patch4-chart-1_RSRepair_PatchNaturalnessYe$$Remove null check in RSRepair_Defects4J_Chart_1. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch5-math-73_RSRepair_PatchNaturalnessYe$$Add missing exception message. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch2-math-73_RSRepair_PatchNaturalnessYe$$Updated curried functions. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch3-math-73_RSRepair_PatchNaturalnessYe$$Updated patch. $$0
math-73$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch4-math-73_RSRepair_PatchNaturalnessYe$$Updated curried function so it can be used as a final closure. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch1-math-31_RSRepair_PatchNaturalnessYe$$Removed erroneous throw in ContinuedFraction. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch5-math-31_RSRepair_PatchNaturalnessYe$$Updated continuedFraction patch. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch2-math-31_RSRepair_PatchNaturalnessYe$$Removed a couple incorrect exceptions. $$0
math-31$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem. System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5)); This returns 499525, though it should be 499999. I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch3-math-31_RSRepair_PatchNaturalnessYe$$Updated continuedFraction patch. Missing patch .. $$0
lang-51$$BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException$$The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.$$patch1-lang-51_RSRepair_PatchNaturalnessYe$$Corrected a typo in StringUtils. $$0
lang-45$$WordUtils.abbreviate bug when lower is greater than str.length$$In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string$$patch1-lang-45_RSRepair_PatchNaturalnessYe$$Extend StringBuffer to take all string length. $$0
oak-e12e2052$$IndexRule not respecting inheritence based on mixins$$IndexRule are meant to be applied based on both primaryType and minin type based inheritance. Currently it appears that only primaryType based inheritance is working$$patch1-oak-e12e2052_Developer_PatchNaturalnessYe$$"Revert "" update index definition """. Fixed small issue with MIME type in IndexDefinition. $$1
oak-60186813$$Long overflow in PermissionEntryProviderImpl$$PermissionEntryProviderImpl#init can end up in a Long overflow if the underlying implementation does not know the exact value of the number children, and the child node count is higher than maxSize.  I will attach a patch with a test case$$patch1-oak-60186813_Developer_PatchNaturalnessYe$$added missing import. Fixed a warning .. "Revert "" update cache to handle large principals """. removed empty line for testing. $$1
oak-7fca85bf$$IllegalStateException for ValueMap on _revisions$$An IllegalStateException may be thrown by the MergeSortedIterator when _revisions on the root document are read with the ValueMap implementation. It only happens when the local _revisions map has entries that are lower than the most recent split document.$$patch1-oak-7fca85bf_Developer_PatchNaturalnessYe$$"avoid "" invalid state "" assertion ( IDEA - 152896 )". "Revert "" update ValueMap """. removed unused import. workflow improvements - added ability to sort by local map. $$1
oak-916cd92f$$Binaries might get removed by garbage collection while still referenced$$The [Microkernel contract|http://svn.apache.org/repos/asf/jackrabbit/oak/trunk/oak-mk-api/src/main/java/org/apache/jackrabbit/mk/api/MicroKernel.java] specifies a specific format for references to binaries: ":blobId:<blobId>". Currently oak-core uses a different format and thus risks premature garbage collection of such binaries.$$patch1-oak-916cd92f_Developer_PatchNaturalnessYe$$"Add "" blobId "" to TypeCodes map". "OAK - 428 "" Hide "" blobId "" in jsonString". "Revert "" removed "" OBE - added missing bracket """. $$1
oak-f303c916$$SegmentWriter saves references to external blobs$$The new {{SegmentWriteOperation#internalWriteStream}} method checks whether the input stream to write is a {{SegmentStream}}. If it's, writer will reuse existing block ids, rather than storing the whole stream.  It should also check whether the blocks in {{SegmentStream}} comes from the same tracker / segment store. Otherwise this will create invalid references if someone invokes the {{internalWriteStream()}} method with a {{SegmentStream}} created externally.$$patch1-oak-f303c916_Developer_PatchNaturalnessYe$$Fix an issue with the SegmentWriter not checking for block ids in an old gen store .. Remove unnecessary code. $$1
oak-dfa87520$$Lucene index rules should be case insensitive$$Following the lucene index definitions update, the ignored properties are upgraded as a lower case version, but the rest of the lucene bits (indexing) still take the case into account, resulting in the exclude rules being ignored, and properties being indexed.$$patch1-oak-dfa87520_Developer_PatchNaturalnessYe$$added missing import. added case insensitive map of property definition to IndexDefinition. ignore case for property names. convert property names to lower case as match in JDK7. $$1
oak-4416a9f8$$Write operations on Property do not check checked-out state of Node$$Write operations on Property do not check the checked-out state. The same is true for Node.setProperty(..., null).$$patch1-oak-4416a9f8_Developer_PatchNaturalnessYe$$throw version exception if property is checked in. added missing import. Clarify remove method to throw if node is checked out .. Clarify usage of method checkPreconditions ( ) in PropertyImpl # performVoid ( ). Clarify usage of method checkPreconditions ( ) in PropertyImpl # performVoid ( ). $$1
oak-36fe017c$$DocumentNodeStore.dispose() may leave repository in an inconsistent state$$The repository may become inconsistent when a commit happens while the DocumentNodeStore is disposed.   The node store writes back pending _lastRevs and then unset the active flag in the clusterNodes collection. It is possible a commit gets through even after the _lastRevs had been updated and the active flag is cleared. This means the missing _lastRev updates will not be recovered on a restart or by another cluster node.$$patch1-oak-36fe017c_Developer_PatchNaturalnessYe$$add more code on disposing of DocumentNodeStore. added checkOpen ( ) to checkstyle. added checkOpen ( ) to checkstyle. always run in parallel. Added private method to prevent DocStore from being disposed .. $$1
oak-342809f7$$Inconsistent handling of invalid names/paths$$Passing an invalid name to a JCR method might or might not throw a {{RepositoryException}} depending on whether name re-mappings exist or not:  {code} session.itemExists("/jcr:cont]ent"); {code}  returns {{false}} if no name re-mappings exist but throws a {{RepositoryException}} otherwise.$$patch1-oak-342809f7_Developer_PatchNaturalnessYe$$don ' t allow space - char in namespaces. removed unused variable. removed erroneous legacy comment. "Revert "" allow whitespace in name "" state """. "Revert "" allow leading spaces in name "" section". "Revert "" removed """. remove unused variable. "Revert "" reset trailing spaces """. "Revert "" Invalidating a file with trailing spaces """. JcrPathParser uses backslash instead of backslash. Fixed error in JcrPathParser. we should probably use /. $$1
oak-dd3437d4$$ConcurrentConflictTest fails occasionally$$Occurs every now and then on buildbot. E.g.: http://ci.apache.org/builders/oak-trunk-win7/builds/16$$patch1-oak-dd3437d4_Developer_PatchNaturalnessYe$$Fix # 322. update readme. Fix revision validity check. update workflow. $$1
oak-192ee9e4$$Document split suppressed with steady load on many cluster nodes$$Document split is suppressed when there is a steady write load on many cluster nodes. The document grows bigger over time and leads to poor performance.$$patch1-oak-192ee9e4_Developer_PatchNaturalnessYe$$getMemory ( ) * SPLIT_RATIO + = 1e6a2c. $$1
oak-55a4f738$$Revisit PrivilegeDefinitionStore's use of null as a child name parameter$$As discussed on OAK-635, I'm extracting the PrivilegeDefinitionStore code&patch into a dedicated issue.  Following the discussion on the dev list, I've filed it as a bug, as nulls are not considered valid input parameters.$$patch1-oak-55a4f738_Developer_PatchNaturalnessYe$$added checkNotNull check. added checkNotNull check. avoid merging of same workspaces in Ace workflow. $$1
oak-374e3f3d$$Simple versionable nodes are invalid after migration$$OAK-3836 introduces a support for migrating {{mix:simpleVersionable}} nodes from JCR2 to {{mix:versionable}} nodes in Oak. It changes the mixin type, however it doesn't add required properties: {{jcr:versionHistory}}, {{jcr:baseVersion}} and {{jcr:predecessors}}. As a result, versioning-related methods invoked on such nodes doesn't work correctly.$$patch1-oak-374e3f3d_Developer_PatchNaturalnessYe$$added missing import. add editor hook for security related editor. added static modifier to VersionablePropertiesEditor. $$1
oak-fcd64766$$Mixin based rules not working for relative properties$$If an indexing rule is defined for mixin then it does not work as expected for relative properties.  Issue here being that most of logic in Aggregate class (which is used for relative property handling also) relies on nodes primaryType and does not account for mixin type$$patch1-oak-fcd64766_Developer_PatchNaturalnessYe$$added missing import. added getMixinNames method. "Revert "" update to lucene 1 . 2 . 0 """. "Revert "" update aggregate to exclude unused imports """. Fixing issue # 14061. added matchingType ( ) for node state. "Revert "" add missing "" line to end of YAML file". added check for aggregates from mixins. $$1
oak-57bd2dc5$$DocumentNS may expose branch commit on earlier revision$$The DocumentNodeStore may expose the changes of a branch on a revision earlier than it's commit revision. This only happens when the read revision equals the revision of the not yet merged changes on the branch.$$patch1-oak-57bd2dc5_Developer_PatchNaturalnessYe$$remove ignore branch flag from NodeDocument. $$1
oak-c7669f31$$Reindex removes all nodes under index definition node$$Reindex logic in {{IndexUpdate}} removes all child node from index definition node thus removing valid nodes which might be part of index defintion. It should only remove hidden nodes$$patch1-oak-c7669f31_Developer_PatchNaturalnessYe$$added missing import. don ' t remove hidden nodes in index update. $$1
oak-6d8146f8$$Item names with trailing spaces should not be allowed$$the following should fail:  {code}         Node hello = session.getRootNode().addNode("hello");         session.save();          Node illegal = hello.addNode("test "); <-- here         session.save();          assertEquals("/hello/test ", illegal.getPath()); <-- and here          Node other = session.getNode("/hello/test "); <-- and here         assertTrue(other.isSame(illegal));         assertTrue(session.nodeExists("/hello/test ")); <-- and here {code}$$patch1-oak-6d8146f8_Developer_PatchNaturalnessYe$$improve namespace check. $$1
oak-2e20589f$$CacheLIRS implementation incomplete$$The current CacheLIRS implementation is not complete and e.g. does not provide a write through ConcurrentMap view on {{asMap()}}. For OAK-1088 it would be good to have this implementation as it allows conditional and atomic updates of cache entries.$$patch1-oak-2e20589f_Developer_PatchNaturalnessYe$$Fix NPE in CacheLIRS. $$1
oak-6feacf6b$$AssertionError in MemoryNodeBuilder$${code}     NodeBuilder root = ...     NodeBuilder child = root.child("new");      root.removeNode("new");     child.getChildNodeCount(); {code}  The last line throws an {{AssertionError}} when no node named "new" existed initially. It throws an {{IllegalStateException}} as expected otherwise.$$patch1-oak-6feacf6b_Developer_PatchNaturalnessYe$$Improved method name. Fix a check for node existence. Fixed # 242. added revision support for memory node builders. $$1
oak-b939aa6e$$Sysview import of single valued mv property creates sv property$$See test in filevault [0].  it imports a multivalue property that only has 1 value, via [1]. the same test succeeds in jackrabbit 2.0, but fails in oak 1.3.14  [0] https://github.com/apache/jackrabbit-filevault/blob/jackrabbit-filevault-3.1.26/vault-core/src/test/java/org/apache/jackrabbit/vault/packaging/integration/TestUserContentPackage.java#L297-L326 [1] https://github.com/apache/jackrabbit-filevault/blob/jackrabbit-filevault-3.1.26/vault-core/src/main/java/org/apache/jackrabbit/vault/fs/impl/io/JcrSysViewTransformer.java#L146-L148$$patch1-oak-b939aa6e_Developer_PatchNaturalnessYe$$don ' t delete multiple status fields when importing property. $$1
oak-db19e70f$$Tree.getStatus() and Tree.getPropertyStatus() fail for items whose parent has been removed$$None$$patch1-oak-db19e70f_Developer_PatchNaturalnessYe$$Improved javadoc in TreeImpl . parent. Fix bug # 257. Added getOwnPropertyStatus ( ) to TreeImpl # internalGetPropertyStatus ( ). can ' t build the path of a removed tree. $$1
oak-0fa892b3$$issues with JsopBuilder.encode and .escape$$1) escape() escapes many characters that do not need to be escaped (>127)  2) encode() does not encode many control characters that would need to be escaped when read through a JSON parser.$$patch1-oak-0fa892b3_Developer_PatchNaturalnessYe$$Allow json escaping of backslash - escaped characters. removed unused local variable. Fix JsopBuilder to ignore unicode characters. Fix JsopBuilder use of int instead of string . format. $$1
oak-2ac1dccd$$NodeDocument.getNewestRevision() incorrect when there are previous documents$$The method may incorrectly return null when there are previous documents and the base revision is lower than all local changes.  This is most likely caused by changes done for OAK-3388.$$patch1-oak-2ac1dccd_Developer_PatchNaturalnessYe$$add clusterIds of local changes as well. getRevisionNewer ( context , lower , r ) =. $$1
oak-e115fd90$$Trailing slash not removed for simple path in JCR to Oak path conversion$$While converting from JCR path to Oak path the trailing slashes are not removed for simple paths. They are removed for complex path  {code} assertEquals("/oak-foo:bar/oak-quu:qux",npMapper.getOakPath("/foo:bar/quu:qux/")); assertEquals("/a/b/c",npMapper.getOakPath("/a/b/c/"));     } {code}  Of the two cases above the first one passes while the second one fails$$patch1-oak-e115fd90_Developer_PatchNaturalnessYe$$remove unused variable. Add back hasTrailingSlash. "Revert "" update to have . . . """. "Revert "" removed last char of jcrPath """. added parse errors. $$1
oak-024e5d37$$Repository upgrade does not copy default values of property definitions$$The {{RepositoryUpgrade}} class needs to copy also the default values of property definitions in the node types being upgraded. See the TODO in https://github.com/apache/jackrabbit-oak/blob/jackrabbit-oak-0.20.0/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java#L485.$$patch1-oak-024e5d37_Developer_PatchNaturalnessYe$$added missing imports. added missing import. added missing import. removed unused imports. added inverse hash to prevent adding nodes to the upgrade map. added missing method. added missing throw. added missing prefixToUri for childNodeDefinition. added missing throws. Fix defaultValues for UpgradeDef. Fix oak upgrade error. $$1
oak-90ea7aa5$$NPE in DocumentNodeStore#retrieve for non existing checkpoint$$Said method throws a NPE when passing it a valid revision identifier from a non existing checkpoint.$$patch1-oak-90ea7aa5_Developer_PatchNaturalnessYe$$added missing import. added missing import. avoid NPE. $$1
oak-00df38d2$$Adding a node with the name of a removed node can lead to an inconsistent hierarchy of node builders$$None$$patch1-oak-00df38d2_Developer_PatchNaturalnessYe$$fix merge bug. $$1
oak-0c3e3d70$$Range check fails with IllegalArgumentException$${{Range.includes()}} fails with IllegalArgumentException when provided revision is from another cluster node:  {noformat} java.lang.IllegalArgumentException: Trying to compare revisions of different cluster ids: r142f43d2f0f-0-2 and r142f43d46fb-0-1 	at org.apache.jackrabbit.oak.plugins.mongomk.Revision.compareRevisionTime(Revision.java:84) 	at org.apache.jackrabbit.oak.plugins.mongomk.Range.includes(Range.java:55) {noformat}  The IllegalArgumentException was introduced with OAK-1274.$$patch1-oak-0c3e3d70_Developer_PatchNaturalnessYe$$"Add @ Nonnull to "" includes "" method". $$1
oak-e6c31270$$Inconsistency in Node#setProperty in case of null value$$Setting a null value to a single valued property will result in 'null' being returned while executing the same on a multivalued property will return the removed property.  jr2 returned the removed property in both cases as far as i  remember and i would suggest that we don't change that behavior. in particular since the specification IMO doesn't allow to return null-values for these methods.$$patch1-oak-e6c31270_Developer_PatchNaturalnessYe$$Fix failing tests. Fix a crash in node - remove ( ). $$1
oak-89317b28$$Hierarchy conflict detection broken$$Hierarchy conflict detection is broken in 1.0.14. It may happen that a child document is created even though the parent is considered deleted.$$patch1-oak-89317b28_Developer_PatchNaturalnessYe$$Fixing # 383. Fix UpdateOp constructor. add conditions. avoid condition copy. add "" conditions "" if it is not null """. "Revert "" update op """. "Revert "" updateCommitRoot with collision checks """. $$1
oak-438e31a7$$Better support for RangeIterators$$Currently all RangeIterators returned from the JCR API don't implement the {{getSize()}} method but rather return {{-1}}. We should return the size of the iterator if and where feasible.$$patch1-oak-438e31a7_Developer_PatchNaturalnessYe$$removed unused import. added static import. added getChildCount ( ) to NodeImpl. added propertyCount method to NodeImpl. $$1
oak-9772f5b2$$Initial read of _lastRev creates incorrect RevisionComparator$$The logic in backgroundRead(false) orders the local lastRev  before external lastRev. This the last change done by the local cluster node will look as if it happend before a potentially older external change.$$patch1-oak-9772f5b2_Developer_PatchNaturalnessYe$$added missing import. getHeadRevision ( ) must return a null value. remove false to pull in changes from other cluster nodes. remove unused parameter. Keep old behaviour unchanged for debugging .. added missing line. Fix an issue where the diff cache could become corrupt after a merge. log external revision timestamps in workflow. remove falsey flag. $$1
oak-4bfbfcdd$$ContentMirrorStoreStrategy should utilize path restriction when available$$Currently {{ContentStoreMirrorStrategy}} has a mirror of content path under {{:index}}. Yet, while {{query}} (and {{count}}) methods doesn't jump directly into restricted path.  This would be very useful for {{PropertyIndex}} where the queries can be optimized by supplying a path restriction along with an indexed property restriction (I don't know if queries with references would use paths so much though)$$patch1-oak-4bfbfcdd_Developer_PatchNaturalnessYe$$add filter to PropertyIndexLookup # count. "removed unused "" TYPE "" index from OrderedPropertyIndex". "Revert "" update to OrderedPropertyIndex with more custom logic """. added missing path prefix. added pathPrefix for OrderedPropertyIndex. added missing closing bracket. "remove "" prefix "" cursor from "" paths "" query". added missing closing backslash. add @ opt for optimized query execution. Added missing javadoc. added filter to property index plan. added filter to property index plan. Fixed static inner class definition. Added missing Override annotation. "Revert "" update to latest opengl """. Remove erroneous legacy comment. Improved cursors that use relative paths together with other cursors. added query ( ) method. added path prefix to query ( ). added pathPrefix to query ( ). Fix path prefix added by using the + 1 as the < - 1 would be the case if. added pathPrefix parameter to query results. Fixed opengling problem. added pathPrefix parameter to QueryResultsWrapper. added missing closing parenthesis. added missing @ Override. adding filterRootPath in last commit. don ' t count nodes if filterRootPath is null. added filterPath and pathPrefix to ContentMirrorStoreStrategy. "Revert "" update iterator to use "" include root """. added relative path to filter path. added pathPrefix + currentPath to result of ContentMirrorStoreStrategy. added default implementation of count. $$1
oak-147515ae$$Async Update fails after IllegalArgumentException$$The async index update can fail due to a mismatch between an index definition and the actual content. If that is the case, it seems that it can no longer make any progress. Instead it re-indexes the latest changes over and over again until it hits the problematic property.  Discussion at http://markmail.org/thread/42bixzkrkwv4s6tq  Stacktrace attached.$$patch1-oak-147515ae_Developer_PatchNaturalnessYe$$Log warning if property multivalued is not supported. Fixed warning for later release notes. $$1
oak-a7f0e808$$NPE in the TypeValidator when using the Lucene Index$$None$$patch1-oak-a7f0e808_Developer_PatchNaturalnessYe$$Avoid NPE in ValidatingHook. Avoid NPE in ValidatingHook. $$1
oak-004db804$$XPath queries with certain combinations of "or" conditions don't use an index$$XPath queries with the following conditions are not converted to "union" SQL-2 queries and therefore don't use an index:  {noformat} /jcr:root/content//*[((@i = '1' or @i = '2') or (@s = 'x')) and (@t = 'a' or @t = 'b')] {noformat}$$patch1-oak-004db804_Developer_PatchNaturalnessYe$$removed unused import. added Expression . optimize ( ). Fixed small issue with Expression . getLeft ( ). Fixed small issue with Expression # getCommonLeftPart ( ). added optimize ( ) method in Expression. fixed in condition class. always use optimize ( ) method of AndCondition. Add an override method to Expression # containsFullTextCondition. override isName ( ) in Expression. Add full text condition implementation. added Expression. "Revert "" update to latest opengl """. Remove unused private fields. optimize query xpath. fixed full text search. Clarify a use case for contains in xpath query. fixed # 77. $$1
oak-29e5b734$$Redundent entries in effective policies per principal-set$$when retrieving the effective policies for a given set of principals the resulting array of policies contains redundant entries if a given policy contains multiple ACEs for the given set of principals.$$patch1-oak-29e5b734_Developer_PatchNaturalnessYe$$"Revert "" update to latest ace access control api """. Add missing imports. Fix null pointer check in AccessControlManagerImpl .. Fixed bug where path in effective set of rules was being added twice. $$1
oak-7ba9dd66$$DocumentNodeStore revision GC removes intermediate docs$$The revision garbage collection in DocumentNodeStore removes intermediate documents of the revision history of a node even if it is still in use.$$patch1-oak-7ba9dd66_Developer_PatchNaturalnessYe$$added missing import. "Revert "" update split doc """. Improved method to validate only deleted local fields after the split. "remove "" INTERMEDIATE "" from GC_TYPES". $$1
oak-e403e003$$Path parsing must support SNS indexes, irrespective of SNS support$${code} Session.getNode("/foo/bar[2]"); {code}  throws {{javax.jcr.RepositoryException: Invalid name or path: /foo/bar\[2]}}  This should be an ItemNotFoundException (if the item does not exist), irrespective if the repository supports SNS or not.$$patch1-oak-e403e003_Developer_PatchNaturalnessYe$$added check for SNS path existence ( added check for 1 ). $$1
oak-3535afe2$$Session.nodeExists("/foo/bar[2]") must not throw PathNotFoundException$$similar to OAK-1216, Session.nodeExists() of an SNS path with indexes > 1 should return false.$$patch1-oak-3535afe2_Developer_PatchNaturalnessYe$$Handle PathNotFoundException in readOperation ( ). Handle case when absPath is null. $$1
oak-c215b267$$TarMK compaction can create mixed segments$$As described in http://markmail.org/message/ujkqdlthudaortxf, commits that occur while the compaction operation is running can make the compacted segments contain references to older data segments, which prevents old data from being reclaimed during cleanup.$$patch1-oak-c215b267_Developer_PatchNaturalnessYe$$"Revert "" update to latest compactor changes """. update Compactor. redundant constructor. $$1
oak-08f0b280$$Possible overflow in checkpoint creation$$Creating a checkpoint with {{Long.MAX_VALUE}} lifetime will overflow the value, allowing the store to immediately release the checkpoint.$$patch1-oak-08f0b280_Developer_PatchNaturalnessYe$$Fixed bug with segment node history. $$1
oak-94110f21$$Provide Simple Exception Name in Credentials Attribute for PW Expiry$$currently upon encountering a pw history exception while changing the password of a user, the credential attribute is set with the FQ class name, instead of the simple name. this requires consumers (e.g. sling) to use oak package names instead of a simple class name to react to the situation.$$patch1-oak-94110f21_Developer_PatchNaturalnessYe$$"Revert "" update to "" use username "" instead of class name """. $$1
oak-f2bb1a17$$MutableTree#isNew: replace implementation by NodeBuilder#isNew$$Similar to the issue described in OAK-1177 we may consider replacing the implementation of MutableTree#isNew by the corresponding call on the NodeBuilder.  See also OAK-947.$$patch1-oak-f2bb1a17_Developer_PatchNaturalnessYe$$made rootBase private. added reset ( ) to the kernel root builder. added missing imports. "Revert "" update to 2005 06 07 """. Improved javadoc in MutableTree. Improved javadoc in MutableTree. Fix javadoc for MutableTree . isVisible ( ). added missing import. fixing mongomk issue. added reset ( ) to MongoRootBuilder. Improve memory node builder. $$1
oak-daf9a4ef$$RootImplFuzzIT test failures$$As seen in the CI build, {{RootImplFuzzIT}} fails every now and then. This might be because of OAK-174, but there's been quite a bit of other work on the same area, so this could be caused also by something else.  The troublesome seeds as seen in failing CI builds are 1437930918, 206057576, 1638075186, 1705736349, -1856261793 and 569172885.$$patch1-oak-daf9a4ef_Developer_PatchNaturalnessYe$$don ' t commit if currentRoot is not the new root node. "Revert "" update to latest root node state after purge - > notifyListeners """. $$1
oak-a1556c30$$[Ordered Index] Indexing on large content is slow$$Indexing large number of ordered properties is quite slow.  Explore ways of making it faster. The current skip list implementation uses 4 lanes with a probability of 10%. It should be made configurable and the defaults changed.$$patch1-oak-a1556c30_Developer_PatchNaturalnessYe$$added missing import. removed unused imports. Fix NPE in OrderedContentMirrorStoreStrategy. reset currentNode to null. added support for empty string properties. added missing closing Javadoc. removed unnecessary check for array length. Fixed default probability of the indexer , but it ' s still in the code , and it. $$1
oak-79467350$$XPath query failures for mvps$$Adding some cases related to mvps that are not currently covered by the existing (jackrabbit) tests.$$patch1-oak-79467350_Developer_PatchNaturalnessYe$$Fixed a bug in property value comparison. Fixed bug in PropertyValues . contains. Fix notMatch implementation. Fix bug in FilterImpl # setAlwaysFalse. CAMEL - 2216 Handle case with null values in IndexFilter. $$1
oak-84fb6b29$$MutableTree#isNew: replace implementation by NodeBuilder#isNew$$Similar to the issue described in OAK-1177 we may consider replacing the implementation of MutableTree#isNew by the corresponding call on the NodeBuilder.  See also OAK-947.$$patch1-oak-84fb6b29_Developer_PatchNaturalnessYe$$Improved javadoc in MemoryNodeBuilder. $$1
oak-24cb1908$$DocumentNodeStore revision GC may lead to NPE$$The DocumentNodeStore revision GC may cause a NPE in a reader thread when the GC deletes documents currently accessed by the reader. The {{docChildrenCache}} is invalidated in {{VersionGarbageCollector.collectDeletedDocuments()}} after documents are removed in the DocumentStore. The NPE may occur if removed documents are access in between.$$patch1-oak-24cb1908_Developer_PatchNaturalnessYe$$added missing import. added missing import. "remove "" import "" statement from opengl". added private modifier to readChildDocs. "Remove "" final "" modifier from StringValue ( path ) ;". "Revert "" update to 0 """. always invalidate children cache when we are done with the last document. $$1
oak-c05cec12$$Invalid JCR paths not caught$${{NamePathMapper.getOakPath}} should return {{null}} when called with an invalid JCR path like {{foo:bar]baz}}, but it doesn't.$$patch1-oak-c05cec12_Developer_PatchNaturalnessYe$$Improved javadoc comment. $$1
oak-86edbffb$$Oak Analyzer can't tokenize chinese phrases$$It looks like the _WhitespaceTokenizer_ cannot properly split Chinese phrases, for example ''. I could not find a reference to this issue other than LUCENE-5096.  The fix is to switch to the _ClassicTokenizer_ which seems better equipped for this kind of task.$$patch1-oak-86edbffb_Developer_PatchNaturalnessYe$$Bump LuceneIndexConstants version to match main pom. added missing import. Removed use of deprecated API. $$1
oak-a2950285$$Parent of unseen children must not be removable$$With OAK-2673, it's now possible to have hidden intermediate nodes created concurrently. So, a scenario like: {noformat} start -> /:hidden N1 creates /:hiddent/parent/node1 N2 creates /:hidden/parent/node2 {noformat} is allowed.  But, if N2's creation of {{parent}} got persisted later than that on N1, then N2 is currently able to delete {{parent}} even though there's {{node1}}.$$patch1-oak-a2950285_Developer_PatchNaturalnessYe$$"remove unused import "" import "" statement". added missing import. Build number 12. $$1
oak-b8fe2ded$$NodeType index doesn't respect the declaringNodeTypes setting$$Following the OAK-1150 discussion, I've noticed that the node type index doesn't respect the declaringNodeTypes setting. Setting a restriction on the node type index definition breaks the index - there are 0 query hits.$$patch1-oak-b8fe2ded_Developer_PatchNaturalnessYe$$added filter to isIndexed ( ) method. Fix nodetype indexing. added cost function to NodeTypeIndex , that now works with nodetype filters. added 58. $$1
oak-b4a93c81$$Always create new UUID on ImportBehavior.IMPORT_UUID_CREATE_NEW$$The implementation should create a new UUID for each referenceable node even if there is no existing node with that UUID. This spec says:  bq.  Incoming nodes are assigned newly created identifiers upon addition to the workspace. As a result, identifier collisions never occur.  This will break backward compatibility, but is IMO the correct behavior and the only way to guarantee import of referenceable nodes does not fail in a concurrent import scenario. See OAK-1186 for more details.$$patch1-oak-b4a93c81_Developer_PatchNaturalnessYe$$added missing author note. $$1
oak-6fc5ea9d$$TreeImpl#*Location: unable retrieve child location if access to parent is denied$$as a consequence of OAK-709 we now have an issue with the way SessionDelegate and Root#getLocation access a node in the hierarchy which has an ancestor which is not accessible.  specifically RootImpl#getLocation will be served a NullLocation for the first ancestor which is not accessible and consequently any accessible child node cannot be accessed.  in order to reproduce the issue you may:  - change AccessControlConfigurationImpl to use PermissionProviderImpl instead   of the tmp solution - and run o.a.j.oak.jcr.security.authorization.ReadTest#testReadDenied$$patch1-oak-6fc5ea9d_Developer_PatchNaturalnessYe$$Fix bug 45195 .. getChildNode ( ) is not a child of the tree. Improved method return type for TreeImpl # getFirstChild ( ). Fixed a small bug. "Revert "" return null """. $$1
oak-093b9128$$Default sync handler property mapping does not allow constant properties$$it would be useful, if the default sync handler user (and group) mapping could also handle constant properties and use given primary type and mixin type information. eg:  {noformat} profile/nt:primaryType="sling:Folder" profile/sling:resourceType="sling/security/profile" {noformat}$$patch1-oak-093b9128_Developer_PatchNaturalnessYe$$Fixed whitespace in SyncHandler. $$1
oak-d645112f$$RepositorySidegrade: oak-segment to oak-segment-tar should migrate checkpoint info$$The sidegrade from {{oak-segment}} to {{oak-segment-tar}} should also take care of moving the checkpoint data and meta. This will save a very expensive full-reindex.$$patch1-oak-d645112f_Developer_PatchNaturalnessYe$$added missing import. added missing imports. Have the SegmentTarFactory return a better implementation. added missing import. added missing imports. do not remove checkpoint references in upgrade workflow. added get checkpoint paths method. added missing import. Have the SegmentFactory return a better implementation. Add back missing constructor .. $$1
oak-2a02a138$$Hidden properties (one prefixed with ':') in lucene's analyzer configuration fail to construct analyzers$$This is similar to OAK-2524 in the sense that lucene doesn't like extra arguments sent its way while constructing analyzers. In some cases (like node move adds {{:source-path}}) we have hidden properties added to index definition nodes and they get passed along to lucene analyzer factories which complaint and fail.$$patch1-oak-2a02a138_Developer_PatchNaturalnessYe$$added missing import. added ISO - 8859 - 2 workflow improvements. $$1
oak-5c4589bd$$Range queries and relative properties resultset should be consistent with JR2$$When running a range query like {{/jcr:root/content/nodes//*[(*/*/*/@prop >= 9)]}} the resultset is not consistent for the same use-case when running in jacrabbit 2.$$patch1-oak-5c4589bd_Developer_PatchNaturalnessYe$$added missing import. added missing log. Add logging for currentOakProperty ( ). Add logging for readOakProperties ( ). added log trace for added property. $$1
oak-a28098fd$$Session.getItem violates JCR Spec$$Session.getItem(path) is supposed to first return a node for the given path, and if no node is found return a property.  The oak implementation returns this in the opposite order.  see attached patch for a possible fix.$$patch1-oak-a28098fd_Developer_PatchNaturalnessYe$$added NodeDelegate for ( @@ ). $$1
oak-70564c7c$$Revisit full-text queries in case of multiple tokens$$There's still an issue with tokenizing the search terms when trying for example to search for a fulltext term that will split into 2 actual terms because of the analyzer.  Taking 'hello-world*' this will break into 2 tokens 'hello' and 'world*' which when treated as a PhraseQuery will not work, so I want to change this into a MutiPhraseQuery based on the simple tokens provided and all the existing tokens that match the wildchar character.$$patch1-oak-70564c7c_Developer_PatchNaturalnessYe$$added missing import. added missing imports. Fixed a small issue with missing reader option. added LuceneIndex . getFullTextQuery ( ) that uses the index reader for the. Fixed a small bug in Indexing. Fixed a small bug in Indexing. added missing reader dependency. added missing IndexReader dependency. Fixed a bug in the Lucene index that was failing too often. Fixed bug in lucene index. $$1
oak-45b110e1$$MemoryNodeBuilder.setNode() loses property values$${code} builder.setNode("a", nodeA); builder.child("a").setProperty(...); {code}  After the 2nd line executed, properties initially present on {{nodeA}} are gone on {{builder.getNodeState()}}.$$patch1-oak-45b110e1_Developer_PatchNaturalnessYe$$added missing copy of base state from getWriteState ( ). $$1
oak-c9765c21$$Ignore files in the root directory of the FileDataStore in #getAllIdentifiers$$The call to OakFileDataStore#getAllIdentifiers should ignore the the files directly at the root of the DataStore (These files are used for SharedDataStore etc). This does not cause any functional problems but leads to logging warning in the logs.  There is already a check but it fails when the data store root is specified as a relative path.$$patch1-oak-c9765c21_Developer_PatchNaturalnessYe$$remove unused imports. added normalizeNoEndSeparator. don ' t normalize path separators ; fix. $$1
oak-c02ecef8$$MemoryPropertyBuilder.assignFrom leads to ClassCastException on getPropertyState with date properties$$None$$patch1-oak-c02ecef8_Developer_PatchNaturalnessYe$$improve memory property builder. $$1
oak-a0a495f0$$Missing privileges after repository upgrade$$After upgrading from Jackrabbit classic all Oak specific privileges are missing (rep:userManagement, rep:readNodes, rep:readProperties, rep:addProperties, rep:alterProperties, rep:removeProperties, rep:indexDefinitionManagement).  The reason seems to be that the {{PrivilegeInitializer}} is not run during upgrade.$$patch1-oak-a0a495f0_Developer_PatchNaturalnessYe$$added missing import. Fixing the build .. Fixing the build .. ignore built in privileges. static resolvePrivilegeBits ( ). $$1
oak-16225d51$$MongoMK GC removes documents with data still in use$$The version garbage collector may delete previous documents that contain commit root information still in use by the main document.$$patch1-oak-16225d51_Developer_PatchNaturalnessYe$$removed unused imports. remove OAK - 1794 from GC_TYPES. $$1
oak-ca63fdf3$$Missing privileges after repository upgrade$$After upgrading from Jackrabbit classic all Oak specific privileges are missing (rep:userManagement, rep:readNodes, rep:readProperties, rep:addProperties, rep:alterProperties, rep:removeProperties, rep:indexDefinitionManagement).  The reason seems to be that the {{PrivilegeInitializer}} is not run during upgrade.$$patch1-oak-ca63fdf3_Developer_PatchNaturalnessYe$$added workspace initializer to each security configuration. $$1
oak-6d82cb64$$PathUtils#getDepth returns 1 for empty path$$PathUtils#getDepths that the root path / has depth 0. however, passing in a empty string is accepted and returns 1.  according to the API contract getDepth is counting the number of elements in the path which for "" should IMO be zero.$$patch1-oak-6d82cb64_Developer_PatchNaturalnessYe$$avoid NPE on initial check for empty path Strings. $$1
oak-117b0a3d$$Node.hasNode("foo[2]") must not throw PathNotFoundException$$similar to OAK-1225, Node.hasNode("foo[2]") should return false$$patch1-oak-117b0a3d_Developer_PatchNaturalnessYe$$added better handling for hasNode ( ). $$1
oak-279bb3ce$$Slow event listeners do not scale as expected$${{org.apache.jackrabbit.oak.jcr.LargeOperationIT#slowListener}} does not scale to {{O n log n}} on the document node store.$$patch1-oak-279bb3ce_Developer_PatchNaturalnessYe$$getCommitRootDepth from local to getCommitRootDepth from repository. Remove a for - loop that is not needed .. getCommitRootDepth ( ) is used by the repository only for the current commit root. $$1
oak-705ce1d1$$NodeStoreKernel doesn't handle array properties correctly$${{NodeStoreKernel}} currently only supports array properties of type long. For other types it will fail with an {{IllegalStateException}}. See also the FIXME in the code.$$patch1-oak-705ce1d1_Developer_PatchNaturalnessYe$$Fixing possible NPE in SegmentNodeState . getProperty ( ). $$1
oak-7e250001$$UpdateOp.Key.equals() incorrect$$As reported on the dev list [0], the equals implementation of UpdateOp.Key is incorrect.  [0] http://markmail.org/message/acpg2mhbxjn4lglu$$patch1-oak-7e250001_Developer_PatchNaturalnessYe$$Fixed updateOp. $$1
oak-64045631$$Inconsistent state in Mongo/KernelRootBuilder$$The state of Kernel- and MongoRootBuilder may turn inconsistent when a NodeStoreBranch.merge() performs a rebase followed by a failed merge on the underlying storage. The head and base are not properly updated to reflect the successful rebase.$$patch1-oak-64045631_Developer_PatchNaturalnessYe$$Improve merge method. fix merge call. $$1
oak-8ed779dc$$Assertion error when adding node with expanded name$${code} node.addNode("{http://foo}new"); {code}  results in an assertion error$$patch1-oak-8ed779dc_Developer_PatchNaturalnessYe$$Fix NodeImpl ' s @@. $$1
oak-26041fe7$$Cross foreign cluster revision comparison may be wrong$$Running one of the access control related benchmarks concurrently on a MongoDB may result in strange conflicts even when DocumentNodeStore retries the commit. The root cause may be a wrong revision comparison when both revision to compare are from a foreign cluster node and one of them is not withing the known seen-at revision ranges.$$patch1-oak-26041fe7_Developer_PatchNaturalnessYe$$Fix null pointer check in revision range. $$1
oak-ff81ef72$$NodeDocument.getNodeAtRevision can go into property history traversal when latest rev on current doc isn't committed$${{NodeDocument.getNodeAtRevision}} tried to look at latest revisions entries for each property in current document. But it just looks at the *last* entry for a given property. In case this last entry isn't committed, the code would go into previous documents to look for a committed value.  (cc [~mreutegg])$$patch1-oak-ff81ef72_Developer_PatchNaturalnessYe$$workflow improvements - remove check for isRevisionNewer ( ) and isNotMostRecentCommitted (. Improved method to compare revisions with valueMap. $$1
oak-2565d74a$$BackgroundLeaseUpdate not scheduled when asyncDelay=0$$The BackgroundLeaseUpdate extends from NodeStoreTask, which returns from the run() method when asyncDelay is 0. This is fine for the background read and update tasks. However, the lease update task must run even when asyncDelay is set to zero.$$patch1-oak-2565d74a_Developer_PatchNaturalnessYe$$added missing import. give NodeStoreTask a chance to cache node delay if it is not used. Fix DocumentNodeStore ' s async delay value. Add back missing constructor .. $$1
oak-b896c926$$Item names starting with '{X}' cause RepositoryException$$The exception is RepositoryException: Invalid name or path: {0} foo  E.g. for an item named '{0} foo'.  I guess oak-jcr tries to interpret it as a name in expanded form but does not find a namespace uri for '0'. IIRC these names are valid in Jackrabbit 2.x.$$patch1-oak-b896c926_Developer_PatchNaturalnessYe$$Fixed check for expanded name. $$1
oak-8159fc21$$Lucene AND query with a complex OR phrase returns incorrect result$$Queries like this {noformat}/jcr:root/content//element(*, test:Asset)[(jcr:contains(., 'cube')) and (jcr:contains(jcr:content/@foo, '"a" OR "b"'))] {noformat} returns wrong results.  This get converted to {noformat}+:fulltext:cube full:jcr:content/foo:"a" full:jcr:content/foo:"b" {noformat}$$patch1-oak-8159fc21_Developer_PatchNaturalnessYe$$Remove must_not ( ) in BooleanQuery. Remove must_not ( x ) from must_not ( x ) since it ' s not. $$1
oak-f4324736$$LuceneIndexProviderService may miss on registering PreExtractedTextProvider$${{LuceneIndexProviderService}} has an optional dependency on {{PreExtractedTextProvider}}. In such a case it can happen that bind for the provided is invoked before the activate is called. In such a case the provider would not be registered.$$patch1-oak-f4324736_Developer_PatchNaturalnessYe$$Fixed NPE in javadoc. added missing register. $$1
oak-3e83a4c1$$NodeDocument _modified may go back in time$$In a cluster with multiple DocumentMK instances the _modified field of a NodeDocument may go back in time. This will result in incorrect diff calculations when the DocumentNodeStore uses the _modified field to find changed nodes for a given revision range.$$patch1-oak-3e83a4c1_Developer_PatchNaturalnessYe$$added missing import. added version check. "Revert "" check version """. Fixed MongoDB operation type. added maxUpdates = new BasicDBObject ( ) ;. Fixed case. added max / max updates to update - > min. add UpdateUtils . applyChanges ( ). Added MAX op to UpdateUtils. Fixing # 12508. Fix update update op. "Remove map entry operation with type = "" REMOVE_MAP_ENTRY "" ; don '. update update op with max ( String , Object ). Fix error in updateOp. "remove unnecessary "" type = "" in UpdateOp constructor". Added update operation for Long value update .. Add constructor to UpdateOp. Fix update op implementation. $$1
oak-cb3ac20d$$Lucene Index should ignore property existence checks$$Some optimizations on the query engine transform certain clauses in property existence checks. ie (p = 'somevalue' turns into 'p is not null').  This doesn't play well with lucene as it can not  effectively build a 'not null' query, even worse the query doesn't return any results.  As a fix I'll just skip the existence constraints from the generated lucene query.$$patch1-oak-cb3ac20d_Developer_PatchNaturalnessYe$$add OAK - 1208 - LuceneIndex does not handle child - level property restrictions. $$1
oak-0adf3a6e$$Folder containing an admin user should not be removed$$The action of removing a folder that contains the admin user should fail.  This is already the case if it is tried to remove the admin node .  Attaching unit test$$patch1-oak-0adf3a6e_Developer_PatchNaturalnessYe$$avoid NPE. added simple constraint exception for removed users .. $$1
oak-06c367af$$Cost per entry for Lucene index of type v1 should be higher than that of v2$$Currently default cost per entry for Lucene index of type # v1 - which uses query time aggregation # v2 - which uses index time aggregation  Are same. However given that query time aggregation would require more effort it should result in a higher cost per entry.  This fact impacts the result in cases like OAK-2081 (see last few comments) where with usage of limits both index are currently considered equals$$patch1-oak-06c367af_Developer_PatchNaturalnessYe$$Fixed missing default value. Should fix # 184. $$1
oak-494da6de$$UserValidator and AccessControlValidator must not process hidden nodes$$This is similar to OAK-3019 but for {{UserValidator}} and {{AccessControlValidator}}.$$patch1-oak-494da6de_Developer_PatchNaturalnessYe$$"Revert "" update to latest commit """. AccessControlValidator should probably use newValidator. AccessControlValidator should probably use newValidator. Add a static constructor to AccessControlValidator. Fixing a TODO. added default constructor. $$1
oak-73cc2442$$MoveDetector does not detect moved nodes that have been moved in an earlier commit already$$None$$patch1-oak-73cc2442_Developer_PatchNaturalnessYe$$"Revert "" update memory node builder to point to the same node """. $$1
oak-913c2f53$$TarMK compaction can create mixed segments$$As described in http://markmail.org/message/ujkqdlthudaortxf, commits that occur while the compaction operation is running can make the compacted segments contain references to older data segments, which prevents old data from being reclaimed during cleanup.$$patch1-oak-913c2f53_Developer_PatchNaturalnessYe$$Added protected method to retrieve the segment tracker from the record .. Improved method to validate compaction status of segments. Fix Compactor constructor. added flush ( ) to FileStore. Drop the SegmentWriter caches before compacting any data .. Oops , now expect the writer to be passed through to constructor. do not compact if data is taken from cache. added uncompaction to SegmentWriter. $$1
oak-f2a2edec$$NamePathMapper should fail on absolute paths escaping root$$The name path mapper should no accept invalid paths of type  {code} /.. {code}  I.e. paths which escape beyond the root of the hierarchy.$$patch1-oak-f2a2edec_Developer_PatchNaturalnessYe$$added missing var. Fixed parser with more than one root node. Increased the depth of the parser for relative names so it parses. "Revert "" update to latest oak """. Add missing final modifier to JcrPath. added relative path escape. "Revert "" getOakPath ( final String , final boolean ) """. Added parse errors for parent ( ). $$1
oak-591e4d4a$$AsyncIndexUpdate may resurrect nodes$$There is a race condition in the AsyncIndexUpdate.run() method. The implementation creates a checkpoint used as the after node state for the comparison with the previous checkpoint. In a next step a builder is created from the current root state of the node store. Node removed between the checkpoint call and retrieving the root state may get resurrected by the AsyncIndexUpdate.$$patch1-oak-591e4d4a_Developer_PatchNaturalnessYe$$Fix typo. $$1
oak-3efb5cbf$$Node not accessible after document split$$In a cluster setup it may happen that a node becomes inaccessible when all remaining local revision entries after a split are not yet visible to a cluster node.$$patch1-oak-3efb5cbf_Developer_PatchNaturalnessYe$$added missing import. added stable type to Commit. workflow workflow should validate revisions against changeRev. "avoid the "" null """. $$1
oak-2e16a983$$Query: UnsupportedOperationException for some combinations of "or" and "and" conditions$$The following query throws an UnsupportedOperationException:  {noformat} select * from [nt:base]    where [a] = 1 and [b] = 2 and [b] = 3 or [c] = 4 {noformat}$$patch1-oak-2e16a983_Developer_PatchNaturalnessYe$$removed OAK - 1933. "Revert "" update to latest query index """. $$1
oak-05c89637$$CacheLIRS concurrency issue$$Some of the methods of the cache can throw a NullPointerException when the cache is used concurrently. Example stack trace:  {code} java.lang.NullPointerException: null org.apache.jackrabbit.oak.cache.CacheLIRS.values(CacheLIRS.java:470)  org.apache.jackrabbit.oak.cache.CacheLIRS 1.values(CacheLIRS.java:1432) org.apache.jackrabbit.oak.plugins.segment.file.FileStore.flush(FileStore.java:205) {code}$$patch1-oak-05c89637_Developer_PatchNaturalnessYe$$"Revert "" update to latest cache "" report". "Revert "" update CacheLIRS to latest cache "" issue". Improved cache implementation. Improved cache implementation. Improved cache presence code. Add null check in CacheLIRS. Fix possible NPE in CacheLIRS . get ( K ). $$1
oak-f37ce716$$DocumentNodeStore does not make use of References while serializing Blob$$The BlobSerializer in DocumentNodeStore does not make use of Blob references which results in copying the blobs by value hence significantly slowing down any migration$$patch1-oak-f37ce716_Developer_PatchNaturalnessYe$$added blob reference check. $$1
oak-8079f7b5$$issues with JsopBuilder.encode and .escape$$1) escape() escapes many characters that do not need to be escaped (>127)  2) encode() does not encode many control characters that would need to be escaped when read through a JSON parser.$$patch1-oak-8079f7b5_Developer_PatchNaturalnessYe$$added int cast to improve JSON output. "Fixed issue where "" isSurrogatePair ( char ) "" was failing in JSON format". $$1
oak-be3a9114$$TARMK Cold Standby size increase due to checkpoints copy$$The current sync design gets confused by existing checkpoints and tries to copy them by value, bypassing the current storage optimization where there are a lot of references to existing content. this can result in a considerable size increase on the standby.$$patch1-oak-be3a9114_Developer_PatchNaturalnessYe$$"Revert "" update to latest standby plugin """. remove logonly option from StandbyApplyDiff constructor. don ' t log by default. don ' t log by default. don ' t remove logonly property when apply is called. remove childNodeAdded logonly for segment node states. added logonly condition for childNodeChanged. don ' t log childNodeDeleted if logOnly is set. $$1
oak-f3c9c818$$NPE in RecordIdMap$${{RecordIdMap}} is not properly guarded against NPEs when calling accessors on an empty map (which is represented by {{keys == null}}.   {noformat} testRecordIdMap(org.apache.jackrabbit.oak.plugins.segment.RecordIdMapTest)  Time elapsed: 0.019 sec  <<< ERROR! java.lang.NullPointerException at org.apache.jackrabbit.oak.plugins.segment.RecordIdMap.size(RecordIdMap.java:100) at org.apache.jackrabbit.oak.plugins.segment.RecordIdMapTest.testRecordIdMap(RecordIdMapTest.java:64) {noformat}$$patch1-oak-f3c9c818_Developer_PatchNaturalnessYe$$Fixed NPE in RecordIdMap. Fix possible NPE in RecordIdMap put. remove null check. Add throws notice for getKey. Add throws. $$1
oak-f2740ce1$$Ordered index does not return relative properties for un-restricted indexes$$Even if we specify an index without any restriction to node type; the ordered index does not return any result for relative properties$$patch1-oak-f2740ce1_Developer_PatchNaturalnessYe$$fixed opengl version. $$1
oak-503451c1$$ContentMirrorStoreStrategy #insert fails to enforce uniqueness and is slow$$Following OAK-734 I've noticed that the _ContentMirrorStoreStrategy_ fails to enforce the uniqueness constraints assumed on the #insert method.  It is also responsible for a slowdown on the #insert method because of the behavior change of the Property2Index (very frequent saves instead of a bulk one).$$patch1-oak-503451c1_Developer_PatchNaturalnessYe$$added TODO. "Revert "" throw exception on uniqueness constraint for key "" + key". "Revert "" update to index ( ) with unique = true """. $$1
oak-08b25cb0$$Lucene Index property definition is ignored if its not in includePropertyNames config$$Lucene index property definition will not be used unless that property is in includePropertyNames config. This enforces including that property in includePropertyNames. includePropertyNames restricts all properties from getting indexed, so user is now enforced to include all properties in includePropertyNames to be indexed.$$patch1-oak-08b25cb0_Developer_PatchNaturalnessYe$$added missing comment. added property definition for property nodes. $$1
oak-63070cf9$$Lucene should not serve queries for what it doesn't index$$If a query is asked and Lucene is chosen as index for serving it, it will try to serve all the restrictions of the query, even the one that are not indexed.$$patch1-oak-63070cf9_Developer_PatchNaturalnessYe$$Add LuceneIndexConstants. added missing import. Fixed missing import. added getIndexDef to the plan. Fixed a bug in LuceneIndex. Fixed a bug in the LuceneIndex constructor. added index definition to nonFullTextConstraints. added node state constraint. don ' t check excluded properties and types in lucene ( they are not used ). Fixed lucene exclusion. $$1
oak-5449bf39$$PathUtils.isAncestor("/", "/") should return false but returns true$$None$$patch1-oak-5449bf39_Developer_PatchNaturalnessYe$$added parsePath method. "fix false alarm in "" denotes root "" of OSGi metadata". $$1
oak-00b4b8a0$$Moving or deleting tree instances with status NEW doesn't change its status to DISCONNECTED$$Further fall out from OAK-606:  {code}         Tree t = tree.addChild("new");          root.move("/x", "/y/x");         assertEquals(Status.DISCONNECTED, t.getStatus()); {code}  The assertion fails.$$patch1-oak-00b4b8a0_Developer_PatchNaturalnessYe$$added private field nodeBuilder. added constructor. Fix # 7751. use the already established node builder. Fixing a warning. Fix getChildCount ( ). Fix typo. added missing semicolon. added OAK - 621. Fixing a warning. added missing parent node builder property. Fix warning. Fixing a warning. Fixing a warning. Fix removeProperty ( ). "Remove "" nodeBuilder "" check for reparenting children of workflow". Fix # 444. Fix # 1796. Fixed issue with ensureChildOrderProperty. $$1
oak-7c320b1e$$issues with JsopBuilder.encode and .escape$$1) escape() escapes many characters that do not need to be escaped (>127)  2) encode() does not encode many control characters that would need to be escaped when read through a JSON parser.$$patch1-oak-7c320b1e_Developer_PatchNaturalnessYe$$removed erroneous legacy check. Add private escape method. Improved JsopBuilder . forDigit ( ). $$1
oak-25a70439$$Parallel execution of SimpleSearchTest fails with MongoMK$$At some point in the benchmark run one MongoMK instance will fail to read a node created by another instance. The exception is very similar to *E1* reported in OAK-1204.$$patch1-oak-25a70439_Developer_PatchNaturalnessYe$$workflow update - don ' t publish revisions of other cluster nodes. workflow update - remove an obsolete code. $$1
oak-90ad50da$$RDB/MongoDocumentStore may return stale documents$$It appears that the implementations of the {{update}} method sometimes populate the memory cache with documents that do not reflect any current or previous state in the persistence (that is, miss changes made by another node).  (will attach test)$$patch1-oak-90ad50da_Developer_PatchNaturalnessYe$$invalidate nodes cache on chunked IDs. Improved the invalidation of cached documents in RDBDocumentStore. removed unused imports. added missing import. Fixed issue with invalidateCache. update cache with nodes updated after last load. invalidate nodes cache on update ( because we think they ' re still in use ). Fixed error in getModCounts ( ). $$1
oak-9c2421ed$$Unnecessary invocations of LastRevRecovery when recovery already done.$$Even after _lastRev recovery executed on a cluster node, there are unnecessary  invocations of recovery happening on that cluster node, till that cluster node comes online again.$$patch1-oak-9c2421ed_Developer_PatchNaturalnessYe$$remove legacy metadata from MissingLastRevSeeker. $$1
oak-5135cf4b$$VersionablePathHook must not process hidden nodes$$The VersionablePathHook also processes hidden nodes, e.g. index data, which adds considerable overhead to the merge phase.$$patch1-oak-5135cf4b_Developer_PatchNaturalnessYe$$added missing import. Stop childNodeChanged ( ) for hidden nodes. avoid version history creation twice. $$1
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1-oak-5286861d_Developer_PatchNaturalnessYe$$avoid NPE. $$1
oak-ce0b0955$$XPath queries: compatibility for missing @ in front of property names$$XPath queries with conditions of the form {noformat}[id='test']{noformat} are not problematic. Jackrabbit 2.x interpreted such conditions as {noformat}[@id='test']{noformat}, and Oak currently interprets them as {noformat}[@id/* = 'test']{noformat}, as this is the expected behavior for conditions of the form {noformat}[jcr:contains(id, 'test')]{noformat}.  I believe the condition {noformat}[id='test']{noformat} is illegal, and it would be better to throw an exception instead, saying a @ is missing.$$patch1-oak-ce0b0955_Developer_PatchNaturalnessYe$$"Revert "" Invalid @ in front of property name """. removed unnecessary &&. Permit Expression constructors to set thereWasNoAt. fixed error in XPathToSQL2Converter. $$1
oak-7acb091a$$Branch conflicts not detected by MongoMK$$MongoMK does not correctly detect conflicts when changes are committed into multiple branches concurrently and then merged back.  ConflictTest already covers conflict detection for non-branch commits and mixed branch/non-branch changes, but is missing tests for conflicting branches. I'll commit an ignored test to illustrate the problem.$$patch1-oak-7acb091a_Developer_PatchNaturalnessYe$$added missing @ param javadoc. Fix workflow error. formatDocument ( Map < String , Object > ). added missing import. added a few known collisions. Improved javadoc in Controller. Fix a typo in Controller # 12. added conflict message for merge of old commit , see # 772. remove false TODO. Fix default implementation of CollisionHandler. $$1
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1-oak-3ce758b7_Developer_PatchNaturalnessYe$$added PutTokenImpl constructor. $$1
oak-0ac7ff20$$TarMK Cold Standby can corrupt bulk segments$$There's a race condition on the segment transfer code that may introduce corrupted binary segments on the secondary instance. What can happen during the head sync phase is that the master may send the head segment twice which will make the client receive&store the second segment thinking it's a different one.$$patch1-oak-0ac7ff20_Developer_PatchNaturalnessYe$$Fix semantic versioning issue. Improved method to return the segment with the id. $$1
oak-0598498e$$DocumentNodeStore.dispatch() may pass null to NodeStateDiff$$This is a regression introduced by OAK-2562. The dispatch method passes a null state if the node does not exist at a given revision.$$patch1-oak-0598498e_Developer_PatchNaturalnessYe$$added missing closing parenthesis. added missing bracket. added getChildNode ( ). added getChildNode ( ) method that returns a node state that is not null. $$1
oak-a9efe3c4$$Wildcards in relative property paths don't work in search expressions$$A search XPath of the form: {code} /jcr:root/etc/commerce/products//*[@size='M' or */@size='M'] {code} returns: {code} Invalid path: * {code} (This works fine in Jackrabbit.)$$patch1-oak-a9efe3c4_Developer_PatchNaturalnessYe$$Fix modifier order in SourceImpl .. Improve javadoc in SimpleExcerptProvider. "Revert "" update selectorImpl """. added missing import. added currentProperty ( ) method that normalizes the property name. Fix SelectorImpl # currentOakProperty ( String , Integer ). "Revert "" update to latest oak property """. Fixed a bug in SelectorImpl # readOakProperties. added oak - specific javadoc. Fixed bug in query . getOakPath ( relativePath ). "Revert "" update to 2005 """. "Revert "" update to latest property value """. "Revert "" fix an issue with "" selector . currentProperty ( ) "" that would conflict. $$1
oak-ca85ecce$$Released checkpoint can still be retrieved$$The following fails on the 2nd assertion on the MongoMK  {code} assertTrue(store.release(cp)); assertNull(store.retrieve(cp)); {code}  The JavaDoc on the {{release}} method is a bit vague, but I assume it is safe to assume that when it returns {{true}} the checkpoint should be gone. If not, we should update the JavaDoc.$$patch1-oak-ca85ecce_Developer_PatchNaturalnessYe$$Fixed NPE in DocumentNodeStore . retrieve ( ). $$1
oak-ab1a0cc2$$EmptyNodeState.equals() broken$$EmptyNodeState.equals() returns incorrect results when the other node state is not of type EmptyNodeState and the two states have differing exists() flags.$$patch1-oak-ab1a0cc2_Developer_PatchNaturalnessYe$$added exists check. $$1
oak-e30023ba$$Oak Lucene index doesn't get notified about updates when index is stored on the file system$$It looks like the the lucene IndexTracked class responsible for refreshing the in-memory cache of the lucene index doesn't get the update notification when the index is stored on the file system. This results in searches not working until the next restart$$patch1-oak-e30023ba_Developer_PatchNaturalnessYe$$added missing import. added missing import. add OAK - 2029 Record the last updated status. $$1
oak-be44b816$$QueryManager does not have autorefresh$$Having two sessions A and B. A writes something for example /content/page/text = "text" Accessing B's QueryManager and exexcute a query for "text" nothing will be found. Triggering an explicit refresh on B before the query and the hit is found.  I assume that the autorefresh is missed for that case$$patch1-oak-be44b816_Developer_PatchNaturalnessYe$$update imports. don ' t perform query on session context , because it is not supported by our version of j. $$1
oak-c83755c3$$NPE during syncAllExternalUsers in LdapIdentityProvider.createUser$$When executing the JMX method syncAllExternalUsers the following NPE has been encountered. This likely indicates that - for a particular user - there is no attribute '{{uid}}':  {code} java.lang.NullPointerException at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider.createUser(LdapIdentityProvider.java:667) at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider.access 000(LdapIdentityProvider.java:88) at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider 1.getNext(LdapIdentityProvider.java:281) at org.apache.jackrabbit.oak.security.authentication.ldap.impl.LdapIdentityProvider 1.getNext(LdapIdentityProvider.java:273) at org.apache.jackrabbit.commons.iterator.AbstractLazyIterator.hasNext(AbstractLazyIterator.java:39) at org.apache.jackrabbit.oak.spi.security.authentication.external.impl.jmx.SyncMBeanImpl Delegatee.syncAllExternalUsers(SyncMBeanImpl.java:245) at org.apache.jackrabbit.oak.spi.security.authentication.external.impl.jmx.SyncMBeanImpl.syncAllExternalUsers(SyncMBeanImpl.java:426) {code}$$patch1-oak-c83755c3_Developer_PatchNaturalnessYe$$don ' t throw exception if id attribute is not found. Fixed LDAP issue. $$1
oak-016df669$$NodeDocument _modified may go back in time$$In a cluster with multiple DocumentMK instances the _modified field of a NodeDocument may go back in time. This will result in incorrect diff calculations when the DocumentNodeStore uses the _modified field to find changed nodes for a given revision range.$$patch1-oak-016df669_Developer_PatchNaturalnessYe$$Fix update update op. "Remove map entry operation with type = "" REMOVE_MAP_ENTRY "" ; don '. update update op with max ( String , Object ). Fix error in updateOp. "remove unnecessary "" type = "" in UpdateOp constructor". Added update operation for Long value update .. Add constructor to UpdateOp. Fix update op implementation. add UpdateUtils . applyChanges ( ). Added MAX op to UpdateUtils. Fixing # 12508. Fixed MongoDB operation type. added maxUpdates = new BasicDBObject ( ) ;. Fixed case. added max / max updates to update log. $$1
oak-52ca008c$$SplitOperations may not retain most recent committed _commitRoot entry$$In some rare cases it may happen that SplitOperations does not retain the most recent committed _commitRoot entry on a document. This may result in an undetected hierarchy conflict.$$patch1-oak-52ca008c_Developer_PatchNaturalnessYe$$"OAK - 4050 added "" mostRecent = false """. $$1
oak-557eec4f$$o.a.j.o.spi.query.Filter exposes unexported class o.a.j.o.query.ast.SelectorImpl$$The interface {{o.a.j.o.spi.query.Filter}} uses in its public API the class {{o.a.j.o.query.ast.SelectorImpl}}, but while the former is contained in an exported package, the latter is not.$$patch1-oak-557eec4f_Developer_PatchNaturalnessYe$$"Revert "" update to latest plugin """. Remove unnecessary code. Fix an issue with property index search where filter has only empty property restrictions. Remove @ Override from FilterImpl # getSelector. "Revert "" update to latest opengl """. "Revert "" update to property index plan """. "Revert "" update PropertyIndexPlan constructor """. "Revert "" update to 1 . 0 . 1 """. Fixing the build .. $$1
oak-6c54045d$$Access to disconnected MemoryNodeBuilder should throw IllegalStateException$$None$$patch1-oak-6c54045d_Developer_PatchNaturalnessYe$$Improved method to return boolean values for ` exists ` method in MemoryNodeBuilder. "Revert "" updateReadState ( ) "" code for MemoryNodeBuilder """. Fix a warning. $$1
oak-977a31d8$$Error while configuring analyzer by composition$$Error while creating analyzer by composition from osgi due to an illegal argument {{jcr:primaryType}} passed to {{TokenizerFactory.forName(clazz, args)}} in {{NodeStateAnalyzerFactory.loadTokenizer()}}  {noformat} Caused by: java.lang.IllegalArgumentException: Unknown parameters: {jcr:primaryType=nt:unstructured} 	at org.apache.lucene.analysis.core.LowerCaseFilterFactory.<init>(LowerCaseFilterFactory.java:45) {noformat}$$patch1-oak-977a31d8_Developer_PatchNaturalnessYe$$added missing import. added JCR props to ignore list. $$1
oak-f1ba7a42$$:childOrder out of sync when node is made orderable concurrently$$The ChildOrderConflictHandler does not merge the :childOrder when an addExistingProperty conflict occurs.$$patch1-oak-f1ba7a42_Developer_PatchNaturalnessYe$$Fixed child order conflicts. Fixed issue with merging of strings and names in the same order as the other one. $$1
oak-b481a14c$$CacheLIRS concurrency issue$$Some of the methods of the cache can throw a NullPointerException when the cache is used concurrently. Example stack trace:  {code} java.lang.NullPointerException: null org.apache.jackrabbit.oak.cache.CacheLIRS.values(CacheLIRS.java:470)  org.apache.jackrabbit.oak.cache.CacheLIRS 1.values(CacheLIRS.java:1432) org.apache.jackrabbit.oak.plugins.segment.file.FileStore.flush(FileStore.java:205) {code}$$patch1-oak-b481a14c_Developer_PatchNaturalnessYe$$"Revert "" update to latest cache """. "Revert "" update CacheLIRS . mask """. "Revert "" update CacheLIRS to cache """. Fix some compiler warnings. avoid NPE on initial refresh , because there is no loader in CacheLIRS. Fix CacheLIRS .. Fix NPE in CacheLIRS .. "Revert "" update CacheLIRS . find ( key , hash ) """. $$1
oak-9d36bede$$Stale cache after MongoMK GC$$After a MongoMK revision GC the docChildrenCache may be stale and lead to a NPE when reading children with deleted and GC'ed siblings.$$patch1-oak-9d36bede_Developer_PatchNaturalnessYe$$invalidate doc children cache on remove. invalidate doc children cache on write. $$1
oak-94c6c575$$Branch reset does not revert all changes$$This is caused by recent changes done for OAK-3646.$$patch1-oak-94c6c575_Developer_PatchNaturalnessYe$$reset diff after adding node. added missing import. "Revert "" update to latest document node store """. remove trivial copy / paste error. don ' t undo changes if they are not in the same branch. remove ancestor revision debug flag. "Revert "" update to latest document node "" error in DocumentNodeStoreBranch """. $$1
oak-4ed7bc8e$$Inconsistency in Node#setProperty in case of null value$$Setting a null value to a single valued property will result in 'null' being returned while executing the same on a multivalued property will return the removed property.  jr2 returned the removed property in both cases as far as i  remember and i would suggest that we don't change that behavior. in particular since the specification IMO doesn't allow to return null-values for these methods.$$patch1-oak-4ed7bc8e_Developer_PatchNaturalnessYe$$Fix failing tests. $$1
oak-428e32c6$$Query: unexpected result on negative limit / offset$$Currently, running a query with limit of -1 never returns any rows, the same as when using limit = 0.  Either the query engine should fail with a negative limit or offset (IllegalArgumentException), or it should ignore negative values (unlimited result rows for limit, probably no offset for offset = -1).  I would prefer IllegalArgumentException, but I can also live with -1 = unlimited, at least for "limit".$$patch1-oak-428e32c6_Developer_PatchNaturalnessYe$$allow negative limits on query engine. XPathQueryBuilder should set maxCount to Long . MAX_VALUE. update QueryEngine. $$1
oak-5138a1e2$$Test failure: CompactionMapTest.removeSome$$Said test fails sporadically:  {noformat} at org.junit.Assert.assertNull(Assert.java:562) at org.apache.jackrabbit.oak.plugins.segment.CompactionMapTest.removeSome(CompactionMapTest.java:156) {noformat}  This is a regression introduced with OAK-3501: the {{recent}} map gets not cleared when {{segmentIdMap}} is empty. This can happen when a recent key is removed again while there are no other changes.$$patch1-oak-5138a1e2_Developer_PatchNaturalnessYe$$Fixed # 1796. $$1
oak-61381ea2$$SQL-2 query parser doesn't detect some illegal statements$$The SQL-2 query parser doesn't detect some illegal statements, for example  {code} select * from [nt:base] where name =+ 'Hello' select * from [nt:base] where name => 'Hello' {code}  Both are currently interpreted as "name = 'Hello'", which is wrong.$$patch1-oak-61381ea2_Developer_PatchNaturalnessYe$$Fixed error in SQL2Parser. "Revert "" fall through to SQL2Parser . parseKeyword ( ) """. $$1
oak-c13708e3$$[RDB] Updated blob still deleted even if deletion interval lower$$If an existing blob is uploaded again, the timestamp of the existing entry is updated in the meta table. Subsequently if a call to delete (RDBBlobStore#countDeleteChunks) is made with {{maxLastModifiedTime}} parameter of less than the updated time above, the entry in the meta table is not touched but the data table entry is wiped out.   Refer https://github.com/apache/jackrabbit-oak/blob/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java#L510$$patch1-oak-c13708e3_Developer_PatchNaturalnessYe$$"Revert "" update RDBBlobStore with last modified < ? """. added log message for chunk delete. $$1
oak-b0014b7d$$IndexOutOfBoundsException in FileStore.writeStream$$When writing streams of specific length I get  {code} java.lang.IndexOutOfBoundsException at java.nio.Buffer.checkIndex(Buffer.java:538) at java.nio.HeapByteBuffer.getInt(HeapByteBuffer.java:359) at org.apache.jackrabbit.oak.segment.Segment.getGcGen(Segment.java:318) at org.apache.jackrabbit.oak.segment.file.FileStore.writeSegment(FileStore.java:1371) at org.apache.jackrabbit.oak.segment.SegmentWriter SegmentWriteOperation.internalWriteStream(SegmentWriter.java:661) {code}$$patch1-oak-b0014b7d_Developer_PatchNaturalnessYe$$"Revert "" update to latest oak segment """. added missing import. Added getter for getGcGen. added uuid to tar writer. added UUID support for writeSegment. $$1
oak-f4d5bbe1$$Incorrect recovery of _lastRev for branch commit$$The recovery process for _lastRevs is incorrect for branch commits. It propagates the revision of the commit to the branch up to the root node instead of the revision of the merge for the changes.$$patch1-oak-f4d5bbe1_Developer_PatchNaturalnessYe$$always use getCommitRevision ( ) instead of getCc ( ) s. always return the same revision. $$1
oak-c3773d53$$Missing commit hooks in upgrade$$There's a TODO in the RepositoryUpgrade class about missing commit hooks. For example the PermissionHook isn't currently run as a part of the upgrade, which breaks permission evaluation even though the actual ACL nodes are present after the upgrade.$$patch1-oak-c3773d53_Developer_PatchNaturalnessYe$$removed unused import. "Revert "" update to latest oak upgrade plugin """. removed unused import. remove workspaceName. Added missing commit hook. added missing method. Add TODO in RepositoryUpgrade. $$1
oak-dde7de85$$Commit.rollback() may remove changes from other commit$$Commit.rollback() removes documents it previously created. With concurrent commits it may happen that this method removes documents some other commit modified in the meantime.$$patch1-oak-dde7de85_Developer_PatchNaturalnessYe$$NPE - 772 added missing reverse revision property. $$1
oak-0be7e8f0$$Tree has wrong parent after move$$After a move operation Tree.getParent() still returns the old parent.  {code} Tree x = r.getChild("x"); Tree y = r.getChild("y");  root.move("x", "y/x"); assertEquals("y", x.getParent().getName());  // Fails {code}$$patch1-oak-0be7e8f0_Developer_PatchNaturalnessYe$$"Revert "" update to latest oak plugin """. added missing imports. Improved constructor access to TreeImpl . children. Improved TreeImpl . getPath ( ). added getChildCount ( ) to TreeImpl # getChild. added iterator on ChildNodeEntries. added support for child modification. added missing call to getBuilder ( ) . setProperty ( name , values ). Fix oak - core remove property method. added code to move a node to the right builder. Fix copy ( ). Fixed # 771. added getNodeStateBuilder. added path separator .. added missing copy of kernel node state builder. added missing backslash. Fix node state builder implementation. added path separator. Fix moveNode ( ) method where the destName was not the same as the srcName and. added missing backslash. added missing method buildPath. $$1
oak-59a83d23$$Non-root lucene index throws exception if query constraints match root of sub-tree$$LucenePropetyIndexProvider returns incorrect (normalized) path for root of sub-tree if index is defined on the sub-tree. e.g. {{/jcr:root/test//element(*, nt:base)\[@foo='bar']}} would fail with following defn {noformat} + /test     - foo="bar"     + test1           - foo="bar"     + oak:index            - indexRules/nt:base/properties/foo/propertyIndex="true" {noformat}$$patch1-oak-59a83d23_Developer_PatchNaturalnessYe$$Fixed lucene logic. $$1
oak-4d231938$$TreeTypeProvider returns wrong type for version related node type definitions$$the following paths with result in type {{VERSION}} instead of {{DEFAULT}} and might lead to unexpected results wrt read access:  - /jcr:system/jcr:nodeTypes/rep:system/rep:namedChildNodeDefinitions/jcr:versionStorage - /jcr:system/jcr:nodeTypes/rep:system/rep:namedChildNodeDefinitions/jcr:activities - /jcr:system/jcr:nodeTypes/rep:system/rep:namedChildNodeDefinitions/jcr:configurations$$patch1-oak-4d231938_Developer_PatchNaturalnessYe$$"Revert "" update to latest commit """. Improve doc string .. Fixed a bug where TreeTypeProvider . getType ( ) returns a non - default type. $$1
oak-1beb2a50$$Upgrade should not overwrite new oak specific builtin nodetypes$$None$$patch1-oak-1beb2a50_Developer_PatchNaturalnessYe$$added missing import. added missing imports. added missing imports. added TODO to RepositoryUpgrade. added missing init in RepositoryUpgrade. added missing namespaces declaration. added OAK - 1235 note. $$1
oak-ba38c380$$LIRS cache: zero size cache causes IllegalArgumentException$$The LIRS cache does not support a zero size cache currently. Such a configuration causes an IllegalArgumentException.  Instead, no exception should be thrown, and no or a minimum size cache should be used.$$patch1-oak-ba38c380_Developer_PatchNaturalnessYe$$Fix an issue with CacheLIRS . setMaxMemory. $$1
oak-c2f5ca6c$$Slow event listeners do not scale as expected$${{org.apache.jackrabbit.oak.jcr.LargeOperationIT#slowListener}} does not scale to {{O n log n}} on the document node store.$$patch1-oak-c2f5ca6c_Developer_PatchNaturalnessYe$$Fixed a bug in the DocumentNodeState class. removed ' from ' and ' to '. Added children variable to class to prevent read / write after close. removed unnecessary use of PathUtils . getName ( ) in DocumentMK .. "Revert "" update to 2005 0198 """. don ' t share strings with other components / files. added path separator for method name. don ' t remove removed elements in added - > removed map. Fixing the build .. Fixed bug in JSON output. remove property call w . close ( ) ; return null ; }. Fix diff. Fix whitespace. added name to doc - node. added better validation. $$1
oak-69ba2a54$$XPath queries with ISO9075 escaped properties don't work$$XPath queries with ISO9075 escaped properties or relative path don't work as expected. Example:   {code} /jcr:root//*/element(*,rep:User)[_x002e_tokens/@jcr:primaryType] {code}  The relative property should be converted to ".tokens/@jcr:primaryType", but is not.  This issue is similar to OAK-1000, but for property names or relative properties.$$patch1-oak-69ba2a54_Developer_PatchNaturalnessYe$$allow path segmentation. read path segment. Fixed XPathToSQL2Converter . readIf ( ). $$1
oak-239de7b8$$Entries in _commitRoot not purged$$Entries in _commitRoot are not purged or moved to previous documents if there are no changes with those revisions. Usually there is always a change associated with a _commitRoot, but in some cases it may happen that the only update on the document is for non-revisioned data like the _children flag.$$patch1-oak-239de7b8_Developer_PatchNaturalnessYe$$"Revert "" update to 0 . 7 . 21 ( added missing imports ) """. "Revert "" update to 1 . 0 . 4 - updated """. "Revert "" update split operations """. collect local changes before collecting them. add bug to commit operations. "$ "" return value is null """. added revision to changes. "Revert "" update split operations """. avoid double negative decrement of garbage count. Fixed bug with document split operations where property_or_deleted is not used. $$1
oak-999097e1$$Node builder for existing node return null for base state$${{MemoryNodeBuilder.getBaseState()}} returns null on builder for an existing node.$$patch1-oak-999097e1_Developer_PatchNaturalnessYe$$"Revert "" update to latest memory node builder """. "remove "" baseState "" assignment from MemoryNodeBuilder # isModified". added read ( ). $$1
oak-f620b79b$$TokenLoginModule can't handle case insensitive userids$$Login against TokenLoginModule with an userid different in case throws:   javax.security.auth.login.LoginException: Invalid token credentials.$$patch1-oak-f620b79b_Developer_PatchNaturalnessYe$$Oops , forgot a property. "Revert "" update to use "" userId "" and "" id "" in TokenProviderImpl #. Oops , we should probably use userId or id. "Revert "" merge fails on commit """. allow null values for token providers. added user method. $$1
oak-7fe28a0e$$Trying to remove a missing property throws PathNotFoundException$$The following code snippet throws a {{PathNotFoundException}} if the "missing" property is not present.  {code:java} node.setProperty("missing", (String) null); {code}  A better way to handle such a case would be for the above statement to simply do nothing.$$patch1-oak-7fe28a0e_Developer_PatchNaturalnessYe$$added method to remove property. added valueConverter to NodeImpl , targetValue is better handled by other nodes .. $$1
oak-74f22886$$TarMK Cold Standby expose standby read timeout value$$Running into a read timeout on the standby instance logs some uncaught error: {code} org.apache.jackrabbit.oak.plugins.segment.standby.client.SegmentLoaderHandler Exception caught, closing channel. io.netty.handler.timeout.ReadTimeoutException: null {code}  I'm not sure how/if I need to fix this, the sync process will pickup again, but we can expose the timeout value, so if the network connection is known to be poor, a client can increase the timeout to work around this issue.$$patch1-oak-74f22886_Developer_PatchNaturalnessYe$$revert change to StandbyClient constructor. $$1
oak-a8c925e0$$Query constraints marked as invalid in the case of an mvp$$It seems that in the case of a query that has more constraints on the same property, like bq. //*[(@prop = 'aaa' and @prop = 'bbb' and @prop = 'ccc')]  the filter is marked as invalid (_#isAlwaysFalse_) and the query returns no results.  This is incorrect and affects queries that search for multi-valued properties on nodes.  This comes from/affects OAK-1075.$$patch1-oak-a8c925e0_Developer_PatchNaturalnessYe$$added workflow improvements. $$1
oak-2f95b81f$$Repeated MongoMK.rebase() always adds new revision$$MongoMK always adds a new revision to the branch on rebase, even when the branch is already up-to-date.$$patch1-oak-2f95b81f_Developer_PatchNaturalnessYe$$using correct method to compare branch with old one. $$1
oak-b76b31f7$$Background update may create journal entry with incorrect id$$The conflict check does not consider changes that are made visible between the rebase and the background read.$$patch1-oak-b76b31f7_Developer_PatchNaturalnessYe$$Fix method name. "Revert "" update to latest snapshot """. "avoid "" null """. Add missing method. $$1
oak-459bd065$$Node#setProperty(String, Calendar) doesn't take time zone in account$$Node#setProperty(String, Calendar) doesn't take time zone in account.  It looks the Calendar value is straightly stored as a long without take in consideration the time zone,  Unit test to follow$$patch1-oak-459bd065_Developer_PatchNaturalnessYe$$ISO -8601 - 1 . 5 use string literals in property value. $$1
oak-194999ed$$SplitOperations purges _commitRoot entries too eagerly$$OAK-2528 introduced purging of _commitRoot entries without associated local changes on the document. Those _commitRoot entries are created when a child nodes is added and the _children flag is touched on the parent.  The purge operation is too eager and removes all such entries, which may result in an undetected hierarchy conflict.$$patch1-oak-194999ed_Developer_PatchNaturalnessYe$$"Revert "" update split operations """. fix commit bug. $$1
oak-f0fbacab$$Node becomes invalid after Session#move()$$moving or renaming an existing (saved) node renders that node instance invalid and any access on that node instance will throw IllegalStateException.$$patch1-oak-f0fbacab_Developer_PatchNaturalnessYe$$Improved method to check if a node - > stale state. Use internal location for getLocation ( ). Make getItemLocator ( ) return items that do not exist ( because we know the revision ) .. $$1
oak-36e70bd7$$NodeBuilder.reset might lead to inconsistent builder$$The following test fails: {code} NodeBuilder root = new MemoryNodeBuilder(BASE); NodeBuilder x = root.child("x"); NodeBuilder y = x.child("y");  root.reset(BASE); assertTrue(root.hasChildNode("x")); assertFalse(x.hasChildNode("y"));  // fails {code}$$patch1-oak-36e70bd7_Developer_PatchNaturalnessYe$$reset revision to 0. $$1
oak-d2da7499$$Blob GC throws NPE$$Blob GC when registered without a shared data store throws NPE. The {{ClusterRepositoryInfo#getId}} method should check if clusterId is registered or not.$$patch1-oak-d2da7499_Developer_PatchNaturalnessYe$$added missing import. added check for null. $$1
oak-5931a4a7$$Non-blocking reindexing doesn't finish properly$$The non blocking reindexer needs to run at least 2 cycles before setting the index definition back to synchronous mode. Currently it is too eager to mark the status as 'done' which confuses the _PropertyIndexAsyncReindex_ mbean into thinking the indexing is over and so skipping the final round that is supposed to do the switch back to sync mode.$$patch1-oak-5931a4a7_Developer_PatchNaturalnessYe$$"Revert "" update to latest oak 4 . 9 . 0 """. Add missing import. added async reindex god for index managers. Fix case. $$1
oak-9238264d$$XPath failures for typed properties$$It looks like there are some failures in xpath queries that expect a match only on properties of a certain type (which is to be inferred from the query)$$patch1-oak-9238264d_Developer_PatchNaturalnessYe$$"Revert "" update to latest oak plugin """. Fix warning. "Revert "" skip current node """. don ' t skip current node if ( elm != null ). Fix an issue with SelectorImpl . properties ( ) where the target is not an empty collection. $$1
oak-65aa40dd$$Condition check broken in MemoryDocumentStore$$The Operation.CONTAINS_MAP_ENTRY condition check does not work correctly in the MemoryDocumentStore and may return false even when the condition is not met.$$patch1-oak-65aa40dd_Developer_PatchNaturalnessYe$$Fixed bug in MongoDB document store. $$1
accumulo-add180fb$$MockAccumulo doesn't throw informative errors$$Users are unable to tell if an error has occurred and whether it is due to unimplemented features in MockAccumulo.$$patch1-accumulo-add180fb_Developer_PatchNaturalnessYe$$Added throw if table does not exist .. throw exception if table does not exist. throw exception if table does not exist. throw exception if table does not exist. throw exception if table exists. throw NotImplementedException. throw exception on setLocalityGroups ( String , Set < Text > ). throw NotImplementedException. $$1
accumulo-c831e44d$$key.followingKey(PartialKey.ROW_COLFAM_COLQUAL_COLVIS) can produce a key with an invalid COLVIS$$Need a new algorithm for calculating the next biggest column visibility, because tagging \0 to the end creates an invalid column visibility. We might be able to minimize the timestamp for this (i.e. set timestamp to Long.MIN_VALUE, but keep column and row elements the same).$$patch1-accumulo-c831e44d_Developer_PatchNaturalnessYe$$static import of Key . toBytes. Remove unused import in Key class. Remove redundant toPrintableString ( ) method. add private modifier to rowColumnStringBuilder. $$1
accumulo-47c64d9a$$ClientConfiguration.getAllPropertiesWithPrefix doesn't work$$I think I introduced this method for trace.span.receiver.*, and didn't write a test for it.  My mistake.$$patch1-accumulo-47c64d9a_Developer_PatchNaturalnessYe$$Remove the .. $$1
accumulo-e29dc4f5$$The update() method on the ProxyServer should throw a MutationsRejectedException$$None$$patch1-accumulo-e29dc4f5_Developer_PatchNaturalnessYe$$add missing throw. remove deprecated exception in AccumuloProxy . update ( ). remove unused throw in AccumuloProxy . recv_update. disable async call by default. Delete some unused exceptions. gh - 661 - update_result now returns null. Fixed # 1796. Fix visibility for BatchWriterPlusException. add exception cache to default constructor. throw exception if it is not null. addCellsToWriter ( Map , BatchWriterPlusException bwpe ). Fix bwpe. Add batch writer exception check. Fix possible NPE in ProxyServer . flush ( ). throw bwpe . exception if writer cache is gone. add exception. $$1
accumulo-0cf2ff72$$Remove username from initialization$$This is an artifact from a brief transition area during the 1.5 development. We have a flag for the user to set what the root username is, except it's never used. We should remove both the variable and the flag for it.$$patch1-accumulo-0cf2ff72_Developer_PatchNaturalnessYe$$gh - 320 - Removed use of deprecated attribute in Initialize. $$1
accumulo-ff8c2383$$MockTableOperations.deleteRow does not handle null for start or end keys$$The deleteRow function does not check for null values for start or end keys. These null values are passed down into key constructor which will throw a NullPointerException: java.lang.NullPointerException 	at org.apache.accumulo.core.data.Key.<init>(Key.java:103) 	at org.apache.accumulo.core.client.mock.MockTableOperations.deleteRows(MockTableOperations.java:315)  The API semantics dictate: if (start == null ) then start == Text() if (end == null ) then end == maxKey()$$patch1-accumulo-ff8c2383_Developer_PatchNaturalnessYe$$Fix NPE in MockTableOperations. $$1
accumulo-ddd2c3bc$$InputTableConfig missing isOfflineScan field in Serializer$$InputTableConfig write(DataOutput dataOutput) forgets to write out the isOfflineScan field, which makes it always false when it gets unserialized.$$patch1-accumulo-ddd2c3bc_Developer_PatchNaturalnessYe$$add offlineScan flag to InputTableConfig. add offline scan flag to InputTableConfig. $$1
accumulo-cfbf5999$$ProxyServer does not set column information on BatchScanner$$The createScanner method uses the options from the thrift request to call fetchColumn() and fetchColumnFamily(). The createBatchScanner should be doing have the same feature, though the statements are absent from the code.$$patch1-accumulo-cfbf5999_Developer_PatchNaturalnessYe$$gh - 66 added missing fetchColumnFamily call. $$1
accumulo-f99b5654$$Missing toString, hashCode and equals methods on BatchWriterConfig$$Tried to test equality of two BatchWriterConfig objects, found they're missing all of the methods from Object that they should be implementing.$$patch1-accumulo-f99b5654_Developer_PatchNaturalnessYe$$imports. add default values. add javadoc. Added missing check for null max latency .. Added comment to BatchWriterConfig. add 122 if timeout is 0. gh - 66 fixed javadoc for BatchWriterConfig. add batch writer config. Fix UTF - 8 encoding of batch writer config. add private method to BatchWriterConfig. gh - 454 - update comment. Fixed bug in BatchWriterConfig . equals. $$1
accumulo-692efde2$$VisibilityFilter does not catch BadArgumentException$$If an invalid column visibility makes it into the system, then the VisibilityFilter may not handle it properly.   The accept method handles VisibilityParseException, but some of the parse code throws a BadArgumentException which is not handled.$$patch1-accumulo-692efde2_Developer_PatchNaturalnessYe$$Add missing import. Add missing argument exception catch block. $$1
accumulo-65390f8c$$Mock does not implement locality groups or merging$$The Mock Instance does not implement locality groups and throws an exception if one attempts to set them. It would be useful for the unit tests that I am writing for the Accumulo proxy to have at least minimal locality group functionality in the Mock instance, for example simply storing the groups and returning the stored groups when asked for.  *Edit: Tablet merging would be useful as well.$$patch1-accumulo-65390f8c_Developer_PatchNaturalnessYe$$add missing import. throw new NotImplementedException ( ). online ( ) throws AccumuloException , NoSuchTableException. add missing throw. throw exception if tableName does not exist. add missing imports. added localityGroups to MockTable. add method to set localityGroups ( ). $$1
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1-accumulo-15476a0d_Developer_PatchNaturalnessYe$$Fix MockTable logic. $$1
accumulo-ebf22df0$$Make sure iterators handle deletion entries properly$$In minor compaction scope and in non-full major compaction scopes the iterator may see deletion entries. These entries should be preserved by all iterators except ones that are strictly scan-time iterators that will never be configured for the minc or majc scopes. Deletion entries are only removed during full major compactions.$$patch1-accumulo-ebf22df0_Developer_PatchNaturalnessYe$$add comment about SortedKeyValueIterator ' s next move. Fix typo in SortedKeyValueIterator javadocs. don ' t delete keys that are no longer used .. $$1
accumulo-cd7feb4d$$RegExFilter deepCopy NullPointerException$$If any of the regex matcher objects are null (i.e. for example, if you only specify a regex for the column family), the deepCopy call will throw a NullPointerException.$$patch1-accumulo-cd7feb4d_Developer_PatchNaturalnessYe$$gh - 661 - RegExFilter doesn ' t copy the matchers in the source iterator. fixed regexp pattern matching. $$1
accumulo-f848178e$$RangeInputSplit doesn't serialize table name$$Found another missed member in the serialization of RangeInputSplit: the table name.  Not a huge deal because the table information should still be in the Configuration for most users, but this does break in "advanced" uses of mapreduce. Work around is to re-set the table in the RangeInputSplit in your overridden InputFormat.getRecordReader or make sure the Configuration is consistent from getRecordReader and getSplits.$$patch1-accumulo-f848178e_Developer_PatchNaturalnessYe$$table = in . readUTF ( ) ; } @ Override public void readFields ( ) throws IOException. Table should write directly to the output stream. $$1
accumulo-6c565dfb$$Shell's setiter is not informative when using a bad class name$$In the shell, I did setiter using a class that wasn't found. Rather then a message about it not being found, I just get told that I have an invalid argument. Even turning on debug, I had to use the stack trace to figure out why it was erroring.$$patch1-accumulo-6c565dfb_Developer_PatchNaturalnessYe$$Fix whitespace. $$1
accumulo-5ca779a0$$hashCode for Mutation has an unfortunate implementation$$While looking at how a tablet server processes constraint violations, I happened to look into Mutation's hashCode implementation:  {code}   @Override   public int hashCode() {     return toThrift(false).hashCode();   } {code}  Clicking through to TMutation hashCode finds this gem:  {code}   @Override   public int hashCode() {     return 0;   } {code}$$patch1-accumulo-5ca779a0_Developer_PatchNaturalnessYe$$Fix hash code for mutations. $$1
accumulo-2f0643a9$$Off-by-one error in FamilyIntersectingIterator$$In the buildDocKey() function within the FamilyIntersectingIterator there is a bug that shortens the docID by 1.  This causes the wrong doc's data to be returned in the results of a query using this Iterator.$$patch1-accumulo-2f0643a9_Developer_PatchNaturalnessYe$$Fix log in FamilyIntersectingIterator. $$1
accumulo-5594b2e0$$importdirectory failing on split table$$bulk import for the wikisearch example isn't working properly: files are not being assigned to partitions if there are splits.$$patch1-accumulo-5594b2e0_Developer_PatchNaturalnessYe$$gh - 454 - remove debug line. gh - 454 - remove unused import. add missing imports. gh - 45 - added missing import. gh - 375 - added missing final check. gh - 663 - Added debug level for bulk imports. remove too much newline. gh - 66 bumped up imports. Added debug statement. Improved method to send data to ACU for later processing .. remove maxnum and add proper enum value. remove unused import. $$1
accumulo-28294266$$TraceProxy.trace should not throw InvocationTargetException$$In {{TraceProxy.trace}} there is the following code snippet: {code}         try {           return method.invoke(instance, args);         } catch (Throwable ex) {           ex.printStackTrace();           throw ex;         } {code} When this is an InvocationTargetException, it can really mess with the calling code's exception handling logic.$$patch1-accumulo-28294266_Developer_PatchNaturalnessYe$$add RuntimeException check. $$1
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1-accumulo-b007b22e_Developer_PatchNaturalnessYe$$Fixed typo in Combiner javadocs. $$1
accumulo-13eb19c2$$AccumuloInputFormat cannot fetch empty column family$$The following fails: {code:java} Job job = new Job(); HashSet<Pair<Text,Text>> cols = new HashSet<Pair<Text,Text>>(); cols.add(new Pair<Text,Text>(new Text(""), null)); AccumuloInputFormat.fetchColumns(job, cols); Set<Pair<Text,Text>> setCols = AccumuloInputFormat.getFetchedColumns(job); assertEquals(cols.size(), setCols.size()); {code}$$patch1-accumulo-13eb19c2_Developer_PatchNaturalnessYe$$Fix bug in Controller . getFetchedColumns. $$1
accumulo-116d5928$$Make sure iterators handle deletion entries properly$$In minor compaction scope and in non-full major compaction scopes the iterator may see deletion entries. These entries should be preserved by all iterators except ones that are strictly scan-time iterators that will never be configured for the minc or majc scopes. Deletion entries are only removed during full major compactions.$$patch1-accumulo-116d5928_Developer_PatchNaturalnessYe$$gh - 66 fixed a small bug in GrepIterator. deep copy GrepIterator , to keep compatibility with GrepIterator interface. $$1
accumulo-c489d866$$"du" on a table without files does not report$${noformat} shell> createtable t shell> du t shell> {noformat}  expected:  {noformat} shell> du t              0 t shell> {noformat}$$patch1-accumulo-c489d866_Developer_PatchNaturalnessYe$$Ignore empty tables in metadata. Do not include empty tables in usage map. $$1
accumulo-25cf3ccd$$Authorizations has inconsistent serialization$$The same set of authorizations may not serialize to the same value each time, if specified in a different order when constructed (like new Authorizations("a", "b") and new Authorizations("b", "a")), because serialization reproducibility depends on the insert order in the underlying HashSet.  So, one could get the following to happen: {code:java} true == auths1.equals(auths2) && !auths1.serialize().equals(auths2.serialize()); {code}$$patch1-accumulo-25cf3ccd_Developer_PatchNaturalnessYe$$Remove unused imports. Fixed a bug in Authorizations. gh - 414 - update workflow workflow. make Authorizations constructor public. gh - 454 - update Authorizations. Fixed trivial equals implementation. gh - 454 - update code. $$1
accumulo-81d25bc2$$display the exact number of tablet servers$$This is a regression of ACCUMULO-1140$$patch1-accumulo-81d25bc2_Developer_PatchNaturalnessYe$$Fixed small print .. Allow override of NumberType constructor. $$1
accumulo-dc95cb69$$FileOperations expects RFile filenames to contain only 1 dot.$$If I attempt to create or read an RFile that contains more than 1 dot in the filename, FileOperations throws an IllegalArgumentException("File name " + name + " has no extension"). Please allow creation/import of RFiles that have more than 1 dot in the filename.$$patch1-accumulo-dc95cb69_Developer_PatchNaturalnessYe$$Fix an error in FileOperations . get ( name ) that could cause mangling directory. $$1
accumulo-cfb832a1$$ProxyServer ignores value of isDeleted on ColumnUpdate$$The ProxyServer ignores the actual boolean value of the isDeleted flag on a ColumnUpdate.  If the isDeleted value is set, regardless of the actual boolean value, the ProxyServer marks the update as a delete.  The ProxyServer should be updated to check the value of the flag.$$patch1-accumulo-cfb832a1_Developer_PatchNaturalnessYe$$gh - 661 don ' t delete timestamps on put ( ). $$1
accumulo-699b8bf0$$ShutdownTServer never sets requestedShutdown$$ACCUMULO-1259 made ShutdownTServer a bit more sane WRT to what it was doing and the FATE repo interface.  One attempt it makes it to not repeatedly invoke shutdownTServer on the master..  Except {{requestedShutdown}} is never set to {{true}}.$$patch1-accumulo-699b8bf0_Developer_PatchNaturalnessYe$$add requestedShutdown flag to shutdown TServer at the end of table. $$1
accumulo-813109d7$$Verify all methods in the ProxyService that take table names actually throw TableNotFoundException when the table is missing.$$None$$patch1-accumulo-813109d7_Developer_PatchNaturalnessYe$$add all the exceptions. add missing throw in addConstraint. add missing exception signature to method. add ouch3 throw in AccumuloProxy . java. Added missing throw in AccumuloProxy . removeTableProperty ( ). Added missing exception signature to method recv_removeTableProperty ( ). add ouch3 throw in AccumuloProxy . java. add missing throw in AccumuloProxy # setTableProperty ( ). Added missing exception signature to AccumuloProxy . recv_setTableProperty ( ). add ouch3 throw in AccumuloProxy . java. add exception type to AccumuloProxy . getResult ( ). add exception type to AccumuloProxy . getResult ( ). add exception type to AccumuloProxy . getResult ( ). catch TableNotFoundException on AccumuloProxy. catch TableNotFoundException on AccumuloProxy. catch TableNotFoundException on AccumuloProxy. add OUCH3_FIELD_DESC. add TableNotFoundException to by name. add case for OUCH3. add OUCH3 to tmpMap. add TableNotFoundException in removeConstraint_result. gh - 454 - added missing ouch3 in addConstraintResult .. add ouch3 to AccumuloProxy . clear ( ). Fixed # 1862. gh - 40179 Fix typo in AccumuloProxy enum. add OUCH3 in AccumuloProxy. Add OUCH3 to thrift test. Fixed check for OC - 7785. Fix typo in compareTo method. "Add ouch3 to "" toString ( ) "" line". gh - 454 - ignore AccumuloProxy ouch3 in thrift. add OUCH3_FIELD_DESC if it is not null. gh - 454 - update thrift to use bit set and not set by default. add missing ouch3 exception in incoming response. add OUCH3_FIELD_DESC constant to AccumuloProxy. add TableNotFoundException to by name. add case OUCH3. add OUCH3 to tmpMap. add ouch3 to AccumuloProxy so it can rethrow as well. Add missing OOME. add ouch3 to AccumuloProxy . clear ( ). Fixed validateOuch3 return type .. Fixed typo in AccumuloProxy .. add OUCH3 in AccumuloProxy. Add support for OUCH3 in thrift. workflow improvements. Fix typo in compareTo method. "Add ouch3 to "" toString ( ) "" line". gh - 454 - ignore AccumuloProxy ouch3 in thrift. add OUCH3_FIELD_DESC if it is not null. gh - 661 - update AccumuloProxy to use bit set and not set by default. add missing ouch3 exception in incoming response. add OUCH3_FIELD_DESC constant to AccumuloProxy. add TableNotFoundException to by name. add case OUCH3. add OUCH3 to tmpMap. add ouch3 to AccumuloProxy so it can rethrow as well. gh - 45921 - Restore original exception if it was set on thrift. add ouch3 to AccumuloProxy . clear ( ). Fixed ouch3 = null ; if it is not set then set the default value to null. Fixed typo in AccumuloProxy .. add OUCH3 in AccumuloProxy. Add OUCH3 to thrift test. gh - 454 - check for same ouch3 value from thrift jar. Fix typo in compareTo method. "Add ouch3 to "" toString ( ) "" line". gh - 454 - Ignore AccumuloProxy ouch3 message in case of error. add OUCH3_FIELD_DESC if it is not null. gh - 454 - update AccumuloProxy to not ignore ouch3. add missing ouch3 exception in incoming response. add missing import. gh - 233 - restore original behaviour. add scanner cache configuration for AccumuloProxy. Added TableNotFoundException check. gh - 661 remove hardcoded method. add missing if / else. Added missing UUID in ProxyServer. gh - 66 fixed gh - 66. $$1
accumulo-0dc92ca1$$Stat calculation of STDEV may be inaccurate$$The math is sound, but it is susceptible to rounding errors. We should address that.  See http://www.strchr.com/standard_deviation_in_one_pass and http://www.cs.berkeley.edu/~mhoemmen/cs194/Tutorials/variance.pdf$$patch1-accumulo-0dc92ca1_Developer_PatchNaturalnessYe$$Add StorelessUnivariateStatistic to Stat class. $$1
accumulo-9396979b$$bulk imported files showing up in metadata after bulk import fails$$Bulk import fails.  The file is moved to the failures directory.  But references in the !METADATA table remain.$$patch1-accumulo-9396979b_Developer_PatchNaturalnessYe$$add import. Improved MetadataConstraints . addIfNotPresent .. gh - 16 - fixed metadata table schema validation error. Fixed bug in MetadataConstraints. Add time constraint for bulk write operations. gh - 16 - fixed issue with metadata constraint check. gh - 231 - add missing violations for schema file. gh - 66 log file for metadata constraint violations. add comment for empty value check. $$1
accumulo-7651b777$$Shell.config()'s return value is ignored.$${{Shell.config()}} returns a boolean which is true if there was an error configuring the shell, but the value is never observed. This can result in other unintended errors (like trying to use the ConsoleReader member when it's not initialized).$$patch1-accumulo-7651b777_Developer_PatchNaturalnessYe$$add configError back. Added missing javadoc. ignore help on startup , because it ' s already been checked in .. set exitCode to 1. ignore exception in shell. add return. config doesn ' t print error code if config fails. ignore config setting the shell failed , just return false for now. ignore configError in MockShell. remove configError check. $$1
accumulo-d9ab8449$$Don't cache credentials in client-side Connector$$AuthenticationToken objects are Destroyable. However, this cannot be exercised properly in the client code, because the Connector immediately serializes the credentials and stores them as long as the Connector lives.  It should be possible to destroy a token after creating a Connector, and thereby forcing any further RPC calls initiated by that Connector to fail to authenticate. This means that serialization on the client side to a TCredentials object needs to occur just before the RPC call.$$patch1-accumulo-d9ab8449_Developer_PatchNaturalnessYe$$add missing import. add missing import. throw exception if token is destroyed. add missing import. gh - 16 - fixed gh - 16. add missing import. gh - 59 - Adding a throw in credentials . toThrift ( ). Fixed constructor. throw exception if token is destroyed. $$1
accumulo-15e83709$$Consolidate ZK code WRT retries$$A couple of general ZK things that should be fixed up:  # Multiple means of automatic retrying of recoverable ZooKeeper errors through use of an InvocationHandler and a Proxy around IZooReader(Writer) # Encapsulate retry logic # Switch over callers to use the retrying instance instead of the non-retrying instance$$patch1-accumulo-15e83709_Developer_PatchNaturalnessYe$$Add missing import. add missing import. Fixed a bug in ZooUtil . equals. Adding missing throws. Fixed typo in ZooUtil putData ( ) where the node exists policy was not respected by. Include all the recursive copyPersistent ( ) calls into the destination directory ; see ZooUtil . java. Fixed typo in ZooCache log. $$1
accumulo-9fcca2ed$$MockTableOperations.tableIdMap always returns tableName as ID$$Noticed and fixed this during ACCUMULO-378.  An exception was thrown unexpectedly when trying to use tableIdMap with a MockInstance. Lift fix from 93c8bddc71d1ee190649eeab263205185d75421c into main tree.$$patch1-accumulo-9fcca2ed_Developer_PatchNaturalnessYe$$add missing import. added tableIdCounter to MockAccumulo .. added missing column to mock table. Fix tableIdMap. gh - 454 - added missing constructor .. add getTableId to MockTable. $$1
accumulo-a3267d3e$$DateLexicoder fails to correctly order dates prior to 1970$$DateLexicoder incorrectly orders dates before 1970 at the end of all other dates.  Therefore, the order was correct for all dates if the user only wrote dates before 1970, or only dates after 1970, but not if they did both.  The DateLexicoder should be fixed to store using a signed LongLexicoder internally, instead of the ULongLexicoder that it used before.$$patch1-accumulo-a3267d3e_Developer_PatchNaturalnessYe$$gh - 66 fixed java sytax error. $$1
accumulo-31aea2ad$$WAL handling fails to deal with 1.4 -> 1.5 -> 1.6$$After doing a 1.4 -> 1.5 -> 1.6 upgrade that still has WALs for some tables, the 1.6 instance fails to correctly handle the 1.4 recovered WALs.  This can happen either through not waiting long enough after the upgrade to 1.5 or because of an offline table brought online on 1.6 (ala ACCUMULO-2816).$$patch1-accumulo-31aea2ad_Developer_PatchNaturalnessYe$$Fix typo in GarbageCollectWriteAheadLogs. Add newline for server names that are not in the list of servers to remove from the server. add ( ) for uuid - > server mapping. fix error in 1 . 4 WAL recovery script. Fixed WAL files to make it an absolute path for 1 . 4. add count values for walog recovery. log statistics. gh - 1406 Add column qualifiers to logEntries. gh - 661 Tablet does not have meta value. Add doomed logging. Add back missing constructor .. add filename and metaReference to DfsLogger. add getter for meta reference. $$1
accumulo-72fd6bec$$MiniAccumuloConfig doesn't set 0 for monitor log4j port$$MonitorLoggingIT will fail on a host if the monitor is already running because MAC doesn't configure itself to use an ephemeral port. We haven't really noticed this because MAC doesn't start a monitor by default.$$patch1-accumulo-72fd6bec_Developer_PatchNaturalnessYe$$add missing property. $$1
accumulo-be2fdba7$$importdirectory failing on split table$$bulk import for the wikisearch example isn't working properly: files are not being assigned to partitions if there are splits.$$patch1-accumulo-be2fdba7_Developer_PatchNaturalnessYe$$gh - 454 - remove debug line. remove maxnum and add proper enum value. gh - 454 - remove unused import. remove unused import. add comment about SortedKeyValueIterator ' s next move. Fix typo in SortedKeyValueIterator javadocs. add missing imports. gh - 45 - added missing import. gh - 375 - added missing final check. gh - 663 - Added debug level for bulk imports. remove too much newline. don ' t delete keys that are no longer used .. gh - 66 bumped up imports. Added debug statement. Improved method to send data to ACU for later processing .. $$1
accumulo-9453bcfa$$MockTable doesn't obey useVersions parameter$$The constructor for {{MockTable}} will call {{IteratorUtil.generateInitialTableProperties()}}, and thus set a versioning iterator on itself regardless of whether the useVersion parameter is set to true or false.   I believe {{MockTable}}'s constructor should call IteratorUtil.generateInitialTableProperties() only if useVersions is true, otherwise, it should populate {{settings}} with a new {{TreeMap}}$$patch1-accumulo-9453bcfa_Developer_PatchNaturalnessYe$$gh - 66 fixed MockTable constructor. gh - 66 - added static method to generateInitialTableProperties ( ). add default iterators. remove the unnecessary empty map. $$1
accumulo-d6472040$$Don't allow viewfs in instance.volumes$$I think one of our folks put viewfs into instance.volumes on accident. File references in accumulo.root and accumulo.metadata were then written with viewfs in the path. The garbage collector then throws errors as compactions occur and it tries delete and move the files to the hdfs users trash directory.  viewfs should never be allowed in instance.volumes property. It should fail.$$patch1-accumulo-d6472040_Developer_PatchNaturalnessYe$$Accidentally log a warning about failing resolve of view fs. Fix check for viewfs volume uri , fail if it doesn ' t look like a URI. Remove try catch block for view fs. $$1
accumulo-11d11e0d$$DefaultLoadBalancer takes a long time when tablets are highly unbalanced$$After creating a thousand splits on a large cluster, I noticed the master was only moving tablets to one server at a time.$$patch1-accumulo-11d11e0d_Developer_PatchNaturalnessYe$$Make ServerCounts package local. Fixed a bug in DefaultLoadBalancer. gh - 454 - Updated default loadBalancer with tooMuch and tooLittle. $$1
accumulo-46f62443$$MockAccumulo doesn't throw informative errors$$Users are unable to tell if an error has occurred and whether it is due to unimplemented features in MockAccumulo.$$patch1-accumulo-46f62443_Developer_PatchNaturalnessYe$$throw exception if table exists. throw NotImplementedException. throw NotImplementedException for getLocalityGroups ( ). throw NotImplementedException. Added throw if table does not exist .. throw exception if table does not exist. throw exception if table does not exist. throw exception if table does not exist. $$1
accumulo-a2c2d38a$$ConditionalWriterIT is failing$$I noticed that the ConditionalWriterIT was failing in master.   Using the following command with {{git bisect}} I tracked it down to commit {{3af75fc}} for ACCUMULO-4077 as the change which broke the IT.  Have not looked into why its failing yet.  {noformat} mvn clean verify -Dit.test=ConditionalWriterIT -Dfindbugs.skip -Dcheckstyle.skip -Dtest=foo -DfailIfNoTests=false {noformat}$$patch1-accumulo-a2c2d38a_Developer_PatchNaturalnessYe$$Fixed a bug in UnsynchronizedBuffer where the array was not synchronized .. $$1
accumulo-a450ac2f$$MockBatchScanner inappropriately filters on ranges$$I believe I have a legitimate case where an iterator will return something outside of the seeked-to range.  This appears to work in a live system, but fails to work in test cases using the MockBatchScanner.  I believe this is because the MockBatchScanner filters on the supplied ranges in addition to seeking the iterators to each range.  Either we need to remove this range filter, or fix the real system to do the same thing.  I prefer the former of course.$$patch1-accumulo-a450ac2f_Developer_PatchNaturalnessYe$$add missing import. add deepCopy to RangesFilter constructor. Fix typo in MockBatchScanner. add missing import. $$1
flink-d033fa8f$$Allow KeySelectors to implement ResultTypeQueryable$$See https://github.com/apache/flink/pull/354$$patch1-flink-d033fa8f_Developer_PatchNaturalnessYe$$Fix TypeExtractor . validateInputType ( ). $$1
flink-32a003d5$$NullPointerException while translating union node$$The NepheleJobGraphGenerator throws a NullPointerException when translating a binary union operator. The BinaryUnionPlanNode is not replaced by a NAryUnionPlanNode and thus is still treated as a DualInputVertex. Accessing the driver code of the BinaryUnionPlanNode causes then the NullPointerException.$$patch1-flink-32a003d5_Developer_PatchNaturalnessYe$$Added missing @ Override annotation. Fix a bug in the union compiler. $$1
flink-02c08456$$Type extractor cannot determine type of function$$This function fails in the type extractor.  {code} public static final class DuplicateValue<T> implements MapFunction<Tuple1<T>, Tuple2<T, T>> { 		 	@Override 	public Tuple2<T, T> map(Tuple1<T> vertex) { 		return new Tuple2<T, T>(vertex.f0, vertex.f0); 	} } {code}$$patch1-flink-02c08456_Developer_PatchNaturalnessYe$$Fix TypeExtractor. $$1
flink-117ba95f$$Checkpoint stats show ghost numbers$$[~StephanEwen] reported an issue with the display of checkpoint stats. A pipeline with a stateful source and stateless intermediate operator shows stats for the stateless intermediate operator. The numbers are most likely the same as for the source operator.$$patch1-flink-117ba95f_Developer_PatchNaturalnessYe$$Fix new operator stats for SimpleCheckpointStatsTracker. $$1
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1-flink-45fb6d82_Developer_PatchNaturalnessYe$$Fix warning. Partitioned coGroupDescriptor from com . gdx . tools . rmb938 to com. add missing import. add custom partitioner to join descriptor. $$1
flink-e3759a5e$$CEP operator does not forward watermarks properly$$The CEP stream operator don't emit a proper watermark when using event time.$$patch1-flink-e3759a5e_Developer_PatchNaturalnessYe$$Fix keyed CEP pattern operator emitWatermark. emit watermark on stream events. $$1
flink-8b40bb7a$$ArrayKeySelector returns wrong positions (or fails)$$The {{ArrayKeySelector}} is broken and returns wrong values in all cases except for [0] as a single only key position.$$patch1-flink-8b40bb7a_Developer_PatchNaturalnessYe$$KeyedDataStream made KeySelector protected. Remove redundant code. Remove unused variable. Remove unused imports. Fix copy / paste error. Make ArrayKeySelector final. Fix copy / paste error in KeySelectorUtil. $$1
flink-0a4c7694$$Events at unitialized input channels are lost$$If a program sends an event backwards to the producer task, it might happen that some of it input channels have not been initialized yet (UnknownInputChannel). In that case, the events are lost and will never be received at the producer.$$patch1-flink-0a4c7694_Developer_PatchNaturalnessYe$$Missing import. Add uninitialized fields to BufferReader , to allow for cleaner dom implementation of deferred loading .. Fix BufferReader . hasInputChannelWithData ( ). check for unknown input channel. Don ' t send uninitialized tasks in BufferReader , closes # 1796. Don ' t send uninitialized events in BufferReader .. $$1
flink-380ef878$$IndexOutOfBoundsException when receiving empty buffer at remote channel$$Receiving buffers from remote input channels with size 0 results in an {{IndexOutOfBoundsException}}.  {code} Caused by: java.lang.IndexOutOfBoundsException: index: 30 (expected: range(0, 30)) 	at io.netty.buffer.AbstractByteBuf.checkIndex(AbstractByteBuf.java:1123) 	at io.netty.buffer.PooledUnsafeDirectByteBuf.getBytes(PooledUnsafeDirectByteBuf.java:156) 	at io.netty.buffer.PooledUnsafeDirectByteBuf.getBytes(PooledUnsafeDirectByteBuf.java:151) 	at io.netty.buffer.SlicedByteBuf.getBytes(SlicedByteBuf.java:179) 	at io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:717) 	at org.apache.flink.runtime.io.network.netty.PartitionRequestClientHandler.decodeBufferOrEvent(PartitionRequestClientHandler.java:205) 	at org.apache.flink.runtime.io.network.netty.PartitionRequestClientHandler.decodeMsg(PartitionRequestClientHandler.java:164) 	at org.apache.flink.runtime.io.network.netty.PartitionRequestClientHandler.channelRead(PartitionRequestClientHandler.java:118) {code}$$patch1-flink-380ef878_Developer_PatchNaturalnessYe$$Fix possible NPE if PartitionRequestClientHandler context is null. PartitionRequestClientHandler should honor empty buffers for read ( ). Fix checkstyle. $$1
flink-495a5c3c$$Streaming does not correctly forward ExecutionConfig to runtime$$When running streaming jobs you see this log entry: "Environment did not contain an ExecutionConfig - using a default config."  Some parts of the code use an ExecutionConfig at runtime. This will be a default config without registered serializers and other user settings.$$patch1-flink-495a5c3c_Developer_PatchNaturalnessYe$$Add missing import. Add missing import. Add missing import. Fix StreamingJobGraphGenerator # exportJobGraph to throw exception. $$1
flink-3e233a38$$Set state checkpointer before default state for PartitionedStreamOperatorState$$Currently the default state is set before the passed StateCheckpointer instance for operator states.  What currently happens because of this is that the default value is serialized with Java serialization and then deserialized on the opstate.value() call using the StateCheckpointer most likely causing a failure.  This can be trivially fixed by swaping the order of the 2 calls.$$patch1-flink-3e233a38_Developer_PatchNaturalnessYe$$Add back missing checkpointer setting. $$1
flink-27e40205$$Type extractor cannot determine type of function$$This function fails in the type extractor.  {code} public static final class DuplicateValue<T> implements MapFunction<Tuple1<T>, Tuple2<T, T>> { 		 	@Override 	public Tuple2<T, T> map(Tuple1<T> vertex) { 		return new Tuple2<T, T>(vertex.f0, vertex.f0); 	} } {code}$$patch1-flink-27e40205_Developer_PatchNaturalnessYe$$Fix TypeExtractor. Fix TypeExtractor. Fix generics warning. Fix TypeExtractor . createTypeInfoFromInputs ( ). Fix TypeExtractor from javadoc. $$1
flink-8f321c72$$FileOutputFormat writes to wrong path if path ends with '/'$$The FileOutputFormat duplicates the last directory of a path, if the path ends  with a slash '/'. For example, if the output path is specified as {{/home/myuser/outputPath/}} the output is written to {{/home/myuser/outputPath/outputPath/}}.  This bug was introduced by commit 8fc04e4da8a36866e10564205c3f900894f4f6e0$$patch1-flink-8f321c72_Developer_PatchNaturalnessYe$$Add comment about Path class .. Fix checkstyle. Fix checkAndTrimPathArg ( ). Trim path string arguments before constructor .. Don ' t validate path arguments when constructor is called .. Don ' t remove trailing separators in Path . normalizePath ( ). Remove backslash which prevents path separators from being read by Flink. $$1
flink-5308ac83$$InstanceConnectionInfo returns wrong hostname when no DNS entry exists$$If there is no DNS entry for an address (like 10.4.122.43), then the {{InstanceConnectionInfo}} returns the first octet ({{10}}) as the hostame.$$patch1-flink-5308ac83_Developer_PatchNaturalnessYe$$Don ' t include host name in instanceConnectionInfo. Fixed misc problems with variable name field. Log warning about no hostname in instance connection info. Remove dead code. Fixed readability of instanceconnectioninfo. Remove unused boolean write. $$1
flink-6bc6dbec$$Sliding Window Keeps Emitting Elements After Source Stops Producing$$This happens when the source produces some elements, then the source stops for a while and then produces again some elements before stopping again. After this, the window will just keep emitting the last emitted element indefinitely.$$patch1-flink-6bc6dbec_Developer_PatchNaturalnessYe$$reset elementsSinceLastPreAggregate = 0 ;. reset elementsSinceLastPreAggregate after reduce. $$1
flink-8e3e2f8f$$Operator checkpoint statistics state size overflow$$State sizes ({{long}}) of checkpoint stats overflow when summing them up per operator, because the sum is stored in an {{int}}.$$patch1-flink-8e3e2f8f_Developer_PatchNaturalnessYe$$Fix the build. $$1
flink-d738430c$$BarrierBuffer does not properly clean up temp files$$None$$patch1-flink-d738430c_Developer_PatchNaturalnessYe$$Fix checkstyle. Fix BarrierBuffer cleanup. $$1
flink-68912126$$FixedLengthRecordSorter can not write to output cross MemorySegments.$$FixedLengthRecordSorter can not write to output cross MemorySegments, it works well as it's only called to write a single record before. Should fix it and add more unit test.$$patch1-flink-68912126_Developer_PatchNaturalnessYe$$Reset offset to 0 when we are done with the sorter. $$1
flink-948b6e05$$CsvParser: Quotes cannot be escaped inside quoted fields$$We should allow users to escape the quote character inside a quoted field.  Quoting could be realized through the \ character like in: {{"This is an \"escaped\" quotation."}}  Mailing list thread: http://apache-flink-mailing-list-archive.1008284.n3.nabble.com/jira-Created-FLINK-2567-CsvParser-Quotes-cannot-be-escaped-inside-quoted-fields-td7654.html$$patch1-flink-948b6e05_Developer_PatchNaturalnessYe$$Add back  backslash in GenericCsvInputFormat. don ' t search for backslash when field is quoted. Add back  backslash. Don ' t search for backslash when it is escaped. Add back  backslash. don ' t search for backslash when it is escaped. $$1
flink-30761572$$PojoType fields not supported by field position keys$$Tuple fields which are Pojos (or any other non-tuple composite type) cannot be selected as keys by field position keys.  Something like   {code} DataSet<Tuple2<Integer, MyPojo>> data = ... data.groupBy(1).reduce(...) {code}  fails with an exception.$$patch1-flink-30761572_Developer_PatchNaturalnessYe$$Remove unused imports. Reorder fields in tuple type definition. Fix bug in Keys. $$1
flink-8fc7e7af$$Early cancel calls can cause Tasks to not cancel properly$$When a task receives the "cancel()" call before the operators are properly instantiated, it can be that the operator never receives a cancel call.  In certain cases, this causes the operator to hang.$$patch1-flink-8fc7e7af_Developer_PatchNaturalnessYe$$Add canceled flag to StreamTask. throw exception if canceled. Add a final check to exit early on running the task. @@ cancel is not enumerable in Javadoc. Added private method to StreamTask. $$1
flink-a17d4e82$$ReduceOnNeighborsWithExceptionITCase failure$$I noticed a build error due to failure on this case. It was on a branch of my fork, which didn't actually have anything to do with the failed test or the runtime system at all.  Here's the error log: https://s3.amazonaws.com/archive.travis-ci.org/jobs/73695554/log.txt$$patch1-flink-a17d4e82_Developer_PatchNaturalnessYe$$Fix volatile flag in SpillableSubpartition .. Added isReleased method. Fix build. Fix isReleased .. Fix compaction issue. Fix isReleased .. Fixes issue 732. Added methods on PipelinedSubpartition to check if isReleased .. Fix isReleased in AsyncIOView. $$1
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1-flink-0cfa43d7_Developer_PatchNaturalnessYe$$Added runtime context for chained operator. Fix modifier order in StreamTask. Fix stream task registration. Added missing mandatory task parameter. $$1
flink-88a97768$$Watermark triggered operators cannot progress with cyclic flows$$The problem is that we can easily create a cyclic watermark (time) dependency in the stream graph which will result in a deadlock for watermark triggered operators such as  the `WindowOperator`.  A solution to this could be to emit a Long.MAX_VALUE watermark from the iteration sources.$$patch1-flink-88a97768_Developer_PatchNaturalnessYe$$Remove unused imports. Add an optimization to reduce the number of times that a stream item is emitted. Fix warning. remove warning suppression. $$1
flink-d594d024$$CancelTaskException leads to FAILED task state$$The {{CancelTaskException}} is thrown to trigger canceling of the executing task. It is intended to cause a cancelled status, rather than a failed status.  Currently, it leads to a {{FAILED}} state instead of the expected {{CANCELED}} state.$$patch1-flink-d594d024_Developer_PatchNaturalnessYe$$make task inner implementation accessible to the cancel ( ) method by the time we switched to running .. Don ' t log cancel ( ) on task fail ( ). Fix typo. Log task cancel in Controller .. $$1
flink-937963e3$$ZooKeeperCheckpointIDCounter.start() can block JobManager actor$$In HA mode, the job manager enables checkpoints during submission of streaming programs.  This leads to call to ZooKeeperCheckpointIDCounter.start(), which communicates with ZooKeeper. This can block the job manager actor.  A solution is to start the counter later instead of the CheckpointCoordinator constructor.$$patch1-flink-937963e3_Developer_PatchNaturalnessYe$$SavepointCoordinator should start the checkpoint id counter thread. $$1
flink-5dfc897b$$FileMonitoring function throws NPE when location is empty$${{StreamExecutionEnvironment.readFileStream()}} does not handle a missing location properly. I would suggest to log that the location is empty and continue running the job.  A test covering the correct behavior is also needed.$$patch1-flink-5dfc897b_Developer_PatchNaturalnessYe$$Remove unused imports. Add missing imports. Added missing warning. $$1
flink-94c8e3fa$$Auxiliary nodes in iterations are not correctly identified as "dynamic" or "static"$$The static/dynamic path tagger starts on the original roots of the step functions, ignoring possible auxiliary nodes that we need to attach to the root (such as NoOps, when the root is a union)$$patch1-flink-94c8e3fa_Developer_PatchNaturalnessYe$$Fix null termination criterion in workset iterations. Fix potential NPE in data flow iterators. $$1
flink-63ef8e86$$Getter/Setter recognition for POJO fields with generics is not working$$Fields like {code} private List<Contributors> contributors; {code}  Are not recognized correctly, even if they have getters and setters. Workaround: make them public.$$patch1-flink-63ef8e86_Developer_PatchNaturalnessYe$$Fix TypeExtractor . equals for boolean fields. Fix TypeExtractor for setters. $$1
flink-d90672fd$$Fix interplay of automatic Operator UID and Changing name of WindowOperator$$WindowOperator can have a changing name because it has the TypeSerializer .toString() output in it's name. For some type serializers that don't implement toString() this means that the name changes.  This means that savepoint restore does not work for the automatically generated UID.$$patch1-flink-d90672fd_Developer_PatchNaturalnessYe$$Add udfOperatorName to hasher. $$1
flink-06e2da35$$CheckpointCoordinator triggers checkpoints even if not all sources are running any more$$When some sources finish early, they will not emit checkpoint barriers any more. That means that pending checkpoint alignments will never be able to complete, locking the flow.$$patch1-flink-06e2da35_Developer_PatchNaturalnessYe$$add missing import. fix a warning. $$1
flink-ed3810b1$$Disable reference tracking in Kryo fallback serializer$$Kryo runs extra logic to track and resolve repeated references to the same object (similar as JavaSerialization)  We should disable reference tracking   - reference tracking is costly   - it is virtually always unnecessary in the datatypes used in Flink   - most importantly, it is inconsistent with Flink's own serialization (which does not do reference tracking)   - It may have problems if elements are read in a different order than they are written.$$patch1-flink-ed3810b1_Developer_PatchNaturalnessYe$$disable reference tracking. $$1
flink-494212b3$$Fix StateDescriptor.readObject$$The readObject method of StateDescriptor uses uses {{ObjectInputStream.read()}}. For very large serialized default values this will not necessarily read all data in one go. We need a loop that reads it in several steps.$$patch1-flink-494212b3_Developer_PatchNaturalnessYe$$Added missing comment. Fix checkstyle. Fix compile error. Add missing /** * *. Added missing javadoc. Add missing @ param javadoc. Fix build .. Fix build. Fix toString ( ) of StateDescriptor. Fix checkstyle. Remove check for data input error. $$1
flink-f2f5bd5b$$Session Window State is Not Checkpointed$$The merging window state in the {{WindowOperator}} is not checkpointed. This means that programs containing session windows will fail upon restore after a failure.  I propose adding a simulated snapshot/restore cycle to the tests in {{WindowOperatorTest}} to catch these problems in the future.$$patch1-flink-f2f5bd5b_Developer_PatchNaturalnessYe$$Add missing import. update missing import. Add a dispose method. Fixing workflow errors in window operator. Fixing merge operator. Fix trigger count bug. Fix warning. Fixing window operator initialization. Fix trigger arguments for window operator .. Fix trigger arguments for window operator .. restore accidentally - deleted merge state in WindowOperator. Add missing import. Add missing persist method to MergingWindowSet .. Fix synchronization issue. Fix context for merge ( ). Fix EvictingWindowOperator processTriggerResult ( ) with the wrong key being passed in the. Fix EvictingWindowOperator processTriggerResult ( ). Fix window evicting bug. $$1
wicket-8c83c5c5$$NPE in FormComponent#updateCollectionModel in case of no converted input and unmodifiable collection$$There are 2 issues with FormComponent#updateCollectionModel. 1) converted input is not checked for null before wrapping it to ArrayList 2) converted input is not checked for null then model returns unmodifiable collection. The both issues causes NPE.$$patch1-wicket-8c83c5c5_Developer_PatchNaturalnessYe$$reverted changes since they can break backwards compatibility. remove null check. kept old error message for backwards compatibility. $$1
wicket-a4caaa57$$AbstractTextComponent not escaping html data by default therefore user text is not redisplayed correctly$$User input is not escaped in all text fields by default (and the default is not configurable).  This leads to user entered text not being redisplayed correctly.  * You can replicate using the project from WICKET-3330. * Just enter the text my&frac12;companyname and press enter * The field will not redisplay the text entered properly$$patch1-wicket-a4caaa57_Developer_PatchNaturalnessYe$$don ' t unescape HTML by default.  wicket - util . string . Strings. don ' t unescape HTML entities when value is not a string. $$1
wicket-087c0a26$$WebSocketRequestHandler is not set as a scheduled and thus RequestCycle#find(AjaxRequestTarget.class) doesn't work$$As discussed at https://groups.google.com/d/topic/wicket-jquery-ui/fw6TdyO5o18/discussion AbstractWebSocketProcessor doesn't schedules the WebSocketRequestHandler in the request cycle and thus it is not reachable for user code via RequestCycle#find(Class) API.  Additionally the configured application RequestCycle listeners are not notified.$$patch1-wicket-087c0a26_Developer_PatchNaturalnessYe$$Fixing license header in WebSocketRequestMapper. Remove unused imports. Remove unused imports. Fix whitespace. Remove duplicated code. Fixed try / catch in AbstractWebSocketProcessor. Fix possible NPE in sendPayload ( ). Adding missing constructor .. $$1
wicket-3cc3fe95$$Component queuing breaks with html tags that don't require close tag.$$Component queuing try to skip to close tag also for those tags that don't have one. This leads to a EmptyStackException (see ArrayListStack#peek).$$patch1-wicket-3cc3fe95_Developer_PatchNaturalnessYe$$add detach operation onMarkupContainer. Allow tag to be dequeueed after having children. $$1
wicket-1ac05533$$PageParameters#mergeWith may loose values of the 'other' PP$$The code at org.apache.wicket.request.mapper.parameter.PageParameters#mergeWith() looks like:  for (NamedPair curNamed : other.getAllNamed()) 		set(curNamed.getKey(), curNamed.getValue());  may loose some values if 'other' has a named parameter with several values.With the current code only the last name/value pair is preserved.$$patch1-wicket-1ac05533_Developer_PatchNaturalnessYe$$added missing non - null values in PageParameters. $$1
wicket-d906576c$$MiniMap.iterator().next() should throw NoSuchElementException$$The wicket.util.collections.MiniMap.iterator().next() should throw NoSuchElementException when there are no more elements to return (line 235), please add: if(i >= size)     throw new NoSuchElementException();$$patch1-wicket-d906576c_Developer_PatchNaturalnessYe$$Add missing import. Added a throw if the map is not empty .. throw exception if index > size ( ) - 1. Added a throw if the map is not empty ( and we ' re about to do it. $$1
wicket-581c7306$$InlineEnclosure are piling up on each render$$InlineEnclosureHandler#resolve() uses an auto-incremented id for its resolved InlineEnclosure,   On the next render, a new instance will be resolved, since the id of the already resolved InlineEnclosure does not match the id in the markup.  But InlineEnclosures are not removed after render as other auto-components, thus all instances pile up in the owning container of the markup.$$patch1-wicket-581c7306_Developer_PatchNaturalnessYe$$Removed unused imports. wicket - enhancer - 1 . 6 - remove inlineEnclosure . java. Remove obsolete code. wicket - core - 1 . 8 - removed inlineEnclosure . getMarkup ( ). add counter to inline enclosures. wicket wicket inline enclosure handler should increment the counter. Removed an unnecessary check for inline enclosures tag id .. $$1
wicket-2f1ece4b$$JavaScriptStripper fails with single line comments$$The valid input x++ // x++  gets transformed to x++ x++  which is syntactically invalid. This breaks the unminified version of bootstrap 2.1.1.  The problem doesn't occur with multiline comments because the linebreaks are preserved there.$$patch1-wicket-2f1ece4b_Developer_PatchNaturalnessYe$$Allow backslash to be passed in JavaScriptStripper. $$1
wicket-faaae8d3$$404 Error on Nested ModalWindows in IE7 and IE8$$When opening a ModalWindow inside a ModalWindow, the inner ModalWindow generates a 404 error.  Both windows use a PageCreator for content.  To replicate, you must use an actual IE 7 or IE 8 browser, as this does not replicate using developer tools and setting the document and brower to IE 7.  The problem can be seen at http://www.wicket-library.com/wicket-examples/ajax/modal-window.  I will attach a Quickstart as well.$$patch1-wicket-faaae8d3_Developer_PatchNaturalnessYe$$add marker for url in bookmarkable form. wicket - core - request . getClientUrl ( ) + urlStartsWith ( baseUrl , namespace. $$1
wicket-8c827e33$$Header can not be set from IRequestCycleListener#onEndRequest()$$Due to HeaderBufferingWebResponse a header can no longer be set from IRequestCycleListener#onEndRequest().  In 1.4.x this was possible because BufferedWebResponse just passed through all headers to HttpServletResponse.$$patch1-wicket-8c827e33_Developer_PatchNaturalnessYe$$Fixed bug. use the same write method as the other write methods in the same response .. Don ' t reset the buffer of the original response if we are still buffering .. $$1
wicket-cf6172bd$$PageParametersEncoder should not decode parameters with no name$$From dev@ mailing list: http://markmail.org/message/khuc2v37aakzyfth  PageParametersEncoder should ignore query parameters like "&=&" and "&=value" because they make no sene and lead to exceptions later at PageParameters#add() call.$$patch1-wicket-cf6172bd_Developer_PatchNaturalnessYe$$add missing import. ignore empty query param. $$1
wicket-b672cb2d$$Spaces in path cause ModifcationWatcher to fail$$The ModificationWatcher isn't able to reload resource files if there's a space in the path.  The problem is that Files#getLocalFileFromUrl(String) receives an URL encoded String in which spaces are encoded to %20. They are never decoded and passed to File(). The fix is not to use the external representation of an URL but the file representation.$$patch1-wicket-b672cb2d_Developer_PatchNaturalnessYe$$add missing import. try java 8 on file names with spaces ( case insensitive ). $$1
wicket-def03add$$StackOverflowError when calling getObject() from load() in LDM$$The fix for WICKET-5772 caused an infinite loop when calling getObject() from inside load() in LoadableDetachableModel. While of course unwise to do so and nobody in their right mind would do so directly, such a cycle can be triggered through a series of unrelated calls emanating from load().$$patch1-wicket-def03add_Developer_PatchNaturalnessYe$$Fixed a typo .. Added toString ( ) to LoadableDetachableModel. Allow model to be attached .. Fixed a regression in how - to - detach. Allow detaching of transient object after detaching ( IDEADEV - 12901 ). Prevent infinite loop on attached state changes. Set attaching state to ATTACHED in onAttach. Fixed isAttached ( ). always append the transient model object to the toString ( ). Allow the model to be attached to another thread. $$1
wicket-2624d2db$$SmartLinkLabel failing to process email with -$$In a similar vein to WICKET-3174 - using SmartLinkLabel with an email address that includes a "-" generates a link only on the right-most part of the address.   Example:  - my-test@example.com  Will generate a link like:  - my-<a href="mailto:test@example.com">test@example.com</a>   The addition of the "-" char is a valid email address format.$$patch1-wicket-2624d2db_Developer_PatchNaturalnessYe$$Adding quotes around email address in DefaultLinkParser. $$1
wicket-556a2236$$Do not use the parsed PageParameters when re-creating an expired page$$WICKET-4014 and WICKET-4290 provided functionality to re-create an expired page if there is a mount path in the current request's url. There is a minor problem with that because the page parameters are passed to the freshly created page. I.e. parameters for a callback behavior are now set as page construction parameters. Since the execution of the behavior is ignored for the recreated page these parameters should be ignored too.$$patch1-wicket-556a2236_Developer_PatchNaturalnessYe$$add WICKET - 4594 - re - creating an expired page instance if pageId is. $$1
wicket-5f69685d$$HeaderResponse.renderCSSReference does not render context path relative url, but wicket filter url-pattern relative url$$In an application with a wicket filter url-pattern different than /*, if you use HeaderResponse.renderCSSReference(String url), where url is a context-path-relative url (css/main.css, for example), the generated css link is not context relative, but wicket url-pattern relative.$$patch1-wicket-5f69685d_Developer_PatchNaturalnessYe$$Remove unused imports. Allow relative url to be passed as arguments. add missing default variable. $$1
wicket-2abc18f1$$TableTree's NodeBorder does not properly close divs$$NodeBorder fails to properly close generated <div>s.$$patch1-wicket-2abc18f1_Developer_PatchNaturalnessYe$$added missing closing < div > tag. $$1
wicket-f3ec1503$$XmlPullParser doesn't parse correctly attributes with complex namespace$$Having a markup like: <a class="addthis_button_google_plusone_badge" g:plusone:size="smallbadge"  g:plusone:href="https://plus.google.com/25252/"></a> causes XmlPullParser to throw the following exception:  java.text.ParseException: Same attribute found twice: g:plusone (line 19, column 100)      at org.apache.wicket.markup.parser.XmlPullParser.parseTagText(XmlPullParser.java:673)      at org.apache.wicket.markup.parser.XmlPullParser.next(XmlPullParser.java:294)      at org.apache.wicket.markup.parser.filter.RootMarkupFilter.nextElement(RootMarkupFilter.java:58) .....$$patch1-wicket-f3ec1503_Developer_PatchNaturalnessYe$$wicket - util parse bug. $$1
wicket-b1f4e6a3$$URL IPv6 parsing$$There is an issue with native IPv6 address parsing. "https://[::1]/myapp", URL parsing fails:  org.apache.wicket.request.Url.parse("https://[::1]/myapp") generates an exception: java.lang.NumberFormatException: For input string: "1]" at java.lang.NumberFormatException.forInputString( NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:492)  However, "https://[::1]:80/myapp" works as expected.$$patch1-wicket-b1f4e6a3_Developer_PatchNaturalnessYe$$workflow improvements - added workflow improvements for IPv6 reverse links. add missing closing qr bracket. $$1
wicket-8ccb1f6d$$IResourceCachingStrategy implementations should only set caching if version matches$$Implementations of IResourceCachingStrategy (FilenameWithVersionResourceCachingStrategy and QueryStringWithVersionResourceCachingStrategy) should only set cache duration to maximum if the version matches. Currently, if a user requests a resource with an arbitrary version, the version will be cached for one year (WebResponse.MAX_CACHE_DURATION). So people could polute proxy caches with potentially upcoming version.$$patch1-wicket-8ccb1f6d_Developer_PatchNaturalnessYe$$Use calculated version if available. Use the calculated version if it is the same as the request .. $$1
wicket-4f08e6f2$$CryptoMapper does not work for applications having a home page that needs query parameters$$CryptoMapper.decryptUrl() should not return null for requests like http://myhost/MyApplication/app/?param=xx   As a possible fix one can replace  if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {            return encryptedUrl; }  with   if (encryptedUrl.getSegments().isEmpty()) {            return encryptedUrl; }  but I suspect that the original test is intended to answer to another use case...$$patch1-wicket-4f08e6f2_Developer_PatchNaturalnessYe$$Improved detection of url - params in AuthProvider .. $$1
wicket-12e1f39b$$CreditCardValidator accepts invalid inputs$$(1) The onValidate() method of the CreditCardValidator class returns true for invalid inputs with null or unicode character such as 4\0\0\0\0\0\0\0\0\0\0\0\0\0\0.  (2) Also there is no length check on the input, therefore even invalid length inputs such as 9845 are accepted.  (3) There is no check for invalid issuer identifier, i.e.,  840898920205250 is accepted, where 84XXXX is not a valid issuer identifier$$patch1-wicket-12e1f39b_Developer_PatchNaturalnessYe$$Fixed a bug in Controller & Accounts .. Allow credit card validation to proceed without error .. $$1
wicket-ef3adb12$$TabbedPanel CSS "last" is wrong if last step is not visible$$TabbedPanel renders a "last" CSS class for the last tab, this fails however if the last tab is not visible.$$patch1-wicket-ef3adb12_Developer_PatchNaturalnessYe$$@@ - 188 - TabbedPanel should set visibilityCache to a proper variable. wicket extensions doesn ' t have access to VisiblityCache. Use the cache for TabbedPanel when the tab is selected .. fixed a small bug. Fixed a typo in TabbedPanel javadocs ( # 971 ). fixed a typo in TabbedPanel. Add one method. $$1
wicket-d558004b$$Problem with setting of IComponentInheritedModel and FLAG_INHERITABLE_MODEL$$Described in the mailing list: [http://mail-archives.apache.org/mod_mbox/wicket-users/201407.mbox/%3CCAF2_608c8TOZjprV8Md15KJpRET6YQdXHe%3DwRzF-y5G_zAXcDg%40mail.gmail.com%3E]  I'm aware of the another issue ([https://issues.apache.org/jira/browse/WICKET-3413]) which dealt with the exact same code - and I believe there was a mistake in the solution that leads to this issue.  Please see the attached quickstart (including a JUnit test) to reproduce the error.$$patch1-wicket-d558004b_Developer_PatchNaturalnessYe$$reset ' inherited model ' when model is explicitely set. remove component inherited model flag. $$1
wicket-a4459ef4$$Event broadcast type "Depth" does not work when the sink is a Component but not a MarkupContainer$$Event broadcast type "Depth" does not work when the sink is a Component but not a MarkupContainer. In this case, no sinks receive the event.$$patch1-wicket-a4459ef4_Developer_PatchNaturalnessYe$$Added breadth - first traversal of Broadcast. Added details on how Broadcast is applied. Forgot to call dispatchEvent ( ) in Controller. $$1
wicket-6a8fc1cc$$MarkupNotFoundException when refreshing a component with AJAX inside a TransparentWebMarkupContainer$$A component placed inside a TransparentWebMarkupContainer, added to its parent cannot be refreshed with AJAX. See quickstart.$$patch1-wicket-6a8fc1cc_Developer_PatchNaturalnessYe$$added missing import. Added missing TODO .. removed unused import. Adding missing import. Adding missing @ Override annotation. Added missing @ Override annotation. Add missing @ Override annotation. Reduced the number of times that a component resolver is found. Added empty line to the top of the HTML header so that we can override existing code. Added IComponentResolver to imports. Added a protected method to searchMarkupInTransparentResolvers ( ). "avoid "" multiple renders "" error ( IDEADEV - 21852 )". $$1
wicket-cda34428$$multiple <style> tags in header are rendered incorrectly$$I created a small quickstart.  The BasePage has some multiple <style> tags. Only he first one is rendered correctly, all following render the tag body only, the surrounding <style></style> is missing.$$patch1-wicket-cda34428_Developer_PatchNaturalnessYe$$Removed unused imports. use the new StringHeaderItem constructor here too. Remove debug code. $$1
wicket-ba516f02$$FormTester throws an exception when a Palette component is added to a Form associated with a compound property model$$FormTester throws an exception when a Palette component is added to a Form associated with a compound property model: org.apache.wicket.WicketRuntimeException: No get method defined for class ... expression: choices  It worked fine in Wicket 6.5.0, and works fine if the form is not associated with a compound property model.$$patch1-wicket-ba516f02_Developer_PatchNaturalnessYe$$Added missing javadoc. $$1
wicket-d79d0192$$Bounds error in PageableListView#getCurrentPage()$$In the getCurrentPage() method of class PageableListView, the following code:  while ((currentPage * rowsPerPage) > getList().size()) {            currentPage--; }  checks if "first cell if out of range". However, the index of that first cell is (currentPage * rowsPerPage), and then the comparison with getList().size() should use a ">=" instead a ">".$$patch1-wicket-d79d0192_Developer_PatchNaturalnessYe$$improve readme. $$1
wicket-84bbbf68$$Incorrect URL for setResponsePage() within a Form#onSubmit( )$$If the WebApplication uses IRequestCycleSettings.RenderStrategy.ONE_PASS_RENDER, the issue described and exemplified in the attached quickstart at  https://issues.apache.org/jira/browse/WICKET-3442  prevails.   Clicking the link on /pageone results in this URL: /pageone?0-1.IFormSubmitListener-form$$patch1-wicket-84bbbf68_Developer_PatchNaturalnessYe$$Change default request redirect policy to ALWAYS_REDIRECT. Fix wicket request redirect policy. wicket 1 . 4 . 3 - old test. $$1
wicket-8f7805f8$$AutocompleteTextField after Submit does not work$$I use an AutocompleteTextfield together with a submit-Button. After once submitting the content oft the AutocompleteTextField the parameter q is added to the URL. After that the autocompletion will only complete the parameter q in the url and not the parameter given by ajax.  I tracked the problem down to the callbackURL.  It contains a pattern looking as follows: ....&q=<paramproducedbysubmit>&q=<paramproducedbyajaxautocomplete>  The callbackurl is build of the parameter q and the extraction of parameters only accepts the first parameter$$patch1-wicket-8f7805f8_Developer_PatchNaturalnessYe$$Removed redundant code. $$1
wicket-6ce34ccf$$Minified name resolves incorrectly if default resource reference is used$$In PackageResourceReference.  When a default reference to a minified resource is used (i.e. the resource wasn't mounted) the resource reference name includes '.min'.   When trying to resolve the minified name, another '.min' is appended, resulting in the minified name resolving to 'html5.min.min.js'.   As a result, the PackageResourceReference concludes that the resource was not minified, and adds compression.$$patch1-wicket-6ce34ccf_Developer_PatchNaturalnessYe$$Extend PackageResourceReference to include min . suffix. $$1
wicket-5e2c6702$$Wicket 1.5 RC-3 Bug with conditional comments$$IE Conditional Comments with script block causes malformed HTML on Chrome and Firefox.$$patch1-wicket-5e2c6702_Developer_PatchNaturalnessYe$$Fix IE7 bug in JavaScriptUtils. $$1
wicket-557de7bc$$FileUpload writeToTempFile() method throws NPE for sessionless requests$$I have created stateless page with stateless form containing FileUploadField, however when I tried to post file to it, NPE was thrown.  The issue is caused by method FileUpload#writeToTempFile() method trying to use session id as temp file prefix.   Workaround: create temp file manually and use method FileUpload#writeToFile( myTempFile)$$patch1-wicket-557de7bc_Developer_PatchNaturalnessYe$$add missing import. add tempFileName used for form uploads. $$1
wicket-7b8b6767$$Multiple events in AjaxEventBehavior with prefix 'on'$$if multiple events are used and one starts with "on", it only works if it is the first one, because of:  {code} 		if (event.startsWith("on")) 		{ 			event = event.substring(2); 		} {code}  Why are events possible to start with "on" ?   Is this legacy? Perhaps should be removed for Wicket 7 ?$$patch1-wicket-7b8b6767_Developer_PatchNaturalnessYe$$Add missing imports. Add note about inline event names. Warn about wrong event name. Accept empty event name as long as it is not empty .. Cleaned up empty event names. $$1
wicket-02ebc8ae$$BufferedWebResponse fails to add/clear cookie in redirect$$bufferedWebResponse.addCookie( cookie );  That fails under certain conditions: (1) when called on the last of three 302 redirects during OpenID login; and (2) on single redirect immediately after container startup, though it later recovers.  Failure confirmed in Firebug; no cookies sent in any of the response headers.  My workaround is to bypass the buffered response.  This works:  ((HttpServletResponse)bufferedWebResponse.getContainerResponse()).addCookie( cookie );$$patch1-wicket-02ebc8ae_Developer_PatchNaturalnessYe$$Remove unused imports. keep the original response object. Fixed a bug where workflow from AJAX - 500 - Remove special handling of metadata headers in. $$1
wicket-d1b62639$$SHOW_NO_EXCEPTION_PAGE responding with HTTP status 500 is overwritten by redirect$$If the application is configured with SHOW_NO_EXCEPTION_PAGE as unexpectedExceptionDisplay, an exception thrown while submitting a form should result in an HTTP 500 status. Since the request is already marked as a redirect in AbstractListenerInterfaceRequestTarget#onProcessEvents(), the 500 status is overwritten with status 200 when the redirect is handled afterwards.$$patch1-wicket-d1b62639_Developer_PatchNaturalnessYe$$revert 121. $$1
wicket-dfc56674$$DiskDataStore returns the wrong page when the page disk space is full$$If the configured file size for the session data is overflowed (see org.apache.wicket.settings.IStoreSettings#setMaxSizePerSession(Bytes)) then Wicket may return wrong page data (bytes) for a expired page.  The problem is in org.apache.wicket.pageStore.PageWindowManager#idToWindowIndex which may have several page ids (the keys) pointing to the same window index (values).$$patch1-wicket-dfc56674_Developer_PatchNaturalnessYe$$Add inversed index of PageWindowManager . idToWindowIndex .. wicket - util - wicket - pagestore should remove old map value. remove duplicated code. added missing initialization .. wicket - util / Collections / Maps / PageWindowManager .. reset windowIndexToPageId after removing window from list. add missing index pointer in PageWindowManager. $$1
wicket-724066f4$$NPE in JsonUtils when the value is null$$Most part of org.apache.wicket.ajax.json.JsonUtils.asArray(Map<String, Object> map) is trying carefully avoid null value. But there is following line  else if (value.getClass().isArray())  which cause NPE in case of empty value for some key.   P.S. Will provide patch.$$patch1-wicket-724066f4_Developer_PatchNaturalnessYe$$Allow null values for JSON arrays. $$1
wicket-ded3c583$$Wicket doesn't encrypt links and Ajax URLs for mounted pages when CryptoMapper is used$$URL encryption does not work in Wicket links and Ajax URLs.  For links the URL appears unencrypted in the href attribute value and is only later forwarded to the encrypted URL using a 302 response.  I am uploading a quickstart.$$patch1-wicket-ded3c583_Developer_PatchNaturalnessYe$$add missing import. Added note about encrypted URLs. Added hidden variable .. Fix error in Controller and IDE web interface. Added missing inheritDoc. wicket - crypto mapper returns null request object. Encrypts a URL , without query parameters it will throw an error if the URL is invalid. Improve decryptRequestListenerParameter method. $$1
wicket-53442bb4$$Component#setDefaultModel() should call #modelChanging()$$Component#setDefaultModel() should call #modelChanging() as #setDefaultModelObject() does. It worked by chance so far because addStateChange() is called.  http://markmail.org/thread/uxl6uufusggqbb6s$$patch1-wicket-53442bb4_Developer_PatchNaturalnessYe$$- modelChanged ( ) now calls modelChanging ( ) and modelChanging ( ). $$1
wicket-d3d42d42$$404 Error on Nested ModalWindows in IE7 and IE8$$When opening a ModalWindow inside a ModalWindow, the inner ModalWindow generates a 404 error.  Both windows use a PageCreator for content.  To replicate, you must use an actual IE 7 or IE 8 browser, as this does not replicate using developer tools and setting the document and brower to IE 7.  The problem can be seen at http://www.wicket-library.com/wicket-examples/ajax/modal-window.  I will attach a Quickstart as well.$$patch1-wicket-d3d42d42_Developer_PatchNaturalnessYe$$wicket - core - request . getClientUrl ( ) + urlStartsWith ( baseUrl , namespace. add marker for url in bookmarkable form. $$1
wicket-e24874da$$StringResourceModels doesn't seem to detach properly$$If a StringResourceModel contains a model for property substitutions, and there has not been assigned a component it is relative to on construction time, it will not detach the property substitution model.  See this thread for a full explanation http://apache-wicket.1842946.n4.nabble.com/StringResourceModels-doesn-t-seem-to-detach-properly-td4257267.html$$patch1-wicket-e24874da_Developer_PatchNaturalnessYe$$Added missing onDetach ( ) method. Added missing semicolon .. $$1
wicket-89184b79$$MountMapper does not support correctly parameter placeholders$$Package mounting doesn't support parameter placeholders. The problem seems to be inside MountMapper which should wrap PackageMapper and take care of substituting placeholders with their actual value.  More precisely this class doesn't read parameter values from PageParameters and it's not very clear to me how it tries to read these values. Does anybody have some hints about this class?$$patch1-wicket-89184b79_Developer_PatchNaturalnessYe$$Allow null page parameters for stateful pages. null check for stateful pages. $$1
wicket-e8dab4a0$$Wicket does not correctly handle http OPTIONS requests$$currently these requests cause regular processing (page rendering), when in fact they should have a special response.  rendering the page in OPTIONS causes renderCount to be incremented and this messes with the subsequent request to the same url via a GET or POST$$patch1-wicket-e8dab4a0_Developer_PatchNaturalnessYe$$Fixing whitespace in WicketFilter .. Fix typo. Fixed a bug where "" OPTIONS "" request is processed with the new request . """. added missing closing parenthesis. Add missing Javadoc. Reduced too broad catch block. Added filterPath getter for protocol / http .. Missing closing < filter > tag. Fixed invalid parameter name in URL path. $$1
wicket-5fd03973$$ListenerInterfaceRequestHandler should not assume existence of a page$$ListenerInterfaceRequestHandler should not assume a page instance is always available in isPageInstanceCreated. This handler can also be used for links on bookmarkable pages. The attached patch fixes this.$$patch1-wicket-5fd03973_Developer_PatchNaturalnessYe$$add warning. $$1
wicket-ccb8fc9e$$Inline enclosure doesn't work if wicket:message attribute is used on the same tag$$Markup like:          <div wicket:enclosure="child" wicket:message="title:something"> 	        <div>Inner div 		        <span wicket:id="child">Blah</span> 	        </div>         </div>  doesn't work (Inner div is visible, no matter whether 'child' is visible or not) because the auto component created for wicket:message breaks somehow wicket:enclosure.$$patch1-wicket-ccb8fc9e_Developer_PatchNaturalnessYe$$wicket - driver - 172 fixed issue. $$1
wicket-b91154ea$$Inline enclosure doesn't work if wicket:message attribute is used on the same tag$$Markup like:          <div wicket:enclosure="child" wicket:message="title:something"> 	        <div>Inner div 		        <span wicket:id="child">Blah</span> 	        </div>         </div>  doesn't work (Inner div is visible, no matter whether 'child' is visible or not) because the auto component created for wicket:message breaks somehow wicket:enclosure.$$patch1-wicket-b91154ea_Developer_PatchNaturalnessYe$$add message tag handler to filters. Removed unused tag handler. Removed redundant component resolvers. wicket - core doesn ' t have inlineEnclosureFilter on IE8. wicket - id = > htmlId. Fixed unreachable code. wicket - message - attribute checks are still empty ( wicket - message - attribute is considered empty ). "remove "" wc """. $$1
wicket-bb7a6995$$FileResourceStream returns unknown content type$$See http://apache-wicket.1842946.n4.nabble.com/PackageResourceReference-and-Doctype-in-Markup-file-tp3889467p3889587.html  The response for FileResourceStreams returns an unknown content type for css- and image-files. Correct content types should be "text/css" and "image/png" (see also attached quickstart).$$patch1-wicket-bb7a6995_Developer_PatchNaturalnessYe$$Remove unused import. fixed NPE for ByteArrayResource ( this is an empty class ). add text / javascript mime mapping. wicket - request . resource . ResourceStreamResource should use its own mimeType ( or null if no. fixed NPE for PackageResource. $$1
wicket-be70e608$$getMarkupId() can be used only if the component's markup is attached$$With change r1037139 Component#getMarkupImpl() first tries to get the markup id from the component's markup. If the markup is not available/attached yet for this component the call ends with : org.apache.wicket.markup.MarkupException: Can not determine Markup. Component is not yet connected to a parent. [Component id = label]$$patch1-wicket-be70e608_Developer_PatchNaturalnessYe$$added missing closing < > tag in MarkupContainer. add missing import. Removed unused class. add missing return statement , because it is not allowed to be set on a component. added missing closing MarkupFragment. $$1
wicket-d547fcd4$$ResourceUtils.getLocaleFromFilename can't handle minimized resources well$$I think the ResourceUtils.getLocaleFromFilename(String path) has the order of locale and minimization wrong: It currently parses: File.min_Lang_Coun_Var.ext while the typical convention is File_Lang_Coun_Var.min.ext Surely considering the ResourceUtils.getMinifiedName() method which does work according to convention.$$patch1-wicket-d547fcd4_Developer_PatchNaturalnessYe$$add locale min regex. Added helpful note about resource locale from minified filename .. Put inline inline with ResourceUtils. Missing locale matcher pattern , this should fix the build .. wicket - util - resource . ResourceUtils now uses language / path as it is done in the. $$1
wicket-9decad35$$POST params ignored by IPageParametersEncoder#decodePageParameters()$$As per this conversation: http://apache-wicket.1842946.n4.nabble.com/how-to-get-https-port-number-in-Wicket-1-5-td4295139.html  it seems that POST params are not properly processed and made available as PageParameters. Can anyone say whether this is intended behavior or not? I will attach a Quickstart to demonstrate.  Martin's proposed fix is straightforward, but I am not comfortable enough with Wicket internals to say whether or not this would break something.  Thanks$$patch1-wicket-9decad35_Developer_PatchNaturalnessYe$$Updated Imports. Removed note on parameter ordering. add missing import. Allow null values for CombinedRequestParametersAdapter constructor. wicket request adapter missed one. Removed unused imports .. remove debug code. Add note about UrlPathPageParametersEncoder. $$1
wicket-d1e0e411$$AbstractTransformerBehavior sets wrong namespace$$AbstractTransformerBehaviour adds a wicket namespace (http://wicket.apache.org) to its tag which is different from that of the whole page (http://wicket.apache.org/dtds.data/wicket-xhtml1.4-strict.dtd).  This causes (at least) XPath queries for Wicket nodes to fail when matching the contents of components with an AbstractTransformerBehavior.$$patch1-wicket-d1e0e411_Developer_PatchNaturalnessYe$$Removed unused imports .. Removed tag namespace stuff .. Removed unused import. Fix XsltOutputTransformerContainer to respect XHTML 1 . 3 restrictions. added missing loop in MarkupContainer . onAfterRenderChildren ( ). Remove unused code. Removed unused import. Allow the XsltTransformerBehavior to handle the wicket tag .. Added WICKET_XHTML_DTD constant to MarkupResourceStream. Updating documentation for wicket namespace. $$1
wicket-1a2bc1bc$$IResponseFilter cannot change buffer contents$$Changes to the responseBuffer, passed to an IResponseFilter, are not picked up, nor are newly created AppendingStringBuffer (return value of the method). Both callers of the method invoke it with a copy of the buffer and ignore return values (BufferedWebResponse line 145 and AjaxRequestTarget line 687).$$patch1-wicket-1a2bc1bc_Developer_PatchNaturalnessYe$$invokeResponseFilters ( ) didn ' t invoke the response filters on the client. Added private method to avoid compiler warning. wicket ajax response target modified ( as per # 1262 ). responseFilters should use the result of the builder instead of the builder .. $$1
wicket-089303f4$$wicketTester.executeAjaxEvent(combo, "onchange"); works with 1.4-rc1 but not anymore with 1.4-rc2$$Try the attached Unit Test.$$patch1-wicket-089303f4_Developer_PatchNaturalnessYe$$add AJAX request redirect header. $$1
wicket-2737d7c7$$The tbody section of a DataTable is empty when no records are returned by the provider.$$When a DataTable is rendered without records, the tbody section is empty. This violates the html spec.  From the spec: "When present, each THEAD, TFOOT, and TBODY contains a row group. Each row group must contain at least one row, defined by the TR element." and "The THEAD, TFOOT, and TBODY sections must contain the same number of columns."$$patch1-wicket-2737d7c7_Developer_PatchNaturalnessYe$$added onConfigure method on data table. $$1
wicket-6122df49$$Minified css/js gets compressed$$Given an application with a resource reference to a minified script, i.e. html5.js and html5.min.js.  When the ResourceRequestHandler responds  it will set compress to false, if the resource reference was PackageResourceReference but it will not change compression if the resource reference was JavaScriptResourceReference.   PackageResourceReference handles minified resources more or less correctly (if they are minified, they should not be further compressed), but this behavior is overwritten in its subclasses.$$patch1-wicket-6122df49_Developer_PatchNaturalnessYe$$remove compress flag if necessary. wicket - api does not compress css files by default. disable minified flag for PackageResourceReference. $$1
wicket-3fc7234e$$Url.canonical() breaks when there are two consecutive "parent" segments followed by a normal segment$$assertEquals("a/d", Url.parse("a/b/c/../../d").canonical().getPath());   breaks with : Expected :a/d Actual   :a/b/../d$$patch1-wicket-3fc7234e_Developer_PatchNaturalnessYe$$Allow Url . segments . add ( segment ) to be added to the Url object. $$1
wicket-0cf14725$$SmartLinkLabel failing to process email with +$$Using SmartLinkLabel with an email address that includes a "+" generates a link only on the right-most part of the address.  Example: - my+test@example.com Will generate a link like: - my+<a href="mailto:test@example.com">test@example.com@pappin.ca</a>  THe addition of the "+" char is a valid email address format.$$patch1-wicket-0cf14725_Developer_PatchNaturalnessYe$$Adding backslash to email address pattern. $$1
wicket-5d64196a$$XsltOutputTransformerContainer incorrectly claims markup type "xsl"$$XsltOutputTransformerContainer return "xsl" from getMarkupType(), forcing is on all contained components.  If the components in org.apache.wicket.markup.outputTransformer.Page_1 are reordered (XsltOutputTransformerContainer coming first) the test fails because no markup for SimpleBorder can be found.$$patch1-wicket-5d64196a_Developer_PatchNaturalnessYe$$Removed unused imports. Fix well formedness of xhtml1 . 3 - strict .. Removed unused getter forMarkupType. $$1
wicket-50b52742$$ByteArrayResource throws error if data is null$$When ByteArrayResource#getData(org.apache.wicket.request.resource.IResource.Attributes) returns null, the class throws a WicketRuntimeException.  This behavior differs from DynamicImageResource and ResourceStreamResource which instead issue the following call: response.setError(HttpServletResponse.SC_NOT_FOUND);  ByteArrayResource should follow the same behavior. This would allow for instance to use it for resources which depend on the contents of attributes.getParameters(). When the parameters are invalid, a 404 should be issued instead of an exception.$$patch1-wicket-50b52742_Developer_PatchNaturalnessYe$$add missing semicolon. Added missing import. fixed error code. $$1
wicket-b6259e5f$$arraycopy with bad length in AbstractRequestLogger:172$$When clicking on DebugBar org.apache.wicket.devutils.inspector.LiveSessionsPage NullPointerException is thrown. After investigating the reason I think AbstractRequestLogger:172 arraycopy params cause it.  {{arraycopy(requestWindow, 0, copy, requestWindow.length - oldestPos, indexInWindow);}} Should be changed to: {{arraycopy(requestWindow, 0, copy, requestWindow.length - oldestPos, oldestPos);}}$$patch1-wicket-b6259e5f_Developer_PatchNaturalnessYe$$remove copyRequestsInOrder redundant code. $$1
wicket-1fb66533$$ServletWebResponse#encodeUrl() makes absolute Urls relative$$When an absolute (full) URL is passed to ServletWebResponse#encodeUrl(), it will be returned relative if the container encodes a session ID.$$patch1-wicket-1fb66533_Developer_PatchNaturalnessYe$$Fix bug in ServletWebResponse. Fix bug in ServletWebResponse. $$1
wicket-b76f9c44$$CreditCardValidator returns incorrect cardId for VISA$$When the validation for a VISA is correct, it returns a SWITCH cardId instead of a VISA. This error occurs in both 1.4.x and 1.5.X$$patch1-wicket-b76f9c44_Developer_PatchNaturalnessYe$$Allow credit card number to be used as a valid card number. $$1
wicket-aadaa4e9$$PageParameters#set not follow INamedParameters#set behavior$$Couple of problems to work with page parameters: Major - The PageParameters#set(final String name, final Object value, final int index) used remove/add pattern instead of set parameter value by specified index. Minor - Inposible to get the index of key in elegant way to use obtained index in #set operation$$patch1-wicket-aadaa4e9_Developer_PatchNaturalnessYe$$@@ set ( String , Object ). $$1
wicket-fb45a781$$Page not recognized as stateless although stateful component is hidden in #onConfigure()$$Page#stateless gets cached. If Page#isStateless() is called before rendering, a page might not be considered stateless although in #onConfigure() all stateful components are hidden.$$patch1-wicket-fb45a781_Developer_PatchNaturalnessYe$$remove duplicated code. nullify stateless in renderCount. $$1
wicket-295e73bd$$IResponseFilter doesn't work in 1.5$$In current 1.5-SNAPSHOT there are no callers of org.apache.wicket.settings.IRequestCycleSettings.getResponseFilters() and thus filters are never executed.$$patch1-wicket-295e73bd_Developer_PatchNaturalnessYe$$add missing import. Add missing import. restore the original response object on after response writer. Added after - respond listeners. Remove use of deprecated WebResponse API. Remove unused WebResponse . respondComponents ( ) modifier from above. add missing import. responseFilters support. add missing @@. $$1
wicket-a7ce7f91$$DownloadLink doesn't wrap the String model used for file name nor does it detach$$Component DownloadLink doesn't call method wrap of class Component on parameter fileNameModel. This causes models like StringResourceModel to not resolve resource bundles correctly. See the discussion here: http://stackoverflow.com/questions/12196533/how-to-use-wicket-stringresourcemodel-in-downloadlink  The patch seems quite trivial.   Detachment is also missing.$$patch1-wicket-a7ce7f91_Developer_PatchNaturalnessYe$$add detachModels ( ). $$1
wicket-2fc6a395$$Method Strings.join doesn't work correctly if separator is empty.$$If we use an empty separator ("") to join strings, the first character of any fragment is truncated. Es "foo", "bar", "baz" became "ooaraz".$$patch1-wicket-2fc6a395_Developer_PatchNaturalnessYe$$remove empty separator string in last piece. $$1
wicket-71b6e905$$NPE with nested property models$$After updated from 1.4.8 to 1.4.14 I got this bug.  The problem is with nested property models where the "top" model has a null model object that is bound to a TextField. You get a NPE when the page is rendered. There is a quick workaround by overriding getOjbectClass() on the property model.  I provide a running example of the problem.$$patch1-wicket-71b6e905_Developer_PatchNaturalnessYe$$corrected a null targetClass value .. $$1
wicket-71674df5$$Problem with WICKET-4441 and RestartResponseAtInterceptPageException$$WICKET-4441 introduced an issue when our app has an authorization strategy and user is logged out. If user tries to access a protected url/page, RestartResponseAtInterceptPageException is handled by DefaultExceptionMapper and leads to exception page instead of redirecting user.$$patch1-wicket-71674df5_Developer_PatchNaturalnessYe$$Correctly handle pagination in WICKET - 5734. $$1
wicket-7e1000dd$$Debug settings / serialize session attributes option not working$$Session attributes are serialized even if this debug setting is turned off. I've noticed that the code that serializes attributes and logs their serialized size in HttpSessionStore#setAttribute is duplicated in Session#setAttribute - but without the debug settings condition. This code was added by the recent patch resolving WICKET-100 and only in the trunk, not in the wicket-1.x branch... why???  Regards, Bendis$$patch1-wicket-7e1000dd_Developer_PatchNaturalnessYe$$Removed unused imports .. remove unused imports. Remove debug code. $$1
wicket-381b90fd$$Cookies#isEqual(Cookie, Cookie) may fail with NullPointerException$$If c1.getPath == null but c2.getPath != null then a NPE will occur. Same is valid for the 'domain' property.$$patch1-wicket-381b90fd_Developer_PatchNaturalnessYe$$add missing import. allow same cookie names. $$1
wicket-a2f848f2$$404 Error on Nested ModalWindows in IE7 and IE8$$When opening a ModalWindow inside a ModalWindow, the inner ModalWindow generates a 404 error.  Both windows use a PageCreator for content.  To replicate, you must use an actual IE 7 or IE 8 browser, as this does not replicate using developer tools and setting the document and brower to IE 7.  The problem can be seen at http://www.wicket-library.com/wicket-examples/ajax/modal-window.  I will attach a Quickstart as well.$$patch1-wicket-a2f848f2_Developer_PatchNaturalnessYe$$Fixed url instance mapper. context url matcher method for PageInstanceMapper. $$1
wicket-b154d12f$$PagingNavigator.setEnabled(false) doesn't work$$1. Create paging navigator PagingNavigator  2. call PagingNavigator.setEnabled(false) 3. navigator will be rendered as enabled, if click on any link ("1", "2" etc) - content of the data view will be changed.  In many cases it's necessary disable navigator, for example, when user need to edit only single line of DataView other controls need to be disabled.$$patch1-wicket-b154d12f_Developer_PatchNaturalnessYe$$enable PagingNavigator on instanceof PagingLink. Added override to parent class to prevent override by children. disable PagingNavigator on form validation. Added missing super in PagingNavigation. $$1
wicket-57d8f051$$Rescheduling the same ajax timer behavior causes memory leak in the browser$$AbstractAjaxTimerBehavior uses JavaScript setTimeout() function to do its job. It has a #stop() method that clears the timeout but if the timeout is re-scheduled without being cleared a memory leak is observed in the browser.$$patch1-wicket-57d8f051_Developer_PatchNaturalnessYe$$Remove unused imports. Added timers id. Remove blank line. Remove broken setTimeout. Remove debug code. $$1
wicket-4a6a573b$$MiniMap.iterator().next() should throw NoSuchElementException$$The wicket.util.collections.MiniMap.iterator().next() should throw NoSuchElementException when there are no more elements to return (line 235), please add: if(i >= size)     throw new NoSuchElementException();$$patch1-wicket-4a6a573b_Developer_PatchNaturalnessYe$$Fixed NPE in MiniMap , WICKET - 428 .. throw exception if index > size - 1. $$1
wicket-f1c0f263$$UrlValidator failes to validate urls that containt multiple dots in path$$refer to UrlValidator.java:466 (isValidPath). if we have an url, that contains more than two consequent dots, for example "http://www.somedomain.com/this_one_is_tricky...but...still.....valid", validator will fail. btw, the other side effect is that countTokens actually counts '...' a two 2dots. One possible workaround is not just count '..' tokens, but count them along with slash, like '../'.$$patch1-wicket-f1c0f263_Developer_PatchNaturalnessYe$$Fix url for example. $$1
wicket-5226978a$$WicketTester Cookie handling$$While trying to test my SecureForm implementation (https://issues.apache.org/jira/browse/WICKET-1885) with WicketTester I ran into this issue: A cookie set in the response never shows up in the "next" request, because both have their own lists of cookies that aren't shared.  Afaik both should share the same List instance to handle cookies. That way its possible to set a cookie in the response and read it from the request.  A simple testcase is attached.$$patch1-wicket-5226978a_Developer_PatchNaturalnessYe$$Removed unused imports .. add hidden var. added add cookie method to the mock web application. add cookies to the servlet request in case we had source knee - abs case. $$1
wicket-7d5b8645$$Form Input example fails when changing the language$$Trying to change the language of http://localhost:8080/forminput example fails with:   Caused by: java.lang.ArrayIndexOutOfBoundsException: -1 	at java.util.ArrayList.remove(ArrayList.java:390) 	at org.apache.wicket.request.Url.resolveRelative(Url.java:884) 	at org.apache.wicket.markup.html.form.Form.dispatchEvent(Form.java:1028) 	at org.apache.wicket.markup.html.form.Form.onFormSubmitted(Form.java:699) 	at org.apache.wicket.markup.html.form.Form.onFormSubmitted(Form.java:670) 	... 37 more$$patch1-wicket-7d5b8645_Developer_PatchNaturalnessYe$$parse url. cleaned up error. Remove queryAt + 147. Remove extraneous whitespace. Fixing attribution for default port for protocol. remove old comment. Updating old comment. update Url class to reflect changes to long form. Fix an issue with Url . isEmpty ( ) being able to represent default port for protocols. Removed old comment. do not strip the first non - folder segment if it is not empty.  wicket - request / Url / Path method with given encoding.  wicket - request does not have iso_ * date in it. cleaned up error. $$1
wicket-8b294488$$Date converters should use a new instance of DateFormat to be thread safe$$Please consider the linked issue WICKET-4833.  I had to open a new issue because I cannot attach the quickstart project I've prepared to a closed issue.$$patch1-wicket-8b294488_Developer_PatchNaturalnessYe$$Fixed thread unsafe converters. $$1
wicket-86066852$$Queuing a component within an enclosure$$Queueing doesn't work if component is in a enclosure tag.   <wicket:enclosure child="inlink"> <a href="panier.html"> 	<span wicket:id="inlink"></span> </a> </wicket:enclosure>$$patch1-wicket-86066852_Developer_PatchNaturalnessYe$$redundant import. resolve child by ID. added resolveChild ( ). added new dequeue context to Enclosure , possibly hiding opengles , for instance. $$1
wicket-30255f11$$WicketTester does not follow absolute redirects$$Wicket tester does not follow absolute redirects:  This is a problem when using HttpsMapper. For example when requesting a page over http:// with an forced redirect to https:// for secure access will make wicket tester return 'null' for the last renderer page instead of the rendered page instance. In general all kinds of absolute redirects to another page will not be tracked by wicket tester. So this potentially a problem for all kinds of tests that rely on absolute redirects.$$patch1-wicket-30255f11_Developer_PatchNaturalnessYe$$Removed final modifier from Url . parse ( ). Fix Url instance correctly set host and port. Removed unnecessary semicolon .. $$1
wicket-b4e9d426$$WicketSessionFilter and HttpSessionStore use different attribute name for Wicket Session$$from this topic  http://apache-wicket.1842946.n4.nabble.com/WicketSessionFilter-and-ignorePaths-in-WicketFilter-td3570291.html Please, look at the second post (the ignorePaths param is not linked with this issue as the title suggests).  How to reproduce with the quickstart: 1. open localhost:8080 - a wicket test page is displayed. 2. open localhost:8080/external - this is the external servlet that tries to access the wicket session. An exception is thrown.$$patch1-wicket-b4e9d426_Developer_PatchNaturalnessYe$$fixed test data. $$1
wicket-dd1df04b$$onError call order doesn't match onSubmit$$onError in Forms and Buttons should be called in the same order as onSubmit (i.e. post-order).$$patch1-wicket-dd1df04b_Developer_PatchNaturalnessYe$$cleaned up error reporting. added error filter. added onSubmitBefore / AfterForm methods. Removed 1226 comment. $$1
wicket-7e7ab76c$$TextField ingnores convertEmptyInputStringToNull = true property when the String type is set$$I posted this patch on WICKET-3269, but the discussion on this ticket is about an improvement request, not a bug. I opened this one for the bug.$$patch1-wicket-7e7ab76c_Developer_PatchNaturalnessYe$$Removed unused imports. Added missing documentation. Fixed null / empty string handling in AbstractTextComponent. remove debug code. revert 8e704f627c7b03427ab1b71bb. $$1
wicket-ea4a3f8a$$PageParameters construced with keyValuePairs does not handle array values$$The PageParameters constructor that takes a "keyValuePairs" argument does not convert repeated keys into an array of values.  For example:  {code} // specify three comma delimited values for the "a" parameters PageParameters parameters = new PageParameters("a=1,a=2,a=3"); String[] a = parameters.getStringArray("a"); assertEquals(3, a.length); // fails because a.length == 1 {code}  Issue first described on the user's list: http://www.nabble.com/PageParameters-with-String-array-question-to22540294.html$$patch1-wicket-ea4a3f8a_Developer_PatchNaturalnessYe$$revert 149 change. remove unused imports. made ValueMap constructor parameter nullable. ValueMap # add ( String , Object ). add putAll with Map < ? extends String , ? extends Object >. wicket + use leftovers in ValueMap. Remove unused code. improve value map. add missing try catch block. add missing throwing. improve value map. made final. add final modifier to getAsDuration ( String ). made final. add final modifier to getAsTime ( ). made getTimeProvider ( ) allow override of default value. allow override of default value for enum implementation .. wicket added missing value for parameter ' pos '. $$1
wicket-3feb0e3a$$MarkupContainer.removeAll() does not detach models recursively$$ML thread at: http://markmail.org/message/ybdfd2ts4i3j2b72$$patch1-wicket-3feb0e3a_Developer_PatchNaturalnessYe$$Fix MarkupContainer ' s detach method. $$1
wicket-beb9086d$$setResponsePage in AjaxLink goes always to localhost:8080 instead to the right host and port$$setResponsePage in an AjaxLink in Wicket 1.4 redirects with a relative path to the response page. Wicket 1.5 takes the absolute path "localhost:8080/path to the response page" even when the host and port are different. (e.g. with Apache2 a virtual host is created with server name www.mycompany.com, setResponce wil go to "localhost:8080/path to page" instead of  "www.mycompany.com/path to page")$$patch1-wicket-beb9086d_Developer_PatchNaturalnessYe$$Remove getAbsoluteURL from ServletWebResponse. $$1
wicket-9e6efa61$$The DateTimeField.onBeforeRender() method does not format the fields correctly.$$The current implementation relies on the org.joda.time.MutableDateTime instance to format the date, hours, amOrPm, and minutes fields. Unfortunately, the MutableDateTime constructor is not provided with the client's TimeZone value (assuming it is set). As a result, the joda library uses the JVM's default timezone. If the defaul timezone differs from the client's timezone, the formatted fields may turn out to be incorrect.$$patch1-wicket-9e6efa61_Developer_PatchNaturalnessYe$$Fixed client timezone in DateTimeField .. $$1
wicket-7da4ad17$$EnumChoiceRenderer misbehaves with anonymous enum classes$$Please find attached testcase reproducing the problem.  Proper fix is to do return object.getDeclaringClass().getSimpleName() + "." + object.name()  instead of return object.getClass().getSimpleName() + "." + object.name()  in EnumChoiceRenderer.resourceKey$$patch1-wicket-7da4ad17_Developer_PatchNaturalnessYe$$Change EnumChoiceRenderer resource key from < T > to < T > .. $$1
wicket-ddf7e8a2$$Links with multiple parameters are wrongly generated$$If you have a PageParameters, with multiple params, then the resulting link will be something like this /url?id=123&amp;sid=456, so for some reason the & sign is encoded to &amp; which will result in the following parameters on the receiving page: id=[123], amp;sid=[456] See the attached quickstart for example.$$patch1-wicket-ddf7e8a2_Developer_PatchNaturalnessYe$$Removed unused imports. Don ' t replace HTML attributes with HTML attributes. Removed url replace replace with ""&"" in HTML tag. wicket - utils - replace replace with /. $$1
wicket-97514205$$In wicket 1.5 urlFor returns incorrect string for package mounted pages$$Attached two quickstart projects for 1.4 and 1.5.  Then access http://localhost:8080/app/Page1 and see 1.5 returns wrong address.$$patch1-wicket-97514205_Developer_PatchNaturalnessYe$$Remove unneeded import. add missing super call to mountPackage ( String , Class ). Removed package separator from package url in case we had source class that was not in the package. $$1
wicket-f5f802c5$$NumberTextField doesn't accept values <=0 for Double and Float$$The org.apache.wicket.util.lang.Numbers class defines the method : public static Number getMinValue(Class<? extends Number> numberType)  This method return the MatchingNumberTypeClass.MIN_VALUE. But for Double.MIN_VALUE and Float.MIN_VALUE return the smallest positive number, not the smallest negative number like for the other number classes.  One side effect is that by default you can't enter a negative value, or a 0 in a NumberTextField<Double> or NumberTextField<Float>.$$patch1-wicket-f5f802c5_Developer_PatchNaturalnessYe$$Fixed formatting. Fixed formatting issue. Fixed no - min default value for Double. $$1
wicket-e2d88568$$AjaxPreprocessingCallDecorator calls the delegate decorator before itself (same behavior as AjaxPostprocessingCallDecorator)$$AjaxPreprocessingCallDecorator calls the delegate decorator before itself (same behavior as AjaxPostprocessingCallDecorator), when it should call itself before the delegate.$$patch1-wicket-e2d88568_Developer_PatchNaturalnessYe$$Fix AJAX - 661. Fix whitespace. Fix AJAX error in AJAX request inner closure. $$1
wicket-2b6da516$$SimpleTree example not working with CryptoMapper$$Adding the following lines to WicketExampleApplication.java causes the SimpleTree example to break. There are no expand icons anymore and there is no way to expand the tree. Even the expand link will not work.  Add to WicketExampleApplication.java   IRequestMapper cryptoMapper = new CryptoMapper(getRootRequestMapper(), this); setRootRequestMapper(cryptoMapper);   Comment out in WicketExampleApplication.java   //getSecuritySettings().setCryptFactory(new ClassCryptFactory(NoCrypt.class, ISecuritySettings.DEFAULT_ENCRYPTION_KEY));  Without the CryptoMapper everythings works fine.$$patch1-wicket-2b6da516_Developer_PatchNaturalnessYe$$Remove debug code. Fixed nit on length of encrypted URL , closes # 1796. remove debug code. add new segments from browser. $$1
wicket-145da021$$SecuritySettings.setEnforceMounts() does not work when the mounted mapper is not in the root compound mapper$$BookmarkableMapper.isPageMounted() assumes that all mounted mappers are in Application.getRootRequestMapperAsCompound(). Sometimes the mappers make a tree structure, with multiple compounds existing, sometimes separated by wrappers, like HttpsMapper and CryptoMapper.  Because of this, BookmarkableMapper fails to realise that a page is mounted and so does not enforce mounting.$$patch1-wicket-145da021_Developer_PatchNaturalnessYe$$add missing import. fix # 5094 - only allow mount if page is mounted. wicket - api / org / wicket / request / mapper / AbstractBookmarkableMapper. $$1
wicket-15477252$$ajax not working due to bugs in resource handling$$A couple of bugs were found that were preventing .js resources to be returned to the client correctly. One bug was returning the jar file size as the content length of the resource if it is in a jar file. The other was copying past a source buffer into the response.  After fixing these bugs, the ajax functions in the trunk seems to be working.  A patch is provided. Test cases included.$$patch1-wicket-15477252_Developer_PatchNaturalnessYe$$Fix bug in AbstractResource . write ( ). Fix NPE. Log if / else with long form workflow. $$1
wicket-ad849602$$Redirect to HTTPS is using wrong port 80 if HttpsConfig with default ports 80/443 is used$$HttpsMapper#mapHandler() doesn't set the Url's port, if the desired protocol uses the standard port.  This leads to UrlRenderer choosing to the request's port as fallback (which is 80 before switching to https).$$patch1-wicket-ad849602_Developer_PatchNaturalnessYe$$Remove unnecessary check for non - standard port. $$1
wicket-c86b972a$$Set an request parameter on Wicket tester do not add it in the request URL$$When submitting an form, the parameters set in request do not get appended to the URL query string. Initial impression is that UrlRender should append query parameters in the base URL on relatives URL.$$patch1-wicket-c86b972a_Developer_PatchNaturalnessYe$$Fixed issue with query parameters being empty string ( or sometimes empty string ). $$1
wicket-9dab1bb5$$bug in Duration.toString(Locale locale)$$Duration.toString(Locale locale) misses milliseconds in line 529$$patch1-wicket-9dab1bb5_Developer_PatchNaturalnessYe$$Fix TimeUnit format. $$1
wicket-5e1bf8d8$$Do not use the parsed PageParameters when re-creating an expired page$$WICKET-4014 and WICKET-4290 provided functionality to re-create an expired page if there is a mount path in the current request's url. There is a minor problem with that because the page parameters are passed to the freshly created page. I.e. parameters for a callback behavior are now set as page construction parameters. Since the execution of the behavior is ignored for the recreated page these parameters should be ignored too.$$patch1-wicket-5e1bf8d8_Developer_PatchNaturalnessYe$$ignore pageParameters for stateful pages. $$1
wicket-d450acb0$$Errors reported from Form#onValidateModelObjects() are ignored$$None$$patch1-wicket-d450acb0_Developer_PatchNaturalnessYe$$Avoid NPE in Form when error is found in submitted form .. $$1
wicket-5837817c$$OnChangeAjaxBehavior should listen for both 'inputchange' and 'change' events for TextField and TextArea$$WICKET-5603 introduced a regression that a TextField using OnChangeAjaxBehavior doesn't work anymore when used as date picker, or Select2. The problem is that usually extensions like DatePicker and Select2 will fire 'change' event when they update the text input.  OnChangeAjaxBehavior should use both 'inputchange" and "change" events for TextField and TextArea components.$$patch1-wicket-5837817c_Developer_PatchNaturalnessYe$$Added ChangeAjaxBehavior event name and code for ' inputchange '. wicket - form - > ' change ' event name. $$1
wicket-5ad32df9$$Component's markup cannot be found in Ajax requests if the parent is transparent$$When TransparentWebMarkupContainer is used an inner markup container cannot find its markup on Ajax updates. The problem seems to be caused by the fact that ComponentResolvers#resolve() is not executed and since there is transparent container involved Markup.find(String) cannot find the markup for non-transparent markup containers. I'll commit a disabled test case that shows the problem.$$patch1-wicket-5ad32df9_Developer_PatchNaturalnessYe$$Remove unused imports. Allow null to be empty string ( or empty string ). add missing import. using getMarkup ( ) on MarkupContainer is not a async API. add missing import. Allow null to be included in a component. Added Error message for failed builds. Allow null to be added to aMarkupContainer. $$1
wicket-4ee5ad1f$$Stack overflow when render malformed html.$$Stack overflow when render malformed html.  Please, note that </HEAD> element is inserted after </body>.  HTML: <html> <head> <body> Malformed HTML </body> </head> </html>  Java: package com.mycompany;  import org.apache.wicket.markup.html.WebPage; public class Test1 extends WebPage { 	private static final long serialVersionUID = -4267477971499123852L;  }   Thanks.$$patch1-wicket-4ee5ad1f_Developer_PatchNaturalnessYe$$Removed unused imports. Added ignoreTheRest flag to HtmlHeaderSectionHandler. wicket - 917 - updated parser course - I am using the component model in the < head. Added wicket - note - that < body > is not valid in < HEAD > tag. $$1
wicket-0e70ce39$$"isPrimary" check is not applied to beans in parent contexts$$see this comment in WICKET-2771: https://issues.apache.org/jira/browse/WICKET-2771?focusedCommentId=12872246&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12872246$$patch1-wicket-0e70ce39_Developer_PatchNaturalnessYe$$Added missing import. fixed a similar issue with AnnotProxyFieldValueFactory. getBeanDefinition ( AbstractApplicationContext ) - > getBeanDefinition ( ). Added support for field type in AnnotProxyFieldValueFactory. Added missing import. Fix possible NPE in SpringBeanLocator. Fix broken build. Added support for bean names with @ deprecated javadoc tags. $$1
wicket-614e3b50$$improve wicket's handling of empty / null page parameters$$- DefaultPageFactory#newPage() should be sure to not pass 'null' to a page constructor with page parameters$$patch1-wicket-614e3b50_Developer_PatchNaturalnessYe$$wicket - request . ajax . isEmpty ( ) disable ajax optimization. $$1
wicket-6cceff44$$DefaultPropertyResolver does not respect JavaBean conventions$$The property name code should handle the isPropertyName pattern  if(getterName.startsWith("get")) { 	name = getterName.substring(3, 4).toLowerCase() + getterName.substring(4); } else { 	name = getterName.substring(2, 3).toLowerCase() + getterName.substring(3); }  Workaround: providing my own property resolver.$$patch1-wicket-6cceff44_Developer_PatchNaturalnessYe$$Added missing import. Allow property getters to be specified with the correct name .. $$1
wicket-0d4d1df7$$Session should be bound when adding messages to it$$When using the Sessions info(), error() and success() methods, and the session is temporary, the messages can be dropped silently. This happens when on stateless pages and a redirect happens in the same request during which a session message is added.  The fix for this could be to make sure the session is bound and call Session#bind() automatically when a session message is added.  Email thread: http://wicket-users.markmail.org/thread/zd72s4gwnlp5d7ch$$patch1-wicket-0d4d1df7_Developer_PatchNaturalnessYe$$Remove unused imports. add code to check for session feedback messages. $$1
wicket-9a6a06be$$NullPointerException in org.apache.wicket.markup.html.form.ValidationErrorFeedback$$org.apache.wicket.markup.html.form.ValidationErrorFeedback throws a NPE in the following situation:  - Form with a TextField<Integer> that has a RangeValidator - value outside range is entered - form is submitted  See attached quickstart.$$patch1-wicket-9a6a06be_Developer_PatchNaturalnessYe$$Adding default message if one is not set .. $$1
wicket-ccd74641$$The default exception mapper is replying cacheable exceptional responses$$The problem is that some common URLs in the application like to a page instance are responding the cached exception page rather than hitting the server for the page instance being requested. It happens because at some moment in the past a exception page were replied and cached for a request in this URL.$$patch1-wicket-ccd74641_Developer_PatchNaturalnessYe$$Remove unused imports. disable caching for exceptional responses in WebResponse. $$1
wicket-21a47387$$Resource bundles are not resolved on PriorityHeaderItems$$If a bundle X provides resource A, and resource A is rendered as priority header item, the resource A is rendered, not bundle X.$$patch1-wicket-21a47387_Developer_PatchNaturalnessYe$$Fix whitespace. wicket - util - wicket - util - wicket - util - wicket - util - wicket - util. I wrapped the header item up until we get the real response. $$1
wicket-ed780cc7$$Parantheses problem with UrlValidator$$One of our users got an error message when trying to add a new URL:  'http://en.wikipedia.org/wiki/Genus_(mathematics)' is not a valid URL  I just created very quickly a junit test and it fails:  String[] schemes = {"http"}; UrlValidator urlValidator = new UrlValidator(schemes); assertTrue(urlValidator.isValid("http://en.wikipedia.org/wiki/Genus_(mathematics)"));$$patch1-wicket-ed780cc7_Developer_PatchNaturalnessYe$$add missing backslash. $$1
wicket-294b0b2f$$When using Servlet 3.0 filter Wicket calculates filter path wrong$$When using a servlet 3.0 filter with annotations Wicket calculates the filter path wrong causing it to not match any pages other than the home page.  e.g.  {code} @WebFilter(value = "/web/*", initParams = {@WebInitParam(name = "applicationClassName", value = "com.example.CheesrApplication")}) public class CheesrFilter extends WicketFilter { } {code}  Will cause Wicket to create a filter path of /web/*/ instead of the expected /web.$$patch1-wicket-294b0b2f_Developer_PatchNaturalnessYe$$Removed the last char from the pattern parameter in the URL .. $$1
wicket-b92591f6$$Queueing component in autocomponent$$There is an exception when a component is added to queue when its parent is an auto component  <body> 		<a href="panier.html"> 			<span wicket:id="inlink"></span> 		</a> 	</body>   Last cause: Unable to find component with id 'inlink' in [TransparentWebMarkupContainer [Component id = wicket_relative_path_prefix_1]] 	Expected: 'wicket_relative_path_prefix_1:inlink'. 	Found with similar names: ''$$patch1-wicket-b92591f6_Developer_PatchNaturalnessYe$$made html header resolver public ( I think ). Removed erroneous @. wicket - 11727 FixRelativePathPrefixHandler. Added check for insideHead. Added missing javadoc. wicket - 7733 - RelativePathPrefixHandler now allows queued children components. Reduced check for isHeadTag ( ). Added auto component factory method to MarkupContainer .. Add note about component resolvers thread - safe. Updating Deprecated warning in ComponentTag. added missing MarkupContainer arg. Added missing method. $$1
wicket-ebe56869$$Dynamically adding component via an IComponentResolver fails within an enclosure for versions after 1.4.1$$We have been using an IComponentResolver implementation for a long time to allow the inclusion of certain panels to be determined by the markup. Some panels are included inside enclosures and some are not. Both cases worked fine in wicket 1.4.1 but in versions 1.4.2 and later a 'Tag expected' error occurs if the component is wrapped inside a wicket enclosure.  A quickstart example has been included to demonstrate the problem.$$patch1-wicket-ebe56869_Developer_PatchNaturalnessYe$$Removed unused imports. Reduce visibility for enclosed WebMarkupContainer. added missing "" childComponent "" method. wicket - 20066 fixed nullability check. Removed erroneous check for child component. Updating enclosure resolve method. Suppress onAfterRender Javadoc warning. Added missing import. Added Error message for failed add ( ). added code style fixes. Added resolveByApplication ( ) method that attempts to resolve a component by application - level resolver. Added resolveByComponentHierarchy method. add toString ( ) to BufferedWebResponse. $$1
wicket-961f2477$$URL query parameter values containing equals sign get cut off$$When calling a page with a query parameter like 'param1=val1=val2' the value of 'param1' obtained from PageParameters will be 'val1'. Everything after the equals sign inside the parameter value gets cut off.$$patch1-wicket-961f2477_Developer_PatchNaturalnessYe$$remove debug code. $$1
wicket-e62ded51$$discrepancy between JavaDoc and code in MarkupContainer#visitChildren()$$The JavaDoc for  MarkupContainer#visitChildren() states that  "@param clazz The class of child to visit, or null to visit all children"  The parameter clazz is used to create a new ClassVisitFilter which in its visitObject() does not check for clazz == null, leading to a NPE.$$patch1-wicket-e62ded51_Developer_PatchNaturalnessYe$$null check in ClassVisitFilter. $$1
wicket-e350f19e$$PropertyValidator ignoring groups with the @NotNull annotation only$$When using groups in your JSR303 compliant classes, Wicket does not honor the groups for the @NotNull annotation.$$patch1-wicket-e350f19e_Developer_PatchNaturalnessYe$$Updated javadoc. Added missing imports. Fix copy / paste error. Added TODO. If property ' s required flag is set , set the required flag on the component .. workflow improvements - added workflow improvements. Fix typo .. Fix typo in wicket - bean - validation. add missing context parameter. add locale parameter. $$1
wicket-f1c9cef2$$MarkupContainer.toString(true) fails with MarkupNotFoundException if the call is made in the component constructor$$org.apache.wicket.MarkupContainer.toString(boolean) uses "if (getMarkup() != null)" to decide whether to write something for the markup but since recently Component#getMarkup() throws MarkupNotFoundException when there is no markup and doesn't return null.$$patch1-wicket-f1c9cef2_Developer_PatchNaturalnessYe$$MarkupContainer doesn ' t add children to the toString method , but I ' m getting an. Remove detailed component lookup in findPage ( ). applied patch for {. $$1
wicket-6cefb9f8$$Behaviors#internalAdd(Behavior) erroneously gets id for stateless behaviors$$see http://markmail.org/thread/jtd4zn527r343jbm$$patch1-wicket-6cefb9f8_Developer_PatchNaturalnessYe$$"Revert "" remove statelessHint ( Component ) """. $$1
wicket-71499e17$$UrlAttributes are encoded incorrectly when style is null but variation is not$$AbstractResourceReferenceMapper.encodeResourceReferenceAttributes() method generates the same "-foo" output for these two different inputs: {locale = null, style = "foo", variation = null} and {locale = null, style = null, variation = "foo"}. For the second input it should generate "--foo" (double dash prefix).$$patch1-wicket-71499e17_Developer_PatchNaturalnessYe$$wicket - request . mapper . AbstractResourceReferenceMapper doesn ' t ignore style empty string in JS. $$1
wicket-0578d6ee$$Invalid javascript when setStripJavascriptCommentsAndWhitespace is enabled$$When setStripJavascriptCommentsAndWhitespace is enabled (for example in deployment mode), some javascript files get corrupted. For example, the following line (notice the 2 spaces after 'return') return  this.__unbind__(type, fn); is compacted to return this.__unbind__(type, fn); which does not execute the unbind function.$$patch1-wicket-0578d6ee_Developer_PatchNaturalnessYe$$Add @ author tag. Add js comments removal. Add newline in whitespace. Allow one - line ifs. Allow underscores in JS stripper. Allow whitespace to be ignored after stripper state = WHITE_SPACE. $$1
wicket-986848f7$$FormTester doesn't correctly submit a form when a FileUploadField was not set (which is not required)$$FormTester doesn't correctly submit a form when  a FileUploadField was not set. This file is not required.  So it is impossible to create a real test because I am forced to always set a File to check to whole form.  There was discussion about this problem here: http://www.nabble.com/FormTester-and-FileUploadField-td18566869.html   I will be very grateful if you can fix it :) Artur$$patch1-wicket-986848f7_Developer_PatchNaturalnessYe$$Removed redundant read method. $$1
wicket-d78132be$$CryptoMapper ignores original queryString parameters$$When an AjaxRequest with parameters (e.g.: Autocomplete.getChoices()) arrives and CryptoMapper decrypts it, original queryString parameters dissapears.  Debugging CryptoMapper, I've checked that this method: private Url decryptUrl(final Request request, final Url encryptedUrl) {         ... }  receives querystrings parameters (on field url.parameter from "request" parameter) and the new Url returned by the method never adds them to its own list.$$patch1-wicket-d78132be_Developer_PatchNaturalnessYe$$add WICKET - 4923 additional parameters. $$1
wicket-2b1ce91d$$Page not mounted with WebApplication#mountPackage$$A bookmarkable page FormPage is mounted via WebApplication#mountPackage().  If this page is opened via IModel model; setResponsePage(new FormPage(IModel model)); then the URL is /wicket/page?0 which is not mounted.  If the page is mounted via WebApplication#mountPage() then the URL is mounted as expected.  If the page is not mounted then the users get PageExpiredException which in this case is unrecoverable.$$patch1-wicket-2b1ce91d_Developer_PatchNaturalnessYe$$Removed erroneous blank line. $$1
wicket-518c933b$$Url#toString(StringMode.FULL) throws exception if a segment contains two dots$$When invoking toString(StringMode.FULL) for a URL like /mountPoint/whatever.../ an IllegalStateException is thrown with message: Cannot render this url in FULL mode because it has a `..` segment: /mountPoint/whatever.../  The method does not actually check for `..` segments but rather checks whether path.contains("..")$$patch1-wicket-518c933b_Developer_PatchNaturalnessYe$$Allow url to be rendered in full mode because it has a .. $$1
wicket-ecdfc124$$WebPageRenderer must not render full page in Ajax requests$$WebPageRenderer renders the full page when WebRequest#shouldPreserveClientUrl() is true or RedirectStrategy.NEVER_REDIRECT is configured.  For Ajax request this means that wicket-ajax-js will not be able to parse the HTML response.$$patch1-wicket-ecdfc124_Developer_PatchNaturalnessYe$$add code to ignore ajax requests. $$1
wicket-0374c040$$AjaxRequestAttributes extra parameters aren't properly handled in getCallbackFunction()$$extra parameters of an Ajax behaviour can be accessed by getRequest().getRequestParameters().getParameterValue(key)  but if one uses getCallbackFunction() of an AbstractDefaultAjaxBehavior, these parameters get screwed and can no longer be accessed in the same manner.   the problem seems to be the merge in attrs.ep = Wicket.merge(attrs.ep, params);$$patch1-wicket-0374c040_Developer_PatchNaturalnessYe$$Allow missing JSON for extra parameters. $$1
wicket-fd910746$$FormComponents remain invalid forever if there is no feedback panel$$if there is no feedback panel the error messages are not removed in ondetach and form component re-validation is skipped so the form component, once marked as invalid, will remain invalid forever or at least until its error messages are rendered.  the error messages should be dropped and the form component should be re-validated on every form submit.$$patch1-wicket-fd910746_Developer_PatchNaturalnessYe$$wicket - 11648 - Remove a redundant validate in Form. $$1
wicket-6e794ad0$$404 Error on Nested ModalWindows in IE7 and IE8$$When opening a ModalWindow inside a ModalWindow, the inner ModalWindow generates a 404 error.  Both windows use a PageCreator for content.  To replicate, you must use an actual IE 7 or IE 8 browser, as this does not replicate using developer tools and setting the document and brower to IE 7.  The problem can be seen at http://www.wicket-library.com/wicket-examples/ajax/modal-window.  I will attach a Quickstart as well.$$patch1-wicket-6e794ad0_Developer_PatchNaturalnessYe$$Updating old import. Fixed url segmentation. make exception if the homepage was not mounted. wicket / bookmarkable / com .. $$1
wicket-5729ed90$$AbstractMarkupParser doesn't remove Comments correctly$$AbstractMarkupParser removeComment(...) doesn't remove Comments correctly  if two html comments stand to close together <!-- foo --> <!-- bar --> foo will be removed but not bar.  see:  https://github.com/mafulafunk/wicketComments  git@github.com:mafulafunk/wicketComments.git$$patch1-wicket-5729ed90_Developer_PatchNaturalnessYe$$Removed unused imports. Removed unnecessary modifier .. Allow ' <!-- ' tag to be parsed as HTML fragment , probably by SpringLoaded .. $$1
wicket-ceac38b1$$Component Use Check always fails for visible components inside an invisible border body$$None$$patch1-wicket-ceac38b1_Developer_PatchNaturalnessYe$$add missing import. added TODO. $$1
wicket-c66cf607$$Link always causes Page to become stateful, regardless of visibility$$Despite the changes made in WICKET-4468 , an invisible Link still causes a Page to become stateful.   The problem seems to be that Component#isStateless does this before even checking the visibility:   		if (!getStatelessHint()) 		{ 			return false; 		}   ... and Link#getStatelessHint() just contains just "return false" .$$patch1-wicket-c66cf607_Developer_PatchNaturalnessYe$$Remove stateless Hint from Controller. Added missing if (. $$1
wicket-aa1d177a$$DataTable row groups are present in markup even when they contain no rows.$$As per the HTML spec : "When present, each THEAD, TFOOT, and TBODY contains a row group. Each row group must contain at least one row, defined by the TR element."  There is no check in place to remove the row group tags from the output if they don't contain any row.$$patch1-wicket-aa1d177a_Developer_PatchNaturalnessYe$$add missing import. addDT - 7744 - Missing two axes constructor. add toolbar to the container. Added a constructor that implements interface to IDE .. Do not go deeper if the data table doesn ' t exist. $$1
wicket-9c8f658a$$AjaxFormChoiceComponentUpdatingBehavior fails for choices containing other invalid FormComponents$$If a TextField inside a RadioGroup has a ValidationError, processing of AjaxFormChoiceComponentUpdatingBehavior will erroneously update the group's model:  - RadioGroup#validate() does not convert the input, because #isValid() returns false (since the nested textfield has an error message) - the behavior tests #hasErrorMessage() on the group, which returns false (since the group itself doesn't have an error message) - the behavior continues processing with a null value$$patch1-wicket-9c8f658a_Developer_PatchNaturalnessYe$$added log level exception. Fixed a typo in AJAX form componentUpdatingBehavior. add warning. revert error handling. Added onError ( target , null ) to invalid form components .. $$1
wicket-56169634$$Page mount with an optional named parameter overtakes a mount with more specific path$$See the discussion in http://markmail.org/thread/sgpiku27ah2tmcim  Having:   mountPage("/all/sindex",Page1.class);   mountPage("/all/#{exp}", Page2.class);  Request to /all/sindex will be handled by Page2.  Compatibility score for optional parameters should be lower than mandatory parameters which should be lower than exact value.$$patch1-wicket-56169634_Developer_PatchNaturalnessYe$$update score for pathSegments. $$1
wicket-ab1856db$$RequestCycleListenerCollection.onException should not throw an exception when multiple listeners handle the exception$$When multiple listeners handle the exception, RequestCycleListenerCollection should simple take the first handler. The current approach makes it impossible to add a listener that handles all exceptions and later add listeners for specific exceptions. Simply removing the 'if (handlers.size() > 1)' should suffice.$$patch1-wicket-ab1856db_Developer_PatchNaturalnessYe$$Added TODO. Added missing javadoc. Log exception if multiple exception handlers were found. $$1
wicket-1b7afefc$$AjaxEventBehavior#onEvent is invoked on disabled behavior$$Security bug  AjaxEventBehavior#onEvent is invoked on disabled behavior. It should not be - it is really dangerous, can you fix it.  I think it is security bug.$$patch1-wicket-1b7afefc_Developer_PatchNaturalnessYe$$Allow default behavior to be ignored .. $$1
wicket-a88882f7$$Wicket example 'forminput' is broken due to bad url for IOnChangeListener$$http://localhost:8080/forminput (wicket-examples) doesn't change the locale of the labels when the locale select is changed. The reason seems to be the produced url: './.?5-1.IOnChangeListener-inputForm-localeSelect'  This is parsed to a Url with one empty segment and thus HomePageMapper doesn't match it and doesn't handle it.$$patch1-wicket-a88882f7_Developer_PatchNaturalnessYe$$wicket - request url does not contain a .. $$1
wicket-31c88569$$Queuing a component in head$$Queuing a component which is in the head section doesn't work : <head> 	<meta charset="utf-8" /> 	<title wicket:id="titre">Test</title> </head>$$patch1-wicket-31c88569_Developer_PatchNaturalnessYe$$ wicket - 7733 - missing import. Added static final class to HtmlHeaderSectionHandler. Set auto component factory to avoid copy and paste error. Set the auto component factory on tag close. Removed unused AutoComponentFactory on head .. Added auto - component factory to html header section handler. $$1
wicket-081cdeb2$$ResourceMapper throws IllegalStateException when attempting to map a request to a URL ending in a empty segment (directory)$$ResourceMapper.mapRequest() calls ResourceMapper.removeCachingDecoration() which, throws IllegalStateException if the URL's last segment is an empty string.  URLs like: path/to/my/non/wicket/directory/ end in a empty segment.   We must change the behaviour to not attempt to undecorate a URL ending in an empty segment.$$patch1-wicket-081cdeb2_Developer_PatchNaturalnessYe$$wicket - request . mapper . ResourceMapper should not ignore empty filenames. $$1
wicket-12124902$$RequestHandler listeners are called with null handler$$When running RequestCycleListeners with WicketTester, they get called with null for the requesthandler in onScheduleHandler(). This is an artifact of the wicket tester requestcycle, which I think should normally not occur in Wicket processing. The parameters are not marked as optional, so it is IMO safe to assume that handler should never be null.  I propose to modify scheduleRequestHandlerAfterCurrent(IRequestHandler handler) to not invoke the listeners when the handler is null, but only to clear the current scheduled handler.$$patch1-wicket-12124902_Developer_PatchNaturalnessYe$$only forward requests to the listeners when handler is null. $$1
wicket-b772ff87$$Null model for AttributeAppender should not render empty attribute$$I can't think of a reason this would be valid, but passing in null model renders <span class="">Test</span>.  If previous and new attribute are both null, the component should render cleanly like <span>Test</span>.$$patch1-wicket-b772ff87_Developer_PatchNaturalnessYe$$Fixed a bug where AttributeAppender . isEmpty ( ) returns null when the value is empty .. $$1
wicket-747bccb5$$WicketTester does not follow absolute redirects$$Wicket tester does not follow absolute redirects:  This is a problem when using HttpsMapper. For example when requesting a page over http:// with an forced redirect to https:// for secure access will make wicket tester return 'null' for the last renderer page instead of the rendered page instance. In general all kinds of absolute redirects to another page will not be tracked by wicket tester. So this potentially a problem for all kinds of tests that rely on absolute redirects.$$patch1-wicket-747bccb5_Developer_PatchNaturalnessYe$$add missing import. parse url string to an object with query string. cleaned up documentation. strtolower the protocol name. Fix NPE in Url class. Fix Url . getDefaultPortForProtocol ( String ). Remove old comment. $$1
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch1-math-8e5867ed_Developer_PatchNaturalnessYe$$Fix precision test. Fix rounding method name. $$1
math-996c0c16$$EnumeratedRealDistribution.inverseCumulativeProbability returns values not in the samples set$$The method EnumeratedRealDistribution.inverseCumulativeProbability() sometimes returns values that are not in the initial samples domain... I will attach a test to exploit this bug.$$patch1-math-996c0c16_Developer_PatchNaturalnessYe$$Add missing import. Add inverseCumulativeProbability ( ) to EnumeratedRealDistribution. $$1
math-185e3033$$GammaDistribution cloning broken$$Serializing a GammaDistribution and deserializing it, does not result in a cloned distribution that produces the same samples.  Cause: GammaDistribution inherits from AbstractRealDistribution, which implements Serializable. AbstractRealDistribution has random, in which we have a Well19937c instance, which inherits from AbstractWell. AbstractWell implements Serializable. AbstractWell inherits from BitsStreamGenerator, which is not Serializable, but does have a private field 'nextGaussian'.  Solution: Make BitStreamGenerator implement Serializable as well.  This probably affects other distributions as well.$$patch1-math-185e3033_Developer_PatchNaturalnessYe$$Fixed a javadoc bug in BitsStreamGenerator. $$1
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch1-math-e2dc384d_Developer_PatchNaturalnessYe$$Fix slightly changed symbol. Fix default value if ( ( value < 0 ) || ( value < 1 ). $$1
math-ad252a8c$$EigenDecomposition fails for certain matrices$$The Schurtransformation of the following matrix fails, which is a preliminary step for the Eigendecomposition:  RealMatrix m = MatrixUtils.DEFAULT_FORMAT.parse("{{0.184944928,-0.0646971046,0.0774755812,-0.0969651755,-0.0692648806,0.3282344352,-0.0177423074,0.206313634},{-0.0742700134,-0.028906303,-0.001726946,-0.0375550146,-0.0487737922,-0.2616837868,-0.0821201295,-0.2530000167},{0.2549910127,0.0995733692,-0.0009718388,0.0149282808,0.1791878897,-0.0823182816,0.0582629256,0.3219545182},{-0.0694747557,-0.1880649148,-0.2740630911,0.0720096468,-0.1800836914,-0.3518996425,0.2486747833,0.6257938167},{0.0536360918,-0.1339297778,0.2241579764,-0.0195327484,-0.0054103808,0.0347564518,0.5120802482,-0.0329902864},{-0.5933332356,-0.2488721082,0.2357173629,0.0177285473,0.0856630593,-0.35671263,-0.1600668126,-0.1010899621},{-0.0514349819,-0.0854319435,0.1125050061,0.006345356,-0.2250000688,-0.220934309,0.1964623477,-0.1512329924},{0.0197395947,-0.1997170581,-0.1425959019,-0.274947791,-0.0969467073,0.060368852,-0.2826905192,0.1794315473}}");$$patch1-math-ad252a8c_Developer_PatchNaturalnessYe$$Updated SchurTransformer with one more root - > one more .. Fix the for - loop of SchurTransformer .. Fix a bug in SchurTransformer where the norm of the vector is not greater than the norm. Fix final SchurTransformer . abs ( ) .. Removing epsilon from SchurTransformer . java. Fix optimisation on SchurTransformer .. Fix SchurTransformer . java. Fix SchurTransformer . equals ( ) , added missing if (. Fix SchurTransformer . java. Fix the for loop. $$1
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-f6dd42b4_Developer_PatchNaturalnessYe$$Added missing error message. Added a message to the error message. Added missing bracketing message .. $$1
math-b9ca51f0$$Need range checks for elitismRate in ElitisticListPopulation constructors.$$There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.$$patch1-math-b9ca51f0_Developer_PatchNaturalnessYe$$Improve doc string .. ElitisticListPopulation constructor should set the elitism rate before setting the population .. ElitisticListPopulation can set the elitism rate to the constructor .. $$1
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch1-math-328513f3_Developer_PatchNaturalnessYe$$removed unused import. Added missing javadoc. removed try catch block. $$1
math-2b852d79$$SpearmansCorrelation fails when using NaturalRanking together with NaNStrategy.REMOVED$$As reported by Martin Rosellen on the users mailinglist:  Using a NaturalRanking with a REMOVED NaNStrategy can result in an exception when NaN are contained in the input arrays.  The current implementation just removes the NaN values where they occur, without taken care to remove the corresponding values in the other array.$$patch1-math-2b852d79_Developer_PatchNaturalnessYe$$added missing import. Added missing documentation. added missing rankTransform call. added missing rankTransform call. added missing final modifier to method computeCorrelationMatrix. Fix NaN strategy matching in rankTransform ( ) .. $$1
math-48dde378$$DerivativeStructure.atan2(y,x) does not handle special cases properly$$The four special cases +/-0 for both x and y should give the same values as Math.atan2 and FastMath.atan2. However, they give NaN for the value in all cases.$$patch1-math-48dde378_Developer_PatchNaturalnessYe$$Fix DSCompiler . atan2 ( x , y ). $$1
math-73605560$$Line.revert() is imprecise$$Line.revert() only maintains ~10 digits for the direction. This becomes an issue when the line's position is evaluated far from the origin. A simple fix would be to use Vector3D.negate() for the direction.  Also, is there a reason why Line is not immutable? It is just comprised of two vectors.$$patch1-math-73605560_Developer_PatchNaturalnessYe$$revert line direction. $$1
math-7994d3ee$$"HarmonicFitter.ParameterGuesser" sometimes fails to return sensible values$$The inner class "ParameterGuesser" in "HarmonicFitter" (package "o.a.c.m.optimization.fitting") fails to compute a usable guess for the "amplitude" parameter.$$patch1-math-7994d3ee_Developer_PatchNaturalnessYe$$Add missing import. Fix a MathIllegalStateException in HarmonicFitter .. Add a throw if the 2D value is zero .. remove erroneous space. $$1
math-c640932d$$weight versus sigma in AbstractLeastSquares$$In AbstractLeastSquares, residualsWeights contains the WEIGHTS assigned to each observation.  In the method getRMS(), these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator!   If the weight is really the weight of the observation, it should multiply the square of the residual even in the computation of the chi2.   Once corrected, getRMS() can even reduce   public double getRMS() {return Math.sqrt(getChiSquare()/rows);}$$patch1-math-c640932d_Developer_PatchNaturalnessYe$$Update the AbstractLeastSquaresOptimizer . getChiSquare ( ) method to return the value of. Added missing semi - colon .. Remove erroneous comment. Add a comment about the singular value decomposition .. Fix EigenDecompositionImpl . checkInfiniteLoops. $$1
math-fc409e88$$Remove "assert" from "MathUtils.equals"$$The "assert" in methods "equals(double,double,int)" and "equals(float,float,int)" is not necessary.$$patch1-math-fc409e88_Developer_PatchNaturalnessYe$$Remove an obsolete assert. Remove an obsolete assert. $$1
math-350f726c$$"BrentOptimizer" not always reporting the best point$${{BrentOptimizer}} (package "o.a.c.m.optimization.univariate") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.$$patch1-math-350f726c_Developer_PatchNaturalnessYe$$Fixing the relative and absolute threshold for Brent in the constructor .. Fix a false positive in BrentOptimizer . java. Added one more test to see if they are null .. $$1
math-fbbb96eb$$Vector3D.crossProduct is sensitive to numerical cancellation$$Cross product implementation uses the naive formulas (y1 z2 - y2 z1, ...). These formulas fail when vectors are almost colinear, like in the following example: {code} Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1); Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1); System.out.println(Vector3D.crossProduct(v1, v2)); {code}  The previous code displays { -1, 2, 0 } instead of the correct answer { -1, 2, 1 }$$patch1-math-fbbb96eb_Developer_PatchNaturalnessYe$$better handle for cross product. $$1
math-784e4f69$$Inconsistent result from Levenberg-Marquardt$$Levenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair.  However, the class holds the optimum point, the vector of the objective function, the cost and residuals.  The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost$$patch1-math-784e4f69_Developer_PatchNaturalnessYe$$Added missing fields. Fix the jacobian reduction issue .. Update the QTy function to 1 . 0 . 1. Fix the bug in LevenbergMarquardtOptimizer . java. Added updateResidualsAndCost ( ) if the orthotol is not reached .. Fix a bug in the LevenbergMarquardtOptimizer . determineLMParameter ( ) method where. Fix grammar error in LevenbergMarquardtOptimizer . java. Remove unused variable. Added a check for convergence. Fixes the case for Levenberg - Marquardt optimization .. Remove unused variable .. $$1
math-a197ba85$$NPE in BSPTree#fitToCell()$$Hello,  I faced a NPE using  BSPTree#fitToCell() from the SVN trunk. I fixed the problem using a small patch I will attach to the ticket.$$patch1-math-a197ba85_Developer_PatchNaturalnessYe$$removed null check. $$1
math-5a6ccd58$$Brent optimizer doesn't use the Base optimizer iteration counter$$BrentOptimizer uses "iter" defined in "doOptimize"  to count iterations. It should ideally use the iteration counter defined for the BaseOptimizer.$$patch1-math-5a6ccd58_Developer_PatchNaturalnessYe$$removed unused local variable. Fix a regression in BrentOptimizer with the help of a few thousand dollars per test .. Added incrementIterationCount ( ) so that it can be used as a final step. $$1
math-8a83581e$$BigFraction.doubleValue() returns Double.NaN for large numerators or denominators$$The current implementation of doubleValue() divides numerator.doubleValue() / denominator.doubleValue().  BigInteger.doubleValue() fails for any number greater than Double.MAX_VALUE.  So if the user has 308-digit numerator or denominator, the resulting quotient fails, even in cases where the result would be well inside Double's range.  I have a patch to fix it, if I can figure out how to attach it here I will.$$patch1-math-8a83581e_Developer_PatchNaturalnessYe$$Add exponent shift for BigFraction precision. Added a note that BigFraction . floatValue ( ) may err on overflow .. $$1
math-97b440fc$$Division by zero$$In class {{Complex}}, division by zero always returns NaN. I think that it should return NaN only when the numerator is also {{ZERO}}, otherwise the result should be {{INF}}. See [here|http://en.wikipedia.org/wiki/Riemann_sphere#Arithmetic_operations].$$patch1-math-97b440fc_Developer_PatchNaturalnessYe$$Fix documentation. Fix MATH - 657. $$1
math-a94ff90a$$FastMath.exp may return NaN for non-NaN arguments$$I have observed that FastMath.exp(709.8125) returns NaN. However, the exponential function must never return NaN (if the argument is not NaN). The result must always be non-negative or positive infinity.$$patch1-math-a94ff90a_Developer_PatchNaturalnessYe$$FastMath . pow ( z , y , z ) returns a NaN. $$1
math-5e638976$$Integer overflow in OpenMapRealMatrix$$computeKey() has an integer overflow. Since it is a sparse matrix, this is quite easily encountered long before heap space is exhausted. The attached code demonstrates the problem, which could potentially be a security vulnerability (for example, if one was to use this matrix to store access control information).  Workaround: never create an OpenMapRealMatrix with more cells than are addressable with an int.$$patch1-math-5e638976_Developer_PatchNaturalnessYe$$Add missing import. Add one throw. $$1
math-c44bfe00$$Exception thrown in ode for a pair of close events$$When two discrete events occur closer to each other than the convergence threshold used for locating them, this sometimes triggers a NumberIsTooLargeException.  The exception happens because the EventState class think the second event is simply a numerical artifact (a repetition of the already triggerred first event) and tries to skip past it. If there are no other event in the same step later on, one interval boundary finally reach step end and the interval bounds are reversed.$$patch1-math-c44bfe00_Developer_PatchNaturalnessYe$$Fix edge case. $$1
math-a56d4998$$bracket function gives up too early$$In UnivariateSolverUtils.bracket(...) the search ends prematurely if a = lowerBound, which ignores some roots in the interval.$$patch1-math-a56d4998_Developer_PatchNaturalnessYe$$Fix a bug in UnivariateSolverUtils. $$1
math-26e878ab$$FastMath.pow(double, long) enters an infinite loop with Long.MIN_VALUE$$FastMath.pow(double, long) enters an infinite loop with Long.MIN_VALUE. It cannot be negated, so unsigned shift (>>>) is required instead of a signed one (>>).$$patch1-math-26e878ab_Developer_PatchNaturalnessYe$$FastMath . exponent ( beware , there is no exclusion ). FastMath . java was using bitwise multiplication. $$1
math-d270055e$$NPE when calling SubLine.intersection() with non-intersecting lines$$When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations.  The attached patch fixes both implementations and adds the required test cases.$$patch1-math-d270055e_Developer_PatchNaturalnessYe$$Fixed a crash in SubLine . intersection ( ) .. Added missing return. $$1
math-495f04bc$$NaN in "equals" methods$$In "MathUtils", some "equals" methods will return true if both argument are NaN. Unless I'm mistaken, this contradicts the IEEE standard.  If nobody objects, I'm going to make the changes.$$patch1-math-495f04bc_Developer_PatchNaturalnessYe$$Fix semantics of equals ( double , double , int ) .. Removed @ deprecated javadoc file. Remove deprecated method. Fix MathUtils round up case. Fix MathUtils round up. Fix MathUtils # nextAfter ( BigDecimal , Double ). removed unused method. $$1
math-91d280b7$$ArrayIndexOutOfBoundsException in MathArrays.linearCombination$$When MathArrays.linearCombination is passed arguments with length 1, it throws an ArrayOutOfBoundsException. This is caused by this line:  double prodHighNext = prodHigh[1];  linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.$$patch1-math-91d280b7_Developer_PatchNaturalnessYe$$Revert to scalar multiplication .. $$1
math-32b0f733$$Division by zero$$In class {{Complex}}, division by zero always returns NaN. I think that it should return NaN only when the numerator is also {{ZERO}}, otherwise the result should be {{INF}}. See [here|http://en.wikipedia.org/wiki/Riemann_sphere#Arithmetic_operations].$$patch1-math-32b0f733_Developer_PatchNaturalnessYe$$Add isZero to Complex .. Fixed a bug where Complex . isNaN ( ) and isInfinite ( ) were acting as zero fields. Added missing closing Javadoc. Fix divide by zero logic .. Fix divide by zero error in Complex .. $$1
math-1352a70f$$BitStreamGenerators (MersenneTwister, Well generators) do not clear normal deviate cache on setSeed$$The BitStream generators generate normal deviates (for nextGaussian) in pairs, caching the last value generated. When reseeded, the cache should be cleared; otherwise seeding two generators with the same value is not guaranteed to generate the same sequence.$$patch1-math-1352a70f_Developer_PatchNaturalnessYe$$added ISAACRandom . clear ( ) .. $$1
math-ba62c59d$$2.0 equal to -2.0$$The following test fails:  {code}     @Test     public void testMath1127() {         Assert.assertFalse(Precision.equals(2.0, -2.0, 1));     } {code}$$patch1-math-ba62c59d_Developer_PatchNaturalnessYe$$Added precision bits to precision class .. updated Precision class link. updated Precision class link. Fix bug in equals ( ) .. Added link to precision class Precision. Fix bug in equals ( ) .. $$1
math-a6f96306$$Convergence Checker Fixes$$None$$patch1-math-a6f96306_Developer_PatchNaturalnessYe$$Fix bit of code. Fix false positives in LevenbergMarquardtOptimizer . evaluate ( ) .. Fix LeastSquaresFactory constructor to copy the point before adding it to the copy constructor. removed final. Change the entry in the column vector in the same way as the others .. $$1
math-49444ee6$$stat.correlation.Covariance should allow one-column matrices$$Currently (rev 1453206), passing 1-by-M matrix to the Covariance constructor throws IllegalArgumentException. For consistency, the Covariance class should work for a single-column matrix (i.e., for a N-dimensional random variable with N=1) and it should return 1-by-1 covariance matrix with the variable's variance in its only element.$$patch1-math-49444ee6_Developer_PatchNaturalnessYe$$Missing import. add missing throws. Make Covariance constructor public. Added a comment to Covariance constructor. Fix checkstyle. Fix Covariance constructor to be compatible with Java 8 restrictions. Fix checkstyle. allow override of computeCovarianceMatrix ( ). Fix Covariance. Fix check for data size , also include zero - length cols. $$1
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch1-math-9e0c5ad4_Developer_PatchNaturalnessYe$$Fix Gamma abssampling .. $$1
math-b2e24119$$inverseCumulativeDistribution fails with cumulative distribution having a plateau$$This bug report follows MATH-692. The attached unit test fails. As required by the definition in MATH-692, the lower-bound of the interval on which the cdf is constant should be returned. This is not so at the moment.$$patch1-math-b2e24119_Developer_PatchNaturalnessYe$$Remove unused import. Fix a potential NPE in AbstractRealDistribution .. $$1
math-98556fed$$AbstractRandomGenerator nextInt() and nextLong() default implementations generate only positive values$$The javadoc for these methods (and what is specified in the RandomGenerator interface) says that all int / long values should be in the range of these methods.  The default implementations provided in this class do not generate negative values.$$patch1-math-98556fed_Developer_PatchNaturalnessYe$$Removed dependency of Double nextDouble in AbstractRandomGenerator. Updated AbstractRandomGenerator . nextLong ( ). $$1
math-ce2badf0$$EmpiricalDistribution cumulativeProbability can return NaN when evaluated within a constant bin$$If x belongs to a bin with no variance or to which a ConstantRealDistribution kernel has been assigned, cumulativeProbability(x) can return NaN.$$patch1-math-ce2badf0_Developer_PatchNaturalnessYe$$EmpiricalDistribution k ( x ) < kernel . getNumericalMean ( ). $$1
math-f4c926ea$$twod.PolygonsSet.getSize produces NullPointerException if BSPTree has no nodes$$org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.getSize() uses a tree internally:  final BSPTree<Euclidean2D> tree = getTree(false);  However, if that tree contains no data, it seems that the reference returned is null, which causes a subsequent NullPointerException.  Probably an exception with a message ("tree has no data") would clarify that this is an API usage error.$$patch1-math-f4c926ea_Developer_PatchNaturalnessYe$$Added a note about limited class size. Fixed a bug in PolygonsSet . boxBoundary ( ). $$1
math-2f2a2dda$$UniformIntegerDistribution should make constructer a exclusive bound or made parameter check more relax$$UniformIntegerDistribution constructer  public UniformIntegerDistribution(RandomGenerator rng,                                       int lower,                                       int upper)  the lower and the upper all inclusive. but the parameter check made a   if (lower >= upper) {             throw new NumberIsTooLargeException(                             LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,                             lower, upper, false); check, i think it is too strict to construct UniformIntegerDistribution (0,0)  this should make it possible$$patch1-math-2f2a2dda_Developer_PatchNaturalnessYe$$Fix Javadoc nag. Added missing exception message. $$1
math-3a08bfa6$$inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.$$The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials.  Following code will be reproduce the problem.  {{System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5));}}  This returns 499525, though it should be 499999.  I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN.  As the result the checkedCumulativeProbability method doesn't work as expected.$$patch1-math-3a08bfa6_Developer_PatchNaturalnessYe$$added note about continued fraction implementation. Fix infinite looping in ContinuedFraction. Using the hN value of ContinuedFraction. $$1
math-76b7413d$$ResizableDoubleArray is not thread-safe yet has some synch. methods$$ResizableDoubleArray has several synchronised methods, but is not thread-safe, because class variables are not always accessed using the lock.  Is the class supposed to be thread-safe?  If so, all accesses (read and write) need to be synch.  If not, the synch. qualifiers could be dropped.  In any case, the protected fields need to be made private.$$patch1-math-76b7413d_Developer_PatchNaturalnessYe$$Removed unused import .. ResizableDoubleArray now uses the ( copied ) double array as reference. Fix double array constructor. Added default expansion mode .. Fix typo in ResizableDoubleArray .. Updating the ResizableDoubleArray class to have consistent expansion workflow. make ResizableDoubleArray constructor nullable. ResizableDoubleArray implements ResizableDoubleArray , closes # 173. Fix a merge of deprecated constructors .. added missing - arg constructor .. Add a checkNotNull check. Fix copy constructor. ResizableDoubleArray doesn ' t have a final constructor. ResizableDoubleArray doesn ' t have a synchronization point .. Synchronized addElementRolling ( ) .. Fix a typo in ResizableDoubleArray . substituteMostRecentElement ( ). removed deprecated method. Remove unused exception signature from ResizableDoubleArray . checkContractExpand ( ). Fix contract implementation. Fix a javadoc bug in ResizableDoubleArray . discardFrontElements ( ) .. Fix a warning. Fix typo in ResizableDoubleArray . expand ( ). Removed synchronized statement which was unintentionally added in ResizableDoubleArray . expand. Fix documentation for getContractionCriteria. ResizableDoubleArray . getElement ( ) is not synchronized .. ResizableDoubleArray . getElements ( ) now returns a copy of the underlying array .. Fix typo in ResizableDoubleArray . getExpansionFactor. Fix typo in ResizableDoubleArray . getExpansionMode. ResizableDoubleArray has only one method that returns a reference to the internal array .. Updating the javadoc of ResizableDoubleArray . getStartIndex ( ) to reflect the actual implementation. Fix setContractionCriteria ( ). ResizableDoubleArray doesn ' t increase the numElements value .. Fix a warning. removed synchronized statement. ResizableDoubleArray copy ( ) is deprecated .. ResizableDoubleArray copy ( ) is not synchronized. ResizableDoubleArray doesn ' t have equals method. Fix hash code for ResizableDoubleArray. $$1
math-ce126bdb$$A random crash of MersenneTwister random generator$$There is a very small probability that MersenneTwister generator gives a following error:  java.lang.ArrayIndexOutOfBoundsException: 624 in MersenneTwister.java line 253 The error is completely random and its probability is about 1e-8.  UPD: The problem most probably arises only in multy-thread mode.$$patch1-math-ce126bdb_Developer_PatchNaturalnessYe$$fixed SynchronizedRandomGenerator use of deprecated nextInt ( ). $$1
math-63d88c74$$MultidimensionalCounter does not throw "NoSuchElementException"$$The iterator should throw when "next()" is called even though "hasNext()" would return false.$$patch1-math-63d88c74_Developer_PatchNaturalnessYe$$Add missing import. Add missing final modifier to MultidimensionalCounter .. changed hasNext ( ) to return the max count. $$1
math-bda25b40$$EigenDecomposition may not converge for certain matrices$$Jama-1.0.3 contains a bugfix for certain matrices where the original code goes into an infinite loop.  The commons-math translations would throw a MaxCountExceededException, so fails to compute the eigen decomposition.  Port the fix from jama to CM.$$patch1-math-bda25b40_Developer_PatchNaturalnessYe$$Fix the case for 1 / 2 shift .. $$1
math-b285f170$$The LinearConstraintSet shall return its constraints in a deterministic way$$As previously discussed on the mailinglist, the LinearConstraintSet should return its internally stored LinearConstraints in the same iteration order as they have been provided via its constructor.  This ensures that the execution of the same linear problem results in the same results each time it is executed. This is especially important when linear problems are loaded from a file, e.g. mps format, and makes it simpler to debug problems and compare with other solvers which do the same thing.$$patch1-math-b285f170_Developer_PatchNaturalnessYe$$removed unused import. removed unnecessary initialization .. $$1
math-09fe956a$$ResizableDoubleArray does not work with double array of size 1$$When attempting to create a ResizableDoubleArray with an array of a single value (e.g. {4.0}), the constructor creates an internal array with 16 entries that are all 0.0  Bug looks like it might be on line 414 of ResizableDoubleArray.java:          if (data != null && data.length > 1) {$$patch1-math-09fe956a_Developer_PatchNaturalnessYe$$Fixed double array resize. $$1
math-cc4ab51e$$BinomialDistribution deals with degenerate cases incorrectly$$The following calculation returns false results:  {{new BinomialDistribution(0, 0.01).logProbability(0)}}  It evaluates to Double.NaN when it should be 0 (cf., for example, "dbinom(0, 0, 0.01, log=T)" in R).  I attach a patch dealing with the problem. The patch also adds a test for this bug.$$patch1-math-cc4ab51e_Developer_PatchNaturalnessYe$$Add log probability method if ( numberOfTrials == 0 ) {. $$1
math-8f35fcb8$$UknownParameterException message prints {0} instead of parameter name$$The constructor for UnknownParameterException stores the parameter name internally but does not forward it to the base class which creates the error message.$$patch1-math-8f35fcb8_Developer_PatchNaturalnessYe$$MissingParameterException constructor should use the correct message .. $$1
math-b55e0206$$Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness function$$If you give large values as lower/upper bounds (for example -Double.MAX_VALUE as a lower bound), the optimizer can call the fitness function with parameters set to NaN.  My guess is this is due to FitnessFunction.encode/decode generating NaN when normalizing/denormalizing parameters.  For example, if the difference between the lower and upper bound is greater than Double.MAX_VALUE, encode could divide infinity by infinity.$$patch1-math-b55e0206_Developer_PatchNaturalnessYe$$Removed unused imports. add comment on CMAESOptimizer. Add CMAJO 500 - Limit the maximum number of decimal places to 2 decimal .. $$1
math-e91d0f05$$Precision.round() returns different results when provided negative zero as double or float$$Precision.round(-0.0d, x) = 0.0 Precision.round(-0.0f, x) = -0.0  After discussion on the mailinglist, the result should always be -0.0.$$patch1-math-e91d0f05_Developer_PatchNaturalnessYe$$MATH - 1089 - negative values rounded to zero should result in negative zero. $$1
math-ebadb558$$ListPopulation Iterator allows you to remove chromosomes from the population.$$Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list. Before returning the iterator we should wrap it in an unmodifiable list.$$patch1-math-ebadb558_Developer_PatchNaturalnessYe$$Fix typo in ListPopulation . iterator ( ). $$1
math-4c4b3e2e$$Overflow checks in Fraction multiply(int) / divide(int)$$The member methods multiply(int) / divide(int) in the class org.apache.commons.math3.fraction.Fraction do not have overflow checks.  {code:java} return new Fraction(numerator * i, denominator); {code}  should be  {code:java} return new Fraction(ArithmeticUtils.mulAndCheck(numerator, i), denominator); {code}  or, considering the case gcd(i, denominator) > 1,  {code:java} return multiply(new Fraction(i)); {code}$$patch1-math-4c4b3e2e_Developer_PatchNaturalnessYe$$Fix DivisionByPointException in Fraction class. Fix divide ( ). $$1
math-5b9302d5$$Dfp Dfp.multiply(int x) does not comply with the general contract FieldElement.multiply(int n)$$In class {{org.apache.commons.math3.Dfp}},  the method {{multiply(int n)}} is limited to {{0 <= n <= 9999}}. This is not consistent with the general contract of {{FieldElement.multiply(int n)}}, where there should be no limitation on the values of {{n}}.$$patch1-math-5b9302d5_Developer_PatchNaturalnessYe$$Fix speed advantages in Dfp multiply ( ). $$1
math-471e6b07$$Digamma calculation produces SOE on NaN argument$$Digamma doesn't work particularly well with NaNs.  How to reproduce: call Gamma.digamma(Double.NaN)  Expected outcome: returns NaN or throws a meaningful exception  Real outcome: crashes with StackOverflowException, as digamma enters infinite recursion.$$patch1-math-471e6b07_Developer_PatchNaturalnessYe$$fix digamma ( x ). fix a warning. $$1
math-f656676e$$Negative value with restrictNonNegative$$Problem: commons-math-2.2 SimplexSolver.  A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call: SimplexSolver.optimize(function, constraints, GoalType.MINIMIZE, true);  Function 1 * x + 1 * y + 0  Constraints: 1 * x + 0 * y = 1  Result: x = 1; y = -1;  Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.$$patch1-math-f656676e_Developer_PatchNaturalnessYe$$Fixed a bug in the objective function coefficients. $$1
math-ac597cc1$$"BrentOptimizer" not always reporting the best point$${{BrentOptimizer}} (package "o.a.c.m.optimization.univariate") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.$$patch1-math-ac597cc1_Developer_PatchNaturalnessYe$$Fix a typo in the Python code. Added a note about the best point encountered so far. Fix a redundant line. Added missing closing parenthesis in BrentOptimizer. Fix error in BrentOptimizer . best ( ). Fix value compositing. $$1
math-7980a242$$Incomplete reinitialization with some events handling$$I get a bug with event handling: I track 2 events that occur in the same step, when the first one is accepted, it resets the state but the reinitialization is not complete and the second one becomes unable to find its way. I can't give my context, which is rather large, but I tried a patch that works for me, unfortunately it breaks the unit tests.$$patch1-math-7980a242_Developer_PatchNaturalnessYe$$removed unused import. removed unused variable. Fix double - packaging. Fix an issue with the intermittent double - callback. $$1
math-86545dab$$Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exception$$An overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple fraction.  For example:  double d = 0.5000000001; Fraction f = new Fraction(d, 10);  Patch with unit test on way.$$patch1-math-86545dab_Developer_PatchNaturalnessYe$$Add the DEFAULT_EPSILON constant to Fraction ( ) .. Default epsilon of Fraction constructor .. Fix typo in Fraction class. Don ' t limit overflow by the max denominator .. Don ' t limit overflow by the max denominator .. $$1
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch1-math-2a6c6409_Developer_PatchNaturalnessYe$$Added a note about potential NPE in PolyhedronsSet constructor. Euclidean3D .. $$1
math-9aabf587$$Use analytical function for UniformRealDistribution.inverseCumulativeProbability$$The inverse CDF is currently solved by a root finding function. It would be much simpler (and faster) to use the analytical expression. This would save the user from having to set the inverseCumAccuracy correctly.  I've attached a patch that implements this.$$patch1-math-9aabf587_Developer_PatchNaturalnessYe$$Updated imports. Deprecated default inverse cumulative probability accuracy .. Remove unused variable .. Add default constructor to UniformRealDistribution. Deprecated UniformRealDistribution constructor .. Add inverse CDF to UniformRealDistribution constructor .. remove superfluous line. Add inverseCumulativeProbability ( ) , to prevent intermittent exception. $$1
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch36-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a small bug in Precision . nextAfter ( double , double ). Fix NPE. FastMath . nextAfter ( unscaled , Double . NEGATIVE_INFINITY ) doesn ' t work. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch31-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix Colt precision reduction. Add one line for precision patch. Fix for redundant rounding in BigDecimal precision test. Fix precision warning. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch54-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a small bug in Precision . ceil ( ) .. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch62-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix precision bug. Remove nextAfter in Precision . java. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch39-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed .. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch30-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix precision issue. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch37-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix one more test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch63-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed .. Add one line , as per EvilSeph ' s request. Fix 64 - bit precision mistake. FixBigDecimal roundoff. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch64-math-8e5867ed_GenProg_PatchNaturalnessYe$$FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch52-math-8e5867ed_GenProg_PatchNaturalnessYe$$Add a facta field to precision . abs. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch55-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix 64 bit fallthrough in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch48-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed .. Fix a bug in BigDecimal precision. Fix precision issue. FixBigDecimal roundoff. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch46-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix reduceResults. Add one line for precision patch. Fix a bug in BigDecimal precision checking. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch41-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. Fix a minor issue with floor ( ) / 2 . 0 being too far away. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch15-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch12-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch24-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in the precision of Math_8e5867ed. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch23-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. Fix nextAfter in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch40-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix Colt rounding bug. Add one line for precision patch. Fix for previous round. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch47-math-8e5867ed_GenProg_PatchNaturalnessYe$$Add pi2b precision. Fix the rounded corner case for BigDecimal precision .. Fix nextAfter in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch49-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch22-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed .. Fix floor. FastMath . nextAfter ( unscaled , Double . NEGATIVE_INFINITY ) added missing patch. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch25-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed .. Fix the rounded angles of the precision column .. Fix a bug in the floor of Math . floor ( unscaled ) .. FastMath . nextAfter ( unscaled , Double . NEGATIVE_INFINITY ) fix. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch13-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix MCP patch. Fix a bug in the rounded part of the Math class .. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch14-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix MCP patch. Remove nextAfter in BigDecimal precision. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch57-math-8e5867ed_GenProg_PatchNaturalnessYe$$Add zb to precision fix .. Fix a potential NPE in BigDecimal precision test. Fix the rounded angles of the precision column .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch61-math-8e5867ed_GenProg_PatchNaturalnessYe$$Remove patch from unscaled precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch59-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a potential NPE in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch11-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix Colt precision reduction. Fix precision warning. Fix a bug in BigDecimal precision checking. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch29-math-8e5867ed_GenProg_PatchNaturalnessYe$$raw precision fix. Fix a small bug in Precision . nextAfter ( double , double ). Fix the rounded corner bug in Math_8e5867ed .. Fix PMD precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch16-math-8e5867ed_GenProg_PatchNaturalnessYe$$Add pi2b precision. Fix the rounded corner case for BigDecimal precision .. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch20-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a small bug in Precision . nextAfter ( double , double ). FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch27-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix Colt precision reduction. Fix the bug for Java 8 . 5 .. Fix compile error. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch42-math-8e5867ed_GenProg_PatchNaturalnessYe$$Add a facta field to precision . abs. Remove patch from unscaled to ceil. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch2-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix the rounded corner case for BigDecimal precision .. Fix nextAfter in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch45-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. Fix precision thingie in java 8e5867ed. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch19-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. Fix nextAfter ( ) in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch26-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix Colt precision reduction. Add one line for precision patch. Fix for previous round. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch21-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in the rounded part of the Math class .. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch28-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed. Fix the rounded angles of the precision column .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch17-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. Add Rln10a patch .. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch10-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix Colt precision reduction. Fix precision warning. Fix for previous round. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch44-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in Math_8e5867ed. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch3-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix precision bug. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch4-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix precision bug. Fix a bug in BigDecimal precision test. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-8e5867ed$$Incorrect rounding of float$$package org.apache.commons.math3.util  example of usage of round functions of Precision class:  Precision.round(0.0f, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float)0.0, 2, BigDecimal.ROUND_UP) = 0.01 Precision.round((float) 0.0, 2) = 0.0 Precision.round(0.0, 2, BigDecimal.ROUND_UP) = 0.0  Seems the reason is usage of extending float to double inside round functions and getting influence of memory trash as value.  I think, same problem will be found at usage of other round modes.$$patch43-math-8e5867ed_GenProg_PatchNaturalnessYe$$Fix a bug in BigDecimal precision. FastMath . ceil ( unscaled ) doesn ' t fix the rounded angles .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch120-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last update. I had left it as is. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch323-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver patch was failing because I added another GLIBC - 2 closing loop. Clarify variable name to match new BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch111-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for variable max value function. Added verifyBracketing ( min , max , f ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch38-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Reset the iterator count as well. Added verifyBracketing to the BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch324-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fixing the BrentSolver bug .. Add patch for bisection. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch129-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix the bug in BrentSolver from patch 0 .. Added verifyBracketing to the BrentSolver. Add back missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch189-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove a couple incorrect lines. I was confused , sorry. Add back missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch348-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value , but is not good enough. changed default function value accuracy in BrentSolver. Added patch for function value endpoints. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch98-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from verifySequence ( ). Remove erroneous test. Set variable name as used by the BrentSolver class .. Added patch for function value min and max. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch145-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver patch was not re - used .. Clarify BrentSolver with better error handling. Set x1 = x2 before setting result .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch53-math-f6dd42b4_GenProg_PatchNaturalnessYe$$I had left it as is. Add back missing patch. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch187-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for variable max value checking. Added verifyBracketing ( min , max , f ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch325-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount as it is only used when checking the sequence. Set iterationCount as well as verifyBracketing ( min , max , f ). revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch110-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for 1 . 8 . 3 .. Reset the iterator count as well. Added verifyBracketing to the BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch39-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the fixed value function , so it is normally possible to reuse it .. changed variable name. Clarify BrentSolver with better error handling. Added patch to prove that the function value is close to 0 . 0 .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch314-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ) to the BrentSolver bug. Fix the bug in the elm function to be compatible with the current AEJC. I had left it as is done in the last commit .. Add a missing return value in inverse quadratic interpolation. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch119-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed variable name for BrentSolver. Added verifyBracketing method to the BrentSolver. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch121-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove a couple incorrect code lines. changed max value of BrentSolver to be 0 if max is good enough. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch37-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous test. Clarify variable name to match new BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch63-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Clarify BrentSolver with better error handling. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch175-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Updated BrentSolver . setResult ( initial , 0 ) ;. Clarify BrentSolver . resultComputed with better accuracy .. Added patch for function value coherency. Add patch for easing of the bug. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch347-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver patch was not re - used .. Clarify solution with better error handling. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch97-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set this . iterationCount = iterationCount + 1 ; rather than the default max .. Set iterationCount as it is normally possible to reuse the same x , y , yInitial .. Added patch for function value min and max. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch181-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set function value accuracy to default , as it is done every time. Added verifyBracketing ( ) to the function value accuracy patch. Fix erroneous test case. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch90-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set x2 and y2 as arguments to the BrentSolver class .. Clarify solution with better error handling. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch186-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set x2 = max value of BrentSolver as well. Clarify variable name to match provided function value accuracy. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch340-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to the function value accuracy patch. I had left it as was done before the move . . .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch64-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set x2 = max as the max is not good enough .. Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant check. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch172-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) patch from BrentSolver. Added erroneous inverse of verifyBracketing ( min , max , f ). Set p1 = 1 . 0 - r3 instead of p0 = 0 . 5 *. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch144-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Set this . iterationCount to zero so that the function value is always good enough. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch52-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed variable name for BrentSolver. Added more iterations to the stub. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch143-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Clarify variable name to match new BrentSolver. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch232-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to the function value accuracy patch. Added patch for 1 . 8 . 0 .. I had left it harwired to verifyBracketing .. Added patch for variable x0 in BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch261-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value .. Fix swapped line. I had left it harwired to verifyBracketing .. Add a missing return value in inverse quadratic interpolation. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch259-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing ( ) to the function value otherwise it will break the build .. Clarify variable name to match provided function value accuracy .. Add back missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch266-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from verifySequence ( ). Added verifyBracketing ( min , max , f ). Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch292-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to the function value accuracy patch. Clarify a use case .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch250-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last fix. Set iterationCount as it was done before the closure was opened .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch234-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value , but not the initial guess. changed max value of BrentSolver to be 0 if ( yMax < min ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch233-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last fix. I had made a mistake in the previous patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch205-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount as well as verifyBracketing ( min , max , f ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch256-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove a couple incorrect code lines. Set maxIterCount and verifyBracketing ( ) as well as maxIterCount. Added patch for function value min and max. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch258-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Set function value accuracy to default , this way we can use the expanded function .. Fix erroneous test .. Fix erroneous variable. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch289-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Added patch for BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch273-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant patch. Added patch to erroneous integration test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch280-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Reset function value accuracy to default function value accuracy. Added verifyBracketing ( ) to the function value accuracy patch. Added verifyBracketing to the BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch218-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for variable max value function. Added verifyBracketing ( min , max , f ). revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch281-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value .. Clarify BrentSolver . resultComputed with updated max value. Added patch for function value endpoints. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch275-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses Object . POSITIVE_INFINITY for parallel execution. Added verifyBracketing ( ) to the function value accuracy patch. Set iterationCount as it was done before the closure closure closure closure closure closure .. revert accidently change. BrentSolver now uses the old delta value .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch272-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set function value accuracy to default , as it is done every time. Added verifyBracketing ( ) to the function value accuracy patch. Fixing a minor typo in the BrentSolver test. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch219-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set x1 = 0 after verifying the pair. Added a throw to the right part of BrentSolver. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch77-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous regression in BrentSolver. I had left it harwired to verifyBracketing .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch195-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous integration with BrentSolver. I had left it as is done in the last commit .. Set iterationCount as - 1 . 5 for inverse quadratic interpolation .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch83-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set this . iterationCount to zero so that the function value is always good enough. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch166-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch70-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. changed vars as well. Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch8-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing ( min , max , f ). Add the missing patch .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch159-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last fix. Added patch for bracketing in BrentSolver. I had left it as is. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch46-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set updated iteration count. Added patch for function value endpoints. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch168-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. changed maxIterCount as well. I had left it harwired to verifyBracketing .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch103-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for variable max value function. Added verifyBracketing ( ) to the function value accuracy patch. Clarify solution with the min value in the function valueAccuracy. Added missing variable .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch309-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to the function value accuracy patch. Set iterationCount as well. Added patch to erroneous integration test .. Add a missing line. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch336-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added x2 = max ; to the main objective function. Set iterationCount as it is normally possible to reuse the same x , y , yInitial .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch104-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now returns 0 iff y = = min ;. Reset the iterator count as well. I had left it as is. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch300-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for 1 . 6 . 2. changed itercount. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch132-math-f6dd42b4_GenProg_PatchNaturalnessYe$$revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch40-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set x2 = max oversampling in BrentSolver. Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch156-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed erroneously set maxIterCount as well. Add back missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch169-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from verifySequence ( ). Fix erroneous variable. Add back missing patch .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch78-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous test. Clarify BrentSolver . resultComputed with better accuracy .. Added patch for function value endpoints. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch71-math-f6dd42b4_GenProg_PatchNaturalnessYe$$I had left it as a last resort .. I had left it as is done in the last commit .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch85-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for 1 . 8 . 3. Set default function value accuracy using provided bracketing. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch49-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove a couple incorrect lines. Set iterationCount as full Brent algorithm. Added patch to erroneous integration test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch339-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last fix. Added verifyBracketing ( ) to the function value accuracy patch. changed max iter count. Add patch for wrong step .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch330-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount = this . iterationCount + 1 ;. Added patch to prevent adding value to the same endpoint .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch14-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Set function value accuracy to default , this way we can use the expanded function .. Added patch for BrentSolver .. Fix erroneous variable. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch50-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy in BrentSolver. Clarify the Brent solver with better error handling. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch61-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added default function value accuracy checking for BrentSolver. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch59-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Clarify BrentSolver with better error handling. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch32-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch to verifySequence ( ). Added verifyBracketing ( ) to the function value accuracy patch. Remove a redundant patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch58-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Clarify BrentSolver with better error handling. Fix erroneous test .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch93-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch to verifySequence ( ). Added verifyBracketing ( ) to the function value accuracy patch. Clarify a use case for BrentSolver as well. Added missing variable .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch185-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added verifyBracketing ( ) to the function value otherwise it will break the build .. I was confused , sorry. Add back missing patch .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch343-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed variable name for BrentSolver. I had left it as is. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch149-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the fixed value function , so it is normally possible to reuse it .. I had left it as is. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch344-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous regression in BrentSolver. Added verifyBracketing method to the BrentSolver class .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch60-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set x2 = max oversampling in BrentSolver. Added patch to verifyBracketing ( min , max , f ). Clarify a use case for BrentSolver as well. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch69-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed variable names. Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch140-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set default function value accuracy across the board. Remove erroneous test. I had left it harwired to verifyBracketing .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch51-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) line. changed max value of BrentSolver to 0 , this way we avoid an NPE. I had left it harwired to verifyBracketing , was causing some problem in the code. revert wrong patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch114-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix variable name error in BrentSolver. changed max value of BrentSolver to verify bracketing. Add back missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch326-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now returns 0 if the initial guess is good enough. Added verifyBracketing ( ) to the function value accuracy patch. Clarify solution with better error handling. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch33-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Add i = 0 ;. Clarify BrentSolver with better error handling. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch265-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed variable name for BrentSolver. Set function value accuracy to 0 if max is not good enough. Fix erroneous test .. Set x1 = x2 before setting result. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch291-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set this . iterationCount as this . x1 = x1 + 1 ;. Clarify variable name to match provided function value accuracy. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch296-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous variable name. Added patch to erroneous integration test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch253-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount as it is normally possible to reuse the same thread. Set iterationCount as it is normally possible to reuse the same x0 value as the min value. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch238-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Reset function value accuracy to default function value accuracy. Added verifyBracketing ( ) to the function value accuracy patch. Clarify solution with the fix from Wright. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch200-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver patch was failing because I added another GLIBC - 2 closing loop. Added verifyBracketing ( ) to the function value accuracy patch. Set default function value accuracy to 1 . 0e - 15 ( minor ). Fix a minor bug in the same way as in the old german. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch236-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from BrentSolver. Remove erroneous test. Set iterationCount and default function value accuracy. Added patch for function value coherency. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch209-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch for 1 . 8 . 3 .. Clarify solution with better error handling. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch299-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value .. Fixing erroneous variable. Added patch for function value endpoints. Add 284 patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch297-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove a couple incorrect lines. Set iterationCount as well as verifyBracketing ( min , max , f ). Added patch to erroneous integration test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch230-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount and default function value accuracy. Added patch to prevent app from being loaded into workflow. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch237-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing to class path. Fix a minor bug in the same way as in the old german. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch208-math-f6dd42b4_GenProg_PatchNaturalnessYe$$I had a bit more debug .. Fix erroneous variable. Add patch for easing of logistics .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch201-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last fix. Added patch for bracketing. Clarify variable name as match provided by the old pull request. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch212-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount = this . iterationCount + 1 ; as it was the case before the reverse. Add back missing patch. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch241-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix variable local variable warning. Added support for bracketing in BrentSolver. Fix a minor bug in the same way as in the old german. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch277-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver patch was failing because I added another GLIBC - 2 closing loop. Added patch for bracketing in BrentSolver. Set default function value accuracy to 1 . 0e - 15 ( minor ). Fix a minor warning. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch270-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Add a fix for changed variable names in BrentSolver . java. Clarify BrentSolver with better error handling. Added patch to verifyInterval. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch213-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). Add a missing return value in inverse quadratic interpolation. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch222-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now clears the result of the last fix. Added verifyBracketing ( ) to the function value accuracy patch. Set iterationCount as it was done before the closure closure closure closure closure closure .. revert accidently change. BrentSolver now uses the old delta value .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch271-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous variable. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch247-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyInterval ( min , max , f ) to BrentSolver. I had left it harwired to verifyBracketing .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch138-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount as it is only used when checking the sequence. Clarify variable name to match provided function value accuracy. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch107-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver doesn ' t clear the result before attempting to use it. Fixing the BrentSolver bug .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch335-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Clarify a use case for bracketing the root .. I had left it harwired to verifyBracketing , was causing some problem in the code. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch136-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Fix erroneous variable. Add back missing patch .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch303-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( ) to the function value accuracy patch. Clarify variable name to match provided input .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch191-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Set iterationCount as it is normally possible to reuse old BrentSolver. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch357-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value , but is not good enough. Clarify BrentSolver . resultComputed with better accuracy .. Added patch for function value coherency. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch165-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Clarify solution with better error handling. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch359-math-f6dd42b4_GenProg_PatchNaturalnessYe$$changed variable name for BrentSolver. Clarify BrentSolver with better error handling. Fix erroneous test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch302-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added verifyBracketing ( min , max , f ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch130-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Fix NPE in BrentSolver. I was confused , sorry. Add back missing patch. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch137-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Added patch to verifySequence. Set maxIterCount to zero if min is good enough .. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch101-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from verifySequence ( ). Set iterationCount and default function value accuracy. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch139-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the result of running f ( x , y ) instead of the min /. I had made a mistake in the previous patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch44-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Clarify solution with the right function value. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch3-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from verifySequence ( ). Remove unused variable. Set iterationCount as well as the last set of functions. I had left it harwired to verifyBracketing , was causing some problem in the code. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch199-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove erroneous test. Clarify solution with better error handling. Added patch to erroneous integration test .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch43-math-f6dd42b4_GenProg_PatchNaturalnessYe$$remove clearResult ( ) from BrentSolver. Added verifyBracketing ( min , max , f ). Set p1 = 1 . 0 - r3 instead of p1 = 0 . 5 *. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch351-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Fix erroneous variable. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch163-math-f6dd42b4_GenProg_PatchNaturalnessYe$$Remove redundant clearResult ( ) line. changed max value of BrentSolver to 0 , this way we avoid an NPE. I had left it harwired to verifyBracketing , was causing some problem in the code. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch75-math-f6dd42b4_GenProg_PatchNaturalnessYe$$BrentSolver now uses the patched value ( already provided by valgrind ). Set default function value accuracy to 0 if max is good enough. Fix erroneous test .. Fix erroneous variable. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch190-math-f6dd42b4_GenProg_PatchNaturalnessYe$$I had left it as a last resort .. I had left it harwired to the IGN patch .. revert patch. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch120-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the missing patch. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch127-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch118-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch111-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch116-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix Gamma inverse inverse function. Fix x3max = 0 ;. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch145-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch117-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused var. Fix Gamma inverse inverse function. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch128-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in Gamma where the inverse of 1 . 0 is not greater than 1 .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch30-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch119-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not greater than 1 .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch121-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the case of Gamma ( x ) being > 1 . 0. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch90-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch144-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch143-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the missing patch. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch55-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix Gamma function .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch48-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch1-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix Gamma inverse inverse function. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch41-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch103-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the recurrence relation in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch15-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused variable warning. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch12-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch132-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the recurrence relation in Gamma ( x ). $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch135-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch40-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused var. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch78-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the recurrence relation in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch71-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix Gamma function. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch85-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch82-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the case for 1 . 0 / ( 1 . 0 + invGamma1pm1 (. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch76-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused variable warning. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch49-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix Gamma function path. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch134-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch133-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch105-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch13-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$fix a warning. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch102-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch14-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the recurrence relation in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch68-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the missing patch. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch141-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the case for Gamma ( x ) where the inverse of the reflection relation is not found. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch124-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in Gamma .. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch32-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of 1 . 0 is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch35-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix Gamma function path. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch93-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix memory leak. Fix the case for Gamma ( x ) where the inverse of the reflection relation is not found. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch149-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the bug in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch94-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in Gamma where the inverse of 1 . 0 is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch140-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the missing patch. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch56-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix Gamma inverse inverse function. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch113-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the gamma function .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch122-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch33-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch138-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Add the nend variable to the gamma function .. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch107-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the case for Gamma ( x ) where the inverse of the reflection relation is not found. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch100-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused var. added fix in Gamma. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch16-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the bug in Gamma ( x ) where the inverse of the reflection relation is not found. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch109-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the bug in Gamma where the inverse of 1 . 0 is not greater than 1 .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch131-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the lanczos function. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch87-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the recurrence relation found by JDK .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch73-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch74-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch2-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the bug in Gamma ( x ) where the inverse of the reflection relation is not found. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch45-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Allow 1 . 5 to be passed to Gamma .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch153-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the warning. Fix the recurrence relation in Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch26-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch108-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch21-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused var. Fix the recurrence relation of Gamma ( x ) .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch28-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$added fix in Gamma function. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch101-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the missing lanczos fix .. Fix the bug in Gamma where the inverse of 1 . 0 is not greater than - 1. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch106-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch10-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix unused local variable. Fix the bug in Gamma where the inverse of the reflection relation is not found .. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch152-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$Fix the bug in gamma ( x ). Fix the recurrence relation in Gamma ( x ). $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch88-math-9e0c5ad4_GenProg_PatchNaturalnessYe$$fix a warning. Fix the recurrence relation of Gamma ( x ) .. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch31-math-2a6c6409_GenProg_PatchNaturalnessYe$$removed patch from BSPTree. fixed a merge bug in PolygonsSet caused by unecessary close. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch62-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed a bug in the ot package. removed patch from BSPTree. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch37-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed a bug in Groovy. removed patch from BSPTree. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch64-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed a small bug. removed unused patch. fixed issue with inf / negInf in GenProg_Bug_dot_jar_Common. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch99-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed a merge bug in PolygonsSet caused by unecessary close. fixed a bug in ot . encode. BSPTree now uses BSPTree . chopOffMinus ( ) , not BSPTree. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch55-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed a bit of code. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch40-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed a bug in OrderedTuple. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch13-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. removed patch from BSPTree. fixed erroneous import. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch14-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed ot . offset = ot . encode ( offset ) ;. removed patch from BSPTree. fixed a small bug. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch50-math-2a6c6409_GenProg_PatchNaturalnessYe$$removed patch. fixed ot . offset = offset ;. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch57-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. removed patch. fixed a bug in ot . encode ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch35-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed OE. removed patch from BSPTree. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch67-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch56-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed ot . offset = offset ;. removed patch from BSPTree. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch34-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed a bug in ot . encode ( ) .. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch29-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed ot . offset = offset ;. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch20-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed scale of OrderedTuple. removed patch from BSPTree. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch27-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed old bug. removed unused vars. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch80-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous import. removed unused patch. fixed old bug. fixed erroneous warning. fixed a small bug. Change the ExceptionContext . getMessage ( ) to use the default locale .. Missing final modifier .. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch42-math-2a6c6409_GenProg_PatchNaturalnessYe$$removed unused patch. fixed old bug. fixed erroneous warning. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch75-math-2a6c6409_GenProg_PatchNaturalnessYe$$fixed erroneous warning. fixed a bug in ot . encode. removed patch from BSPTree. $$0
oak-7c320b1e$$issues with JsopBuilder.encode and .escape$$1) escape() escapes many characters that do not need to be escaped (>127)  2) encode() does not encode many control characters that would need to be escaped when read through a JSON parser.$$patch1-oak-7c320b1e_Kali_PatchNaturalnessYe$$"Revert "" fix buffer overflow on Travis """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1-oak-3ce758b7_Kali_PatchNaturalnessYe$$Fix avoid warning. $$0
accumulo-cd7feb4d$$RegExFilter deepCopy NullPointerException$$If any of the regex matcher objects are null (i.e. for example, if you only specify a regex for the column family), the deepCopy call will throw a NullPointerException.$$patch1-accumulo-cd7feb4d_Kali_PatchNaturalnessYe$$add return. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1-accumulo-b007b22e_Kali_PatchNaturalnessYe$$Fix top level delete / merge bug. $$0
accumulo-3d55560a$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1-accumulo-3d55560a_Kali_PatchNaturalnessYe$$"Revert "" fix merge conflict """. $$0
accumulo-6dbbdc21$$RegExFilter deepCopy NullPointerException$$If any of the regex matcher objects are null (i.e. for example, if you only specify a regex for the column family), the deepCopy call will throw a NullPointerException.$$patch1-accumulo-6dbbdc21_Kali_PatchNaturalnessYe$$add return. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch1-math-9e0c5ad4_Kali_PatchNaturalnessYe$$Bump the gamma patch to see if it is still failing after rebase. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch36-oak-5286861d_Arja_PatchNaturalnessYe$$remove patch for same parent branch. get back automatic branch root id. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch118-oak-5286861d_Arja_PatchNaturalnessYe$$remove old map entry. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch740-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. remove unused commitTS. remove patched put commit. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch714-oak-5286861d_Arja_PatchNaturalnessYe$$Ooops . . . forgot a conflict in commit builder. remove patched putTokens . remove ( token ). "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch370-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. Remove patched commit .. I was confused , sorry. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch142-oak-5286861d_Arja_PatchNaturalnessYe$$remove wrong branch root id. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1134-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. remove old branch head after merge. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch949-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. Remove patch_149. "Revert "" update patch for 1 . 4 . 0 """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1104-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. Remove unused patch. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch203-oak-5286861d_Arja_PatchNaturalnessYe$$Oops , now have a 179 commit code. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch204-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. Remove unused method. remove old branch head after merge. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch803-oak-5286861d_Arja_PatchNaturalnessYe$$Remove unused method. "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1047-oak-5286861d_Arja_PatchNaturalnessYe$$use the same map. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch651-oak-5286861d_Arja_PatchNaturalnessYe$$only replace one head with the same parent branch. remove wrong branch root id. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1078-oak-5286861d_Arja_PatchNaturalnessYe$$Improved javadoc comment. remove msg override for merges. "Revert "" update to latest AJAX update """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1025-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch401-oak-5286861d_Arja_PatchNaturalnessYe$$remove old branch head after merge. remove wrong branch root id. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch894-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove unused commitTS. remove unused variable. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch289-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch413-oak-5286861d_Arja_PatchNaturalnessYe$$remove patched putTokens . remove ( token ). remove patched commit. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch227-oak-5286861d_Arja_PatchNaturalnessYe$$Ooops , really update commit builder. Remove patch from putCommit ( ) method. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch478-oak-5286861d_Arja_PatchNaturalnessYe$$Remove unused method. remove wrong branch root id. "Revert "" update to latest AJAX - level upgrade """. remove old map entry. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch675-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. remove old map entry. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1007-oak-5286861d_Arja_PatchNaturalnessYe$$remove extraneous line. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch412-oak-5286861d_Arja_PatchNaturalnessYe$$remove unused commitTS. remove branch root id from commit object. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1036-oak-5286861d_Arja_PatchNaturalnessYe$$remove old if / else. Ooops , really set the message. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch288-oak-5286861d_Arja_PatchNaturalnessYe$$Remove unused method. remove old branch head after merge. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch618-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove old map entry. Oops , now have a 179 commit code. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch821-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. Improve readme. remove patched commit property. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch817-oak-5286861d_Arja_PatchNaturalnessYe$$Oops , now have a 179 commit code. getHeadRevision from patched file. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch810-oak-5286861d_Arja_PatchNaturalnessYe$$getHeadRevision from patch. "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch161-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove extra line break. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1126-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. getHeadRevision from patch_971. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch157-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getMD. remove patched putTokens . remove ( token ). $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch103-oak-5286861d_Arja_PatchNaturalnessYe$$I was confused , sorry. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch594-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. only replace one head with the same parent branch. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch338-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. Remove extra line break. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1116-oak-5286861d_Arja_PatchNaturalnessYe$$remove old branch head after merging. getMD. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch363-oak-5286861d_Arja_PatchNaturalnessYe$$Ooops , really set the message. remove unused variable. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch397-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove extra line. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1118-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. removed change . asDiff ( ). $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch50-oak-5286861d_Arja_PatchNaturalnessYe$$remove patched putTokens . remove ( token ). getHeadRevision from patch. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch380-oak-5286861d_Arja_PatchNaturalnessYe$$remove old map entry. Remove unused method. "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1108-oak-5286861d_Arja_PatchNaturalnessYe$$don ' t replace branch root ID with another one. getMD. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch61-oak-5286861d_Arja_PatchNaturalnessYe$$use the same map. I was confused , sorry. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch513-oak-5286861d_Arja_PatchNaturalnessYe$$I was confused , sorry. remove old head check. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch59-oak-5286861d_Arja_PatchNaturalnessYe$$get back automatic branch root id. remove old branch head after merge. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch578-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. remove patched commit property. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch112-oak-5286861d_Arja_PatchNaturalnessYe$$Ooops , really set the message. Ooops . . . forgot a conflict in commit builder. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch576-oak-5286861d_Arja_PatchNaturalnessYe$$getHeadRevision from patch. getHeadRevisionId ( ) didn ' t return an empty revision ID. use the same map. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch727-oak-5286861d_Arja_PatchNaturalnessYe$$Remove patch from putCommit ( ) method. remove old map entry. remove parent reference. remove wrong branch root id. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch343-oak-5286861d_Arja_PatchNaturalnessYe$$remove patched commit property. use the same map. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1109-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove old branch head after merge. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch94-oak-5286861d_Arja_PatchNaturalnessYe$$use the same map. remove unused commitTS. getHeadRevision from patch_265. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch114-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove branch root id from commit object. remove old head check. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch317-oak-5286861d_Arja_PatchNaturalnessYe$$remove old map entry. getHeadRevision from patched file. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1017-oak-5286861d_Arja_PatchNaturalnessYe$$remove patched commits that were not necessary after last commit. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1075-oak-5286861d_Arja_PatchNaturalnessYe$$remove patched putTokens . remove ( token ). removed change . asDiff ( ). "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch469-oak-5286861d_Arja_PatchNaturalnessYe$$Remove patched put commit .. remove old head branch if it is the first branch. "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1044-oak-5286861d_Arja_PatchNaturalnessYe$$remove extraneous line. Remove patch from putCommit ( ) method. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch800-oak-5286861d_Arja_PatchNaturalnessYe$$remove extra line. remove patched putTokens . remove ( token ). "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1027-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove old branch head after merging. remove branch root id from commit object. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1016-oak-5286861d_Arja_PatchNaturalnessYe$$remove msg override for merges. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1074-oak-5286861d_Arja_PatchNaturalnessYe$$getHeadRevision from patched file. "Revert "" update to latest AJAX - 1006 """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch812-oak-5286861d_Arja_PatchNaturalnessYe$$Remove unused method. use the same map. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch823-oak-5286861d_Arja_PatchNaturalnessYe$$remove temp branch mapping. Remove unused method. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1060-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. use the same map. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch682-oak-5286861d_Arja_PatchNaturalnessYe$$remove extra line break. use the same map. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch212-oak-5286861d_Arja_PatchNaturalnessYe$$remove wrong branch root id. Remove unused method. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch846-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove unused commitTS. use the same map. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1061-oak-5286861d_Arja_PatchNaturalnessYe$$use the same map. remove extraneous line. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1059-oak-5286861d_Arja_PatchNaturalnessYe$$Remove patched put commit .. "Revert "" update patch for 1 . 4 . 0 """. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch878-oak-5286861d_Arja_PatchNaturalnessYe$$don ' t replace branch root ID with another one. remove branch root id from commit object. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1035-oak-5286861d_Arja_PatchNaturalnessYe$$getHeadRevision from patched file. "Revert "" update to latest AJAX - level upgrade """. Remove unused patch. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch876-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. remove temp branch mapping. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch138-oak-5286861d_Arja_PatchNaturalnessYe$$remove old branch head after merging. remove unused commitTS. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch11-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. Remove patched put commit .. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch100-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. getHeadRevision from patch. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch758-oak-5286861d_Arja_PatchNaturalnessYe$$remove old branch head after merge. "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch162-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. remove unused commitTS. Ooops , really correct the commit object. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch506-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update patch for 1 . 4 . 0 """. "Revert "" update to latest AJAX - level upgrade """. getHeadRevisionId ( ) didn ' t match any file ( s ) known to git (. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch42-oak-5286861d_Arja_PatchNaturalnessYe$$remove branch root id from commit object. use the same map. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch101-oak-5286861d_Arja_PatchNaturalnessYe$$Remove patched commit .. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch509-oak-5286861d_Arja_PatchNaturalnessYe$$Remove unused method. set gcStart. "Revert "" update to latest AJAX - level upgrade """. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch1115-oak-5286861d_Arja_PatchNaturalnessYe$$"Revert "" update to latest AJAX - level upgrade """. remove changeLog closing. Remove unused method. $$0
oak-5286861d$$Empty branch commit returns head revision on trunk$$MicroKernelImpl returns the head revision on trunk when an empty commit happens on a branch revision.$$patch369-oak-5286861d_Arja_PatchNaturalnessYe$$don ' t replace branch root ID with another one. remove branch root id from commit object. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1160-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. Remove patched put token equals method. Remove patch for rebase. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch312-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commitTS. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch315-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose check. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch924-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. don ' t write initial commit. "Revert "" update to latest put token "" after patch """. Remove rethrowing of closed stream objects in patch. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch588-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patched files. "Revert "" update to latest head """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch111-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch778-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. "Revert "" update to latest cache with updated memory """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch324-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache size """. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch129-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch526-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. remove patched code. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch370-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). Remove rethrowing of stderr in case of error. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch713-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest put token "" after patch """. update tmp. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch983-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest put token "" after patch """. remove patched file. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1134-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache with updated memory """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch948-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. remove patched commitTS. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch574-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. update checkstyle. "Revert "" update to latest put token "" after patch """. remove checkstyle blobstore close. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch770-oak-3ce758b7_Arja_PatchNaturalnessYe$$add patch. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch126-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. Remove rethrowing of deprecated API in DefaultRevisionStore. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1159-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commit ts. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch922-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove patched file. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch347-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" update to latest put token """. Remove patch from tmp. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch97-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. Remove redundant shutdown method. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch90-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commitTS. Remove redundant shutdown / restore lines. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch186-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. remove patched commit ts. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch947-oak-3ce758b7_Arja_PatchNaturalnessYe$$update cache to not use full disk. Remove patch from tmp. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch978-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove patched file. Remove IOUtils . closeQuietly for repo replication. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch52-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove patched file. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch520-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched file. remove patched commitTS. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch518-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. Remove patched put token equals method. update tmp. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch188-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patch for hadoop / fs / LengthFileChecksum . java. "Revert "" update to latest cache with updated memory """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch715-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch55-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch385-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove closeQuietly. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1085-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched file. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1082-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1076-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" remove marked "" after readIds ( ) """. "Revert "" update to latest put token "" after patching". $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch499-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. don ' t write head twice. "Revert "" update to latest put token "" after patch """. remove fail silently on stop ( ). $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1040-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch497-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. remove patched gate commit. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1281-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1078-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1013-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1219-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from tmp. "Revert "" update to latest put token "" after patch """. remove fail silently on stop ( ). $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1226-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1014-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patch from repo. "Revert "" update to latest put token "" after patching """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch895-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest """. Remove patch_10w1 try {. "Revert "" update to latest head of cache in case of need """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1022-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove IOUtils . closeQuietly for patch_908. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch892-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patched file. don ' t write head twice. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch866-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove rethrowing of closed streams in ` init ` file. "Revert "" update to latest head """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1025-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1217-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. Remove IOUtils . closeQuietly for patch_1268. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch401-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patch. Remove redundant shutdown / restore of cache in case of error. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch633-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest put token "" after patch """. remove patch. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch650-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch for now. "Revert "" check initialized before attempting to patch """. Remove rethrowing of stderr in case of error. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1280-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest cache size """. Remove patch from put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1273-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove possible NPE in dependency. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1041-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch465-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. Remove patched put token equals method. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch453-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1083-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. remove patch_139. "Revert "" update to latest cache size """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1084-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache """. Remove patch from tmp. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch692-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch269-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1229-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch858-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update patch to match class name """. remove fail silently on stop ( ). $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch632-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. don ' t write initial commit. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1023-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose check. Remove patch for failing test. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch267-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. don ' t write initial commit. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch603-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. Remove patch from tmp. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1220-oak-3ce758b7_Arja_PatchNaturalnessYe$$shut down the hell for the duration of the upgrade. "Revert "" update to latest cache with updated memory """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1012-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from tmp. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1030-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1001-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. remove patch_178. "Revert "" update to latest cache size """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch617-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). "Revert "" update to latest cache size """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch280-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose check. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch449-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" remove objects . clear ( ) """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch476-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch688-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. Remove rethrowing of deprecated API in DefaultRevisionStore. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch227-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove patch for hadoop / fs / LengthFileChecksum . java. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch829-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. "Revert "" update to latest cache """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch229-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache size """. "Revert "" update to latest """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch424-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch620-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commit ts. "Revert "" update to latest oak - mk """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch618-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" update to latest oak - mk """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch872-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. don ' t write head twice. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch477-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from tmp. "Revert "" update to latest put token """. "Revert "" update to latest """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch221-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch353-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token "" after patch """. Remove IOUtils . closeQuietly for patch_3185 .. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch708-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove patch for hadoop / fs / LengthFileChecksum . java. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch84-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched file. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch354-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head of cache in case of need """. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1119-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. "Revert "" update to latest patch """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch365-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. "Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch755-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. "Revert "" update to latest put token """. update tmp. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch331-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" set rep to null """. "Revert "" check initialized before attempting to patch """. remove patched commitTS. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch938-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache with updated memory """. Remove patch from put token equals method. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch556-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. "Revert "" check initialized """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch764-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). update checkstyle. "Revert "" check initialized """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch24-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. Remove patched files. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch135-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch307-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from tmp. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch551-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache with updated memory """. don ' t write head twice. Remove patched put token equals method. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch797-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1175-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache and shutdown ( ) """. "Revert "" update to latest put token """. remove patched file. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch390-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). Remove redundant shutdown method. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch700-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache with updated data """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch7-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update patch to match class name """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch955-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch for now. update cache size to fix # 1227. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch363-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" check initialized """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch151-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove closeQuietly. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch71-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1118-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched file. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1120-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch306-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. remove patched dirs. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch134-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from tmp. remove patched commit ts. "Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch550-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. Remove patched put token equals method. remove fail silently on stop ( ). $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch133-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" check initialized before attempting to patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch308-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1189-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. Remove IOUtils . closeQuietly for repo replication. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch559-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. Remove redundant shutdown / restore of cache .. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch754-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. "Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token "" after patch """. remove patch for hadoop / fs / LengthFileChecksum . java. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch374-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. don ' t write initial commit. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patching """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch989-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1333-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. "Revert "" remove patched opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch717-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. "Revert "" check initialized """. "Revert "" update to latest put token """. Remove patched file. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch95-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest """. "Revert "" check initialized before attempting to start". "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch183-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patched files. don ' t write head twice. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1305-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. update checkstyle. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1137-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patch for same node. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch177-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest cache with updated memory """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch721-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. update default revision store. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch719-oak-3ce758b7_Arja_PatchNaturalnessYe$$update cache size to not increase in case of an update. "Revert "" update to latest put token "" after patch """. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch316-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove redundant shutdown / restore lines. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1164-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch786-oak-3ce758b7_Arja_PatchNaturalnessYe$$set gcStart. "Revert "" update to latest put token "" after patching """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch123-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patch from tmp. remove patch_156. "Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch578-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose check. "Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch327-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache """. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch929-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patched directory. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch788-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest source of authority """. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch916-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch972-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. remove patch for hadoop / fs / LengthFileChecksum . java. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch185-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest source / rdoc """. "Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest master ; """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch515-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest ( = = snapshot ) """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch176-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1136-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch182-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch386-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. don ' t write head twice. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1138-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache """. "Revert "" update to latest patch """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch711-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. Remove patched put token equals method. remove blobStoreNeedsClose check. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch745-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. "Revert "" update to latest put token "" after patch """. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch548-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove shut down try catch block. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch34-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest cache with updated memory """. "Revert "" update to latest cache """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch310-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commit ts. "Revert "" update to latest put token """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch579-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch .. "Revert "" update to latest archive , started with """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch921-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1165-oak-3ce758b7_Arja_PatchNaturalnessYe$$update checkstyle. "Revert "" update to latest put token "" after patching """. remove patched file. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch787-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest head """. remove patch_187. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1028-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest patch """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1225-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1222-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. "Revert "" update to latest head """. remove patched commit ts. "Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1010-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest archive , started with """. "Revert "" update to latest put token "" after patching". update tmp. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1019-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. "Revert "" set rep to null """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1021-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" set rep to null """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1081-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" set rep to null """. "Revert "" update to latest cache size """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1278-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1088-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch299-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest oak - mk implements new constructor """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1020-oak-3ce758b7_Arja_PatchNaturalnessYe$$update tmp. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch252-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. don ' t write initial commit. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch435-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. Remove patch from tmp. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1223-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commitTS. "Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1029-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1016-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest head """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1042-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove redundant shutdown / restore of cache .. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1277-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose check. don ' t write initial commit. "Revert "" remove patched opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl opengl. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1248-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. Remove patch from tmp. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch486-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache with updated memory """. remove patch_120. "Revert "" update to latest put token """. remove patch from tmp. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1056-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patched put token equals method. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch812-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commitTS. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch671-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 06 07 """. remove closeQuietly. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1255-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest put token "" after patch """. remove fail silently on stop ( ). $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch444-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove closeQuietly. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch848-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. shut down the hell for the duration of the upgrade. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch279-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache """. "Revert "" update to latest put token "" after patch """. remove patched file. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch884-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove redundant shutdown / restore of cache .. "Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch613-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove unused opengl. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch248-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch841-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from tmp. Remove patch from put token equals method. remove patch. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1095-oak-3ce758b7_Arja_PatchNaturalnessYe$$added patch for readIds. "Revert "" update to 2005 - 06 07 """. don ' t write head twice. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1061-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch473-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest archive , started with """. "Revert "" update to latest put token """. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch878-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from gate. "Revert "" update to latest cache size """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch885-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove fail silently on stop ( ). "Revert "" update to latest put token """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch429-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write head twice. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch623-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 06 07 """. "Revert "" update to latest cache size """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1238-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. Remove patch from put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch564-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose check. "Revert "" remove closeQuietly ( pm ) "" for readme". "Revert "" update to latest put token "" after patching """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch100-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch16-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove patched gate commit. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1149-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 06 07 """. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1317-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove closeQuietly. Remove patched files. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch992-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove patched commit ts. "Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch19-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1170-oak-3ce758b7_Arja_PatchNaturalnessYe$$update gcpm. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch565-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. "Revert "" update to latest patch """. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch101-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch17-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove redundant shutdown / restore lines. "Revert "" update to latest put token "" after patch """. Fix commit of gate. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch333-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to 2005 - 06 07 """. "Revert "" update to latest head """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1179-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose check. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch334-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch106-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove blobStoreNeedsClose. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch394-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. "Revert "" update to latest patch """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch509-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized """. "Revert "" update to latest put token "" after patch """. "Revert "" update to latest patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch199-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose check. "Revert "" update to latest patch """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch393-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest """. "Revert "" update to latest cache size """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1327-oak-3ce758b7_Arja_PatchNaturalnessYe$$Remove patch from put token equals method. Remove patch for now. remove closeQuietly. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch4-oak-3ce758b7_Arja_PatchNaturalnessYe$$don ' t write initial commit. "Revert "" update to latest patch """. "Revert "" update patch to match class name """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch155-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" check initialized before attempting to patch """. remove patched commitTS. "Revert "" update to latest oak - mk """. "Revert "" update to latest put token "" after patch """. Remove IOUtils . closeQuietly for patch_248. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch956-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" remove marked "" after readIds ( ) """. "Revert "" update to 2005 - 12 - 29 """. "Revert "" update to latest put token """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch164-oak-3ce758b7_Arja_PatchNaturalnessYe$$remove blobStoreNeedsClose. don ' t write initial commit. Remove patched put token equals method. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch1316-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest cache """. "Revert "" update to latest put token "" after patch """. $$0
oak-3ce758b7$$PutTokenImpl not thread safe$${{PutTokenImpl}} uses prefix increment on a static member to generate presumably unique identifiers. Prefix increment is not atomic though which might result in non unique ids being generated.$$patch967-oak-3ce758b7_Arja_PatchNaturalnessYe$$"Revert "" update to latest put token "" after patch """. remove patch. remove blobStoreNeedsClose. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch544-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Remove redundant patch. gh - 66 fixed a small bug. fix missing timestamp in MockTable. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch38-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix MockTable count in compareTo. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch572-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix MockTable count in compareTo. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch145-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix JAR compareTo .. remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1105-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Remove erroneous check for table name. gh - 66 fixed a small bug. Remove redundant patch. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch110-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. remove patched file. remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch39-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous line. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch925-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put ( ) method. gh - 66 fixed a small bug. Remove erroneous check for table name. remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch378-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. Remove erroneous check for table name. Fix put ( ) method. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch203-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix columulo index update patch. Fix MockTable compareTo. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch232-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed case with datanucleus scan. remove patch for now. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1041-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous check for table name. gh - 66 fixed a small bug. Fix put ( ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch205-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove patch. gh - 66 fixed a small bug. Fix column visibility for collapsed scans. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch202-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. Fix columulo index update patch. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch400-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix an issue with MockStoreTest . compareTo ( Key ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch438-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Remove erroneous check for tableName. remove erroneous check for table name. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch258-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous check for table name. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1015-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix ant build break. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1030-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put ( ). Fix ant build break. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch619-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix an issue with MockStoreTest . compareTo ( Key ). Fix put ( ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch245-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put ( ). gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1001-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous line. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch220-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1063-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix MockTable age. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1007-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - fixed opengl error. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1009-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. remove patch for columulo column update. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch826-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 fixed opengl error. gh - 66 fixed case with datanucleus scan. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1065-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Remove erroneous check for table name. Fix put ( ). remove erroneous line. gh - 66 fixed a small bug. fix missing timestamp in MockTable . put ( ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1096-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous check for table name. gh - 66 fixed a small bug. gh - 66 fixed opengl error. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch737-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch48-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix columulo columulo patch .. fix broken patch. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1119-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous check for table name. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch159-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - fixed opengl error. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch396-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix collocation in MockTable . compareTo ( Key ). gh - 66 fixed opengl mistake. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1110-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix columulo columulo patch. remove patch for now. Remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch534-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 fixed opengl error. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch41-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. Fix put ( ) method. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1128-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put ( ). gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch103-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. remove erroneous line. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1144-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove patched addMutation. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch169-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix an issue with MockStoreTest . compareTo ( Key ). remove erroneous line. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch738-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. fix missing timestamp in MockTable . put ( ). remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1127-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - fixed opengl mistake. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch796-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix ant build break. gh - 66 fixed opengl error. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch791-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix data file. fix broken patch. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch102-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed case with MockConnector. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch374-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. remove patch. remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch115-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put ( ) method. Fix columulo index update patch. remove erroneous check for table name. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch788-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a slight problem. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch69-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. Fix put patch. Fix put ( ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1010-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1026-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch838-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - Updated patch for CASSANDRA - 51. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1088-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - Updated patch for CASSANDRA - 51. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1029-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Remove erroneous check for tableName. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1016-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put patch. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch201-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Remove erroneous check for tableName. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1051-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 fixed opengl error. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1093-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - fixed opengl error. Remove erroneous check for tableName. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch241-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous line. gh - 66 fixed a small bug. Fix put ( ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch846-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 fixed opengl mistake. Remove erroneous check for tableName. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch474-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix put ( ). fix broken patch. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch271-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 removed patch to fix failing test. remove patch for now. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch282-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. remove patch for 1 . 5476a0d. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch332-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix MockTable compareTo. gh - 66 fixed case with MockConnector. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1140-accumulo-15476a0d_Arja_PatchNaturalnessYe$$fix merge conflict count bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch552-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous check for table name. gh - 66 fixed a small bug. remove erroneous line. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch793-accumulo-15476a0d_Arja_PatchNaturalnessYe$$remove erroneous check for table name. Fix MockTable compareTo. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1125-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 fixed a small bug. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch162-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix MockTable compareTo. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch506-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. fix missing timestamp in MockTable. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch2-accumulo-15476a0d_Arja_PatchNaturalnessYe$$Fix an issue with MockStoreTest . compareTo ( Key ). Remove erroneous check for tableName. remove erroneous check for table name. $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1141-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 66 fixed a small bug. gh - 66 - fixed opengl error. Fix put ( ). $$0
accumulo-15476a0d$$Mock Accumulo Inverts order of mutations w/ same timestamp$$Mock accumulo has different behavior than real accumulo when the same key is updated in the same millisecond.  The hidden in memory map counter in mock accumulo needs to sort descending.$$patch1115-accumulo-15476a0d_Arja_PatchNaturalnessYe$$gh - 454 - added missing throw. gh - 66 fixed a small bug. gh - 66 - fixed opengl error. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch120-accumulo-b007b22e_Arja_PatchNaturalnessYe$$Remove unnecessary switch case. remove patched code. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1194-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove accidential modification. remove patch for > => < =. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch315-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patch for > => < =. remove old combiner patch. remove patch for ' findTop ( ) '. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1085-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove unnecessary check for type. remove a redundant check. remove old combiner patch. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1076-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove a / b sign from a combiner. remove patched code. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1047-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old erroneous fall through for long combiner. remove max / min entries found by accident. remove old combiner patch. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1083-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove max / min entries in jar because they ' re not compatible with java 1 . 5. remove old combiner patch. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1084-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove unnecessary check for type. remove max / min entries found by accident. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch273-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch for > => < =. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1052-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove aSign == 0 for greater than or equal to 0. remove patch from top level. remove patch for column family iterators. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1090-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old break. remove old combiner patch. remove findTop ( ) from Combiner . java. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patch for > => < =. remove old combiner patch. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1172-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patched code. remove patch for column family iterators. remove patch for > > >. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch135-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old erroneous fall through for long combiner. remove old combiner patch. remove patched findTop. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch194-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove old erroneous fall through for long combiner. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch76-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove old erroneous fall through for long combiner. remove max / min implementation of LongCombiner. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch61-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch for column family iterators. remove max / min entries found by accident. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch585-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch. remove patch for > => < =. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch972-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove unnecessary check for type. gh - 66 fixed a bug. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1196-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch for column family iterators. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1010-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch for column family iterators. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1044-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch for > => < =. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch231-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patch from top level jar. remove old erroneous fall through for long combiner. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch636-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove a redundant check. remove old combiner patch. remove patch for column family iterators. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch801-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patch for hadoop / accumulo / hadoop / fs / LengthFileChecksum . java. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch239-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove accidential modification. remove aSign > bSign. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch1002-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove patch for > > >. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch100-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patch for reduce ( ). $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch590-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove patch for reduce ( ). remove max / min entries in jar because they ' re not compatible with java 1 . 5. $$0
accumulo-b007b22e$$Combiner default behavior is dangerous$$Currently if the users does not give the combiner any columns to work against, it will work against all columns.  This is dangerous, if a user accidentally forgets to specify columns then their data could be unintentionally corrupted.  Something different needs to be done.    Also classes that extend combiner should call super.validateOptions().$$patch10-accumulo-b007b22e_Arja_PatchNaturalnessYe$$remove old combiner patch. remove old erroneous fall through for long combiner. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch912-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove unused incompilable code. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch189-flink-45fb6d82_Arja_PatchNaturalnessYe$$Updated toString patch. Remove badly placed patch. Remove inconsistent check for group strategy. Remove redundant initProperties call. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch941-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Removed patch from source files. Remove inconsistent check for group strategy. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch983-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. update marker. Removed patch from source files. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch914-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. update marker. Remove forced rebalancing from PartitionNode. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch121-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove local strategy from group reduce node. Remove patch for compiler error. Removed patch for compiler node. Remove unused patch. Remove patch from rgps. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1103-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. Remove old patch. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch455-flink-45fb6d82_Arja_PatchNaturalnessYe$$Updated patch for compiler toString. Remove forced rebalancing from PartitionNode. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch832-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. Remove old merge conflict. Remove patch from rgps. Updated patch for compiler debug information. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1082-flink-45fb6d82_Arja_PatchNaturalnessYe$$Allow restrictive plan hints at compile time. Remove redundant patch. Remove inconsistent check for group strategy. Remove redundant initProperties call. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1049-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove inconsistent check for group strategy. Remove unnecessary call to setGroupedFields ( ) in GroupReduceWithCombineProperties. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1047-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove forced rebalancing from PartitionNode. update tmp. Fix inconsistent sort for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1013-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch437-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove badly placed patch. Fix inconsistent sort for group strategy. Remove old combiner node setDegreeOfParallelism. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch602-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove old patch. Removed break line. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch406-flink-45fb6d82_Arja_PatchNaturalnessYe$$Removed patch from source files. Remove forced rebalancing from PartitionNode. Fix inconsistent sort for group strategy. Fix bug in GroupReduceWithCombineProperties. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1048-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove unnecessary call to setGroupedFields ( ) in GroupReduceWithCombineProperties. Remove patch from rgps. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch833-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Removed two redundant lines. Remove patch .. Fix broken patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch856-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove inconsistent check for group strategy. Remove over - aggressive merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1015-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Remove badly placed patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch851-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove a redundant check. Remove old patch. Remove unused incompilable code. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch409-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. remove old combiner init property. Remove forced rebalancing from PartitionNode. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch414-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old merge conflict. Removed local improvements. Remove patch from rgps. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch220-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. remove redundant initProperties call. Remove unused incompilable code. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch471-flink-45fb6d82_Arja_PatchNaturalnessYe$$remove redundant initProperties call. Remove patch from rgps. Remove unused incompilable code. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1063-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1090-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. update tmp. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch616-flink-45fb6d82_Arja_PatchNaturalnessYe$$remove old combiner init property. Remove unused patch .. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch843-flink-45fb6d82_Arja_PatchNaturalnessYe$$remove old combiner init properties. Remove old patch. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch288-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix a bug inOptimizerNode . toString ( ). Remove old patch. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch826-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant merge of GroupReduceWithCombineProperties .. Removed local testing patch. Remove unused incompilable code. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch70-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove inconsistent check for group strategy. remove old combiner init properties. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1188-flink-45fb6d82_Arja_PatchNaturalnessYe$$Removed patch for compiler class name. Remove forced rebalancing from PartitionNode. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch76-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove old patch. Updated patch for compiler test. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch339-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Allow restrictive plan hints at compile time. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch13-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Remove patched code .. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch330-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove patch .. Remove patch from rgps. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch717-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. Remove old patch. Remove old toString patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch373-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove badly placed patch. Remove inconsistent check for group strategy. Remove old merge conflict. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch345-flink-45fb6d82_Arja_PatchNaturalnessYe$$Removed patch from source files. Remove old patch. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch540-flink-45fb6d82_Arja_PatchNaturalnessYe$$Removed patch for compiler class name. Remove patch from rgps. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch32-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove unused incompilable code. Remove local strategy from group reduce node. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1163-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove unused incompilable code. Remove redundant patch. Remove old merge conflict. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1136-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Removed patch from source files. Updated toString patch. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch321-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. Remove old patch. Remove unused patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch742-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Removed local testing. Remove redundant patch. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1017-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix swapped joins. Remove redundant patch. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch891-flink-45fb6d82_Arja_PatchNaturalnessYe$$Removed patch fromOptimizerNode. Remove old patch. Remove old merge conflict. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1072-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove local strategy from group reduce node. Remove old patch. Updated patch for compiler test. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch655-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Allow restrictive plan hints at compile time. Remove unused incompilable code. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1043-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Remove old patch. Removed local improvements. Remove unused patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch863-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove patch from plan graph. Remove unused patch .. Remove patch from rgps. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1027-flink-45fb6d82_Arja_PatchNaturalnessYe$$Removed two redundant lines. Remove unused patch. Remove old patch. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1029-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove forced rebalancing from PartitionNode. Removed patch from source files. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch230-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Removed local improvements. remove redundant initProperties call. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch812-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Fix bug in GroupReduceWithCombineProperties. Removed a couple of unused lines. Remove patch from rgps. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1060-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1206-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant initProperties call. Updated patch for compiler test. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch241-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove unused patch. Fix inconsistent sort for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch417-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove forced rebalancing from PartitionNode. update marker. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch213-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Remove forced rebalancing from PartitionNode. Removed break line. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1050-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove old patch. update marker. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch474-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Remove old patch. Removed local improvements. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1003-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant initProperties call. Remove forced rebalancing from PartitionNode. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch1207-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. Remove forced rebalancing from PartitionNode. Remove inconsistent check for group strategy. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch165-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove unused incompilable code. Remove old patch. Remove redundant patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch705-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove redundant patch. Updated toString patch. Remove inconsistent check for group strategy. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch792-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix inconsistent sort for group strategy. Fix bug in GroupReduceWithCombineProperties. update tmp. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch768-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant patch. Allow restrictive plan hints at compile time. Removed break line. Remove old patch. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch101-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove old patch. Allow restrictive plan hints at compile time. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch139-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove redundant mark on GroupReduceWithCombineProperties node. Remove forced rebalancing from PartitionNode. Allow restrictive plan hints at compile time. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch704-flink-45fb6d82_Arja_PatchNaturalnessYe$$Fix bug in GroupReduceWithCombineProperties. Remove patch from rgps. Updated patch for compiler toString. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch394-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove forced rebalancing from PartitionNode. add a heuristic disk cost comparison to the disk cost comparison. Remove redundant initProperties call. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch43-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove old patch. Remove patch. Fix inconsistent sort for group strategy. Remove redundant patch. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch507-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove forced rebalancing from PartitionNode. Remove redundant patch. Remove redundant merge of GroupReduceWithCombineProperties .. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch190-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove inconsistent check for group strategy. Remove old patch. Removed a couple incorrect lines from a previous commit that prevents you from using an old one. Removed a couple of unused lines. $$0
flink-45fb6d82$$Optimizer prunes all candidates when unable to reuse sort properties$$Programs fail with an exception that no plan could be created. The bug can be reproduced by the following code:  {code} val data : DataSet[(Long, Long)] = ...  data.distinct(0, 1).groupBy(0).reduceGroup(...) {code}$$patch86-flink-45fb6d82_Arja_PatchNaturalnessYe$$Remove a redundant check. Allow restrictive plan hints at compile time. Remove patch from rgps. Remove redundant patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch521-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update tmp. Remove patch 1434. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch341-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. update patched jar. Remove a redundant call to put in a map. Remove patched code. fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch313-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove unnecessary code. fix broken patch. update patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch347-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patched code. update patched jar. fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch835-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Removed patch for codenarc. update patch for code improvement. Remove wrapper from chained configuration ; it is not needed .. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch401-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patch from code. Fix a bug in the CollectorWrapper class .. fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch233-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. update patched jar. Remove patch from jar. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch409-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. fix broken patch. Remove wrapper from chained configuration ; it is not needed .. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch436-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. Remove wrapper from chained configuration ; it is not needed .. Remove patched code. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1205-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patched code. update patched jar. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1006-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch221-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patched code. Removed patch for code improvement. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch569-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update patched jar. Remove patch from jar. Fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch990-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove wrapper from chained configuration ; it is not needed .. update patch for code improvement. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch76-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. Remove unnecessary code. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch592-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. update patch for closure issues. Remove patch from code. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1137-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove unnecessary code. fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1130-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patched code. fix broken patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch582-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update patched jar. Remove patch from jar. Updated patch for code improvement. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1131-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix a bug in the code style. update patch for streaming job graph generator. Added patch for streaming job graph generation. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1028-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update tmp. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch291-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patch for class loader reset. Remove wrapper from chained configurations. Remove unused patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch899-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update patched jar. update patched jar. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch492-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patched code. fix broken patch. Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1067-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update patched jar. Added patch for streaming job graph generation. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1094-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. Remove wrapper from chained configuration ; it is not needed .. Remove patched code. Removed patched code. update patched jar. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1034-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patched code. update patched jar. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch1057-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. Remove wrapper from chained configuration ; it is not needed .. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch882-flink-0cfa43d7_Arja_PatchNaturalnessYe$$update patch for code improvement. Remove patch from jar. update patch for closure issues. Moving to a new patch. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch87-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove patch from jar. Fix a bug in the BroadcastOutputSelectorWrapper . addCollector. update tmp. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch45-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Removed patch .. update patched jar. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch933-flink-0cfa43d7_Arja_PatchNaturalnessYe$$fix broken patch. update patch. Remove wrapper from chained configuration ; it is not needed .. $$0
flink-0cfa43d7$$Chained stream tasks share the same RuntimeContext$$Chained stream operators currently share the same runtimecontext, this will certainly lead to problems in the future.   We should create separate runtime contexts for each operator in the chain.$$patch562-flink-0cfa43d7_Arja_PatchNaturalnessYe$$Remove wrapper from tmp. fix broken patch. update patch for closure issues. update tmp. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch31-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a backprop to the patch .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch30-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix a bug in leastsquares optimizer .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch8-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a line of code to track the number of times we iterate over the two - . Remove an unnecessary call to incrementCount .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch1-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix NPE in LevenbergMarquardtOptimizer . java. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch6-math-e2dc384d_Arja_PatchNaturalnessYe$$Updated variable name. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch15-math-e2dc384d_Arja_PatchNaturalnessYe$$Updated variable name. Fix a bug in the leastsquares optimizer .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch12-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a line of code to track the number of times we think we ' ve done the. Remove an unnecessary call to incrementCount .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch23-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix a bug in the leastsquares optimizer .. Fix the patch for one more test. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch7-math-e2dc384d_Arja_PatchNaturalnessYe$$Updated variable name. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch9-math-e2dc384d_Arja_PatchNaturalnessYe$$Put back the initial value of the function in the same thread as the other one .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch22-math-e2dc384d_Arja_PatchNaturalnessYe$$Added step to increase xNorm .. Fix variable name error. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch25-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix variable name variable. Fix xNorm reset during minimized least squares test. Fix the case for svn patch .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch13-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a line of code to mark the end of a line of code. Remove an unnecessary call to incrementCount .. Fix the patch for one more test. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch14-math-e2dc384d_Arja_PatchNaturalnessYe$$Updated one of the patched code .. Fix a bug in the same way as in the other one .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch32-math-e2dc384d_Arja_PatchNaturalnessYe$$Updated one of the work items for the patch .. Fix one more test. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch5-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a line of code to track the number of times we iterate over the two - . Fix a bug in the inverse function so that it doesn ' t become an error in the inverse. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch2-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a line of code that was accidentally left in the last commit .. Remove an unnecessary call to incrementCount .. Fix xNorm reset during minimized least squares test. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch19-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix variable variable. Fix the case for svn patch .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch26-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix variable name error in LevenbergMarquardtOptimizer. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch21-math-e2dc384d_Arja_PatchNaturalnessYe$$Added missing incrementCount ( ) to LevenbergMarquardtOptimizer. Fix a bug in the inverse search. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch28-math-e2dc384d_Arja_PatchNaturalnessYe$$Added a line of code to track the number of times we iterate over the two - . Remove an unnecessary call to incrementCount .. Fix patch. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch17-math-e2dc384d_Arja_PatchNaturalnessYe$$Updated variable name. Fix a bug in the likelihood function. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch10-math-e2dc384d_Arja_PatchNaturalnessYe$$Added one more test to see if the function is still working .. $$0
math-e2dc384d$$LevenburgMaquardt switched evaluation and iterations$$None$$patch3-math-e2dc384d_Arja_PatchNaturalnessYe$$Fix a bug in the inverse function to save energy .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch120-math-f6dd42b4_Arja_PatchNaturalnessYe$$fixed NPE in UnivariateRealSolverImpl . verifyInterval. Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch36-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set the result of the patch as it was clear before the patch was added .. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch31-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reset the inverse of the patch to the last result .. Add missing patch. changed max iterations count. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch118-math-f6dd42b4_Arja_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Added a solution if the function value is good enough. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch111-math-f6dd42b4_Arja_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Add missing patch. Added patch to root cause error .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch38-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Fix swapped vec3s in BrentSolver . java. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch116-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing exception. Fix swapped vecs in BrentSolver . java. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch54-math-f6dd42b4_Arja_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch98-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reduce min and initial bracket the root .. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch53-math-f6dd42b4_Arja_PatchNaturalnessYe$$Remove a couple incorrect code lines. Set default function value accuracy back to 0 . 5 . 4. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch62-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver does not clear the result flag at the end of a test. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch117-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Added missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch110-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver now returns 0 if yMin is < 0 .. Add missing patch. Fix swapped deltas. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch39-math-f6dd42b4_Arja_PatchNaturalnessYe$$Removed a redundant line. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch126-math-f6dd42b4_Arja_PatchNaturalnessYe$$added fix from pull request. Set function value accuracy to default function value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch30-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing exception. Set default function value accuracy to 1 . 0e - 15 .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch119-math-f6dd42b4_Arja_PatchNaturalnessYe$$throw exception if function to solve cannot be null. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch63-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver now returns 0 if yMin is < 0 .. Add missing patch. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch97-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch90-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a throw exception if the function value at endpoints do not have the same signs .. Set default function value accuracy to 1 . 0e - 15 .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch64-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch99-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch52-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch55-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reset the inverse of the patch if it is better than the function value .. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch77-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. BrentSolver . setResult ( x1 , i ) ;. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch83-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reset the computed result as false in BrentSolver .. Add missing patch. Fix broken patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch48-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Add a throw exception if the function to solve cannot be null. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch84-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added verifyInterval to BrentSolver. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch70-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver doesn ' t clear the result before attempting to use it. Added a throw to the console. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch8-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver doesn ' t clear the result before attempting to use it. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added verifyInterval ( ) to function value function. Add missing patch. Fix a minor bug in BrentSolver. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch79-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. changed max iterations count. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch103-math-f6dd42b4_Arja_PatchNaturalnessYe$$Removed erroneous test. Added a throw to the console. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch15-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. revert accidently change. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch104-math-f6dd42b4_Arja_PatchNaturalnessYe$$added update of erroneous line. Added a throw to the console. BrentSolver . setResult ( x1 , i ) ;. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch12-math-f6dd42b4_Arja_PatchNaturalnessYe$$Remove a redundant patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch24-math-f6dd42b4_Arja_PatchNaturalnessYe$$added fix from pull request. Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch23-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch40-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a solution if the solution is good enough. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch7-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added missing exception check. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch47-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a throw to the console. Set default function value accuracy to 1 . 0e - 15 .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch78-math-f6dd42b4_Arja_PatchNaturalnessYe$$add a throw exception if one of the interval is not a sequence. Add missing exception. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch85-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to 0 .. Add missing patch. BrentSolver setResult ( x1 , i ) ;. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch9-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a throw to the console. revert accidently change to the old one. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch76-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to 0 if yInitial is good enough .. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch49-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a result computed so that it can be used as the sole endpoint .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch22-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch25-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a throw exception if the function value at endpoints do not have the same signs .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch105-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy. Add missing patch. Add a throw exception if the function to solve cannot be null. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch13-math-f6dd42b4_Arja_PatchNaturalnessYe$$added backprop to verifySequence ( ). Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch102-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default , as it is done with the default function value accuracy. Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch14-math-f6dd42b4_Arja_PatchNaturalnessYe$$I had left it as a last resort .. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch50-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reset the iterator count as we proceeded to the next test. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch68-math-f6dd42b4_Arja_PatchNaturalnessYe$$throw exception if function to solve is null. Added missing exception check. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch57-math-f6dd42b4_Arja_PatchNaturalnessYe$$fixed a minor bug in UnivariateRealSolverImpl . verifyInterval. Added a throw to the console. revert accidently change to the old one. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch95-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix the case for the min function to be good enough. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch61-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to 0 if endpoints are not good enough. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch59-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Fixing a minor bug in BrentSolver .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch66-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch92-math-f6dd42b4_Arja_PatchNaturalnessYe$$Removed a redundant line. Added a throw to the console. Fix erroneous cross - sentence error in BrentSolver. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch124-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch32-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set this . resultComputed to false in BrentSolver . java. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch123-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix the case for the min function to work properly. Add missing patch. changed max iter count. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch115-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reset the inverse of the patch if it is better than the function value .. Add missing patch. BrentSolver . setResult ( x1 , i ) ;. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch58-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Added patch to prevent adding iterations to the same thread. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch67-math-f6dd42b4_Arja_PatchNaturalnessYe$$throw exception if function to solve is null. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch60-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver now uses 0 . 0 solution. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch94-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch69-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing exception. changed parallel patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch56-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to 0 if y < min && y > max. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch51-math-f6dd42b4_Arja_PatchNaturalnessYe$$throw exception if function to solve is null. Add missing patch. changed line. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch113-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added missing exception check. Fix broken patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch114-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix test. Add missing patch. Add a throw exception if the function to solve cannot be null. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch122-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver now returns 0 if yMin is < 0 .. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch34-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing exception. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch125-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a throw exception if the function value at endpoints do not have the same signs .. revert accidently change. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch33-math-f6dd42b4_Arja_PatchNaturalnessYe$$throw exception if function to solve cannot be null. Remove a redundant check. Added a throw to the console. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch107-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Fix broken patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch11-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add a throw exception if we can ' t find a solution. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch29-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default value accuracy. Add missing exception. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch100-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch16-math-f6dd42b4_Arja_PatchNaturalnessYe$$fixed a minor bug in UnivariateRealSolverImpl . verifyInterval. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch109-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch18-math-f6dd42b4_Arja_PatchNaturalnessYe$$Removed a redundant line. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch87-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing exception. BrentSolver had a clear result ; removed redundant clearResult calls. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch73-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set default function value accuracy to 1 . 0e - 15 .. Add missing patch. Fixing a minor bug in BrentSolver .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch74-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix incorrect patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch80-math-f6dd42b4_Arja_PatchNaturalnessYe$$added missing line. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch42-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch5-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch89-math-f6dd42b4_Arja_PatchNaturalnessYe$$added verifyBracketing. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch45-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch19-math-f6dd42b4_Arja_PatchNaturalnessYe$$BrentSolver now uses the result of running function with a lower tolerance .. Added a throw to the console. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch108-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. revert patch. Add a throw exception if the function to solve cannot be null. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch21-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing exception. BrentSolver . setResult ( x1 , i ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch28-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy. I had made a mistake of failing test. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch101-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set default function value accuracy. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch17-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. Fix changed delta .. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch106-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set default function value accuracy back to 0 . 1 . 0. Fix broken patch. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch44-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix the case for the min function to return the first endpoint. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch3-math-f6dd42b4_Arja_PatchNaturalnessYe$$Added a throw exception if the function value at endpoints do not have the same signs .. changed max iterations count. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch4-math-f6dd42b4_Arja_PatchNaturalnessYe$$Set function value accuracy to default function value accuracy. Add missing patch. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch88-math-f6dd42b4_Arja_PatchNaturalnessYe$$Fix the merge of one - to - one calls into conferences. Add missing patch. Fix a minor bug in the BrentSolver such that yMin and yMax are not close to. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch81-math-f6dd42b4_Arja_PatchNaturalnessYe$$Remove redundant clearResult ( ) call. Set function value accuracy to default function value accuracy. Add missing patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch75-math-f6dd42b4_Arja_PatchNaturalnessYe$$update inverse patch. Added a throw to the console. revert patch. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch72-math-f6dd42b4_Arja_PatchNaturalnessYe$$Add missing patch. improve stability of BrentSolver. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch86-math-f6dd42b4_Arja_PatchNaturalnessYe$$Reset the cached result of the BrentSolver such that it is not possible to reduce the interval of. Add missing patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch120-math-328513f3_Arja_PatchNaturalnessYe$$Remove one more test. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch127-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix CMAESOptimizer logMu2 = Math . log ( mu + 0 . 5 ) ;. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch31-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch118-math-328513f3_Arja_PatchNaturalnessYe$$Revert this. update marker file. Fix C = diag ( x ) .. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch111-math-328513f3_Arja_PatchNaturalnessYe$$Fix C = fix. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch38-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). remove patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch116-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix single line error in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch129-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Remove a couple incorrect lines. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch142-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch54-math-328513f3_Arja_PatchNaturalnessYe$$Reset repaired [ i ] to 0 ; we don ' t need it. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch98-math-328513f3_Arja_PatchNaturalnessYe$$CCC = > RC. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch145-math-328513f3_Arja_PatchNaturalnessYe$$Use the latest log4j step for CMAES optimization. Fix a bug in CMAESOptimizer caused by incorrect patch .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch53-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Remove a couple incorrect lines. Fix a bug in CMAESOptimizer where the boundaries are not null .. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch65-math-328513f3_Arja_PatchNaturalnessYe$$update marker. CCC = > RBF ( min mueff value ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch91-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. Fix single line error in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch96-math-328513f3_Arja_PatchNaturalnessYe$$Fix single line exception. CANCER patch attempted fix. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch62-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix a look for a better error message. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch117-math-328513f3_Arja_PatchNaturalnessYe$$Fix a minor bug in CMAESOptimizer such that it does not set a value. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch128-math-328513f3_Arja_PatchNaturalnessYe$$Fix a look for a better exception in ' cmAESOptimizer '. fix merge conflict resolution. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch110-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Updated patch for MathRuntimeException . getLocalizedMessage ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch39-math-328513f3_Arja_PatchNaturalnessYe$$Missing context variable. Fix possible NPE in CMAESOptimizer. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch126-math-328513f3_Arja_PatchNaturalnessYe$$Fix single line error in CMAESOptimizer . repair ( ) .. Fix possible NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch30-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Use the latest log4j step for CMAES optimization. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch119-math-328513f3_Arja_PatchNaturalnessYe$$update marker. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch121-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Remove a couple incorrect lines. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch37-math-328513f3_Arja_PatchNaturalnessYe$$Remove stray patch .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch63-math-328513f3_Arja_PatchNaturalnessYe$$Use the latest log4j step for CMAES optimization. Fix CMAESOptimizer patch .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch97-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Fix a look for a better error message. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch90-math-328513f3_Arja_PatchNaturalnessYe$$Add a backprop to CMAESOptimizer logMu2 .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch64-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). CCC = min mueff for CMAES optimization. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch99-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). readded missing context object .. Remove unnecessary line. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch144-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch52-math-328513f3_Arja_PatchNaturalnessYe$$Use the latest log4j step for CMAES optimization. Fix a bug in CMAESOptimizer where the boundaries are not null. Revert previous patch. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch143-math-328513f3_Arja_PatchNaturalnessYe$$Fix diagD. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch55-math-328513f3_Arja_PatchNaturalnessYe$$Revert previous patch. update marker. CAMEL - 2833 fixed the inverse of square root. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch161-math-328513f3_Arja_PatchNaturalnessYe$$Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch77-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix diagD = sqrt ( diagD ) ;. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch48-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update penalty from patched PR. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch84-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). CAMAESOptimizer now uses one - to - one because it is not compatible with current A. CAMEL - 102 fixed the indentation of the objective function. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch70-math-328513f3_Arja_PatchNaturalnessYe$$update marker. CAMAESOptimizer now uses one - to - one because it is not compatible with current A. Revert MathUtils rounding method. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch8-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Set historySize for CMAESOptimizer . penalty ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch159-math-328513f3_Arja_PatchNaturalnessYe$$Revert MathUtils rounding method. Fix single line error in CMAESOptimizer . repair ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch46-math-328513f3_Arja_PatchNaturalnessYe$$Revert MathUtils rounding method. remove patch from CMAESOptimizer. Fix single line error in CMAESOptimizer . repair ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch150-math-328513f3_Arja_PatchNaturalnessYe$$Fix NPE in CMAESOptimizer. Fix NPE in CMAESOptimizer . repair ( ) .. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch1-math-328513f3_Arja_PatchNaturalnessYe$$update patch for CMAESOptimizer. Fix a bug in CMAESOptimizer where the boundaries are not null. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch79-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Remove one more test. Remove a couple incorrect lines. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch6-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix a minor bug in CMAESOptimizer . java. Fix CMAESOptimizer penalty ( fixed in 1 . 6 . 2 ) .. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch41-math-328513f3_Arja_PatchNaturalnessYe$$Remove ccovmuSep from CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch157-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Reset fitness history after 1 . 0 value was found. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch103-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix CMAESOptimizer patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch15-math-328513f3_Arja_PatchNaturalnessYe$$Revert MathUtils rounding method. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch104-math-328513f3_Arja_PatchNaturalnessYe$$Stop the CMAES optimization from running in a war. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch12-math-328513f3_Arja_PatchNaturalnessYe$$Revert previous patch. Fix single line exception. Fix NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch24-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer where lambda was not applied , this . lambda was not used. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch132-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update patch. Remove a couple incorrect lines. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch23-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Set context to empty string so it doesn ' t get put into the same place as the other. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch135-math-328513f3_Arja_PatchNaturalnessYe$$Updated patch for MathRuntimeException . getMessage. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch40-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix possible NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch156-math-328513f3_Arja_PatchNaturalnessYe$$readded missing context object .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch7-math-328513f3_Arja_PatchNaturalnessYe$$Set historySize for CMAESOptimizer . penalty ( ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch47-math-328513f3_Arja_PatchNaturalnessYe$$update patch. Fix CMAESOptimizer patch. Fix C = diag ( x ) .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch78-math-328513f3_Arja_PatchNaturalnessYe$$update normps after convergence check. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch71-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Updated patch for 118. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch85-math-328513f3_Arja_PatchNaturalnessYe$$Fix CMAESOptimizer patch. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch158-math-328513f3_Arja_PatchNaturalnessYe$$increment evaluations . incrementCount ( ). Fix incorrect C = > 1 . 0 in CMAESOptimizer. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch9-math-328513f3_Arja_PatchNaturalnessYe$$Fix unnecessarily non - minimal penalty in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch82-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix diagD .. Set historySize for CMAESOptimizer . penalty ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch160-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix broken patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch76-math-328513f3_Arja_PatchNaturalnessYe$$update patch for CMAESOptimizer. Fix CMAESOptimizer penalty ( fixed in 1 . 6 . 2 ) .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch49-math-328513f3_Arja_PatchNaturalnessYe$$Remove a couple incorrect lines. Set historySize for CMAESOptimizer . penalty ( ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch22-math-328513f3_Arja_PatchNaturalnessYe$$Fix C = diag ( x ) .. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch134-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update patch. Set historySize for CMAES optimization patch .. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch25-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Missing context variable. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch133-math-328513f3_Arja_PatchNaturalnessYe$$Fix uninitialized variable. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch13-math-328513f3_Arja_PatchNaturalnessYe$$Remove a redundant check. update CMAESOptimizer with a new patch. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch102-math-328513f3_Arja_PatchNaturalnessYe$$update prev guess after convergence check. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch14-math-328513f3_Arja_PatchNaturalnessYe$$Revert previous patch. CAMEL - 328513f3 fixed a small bug. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch146-math-328513f3_Arja_PatchNaturalnessYe$$Fix a minor bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch68-math-328513f3_Arja_PatchNaturalnessYe$$Fix single dimension exception. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch141-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Added missing patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch57-math-328513f3_Arja_PatchNaturalnessYe$$Set iterations = 0 in CMAESOptimizer . java. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch148-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch95-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer. Fix a minor bug in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch61-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix C = diag ( x ) .. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch59-math-328513f3_Arja_PatchNaturalnessYe$$Use the latest log4j step for CMAES optimization. Revert this. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch66-math-328513f3_Arja_PatchNaturalnessYe$$Use a new evaluations object added by accident. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch92-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Fix single line exception. Fix single line error in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch124-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update marker. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch32-math-328513f3_Arja_PatchNaturalnessYe$$update marker. CANCEO - 1216 , adjust for the fix. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch123-math-328513f3_Arja_PatchNaturalnessYe$$Set historySize for CMAESOptimizer. Fix C = diag ( x ) .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch35-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). CAMAESOptimizer now uses one - to - one because it is not compatible with current A. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch115-math-328513f3_Arja_PatchNaturalnessYe$$Revert previous patch. Allow null values in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch112-math-328513f3_Arja_PatchNaturalnessYe$$Reset diagonalonly after each loop. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch93-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer where the boundaries are not null .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch67-math-328513f3_Arja_PatchNaturalnessYe$$Revert this. Fix a bug in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch149-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix CMAESOptimizer patch .. Fix incorrect patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch60-math-328513f3_Arja_PatchNaturalnessYe$$Set iterations = 0 in CMAESOptimizer . java. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch94-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Set historySize for CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch69-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). readded missing context object .. update patch. Fix cmAESOptimizer patch. Remove stray patch from CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch140-math-328513f3_Arja_PatchNaturalnessYe$$Fix CMAESOptimizer patch. Fix diagD .. Updated patch for MathRuntimeException . getLocalizedMessage ( ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch51-math-328513f3_Arja_PatchNaturalnessYe$$Add missing patch. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch113-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix cmAESOptimizer patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch114-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer caused by incorrect patch .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch122-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). CANCEO - 1216 , adjust for the fix. Fix CMAESOptimizer patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch34-math-328513f3_Arja_PatchNaturalnessYe$$update patch. Fix single line error in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch125-math-328513f3_Arja_PatchNaturalnessYe$$CCC = > RBF ( min mueff value ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch33-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix possible NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch11-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Fix a possible NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch29-math-328513f3_Arja_PatchNaturalnessYe$$CAMEL - 6209 Fixed a bug in CMAESOptimizer such that lambda > .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch16-math-328513f3_Arja_PatchNaturalnessYe$$CAMEL - 6209 Fixed the inverse of square root .. CANCER patch attempted fix. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch20-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Updated patch for MathRuntimeException. Use the latest log4j step for CMAES optimization. increment evaluations . incrementCount ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch18-math-328513f3_Arja_PatchNaturalnessYe$$Fix uninitialized variable. CAMEL - 7209 Fixed a minor issue with the inverse function of some of the arguments. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch27-math-328513f3_Arja_PatchNaturalnessYe$$CAMEL - 7209 Fixed a minor issue with the objective function of CMAESOptimizer at. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch87-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Remove one more test. Fix diagD .. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch73-math-328513f3_Arja_PatchNaturalnessYe$$Fix NPE in CMAESOptimizer. Set historySize for CMAESOptimizer . penalty ( ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch80-math-328513f3_Arja_PatchNaturalnessYe$$Reset fitness history after 1 . 0 value was found. Fix NPE in CMAESOptimizer. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch42-math-328513f3_Arja_PatchNaturalnessYe$$CANCER patch attempted fix. Remove unnecessary line. Revert previous patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch5-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update patch. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch89-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update CMAESOptimizer with a new one - liner. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch2-math-328513f3_Arja_PatchNaturalnessYe$$Fix single line exception. Remove a couple incorrect lines. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch45-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch19-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch26-math-328513f3_Arja_PatchNaturalnessYe$$Revert previous patch. update patch. Add ccov1 back into repaired objective function. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch21-math-328513f3_Arja_PatchNaturalnessYe$$Fix single line exception. Fix a bug in CMAESOptimizer where the boundaries are not null .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch28-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update marker. Use the latest log4j step for CMAES optimization. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch17-math-328513f3_Arja_PatchNaturalnessYe$$Revert MathUtils rounding method. Remove a couple incorrect lines. Fix possible NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch10-math-328513f3_Arja_PatchNaturalnessYe$$Remove a couple incorrect lines. CCC = > RBF ( min mueff value ). Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch44-math-328513f3_Arja_PatchNaturalnessYe$$CANCER patched , so that we can use the ccov1 function as well. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch152-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix a bug in CMAESOptimizer. Fix NPE in CMAESOptimizer. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch3-math-328513f3_Arja_PatchNaturalnessYe$$Revert MathUtils rounding method. Reset the value of the penalty column to 0 ; the new penalty column would be better placed on. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch4-math-328513f3_Arja_PatchNaturalnessYe$$update penalty from patched PR. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch43-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). update patch. Fix single line exception. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch155-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer where the boundaries are not null. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch88-math-328513f3_Arja_PatchNaturalnessYe$$Fix diagD .. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch81-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). CAMEL - 2833 fixed lambda = 4 + ( int ) ( 3 . log (. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch163-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Fix C = diag ( x ) .. CCC = > RBF ( min mueff value ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch75-math-328513f3_Arja_PatchNaturalnessYe$$Fix cmAESOptimizer patch. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch164-math-328513f3_Arja_PatchNaturalnessYe$$update lambda / 2. Reverted accidental throw of MathUtils . doubleValue ( ). $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch72-math-328513f3_Arja_PatchNaturalnessYe$$Reverted accidental throw of MathUtils . doubleValue ( ). Add a logMu2 variable to CMAESOptimizer . java. $$0
math-328513f3$$MathUtils round method should propagate rather than wrap Runitme exceptions$$MathUtils.round(double, int, int) can generate IllegalArgumentException or ArithmeticException.  Instead of wrapping these exceptions in MathRuntimeException, the conditions under which these exceptions can be thrown should be documented and the exceptions should be propagated directly to the caller.$$patch86-math-328513f3_Arja_PatchNaturalnessYe$$Fix a bug in CMAESOptimizer. Added CCC to the patch for CMAES optimization. Revert previous patch. $$0
math-cc4ab51e$$BinomialDistribution deals with degenerate cases incorrectly$$The following calculation returns false results:  {{new BinomialDistribution(0, 0.01).logProbability(0)}}  It evaluates to Double.NaN when it should be 0 (cf., for example, "dbinom(0, 0, 0.01, log=T)" in R).  I attach a patch dealing with the problem. The patch also adds a test for this bug.$$patch25-math-cc4ab51e_Arja_PatchNaturalnessYe$$Fix SaddlePointExpansion test. Fix NPE in SaddlePointExpansion. $$0
math-cc4ab51e$$BinomialDistribution deals with degenerate cases incorrectly$$The following calculation returns false results:  {{new BinomialDistribution(0, 0.01).logProbability(0)}}  It evaluates to Double.NaN when it should be 0 (cf., for example, "dbinom(0, 0, 0.01, log=T)" in R).  I attach a patch dealing with the problem. The patch also adds a test for this bug.$$patch2-math-cc4ab51e_Arja_PatchNaturalnessYe$$Fix SaddlePointExpansion with a max of 1 , min = - 1 , max = -. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch36-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. fixed a bug in OrderedTuple. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch54-math-2a6c6409_Arja_PatchNaturalnessYe$$update pending array. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch53-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw new MathInternalError ( ). Fix swapped inf / inf in OrderedTuple. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch62-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. BSPTree now uses the modified cut property. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch39-math-2a6c6409_Arja_PatchNaturalnessYe$$removed extraneous whitespace. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch37-math-2a6c6409_Arja_PatchNaturalnessYe$$Fix euclidean intersections , added missing patch. Fix swapped offset values in OrderedTuple. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch63-math-2a6c6409_Arja_PatchNaturalnessYe$$Fix parallel hyperplanes , added patch. removed patch for BSPTree. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch64-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. Set exception context to empty string context for now. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch52-math-2a6c6409_Arja_PatchNaturalnessYe$$removed patch from BSPTree. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch55-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. BSPTree now cuts off - the - minus sign .. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch8-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. removed patch from BSPTree. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch1-math-2a6c6409_Arja_PatchNaturalnessYe$$Add blank line. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch6-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw new MathInternalError ( ). fixed a bug in OrderedTuple. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch41-math-2a6c6409_Arja_PatchNaturalnessYe$$fixed a small bug in OrderedTuple. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch24-math-2a6c6409_Arja_PatchNaturalnessYe$$Missing patch for getting message from default locale .. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch7-math-2a6c6409_Arja_PatchNaturalnessYe$$fixed a bug in OrderedTuple. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch9-math-2a6c6409_Arja_PatchNaturalnessYe$$BSPTree no longer links ( cut = null ). removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch49-math-2a6c6409_Arja_PatchNaturalnessYe$$Fix Euclidean geometry patch. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch22-math-2a6c6409_Arja_PatchNaturalnessYe$$Fix swapped inf / inf in OrderedTuple. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch25-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. Fixed a typo in code. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch14-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw new MathInternalError ( ). Fix swapped offset values in OrderedTuple. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch50-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. reset parent links. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch57-math-2a6c6409_Arja_PatchNaturalnessYe$$removed patch for BSPTree. fixed a bug in OrderedTuple. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch61-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw new MathInternalError ( ). Fix swapped offset values in OrderedTuple. Revert accidently removed patch .. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch59-math-2a6c6409_Arja_PatchNaturalnessYe$$BSPTree now uses the same cut value as the others. fixed a small bug in OrderedTuple. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch32-math-2a6c6409_Arja_PatchNaturalnessYe$$Fix swapped offset values in OrderedTuple. removed throw new MathInternalError ( ). $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch58-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. Revert since it was removed as part of a revu 58396 .. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch56-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. Fix euclidean intersections , add patch. remove patch. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch34-math-2a6c6409_Arja_PatchNaturalnessYe$$BSPTree now has a null pointer. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch2-math-2a6c6409_Arja_PatchNaturalnessYe$$fixed possible NPE in OrderedTuple. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch26-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. Fix swapped inf / inf in OrderedTuple. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch21-math-2a6c6409_Arja_PatchNaturalnessYe$$Set lsb to Integer . MAX_VALUE for OrderedTuple. removed throw. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch17-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw. removed patch from BSPTree. $$0
math-2a6c6409$$Constructor of PolyhedronsSet throws NullPointerException$$The following statement throws a NullPointerException: new org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet(0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d);  I found that other numbers also produce that effect. The stack trace: java.lang.NullPointerException         at org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(BSPTree.java:297)         at org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(BSPTree.java:155)         at org.apache.commons.math3.geometry.partitioning.RegionFactory.buildConvex(RegionFactory.java:55)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.buildBoundary(PolyhedronsSet.java:119)         at org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.<init>(PolyhedronsSet.java:97)$$patch3-math-2a6c6409_Arja_PatchNaturalnessYe$$removed throw new MathInternalError ( ). Reset inf / negInf after first try. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch1-math-f6dd42b4_RSRepair_PatchNaturalnessYe$$BrentSolver now uses verifyBracketing ( ). $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch3-math-f6dd42b4_RSRepair_PatchNaturalnessYe$$Fix null pointer exception in UnivariateRealSolverImpl . verifyInterval. revert accidently change. $$0
math-f6dd42b4$$Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign$$Javadoc for "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)" claims that "if the values of the function at the three points have the same sign" an IllegalArgumentException is thrown. This case isn't even checked.$$patch4-math-f6dd42b4_RSRepair_PatchNaturalnessYe$$Repair fix from # 77. $$0
math-9e0c5ad4$$Gamma function computation$$In the gamma method, when handling the case "absX > 20", the computation of gammaAbs should replace "x" (see code below with x in bold) by "absX". For large negative values of x, the function returns with the wrong sign.  final double gammaAbs = SQRT_TWO_PI / *x* *                                      FastMath.pow(y, absX + 0.5) *                                      FastMath.exp(-y) * lanczos(absX);$$patch1-math-9e0c5ad4_RSRepair_PatchNaturalnessYe$$Fix the recurrence relation patch .. $$0
bears-95$$ClassGeneratingPropertyAccessorFactory.isTypeInjectable() fails with NPE for entities in default packages [DATACMNS-1201]$$opened and commented Introspecting ClassGeneratingPropertyAccessorFactory support for an entity fails with an NPE if the entity resides in the default package.     Affects: 1.13.8 (Ingalls SR8), 2.0 GA (Kay)  Referenced from: pull request #256  Backported to:  2.0.1 (Kay SR1) , 1.13.9 (Ingalls SR9)$$patch1-bears-95_Developer_PatchNaturalnessYe$$Fix ClassGeneratingPropertyAccessorFactory # isTypeInjectable. $$1
bears-92$$AnnotationRevisionMetadata throws ClassCastException [DATACMNS-1173]$$opened and commented  AnnotationRevisionMetadata throws ClassCastException at line 90 :  Most likely leftovers during migration to  java.util.Optional   Affects: 2.0 RC3 (Kay)$$patch1-bears-92_Developer_PatchNaturalnessYe$$Fix build. Fixing the build error of ControllerRevisionMetadata on Application level 9. Fix getRequiredRevisionDate return type. $$1
bears-103$$ClassCastExecption$$Hi,  I have started using a meitrack tc68s device, however when I try and generate a summary/trip report it returns the following error in console:  The device is not in the future and has the correct timezone, also I am using the official build. Any recommendation?  All the other, osram works fine.$$patch1-bears-103_Developer_PatchNaturalnessYe$$added parser . next ( ) and parser . nextInt ( ) to position so it will use the. Updated to use parser . nextInt ( ) * 1000 as value is stored in a variable. added parser . nextInt ( ) to position so it can be used as an alternative to parser .. $$1
bears-168$$address-controller: NPE when required parameters (address, plan or type) are not set$$Description:  When required parameter (address,plan or type) in address definition is not set then it cause NPE in address-controller.  https://github.com/EnMasseProject/enmasse/blob/master/address-model-lib/src/main/java/io/enmasse/address/model/v1/AddressV1Deserializer.java#L36 Steps to reproduce:    create brokered address-space "brokered-space"  create address without required parameter: "brokered_incorrect_address.json"    Automated test:  we have no automated test for that yet output from address-controller log:$$patch1-bears-168_Developer_PatchNaturalnessYe$$Add missing import. Removed special treatment for AddressController client errors. Add missing import. Added validate ( ) to AddressV1Deserializer . deserialize ( ObjectNode ). Added validate method on AddressV1Deserializer .. Add validate ( ) to AddressSpaceV1Deserializer. Added a few things so that we can have better error reporting. $$1
bears-150$$Locale deserialize 'zh-hant_CN'$$zh-hant_CN will convert to zh_HANT_cn Locale include (language, country, variant), Locale.toString() use '_' to split then  {language}_{country}_({variant}_# | #){script}-{extensions} but Jackson deserialize Locale use '-' or '_'  : (  code: LocaleHandle.readResolve()  iana language-tags   rfc4647 language lookup    in jdk1.5 -> 1.8$$patch1-bears-150_Developer_PatchNaturalnessYe$$Fix error in LocaleSerializer. missing fields. $$1
bears-35$$How could I disable static imports in the v55 output?$$I found v53+ are producing static imports.$$patch1-bears-35_Developer_PatchNaturalnessYe$$Changed imports to static for field references .. Added imports to avoid unused imports. Added imports for spoon . reflect . declaration .. Added unused imports. Added a fieldAndMethodsNames field to ImportScannerImpl . java. Changed superclass imports to local or not .. Improved JDK7 build breakage .. CtBlock is not in an inner class block .. Updated import scanner to ignore package imports .. $$1
bears-34$$ParentNotInitializedException on CtComments$$Hello,  When I build JavaFileTest from javapoet with comments enabled, the build throw me the following error:   snippet example:   assertThat(source)$$patch1-bears-34_Developer_PatchNaturalnessYe$$pretty printer always adds comment after expression. added comment after parentheses if it is not a statement. Removed unnecessary empty line before the condition is used in the AST .. Removed unnecessary scan ( ) method. Removed unnecessary whitespace .. Removed redundant comment in newly added array indexing operation. Removed redundant scan ( ) method. Updated code to write array comments. Add missing import. Added missing line separators to parent exiter .. $$1
bears-33$$CtTypeReferenceImpl#getSuperClass() fails in noClasspath mode$$The method has the following implementation:   As you can see, it doesn't check for noClasspath and, thus, may fail when calling  getActualClass() .$$patch1-bears-33_Developer_PatchNaturalnessYe$$Added catch block for CtTypeReferenceImpl . getDeclaredExecutables ( ). Added a catch block to prevent CtTypeReference from being able to find the superclass .. $$1
bears-167$$address-controller allows to create multiple addresses with the same "spec.address" value$$reproducible via following steps:    create standard address space (reproducible with brokered as well)  deploy 3 addresses into this address space     all addresses were created successfully, console shows only one of those addresses, next address appears once previous one is removed.  And only first of multiple addresses has isReady attribute set to true in configMap  standard_anycast.json$$patch1-bears-167_Developer_PatchNaturalnessYe$$Add missing import. Add missing import. Added check for same resource name in AddressApiHelper. $$1
bears-219$$feat: add support for ${java.version} in pom.xml$$Hi !  I have an issue creating a MavenLauncher for projects that have ${java.version} in their POM.xml .  Replacing it with  1.8 for example seems to work around. Thank you for your help !$$patch1-bears-219_Developer_PatchNaturalnessYe$$Corrected java version in SpoonPom , to make it work reliably outside. Fixed incorrect java version string in Getter for SpoonPom. $$1
bears-202$$Calling  blacklistLibOrExtJars without arguments causes an Exception$$Calling  blacklistLibOrExtJars() without arguments throws java.lang.IllegalArgumentException: Can only blacklist jars by leafname: /System/Library/Java/Extensions/MRJToolkit.jar while whitelistLibOrExtJars() without arguments works fine.$$patch1-bears-202_Developer_PatchNaturalnessYe$$Fix bug in ClassGraph. $$1
bears-174$$One-to-many with integer ids retrieval broken$$How to Reproduce  Upload:   string-id.xlsx Go to dataexplorer, select Subjects table  I don't like the order of the samples, so I want to change the ID attribute datatype of the samples to int Upload:  int-id.xlsx Go to your table again Expected behavior  My beautiful table, nicely int sorted --> happy datamanager  Observed behavior    --> Sad datamanager$$patch1-bears-174_Developer_PatchNaturalnessYe$$Fixed error in PostgreSqlEntityFactory , where MREF_ID is not a string. $$1
bears-20$$FromStringDeserializer ignores registered DeserializationProblemHandler for java.util.UUID$$Culprit appears to be  lines 155-161 of FromStringDeserializer :  The above lines appear to show that the exception will be thrown regardless of any problem handling logic.  Test Case:   The handler handles the issue properly; but an exception is thrown anyway:$$patch1-bears-20_Developer_PatchNaturalnessYe$$Add missing import. Remove spurious blank line. Fixing an internal warning in FromStringDeserializer .. $$1
bears-173$$Importing an entitytype with several columns with the same name, import without errors$$How to Reproduce  Import a datasheet with multiple columns that have the same name.  Expected behavior  An error telling me to only use the name of every attribute once per entitytype  Observed behavior  Everything imports fine and I have issues much later then one would expect.$$patch1-bears-173_Developer_PatchNaturalnessYe$$Excel sheet should throw exception if column idx already exists. Added throw exception if existing column idx already exists. $$1
bears-11$$Enum key for Map ignores SerializationFeature.WRITE_ENUMS_USING_INDEX$$Version: latest 2.8  Failing unit tests added here:   https://github.com/SolaKun/jackson-databind/commit/6e095f75edd1de3eb33be5950c56d562bd6d584a Only java.util.Map test case provided, but doesn't work with EnumMap as well..$$patch1-bears-11_Developer_PatchNaturalnessYe$$Fix serialization of enums ( via enum value ). Fix bug in StdKeySerializers. Fix serialization of Enums ( from # 77 ). $$1
bears-116$$MU-201 v3.xx doesnt work?$$Hi,  i've tried to install my tracker in Traccar but it doesn't work. The Logfile was generated and everything is running but not the tracker...  HEX is translatet to:   Port 5051  How can i add the device?  Kind regards  Daniel$$patch1-bears-116_Developer_PatchNaturalnessYe$$Fix german translation .. removed 0xhh postfix. $$1
bears-45$$CtFieldReference.getDefaultExpression() returns initializer from a field of another class$$Hi, I'm trying to collect and evaluate certain strings in the source repository.  I tried VisitorPartialEvaluator, but it runs into an infinite loop. The reason of this is that fields get mixed up. The code setup is like this:   Now if you try to read the return value of the  getKey() method, the CtFieldReference object will return the default value of ClassB.PREFIX , not BaseClass.PREFIX .$$patch1-bears-45_Developer_PatchNaturalnessYe$$Set the simpleName in CtNamedElementImpl .. Removed unneeded assignment .. Refactoring . changeTypeName ( ) now returns the same thing. Removed unused imports. Removed try catch block for field lookup dynamically. $$1
bears-87$$Converting to Vavr Option fails for present value [DATACMNS-1087]$$opened and commented Curently  QueryExecutionConverters tries to invoke Vavr's Optional.of like an instance method rather than static one. This causes exception:    Affects: 1.13.4 (Ingalls SR4)  Referenced from: commits ,$$patch1-bears-87_Developer_PatchNaturalnessYe$$Remove unneeded invoke of method .. $$1
bears-17$$Extraneous type id mapping added for base type itself$$Looks like type id (name) matching base type is included in type resolution list, automatically. While this might be useful sometimes it seems quite odd, and probably should only be included if:    Base type is concrete and  Base type has explicit name (not add if default name used)$$patch1-bears-17_Developer_PatchNaturalnessYe$$Add missing import. Added javadoc. fix null property resolve bug. Fixing nullability note in stdSubtypeResolver. Fix stdSubtypeResolver. Fix stdSubtypeResolver. add rawBase before _combineNamedAndUnnamed ( ). remove unused modifier. Added ignore for abstract base type in stdSubtypeResolver. $$1
bears-172$$Repository.findOne method fails to return row for row level secured entity type if first row isn't readable$$Code inspection  FindOne shouldn't check if first row of delegate is readable but find first readable row.$$patch1-bears-172_Developer_PatchNaturalnessYe$$Fix row level security repo decorator findOne ( ). $$1
bears-8$$MapSerializer._orderEntries() throws NPE when operating on ConcurrentHashMap$$It seems that the fix introduced for  #1411 in 2.8 can be problematic for ConcurrentSkipListMap (and possibly other map data structures).  doc for ConcurrentSkipListMap.doGet()$$patch1-bears-8_Developer_PatchNaturalnessYe$$Fixed MapSerializer # 153. Fixed method name in MapSerializer. $$1
bears-175$$NPE importing EMX with abtract entity type data$$How to Reproduce  Import  this file Expected behavior  Success, or if I am not allowed to add data to abstract entities I expect a message  Observed behavior  Importer hangs, server logs report a null pointer exception in the  dataservice.add() method.$$patch1-bears-175_Developer_PatchNaturalnessYe$$removed unused imports. throw exception if entityType is abstract. $$1
bears-21$$DateTimeSerializerBase ignores configured date format when creating contextual$$DateTimeSerializerBase#createContextual creates a new serializer with StdDateFormat.DATE_FORMAT_STR_ISO8601 format instead of re-using the actual format that may have been specified on the configuration. See the following code:  Using the  @JsonFormat annotation on a field will therefore reset the format to Jackson's default even if the annotation doesn't specify any custom format.  DateBasedDeserializer#createContextual behaves differently and tries to re-use the configured format:  Shouldn't the serializer follow the same approach ?$$patch1-bears-21_Developer_PatchNaturalnessYe$$Fix # 1862. $$1
bears-44$$bug in removeStatement$$In this example, if you want to remove the second i++ with  block.removeStatement(block.getStatement(3)); , Spoon removes the first one.  (found by  @martinezmatias thanks!)$$patch1-bears-44_Developer_PatchNaturalnessYe$$Added support for removeStatement. $$1
bears-31$$element.toString() crashes with a NP in DefaultJavaPrettyPrinter.visitCtTypeReference()$$When analyzing elasticsearch we get a NP when calling element.toString().  As this has something to do with type references, I can't give you a concrete source file with this problem, but rather a part of the project as tar archive. (  elasticsearch.tar.gz )$$patch1-bears-31_Developer_PatchNaturalnessYe$$Fix CtTypeReferenceImpl . is visible in package only. Added throw .. $$1
bears-131$$meitrack temp sensor with negative value$$Hi Anton,  I'm receiving a wrong value from temp sensor for negative temp values, example: data for temp is 06FB2E which should translate to -12.34C according to doc for protocol v3.  Could you please check if traccar is reading temp correctly for negative values?  a sample data to test with:   Regards,$$patch1-bears-131_Developer_PatchNaturalnessYe$$Mimics the parser ' s rules about byte precision .. $$1
bears-96$$Repositories does not expose registered repository for proxy type [DATACMNS-1215]$$opened and commented Converting an entity to an ID using  DomainClassConverter.ToIdConverter fails if the entity instance is actually a proxy. This is because DomainClassConverter.ToIdConverter.matches() only checks for a repository with the sourceType.getType() . In the case of a Hibernate proxy, this type is EntityClass_$$patch1-bears-96_Developer_PatchNaturalnessYe$$Fix Repositories . containsKey ( Class ). Use the user class in the Repositories. $$1
bears-99$$Blank map and no pointer when tracker is sending vibration alarm$$Hello,  Im very happy with the traccar platform but got a strange issue.  I got about 40 trackers connected but 2 is missing map and pointers. I noticed those 2 trackers is marked with vibration alarm and ignition OFF. Is it a bug or am I doing something wrong ? trackers is running on h02 protocol.  Thanks$$patch1-bears-99_Developer_PatchNaturalnessYe$$Fix checkstyle. Remove debug code. Missing return null for $ { } marker. Fix license header. Skip X char in H02 frame headers .. Improved H02 frame decode logic so that X messages are sent earlier. $$1
bears-90$$AbstractPersistentProperty.getRawType() does not consider generics [DATACMNS-1139]$$opened and commented  AbstractPersistentProperty.getRawType() currently uses the field's or property descriptor's type which in turn doesn't use our generics resolution mechanism which means for generic fields you'll get different results if you call .getTypeInformation().getType() and .getRawType()   Affects: 1.12.11 (Hopper SR11), 1.13.6 (Ingalls SR6), 2.0 RC2 (Kay)  Backported to:  1.13.7 (Ingalls SR7) , 1.12.12 (Hopper SR12)$$patch1-bears-90_Developer_PatchNaturalnessYe$$Use the type when creating a persistent property .. $$1
bears-212$$YamlGenerator closes the target stream when configured not to$$Bug description  YamlGenerator closes the target stream when configured not to.  Versions used  jackson-dataformat-yaml 2.9.2  jackson-databind 2.9.6 Expected result  The target stream not closed when writing a value. No output when running reproduction script/program.  Actual result  The target stream is closed when using the YamlGenerator, with the following output when running the reproduction script/program.   Steps to reproduce$$patch1-bears-212_Developer_PatchNaturalnessYe$$Allow parser to close the stream if it is resource - managed. Fix YAMLGenerator close. $$1
bears-240$$Context must read system properties to rewrite properties from file.$$Context must read system properties to rewrite properties from file.$$patch1-bears-240_Developer_PatchNaturalnessYe$$made constructor public. Added missing import. Ctor of StDefault can take multiple arguments. $$1
bears-225$$ReactiveCommandSegmentCommandFactory resolves StreamingOutput for all reactive types$$I'm using Redis Lettuce dynamic client as described in official documentation  https://github.com/lettuce-io/lettuce-core/wiki/Redis-Command-Interfaces#command-interfaces.response-types My commands interface looks exactly the same   The problem is when method get cannot find value by key there's exception thrown instead of returning empty Mono.   When using predefined RedisReactiveCommands get works fine, it returns empty Mono. So it seems like a bug to me.  The Redis Lettuce version being used is   < Also checked with 5.0.4 RELEASE - issue remained$$patch1-bears-225_Developer_PatchNaturalnessYe$$Added missing constructor .. Fix resolving of streaming configuration for RMI segment commands. remove dependency of ReactiveTypes . supports. $$1
bears-230$$TracingP6SpyListener is not computing the Tags.DB_TYPE properly.$$Type: bugfix  In the TracingP6SpyListener class, line 112   We should take into account that a url returned by a DatabaseMetaData can be null.$$patch1-bears-230_Developer_PatchNaturalnessYe$$Missing peer name and dbInstance tags on p6spy listener. Fix NPEER_SERVICE_FINDER url reference .. isNullOrEmpty ( String ) returns a non - null value , even if it ' s empty ( ). $$1
bears-46$$CtElementImpl.getMetadataKeys() throws NPE$$I get NPE when invoking method getMetadataKeys() on CtElement. Looking through source code, it looks like metadata can be null. It should have null check and return null like getMetadata() method or return empty set.$$patch1-bears-46_Developer_PatchNaturalnessYe$$Added metadata keys if it is null. $$1
bears-79$$Processor is not using templated type when process method is in an abstract class$$We define an abstract spoon Processor declaring a process method on a templated type:     And create a concrete class extending the previous one:      The problem is that both the concrete processors are receiving every classes that matches the  upper bound of our template.$$patch1-bears-79_Developer_PatchNaturalnessYe$$Changed sympathy with ProcessingVisitor. $$1
bears-48$$[generic type] Regression in being able to spoon Guava$$It seems that  #1218 introduced a regression on Guava project which is used by our CI to check the behaviour of Spoon, see the trace :     See full stack trace:   https://ci.inria.fr/sos/job/Guava/262/console$$patch1-bears-48_Developer_PatchNaturalnessYe$$Added note to ClassTypingContext . getActualTypeArguments for non - type scoped closures. Added getActualTypeArguments to ClassTypingContext .. $$1
bears-170$$A mapping service mapping error has its toString value inserted into an integrated dataset$$How to Reproduce     Go to the mapping service  Create a new mapping project with  Add TypeTestRef as new source  Edit label attribute  Fill in  Create integrated dataset  Expected behaviour  Mapping fails because the validation for the label to label mapping contains script errors  Observed behaviour  The mapping is executed and the toString() value of the error is inserted as a label$$patch1-bears-170_Developer_PatchNaturalnessYe$$removed unused import. Convert exception in jsMagmaScriptEvaluator. If jsMagmaScriptEvaluator . eval ( ) throws , throw the exception. $$1
bears-23$$StdDateFormat deserializes dates with no tz/offset as UTC instead of configured timezone$$Prior to version  2.8.9 , dates without time zone or time offset (eg 1970-01-01T00:00:00.000 ) were deserialised in the TimeZone set on the ObjectMapper. Starting from 2.8.9 , these dates are deserialised in UTC - which is a major (breaking) change in behaviour... Example:$$patch1-bears-23_Developer_PatchNaturalnessYe$$Add @ since comment for ' date . format ' method. Add ISO8601 NO_TZ date format to all supported date formats .. Remove RFC1123 and ISO8601 NO_TZ date formats .. Fixed erroneous override for ISO8601 no - TZ .. Add formatISO8601_noTz back. Remove possible timeZone fix. Fixed erroneous build .. Add missing fields. $$1
bears-4$$ArrayIndexOutOfBoundsException on impossible non-static inner class constructor$$Minimal repro:     Fails like this:   Validation is missing for this impossible constructor. Works as expected when  InnerSomething is static.$$patch1-bears-4_Developer_PatchNaturalnessYe$$Added getter for inner class property. $$1
bears-3$$ACCEPT_CASE_INSENSITIVE_PROPERTIES fails with @JsonUnwrapped$$(note: moved from  FasterXML/jackson-dataformat-csv#133 ) When trying to deserialize type like:   with case-insensitive mapper (  mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES); ) I get exception:$$patch1-bears-3_Developer_PatchNaturalnessYe$$Added hash calculation of BeanPropertyMap , now that we have calculated the size of the primary. Added missing closing bracket. Add case note for property name. $$1
bears-78$$NPE on DefaultJavaPrettyPrinter#printCtFieldAccess$$More intel about bug reproduction can be found on the following issue:  HabchiSarra/SmellDetector#8 The full stack trace using spoon 5.9.0-SNAPSHOT below$$patch1-bears-78_Developer_PatchNaturalnessYe$$Do not put fieldDeclaration in implicit target. $$1
bears-13$$@JsonProperty(access = READ_ONLY) together with generated constructor (lombok) causes JsonMappingException: Could not find creator property with name [...]$$The following class fails to deserialise with a  com.fasterxml.jackson.databind.JsonMappingException: Could not find creator property with name 's' (in class LombokObject) :  Whereas the following class - which is functionally identical but with constructors, getters and setters in the code - can be deserialised:   The exception is$$patch1-bears-13_Developer_PatchNaturalnessYe$$Added getter for creator properties in BeanDeserializerFactory. Fix getter / setter legis. fixed findConstructorParameter ( ) for non - concrete property. Added a couple of errors in the deser mapping , so that it is reported to the. $$1
bears-14$$Jackson Deserializer security vulnerability via default typing (CVE-2017-7525)$$I have send email to  info@fasterxml.com$$patch1-bears-14_Developer_PatchNaturalnessYe$$Added check for illegal types in BeanDeserializerFactory. Added a method to check illegal types for JSON output. $$1
bears-22$$Missing properties from base class when recursive types are involved.$$When a type hierarchy as follows is constructed and the base class' type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class.   Serializes sub as  {"sub":2} where {"base":1,"sub":2} is expected. I've created a minimal scenario of this bug here:  https://github.com/slobo-showbie/jackson-recursive-type-bug I've experienced this bug in 2.7.8, 2.8.8, and 2.8.8.1$$patch1-bears-22_Developer_PatchNaturalnessYe$$Added missing superClass method. $$1
bears-149$$When i use the parameters configured in the dubbo provider in the routing rules, the rules can not be matched$$dubbo provider   <dubbo:provider  serialization="fastjson" /> url default.serialization=fastjson   "=> serialization=fastjson" default.serialization=fastjson $$patch1-bears-149_Developer_PatchNaturalnessYe$$add default key prefix to sample. $$1
bears-171$$When I upload data with one row, data is not uploaded$$How to Reproduce  Upload with advanced importer, add mode:   eric_de_test_model.xlsx Upload csv in this zip:  eu_bbmri_eric_DE_biobanks.csv.zip Expected behavior  1 row is added to the biobanks table  Observed behavior  Import succeeds, 0 rows imported$$patch1-bears-171_Developer_PatchNaturalnessYe$$Add missing imports. Excel sheet has extra space left. Excel sheet has too many columns but no values. $$1
