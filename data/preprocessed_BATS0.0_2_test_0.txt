[{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "erron", "loop", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "erron", "loop", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added missing @@. ", "B_clean_title": ["ad", "miss"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Added a fix for null constraint. ", "B_clean_title": ["ad", "fix", "null", "constraint"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "small", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed a small bug. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. fixed bug in BisectionSolver. ", "B_clean_title": ["fix", "small", "bug", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. updated bisection solver with updated maximal iterations. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "updat", "bisect", "solver", "updat", "maxim", "iter"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver . solve ( ) .. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous loop. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Set default function value accuracy across the full range of solutions .. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "set", "default", "function", "valu", "accuraci", "across", "full", "rang", "solut"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed N4G test. Set result to 0 in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "n4g", "test", "set", "result", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in the bisection solver. ", "B_clean_title": ["fix", "bug", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed n4g1 patch. fixed erroneous build. ", "B_clean_title": ["fix", "n4g1", "patch", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. ", "B_clean_title": ["fix", "n4g", "problem"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed NPE in BisectionSolver . solve ( ) .. ", "B_clean_title": ["fix", "npe", "bisectionsolv", "bisect", "solver", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous build. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "build"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed NPE in BisectionSolver . solve ( ) .. ", "B_clean_title": ["fix", "npe", "bisectionsolv", "bisect", "solver", "solv"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver . solve ( ) .. fixed bug in BisectionSolver. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "solv", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. Fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "small", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed N4G problem. fixed bug in BisectionSolver. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "n4g", "problem", "fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed erroneous loop. ", "B_clean_title": ["fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. Revert  fix a small bug in BisectionSolver . ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "revert", "fix", "small", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Reverted the changes related to bisectionSolver. ", "B_clean_title": ["updat", "intro", "patch", "revert", "chang", "relat", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. Fix error in BisectionSolver. ", "B_clean_title": ["updat", "solv", "method", "fix", "error", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a merge conflict in BisectionSolver. I had left it harwired to allow for partial nashorn support .. ", "B_clean_title": ["fix", "merg", "conflict", "bisectionsolv", "bisect", "solver", "had", "left", "it", "harwir", "allow", "partial", "nashorn", "support"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Set default function value accuracy after running fixed tests .. ", "B_clean_title": ["set", "default", "function", "valu", "accuraci", "after", "run", "fix", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "I had left it harwired to say that we can merge a couple of solutions together. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "we", "merg", "coupl", "solut", "togeth"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous loop. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Revert  Increased maximal iterations for bisection solver to fix cruise (. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "revert", "increas", "maxim", "iter", "bisect", "solver", "fix", "cruis"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). fixed erroneous loop. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. Re - computed the bisection solver with fixed erroneous data. ", "B_clean_title": ["fix", "small", "bug", "re", "comput", "bisect", "solver", "fix", "erron", "data"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. fixed maxIter = max ; patched. ", "B_clean_title": ["updat", "solv", "method", "fix", "maxit", "max", "iter", "max", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. ", "B_clean_title": ["fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). fixed erroneous loop. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). Set functionValueAccuracy to defaultFunctionValueAccuracy. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "set", "functionvalueaccuraci", "function", "valu", "accuraci", "defaultfunctionvalueaccuraci", "default", "function", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Increasing max iterations for bisection solver .. ", "B_clean_title": ["increas", "max", "iter", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed a bug in BisectionSolver. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "bug", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Set function value accuracy to default value accuracy. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "set", "function", "valu", "accuraci", "default", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. fixed erroneous loop. added i = 0 ; patched. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "loop", "ad", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. Revert  Fixed a small bug in BisectionSolver . computedValue ( ) . ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "revert", "fix", "small", "bug", "bisectionsolv", "bisect", "solver", "computedvalu", "comput", "valu"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. Set function value accuracy to default value accuracy. ", "B_clean_title": ["updat", "solv", "method", "set", "function", "valu", "accuraci", "default", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "Reset the function value accuracy after running the bisectionSolver .. ", "B_clean_title": ["reset", "function", "valu", "accuraci", "after", "run", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor bug in BisectionSolver. Set function value accuracy to default when min = max = 0. ", "B_clean_title": ["fix", "minor", "bug", "bisectionsolv", "bisect", "solver", "set", "function", "valu", "accuraci", "default", "when", "min", "max"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed maxIter = max ; patched. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "maxit", "max", "iter", "max", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "I had left it harwired to allow for correct bracketing. ", "B_clean_title": ["had", "left", "it", "harwir", "allow", "correct", "bracket"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. Reset function value accuracy after maximal iterations reached the default max .. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "reset", "function", "valu", "accuraci", "after", "maxim", "iter", "reach", "default", "max"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. fixed erroneous test. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a minor issue with bisectionSolver. Reverted the changes related to bisectionSolver. ", "B_clean_title": ["fix", "minor", "issu", "bisectionsolv", "bisect", "solver", "revert", "chang", "relat", "bisectionsolv", "bisect", "solver"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a bug in BisectionSolver. updated patch. ", "B_clean_title": ["fix", "bug", "bisectionsolv", "bisect", "solver", "updat", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. fixed a small bug. ", "B_clean_title": ["updat", "solv", "method", "fix", "small", "bug"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "set result of bisectionSolver. updated intro patch. ", "B_clean_title": ["set", "result", "bisectionsolv", "bisect", "solver", "updat", "intro", "patch"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated solve ( ) method. fixed erroneous loop. ", "B_clean_title": ["updat", "solv", "method", "fix", "erron", "loop"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Set maximalIterationCount as well. ", "B_clean_title": ["updat", "intro", "patch", "set", "maximaliterationcount", "maxim", "iter", "count", "as", "well"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Set default function value accuracy. ", "B_clean_title": ["updat", "intro", "patch", "set", "default", "function", "valu", "accuraci"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a typo in BisectionSolver . solve ( ). Set default function value accuracy when using fixed maxIterCount. ", "B_clean_title": ["fix", "typo", "bisectionsolv", "bisect", "solver", "solv", "set", "default", "function", "valu", "accuraci", "when", "fix", "maxitercount", "max", "iter", "count"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. fixed erroneous test. ", "B_clean_title": ["updat", "intro", "patch", "fix", "erron", "test"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "fixed a small bug. I had left it harwired to allow for partial nashorn support .. ", "B_clean_title": ["fix", "small", "bug", "had", "left", "it", "harwir", "allow", "partial", "nashorn", "support"]},
{"A_title": "BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial) throws NullPointerExceptionMethod      BisectionSolver.solve(final UnivariateRealFunction f double min double max double initial)   invokes      BisectionSolver.solve(double min double max)  which throws NullPointerException as member variable     UnivariateRealSolverImpl.f  is null. Instead the method:     BisectionSolver.solve(final UnivariateRealFunction f double min double max) should be called. Steps to reproduce: invoke:      new BisectionSolver().solve(someUnivariateFunctionImpl 0.0 1.0 0.5); NullPointerException will be thrown.", "A_clean_title": ["bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "throw", "nullpointerexceptionmethod", "null", "pointer", "except", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "doubl", "initi", "invok", "bisectionsolv", "solv", "bisect", "solver", "doubl", "min", "doubl", "max", "which", "throw", "nullpointerexcept", "null", "pointer", "except", "as", "member", "variabl", "univariaterealsolverimpl", "univari", "real", "solver", "impl", "null", "instead", "method", "bisectionsolv", "solv", "bisect", "solver", "final", "univariaterealfunct", "univari", "real", "function", "doubl", "min", "doubl", "max", "call", "step", "reproduc", "invok", "new", "bisectionsolv", "bisect", "solver", "solv", "someunivariatefunctionimpl", "some", "univari", "function", "impl", "nullpointerexcept", "null", "pointer", "except", "will", "thrown"], "B_title": "updated intro patch. Set iterationCount as well as maximalIterationCount. ", "B_clean_title": ["updat", "intro", "patch", "set", "iterationcount", "iter", "count", "as", "well", "as", "maximaliterationcount", "maxim", "iter", "count"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix parseShort erro. ", "B_clean_title": ["fix", "parseshort", "pars", "short", "erro"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed extra chars. ", "B_clean_title": ["remov", "extra", "char"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Improve error handling for --  and  ( areas with the same length ) - removed 0x. ", "B_clean_title": ["improv", "error", "handl", "area", "same", "length", "remov", "0x"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Handle hex number format in NumberUtils. ", "B_clean_title": ["handl", "hex", "number", "format", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "formatting fixes. ", "B_clean_title": ["format", "fix"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Remove a check for -- . ", "B_clean_title": ["remov", "check"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix checkstyle. ", "B_clean_title": ["fix", "checkstyl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix a regression in NumberUtils. ", "B_clean_title": ["fix", "regress", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. fixed NPE in NumberUtils. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NumberFormatException. Fix NPE. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in NumberUtils. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. fixed E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix E3C. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032c0. fix the build. Added patch for E3E. revert accidently change. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032c0", "fix", "build", "ad", "patch", "e3e", "revert", "accid", "chang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Handle null string in GenProg_Defects4J_Lang_7. Added patch for DoubleUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "handl", "null", "string", "genprog", "defects4j", "lang", "gen", "prog", "ad", "patch", "doubleutil", "doubl", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. Fix StringUtils . createDouble ( String ). ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032", "error", "genprog", "defects4j", "lang", "gen", "prog", "fix", "stringutil", "string", "util", "createdoubl", "creat", "doubl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NPE in NumberUtils. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NPE in NumberUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Fix NPE in GenProg_Defects4J_Lang_7. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "fix", "npe", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix e3c032e032c0. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "e3c032e032c0"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Eliminate more flakiness in NumberUtils. fix the build. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "elimin", "more", "flaki", "numberutil", "number", "util", "fix", "build", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. formatting fixes. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "format", "fix"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix StringUtils . createDouble ( String ). ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "stringutil", "string", "util", "createdoubl", "creat", "doubl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NPE in GenProg_Defects4J_Lang_7. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "npe", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032e. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the fix of the merge conflict in NumberUtils. Fix NumberFormatException. Allow null values for exp. ", "B_clean_title": ["elimin", "fix", "merg", "conflict", "numberutil", "number", "util", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete unused patch. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. fix a typo in the code. ", "B_clean_title": ["delet", "unus", "patch", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032", "error", "genprog", "defects4j", "lang", "gen", "prog", "fix", "typo", "code"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix e3c032e032b1. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "e3c032e032b1"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "E3C - 11674 Fix too many for an int. Fix E3C. ", "B_clean_title": ["e3c", "11674", "fix", "too", "mani", "int", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix e3c032e032b1. Fix NPE in GenProg_Defects4J_Lang_7. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032b1", "fix", "npe", "genprog", "defects4j", "lang", "gen", "prog", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NumberFormatException. Allow null values for exp. Ignore undefined fields in GenProg_Defects4J_Lang_7. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "ignor", "undefin", "field", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. ", "B_clean_title": ["ignor", "sign", "0x", "digit"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. Fix e3c032e032c0. Fix E3C. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032e032c0", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. fix the build. fixed formatting. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "fix", "build", "fix", "format"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. formatting fix. fix a bug in NumberUtils. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "format", "fix", "fix", "bug", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NPE in NumberUtils. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "revert accidently change. Delete old and unused local variable. Fix NumberFormatException. ", "B_clean_title": ["revert", "accid", "chang", "delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for hex digits. Fix NumberFormatException. Fix e3c032 error in GenProg_Defects4J_Lang. ", "B_clean_title": ["ignor", "sign", "hex", "digit", "fix", "numberformatexcept", "number", "format", "except", "fix", "e3c032", "error", "genprog", "defects4j", "lang", "gen", "prog"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate negative hex digits in StringUtils. Eliminate more flakiness in NumberUtils. Allow null values for exp. ", "B_clean_title": ["elimin", "neg", "hex", "digit", "stringutil", "string", "util", "elimin", "more", "flaki", "numberutil", "number", "util", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. fix the build. revert accidently change. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "fix", "build", "revert", "accid", "chang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Ignore signs for 0x digits. Fix NumberFormatException. ", "B_clean_title": ["ignor", "sign", "0x", "digit", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. fix the build. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "build"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the hex digits from the beginning of a string. Fix NumberFormatExceptions. Allow null values for exp. ", "B_clean_title": ["elimin", "hex", "digit", "begin", "string", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix a bug in NumberUtils. Fix NumberFormatException. ", "B_clean_title": ["fix", "bug", "numberutil", "number", "util", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix NPE in DateUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "npe", "dateutil", "date", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Allow null values for exp. Improve patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "allow", "null", "valu", "exp", "improv", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Delete old definition file. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "delet", "old", "definit", "file"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Eliminate more flakiness in NumberUtils. Allow null values for exp. fix the build. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "elimin", "more", "flaki", "numberutil", "number", "util", "allow", "null", "valu", "exp", "fix", "build", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. Fix erroneous error in NumberUtils. Fix E3C. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "erron", "error", "numberutil", "number", "util", "fix", "e3c"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Allow null values for exp. Eliminate trailing comma in NumberUtils . createDouble ( ). Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "allow", "null", "valu", "exp", "elimin", "trail", "comma", "numberutil", "number", "util", "createdoubl", "creat", "doubl", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the fix of the merge conflict in NumberUtils. Fix NumberFormatException. ", "B_clean_title": ["elimin", "fix", "merg", "conflict", "numberutil", "number", "util", "fix", "numberformatexcept", "number", "format", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. formatting fixes. Eliminate trailing comma in NumberUtils . createDouble ( ). Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "format", "fix", "elimin", "trail", "comma", "numberutil", "number", "util", "createdoubl", "creat", "doubl", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Fix NumberFormatException. fix the build. Fix NPE in NumberUtils. ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "fix", "numberformatexcept", "number", "format", "except", "fix", "build", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused local variable. Added patch for StringUtils . createDouble ( String ). ", "B_clean_title": ["delet", "old", "unus", "local", "variabl", "ad", "patch", "stringutil", "string", "util", "createdoubl", "creat", "doubl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Delete old and unused patch. Fix NumberFormatException. fix the build. Fix NPE in NumberUtils. Added patch for E3E. ", "B_clean_title": ["delet", "old", "unus", "patch", "fix", "numberformatexcept", "number", "format", "except", "fix", "build", "fix", "npe", "numberutil", "number", "util", "ad", "patch", "e3e"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patching. ", "B_clean_title": ["fix", "nbfi", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the hex digits in the first place ; we  re adding them all at the. ", "B_clean_title": ["elimin", "hex", "digit", "first", "place", "we", "re", "ad", "them", "all", "at"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Added exp = null for isNaN ( ) / null .. ", "B_clean_title": ["remov", "patch", "string", "util", "ad", "exp", "null", "isnan", "na", "null"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Fix NPE in Arja  s StringUtils. I don  t really see a justification for doing a number format change in Arja  s. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "fix", "npe", "arja", "stringutil", "string", "util", "don", "realli", "see", "justif", "do", "number", "format", "chang", "arja"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in NumberUtils. Handle early NPE for string isEmpty. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util", "handl", "earli", "npe", "string", "isempti", "empti"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. I had left it harwired to say it was a valid number .. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "had", "left", "it", "harwir", "say", "it", "wa", "valid", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFR patching. ", "B_clean_title": ["fix", "nbfr", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. ", "B_clean_title": ["fix", "nbfi", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. fix a numeric value to work with StringUtils. Added exp = null for numberUtils . createDouble ( ). ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "numer", "valu", "work", "stringutil", "string", "util", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in Arja  s StringUtils. ", "B_clean_title": ["fix", "npe", "arja", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Added exp = 0 . 0F to NumberUtils . createFloat ( ). ", "B_clean_title": ["remov", "patch", "string", "util", "ad", "exp", "0f", "numberutil", "number", "util", "createfloat", "creat", "float"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Allow negative exponents in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "allow", "neg", "expon", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle StringUtils . isBlank ( str ) in ArjaDefects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "stringutil", "string", "util", "isblank", "blank", "str", "arjadefects4j", "lang", "arja", "defects4j"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Add the missing throwing of the exception. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "add", "miss", "throw", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Added exp = null for numberUtils . createDouble ( ). ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja  s patch. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "patch", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in Arja  s patch. ", "B_clean_title": ["fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. remove exp. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util", "remov", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Add exp back. ", "B_clean_title": ["remov", "patch", "string", "util", "add", "exp", "back"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. remove exp. ", "B_clean_title": ["remov", "patch", "string", "util", "remov", "exp"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. remove backslash. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "remov", "backslash"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in NumberUtils. ", "B_clean_title": ["fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Remove patch for 0x18e01095c1. removed expPos from str ; fix it. ", "B_clean_title": ["remov", "patch", "0x18e01095c1", "remov", "exppo", "exp", "po", "str", "fix", "it"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Remove exp from numberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "remov", "exp", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Allow one - line ifs. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "allow", "one", "line", "if", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. fixed NPE for 1 . 7. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. Fix NPE in StringUtils. ", "B_clean_title": ["fix", "nbfi", "patch", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NBFI for ( ). ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "nbfi"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed extraneous space. ", "B_clean_title": ["remov", "extran", "space"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Added exp = null for numberUtils . createDouble ( String  boolean  boolean ). ", "B_clean_title": ["remov", "patch", "string", "util", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl", "string", "boolean", "boolean"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. fixed NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add missing exception check. ", "B_clean_title": ["add", "miss", "except", "check"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in StringUtils. ", "B_clean_title": ["fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add the missing patch. ", "B_clean_title": ["add", "miss", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. adding mant variable to exp var. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "ad", "mant", "variabl", "exp", "var"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja  s StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. Handle null string input in NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "defects4j", "lang", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Handle null string input. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "handl", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle string blank numbers in Arja  s patch. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "string", "blank", "number", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle  ----  in NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. remove expPos. Allow null string input. I am using the patch I just added. ", "B_clean_title": ["remov", "patch", "string", "util", "remov", "exppo", "exp", "po", "allow", "null", "string", "input", "am", "patch", "just", "ad"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Allow string to be expanded into a valid number. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "allow", "string", "expand", "into", "valid", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed extraneous space. ", "B_clean_title": ["remov", "extran", "space"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Add the missing throwing of the exception. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "add", "miss", "throw", "except"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add a throw exception if it is not a valid number. ", "B_clean_title": ["add", "throw", "except", "it", "not", "valid", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. Handle null string input from NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. ", "B_clean_title": ["fix", "nbfi", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in StringUtils. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "stringutil", "string", "util", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle null string input from JSON. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "null", "string", "input", "json"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Handle null string input in NumberUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "handl", "null", "string", "input", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Allow null string input. ", "B_clean_title": ["remov", "patch", "string", "util", "allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in JSON. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "json"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the hex digits in the first place ; we  re adding them all at the. fix a numeric string to work with StringUtils. ", "B_clean_title": ["elimin", "hex", "digit", "first", "place", "we", "re", "ad", "them", "all", "at", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow too many hex digits for an int. ", "B_clean_title": ["allow", "too", "mani", "hex", "digit", "int"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. fixed NPE in NumberUtils. ", "B_clean_title": ["allow", "null", "string", "input", "fix", "npe", "numberutil", "number", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Fix NBFC for LIGHT_NO_MOON. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "nbfc", "light", "no", "moon"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. removed the prefix removed by the patch. ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "remov", "prefix", "remov", "by", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Add missing throw. Allow string to be expanded into float precision .. ", "B_clean_title": ["add", "miss", "throw", "allow", "string", "expand", "into", "float", "precis"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from StringUtils . parseLong ( str. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "stringutil", "string", "util", "parselong", "pars", "long", "str"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. fix a numeric string to work with StringUtils. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "fix", "numer", "string", "work", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in OE. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "parseShort was throwing an exception. Added exp = null for numberUtils . createDouble ( ). ", "B_clean_title": ["parseshort", "pars", "short", "wa", "throw", "except", "ad", "exp", "null", "numberutil", "number", "util", "createdoubl", "creat", "doubl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. Added missing exp string for float precision string. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "ad", "miss", "exp", "string", "float", "precis", "string"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string startsWith. remove mant. ", "B_clean_title": ["remov", "patch", "string", "startswith", "start", "remov", "mant"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. fixed NPE in StringUtils. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE for OE. ", "B_clean_title": ["fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow too many hex digits for an int. Allow negative exponents in StringUtils. ", "B_clean_title": ["allow", "too", "mani", "hex", "digit", "int", "allow", "neg", "expon", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Allow null string input. ", "B_clean_title": ["allow", "null", "string", "input"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Eliminate the over - aggressive loop through the string .. Added missing backslash. ", "B_clean_title": ["elimin", "over", "aggress", "loop", "through", "string", "ad", "miss", "backslash"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NBFI patch. Revert  move to the patch . ", "B_clean_title": ["fix", "nbfi", "patch", "revert", "move", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in StringUtils. ", "B_clean_title": ["fix", "npe", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja  s patch. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "fixed NPE for number utils. Remove erroneous test for isFinite ( ) and allZeros ( ). ", "B_clean_title": ["fix", "npe", "number", "util", "remov", "erron", "test", "isfinit", "finit", "allzero", "all", "zero"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in Arja_Defects4J_Lang_7. Fix NBFR patch. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "arja", "defects4j", "lang", "fix", "nbfr", "patch"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from string utils. Fix NPE in OE. ", "B_clean_title": ["remov", "patch", "string", "util", "fix", "npe", "oe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed the unnecessary  - - hexDigits - - err  from the opengl opengl string. Allow negative exponents in StringUtils. ", "B_clean_title": ["remov", "unnecessari", "hexdigit", "hex", "digit", "err", "opengl", "opengl", "string", "allow", "neg", "expon", "stringutil", "string", "util"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix newline in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "newlin", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed patch from previous commit  fixes NPE. revert accidently change. ", "B_clean_title": ["remov", "patch", "previou", "commit", "fix", "npe", "revert", "accid", "chang"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix null in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "null", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE. ", "B_clean_title": ["fix", "npe"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix newline in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "newlin", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "don  t allow signs in numbers. ", "B_clean_title": ["don", "allow", "sign", "number"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix null string handling. ", "B_clean_title": ["fix", "null", "string", "handl"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "Fix NPE in RSRepair_Defects4J_Lang_7. ", "B_clean_title": ["fix", "npe", "rsrepair", "defects4j", "lang", "rs", "repair"]},
{"A_title": "NumberUtils#createNumber - bad behaviour for leading --NumberUtils#createNumber checks for a leading -- in the string and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. Its not clear whether the BigDecimal problem still exists with recent versions of Java. However if it does exist then the check needs to be done for all invocations of BigDecimal i.e. needs to be moved to createBigDecimal.", "A_clean_title": ["numberutil", "number", "util", "createnumb", "creat", "number", "bad", "behaviour", "lead", "numberutil", "number", "util", "createnumb", "creat", "number", "check", "lead", "string", "return", "null", "found", "thi", "document", "as", "work", "round", "bug", "bigdecim", "big", "decim", "return", "nulll", "contrari", "javadoc", "behaviour", "other", "method", "which", "would", "throw", "numberformatexcept", "number", "format", "except", "it", "not", "clear", "whether", "bigdecim", "big", "decim", "problem", "still", "exist", "recent", "version", "java", "howev", "it", "exist", "then", "check", "need", "done", "all", "invoc", "bigdecim", "big", "decim", "need", "move", "createbigdecim", "creat", "big", "decim"], "B_title": "removed unused var. ", "B_clean_title": ["remov", "unus", "var"]},
{"A_title": "NullPointerException in isAvailableLocale(Locale)FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasnt been called it will cause a NullPointerException.", "A_clean_title": ["nullpointerexcept", "null", "pointer", "except", "isavailablelocal", "avail", "local", "local", "findbug", "find", "bug", "point", "out", "uwf", "uw", "field", "not", "initi", "constructor", "org", "apach", "common", "lang", "localeutil", "cavailablelocaleset", "local", "util", "avail", "local", "set", "cavailableset", "avail", "set", "use", "directli", "onc", "sourc", "availablelocaleset", "avail", "local", "set", "hasnt", "been", "call", "it", "will", "caus", "nullpointerexcept", "null", "pointer", "except"], "B_title": "Add null check in LocaleUtils. ", "B_clean_title": ["add", "null", "check", "localeutil", "local", "util"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Don  t reverse the changes since we  re about to manipulate the codepoint count. ", "B_clean_title": ["don", "revers", "chang", "sinc", "we", "re", "about", "manipul", "codepoint", "count"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Use the writer null pointer for CharSequenceTranslator. ", "B_clean_title": ["use", "writer", "null", "pointer", "charsequencetransl", "char", "sequenc", "translat"]},
{"A_title": "StringIndexOutOfBoundsException in CharSequenceTranslatorI found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. uD83DuDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception      assertEquals(uD83DuDE30 StringEscapeUtils.escapeCsv(uD83DuDE30));    Youll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2 at java.lang.String.charAt(String.java:658) at java.lang.Character.codePointAt(Character.java:4668) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95) at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59) at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached the method affected:  public final void translate(CharSequence input Writer out) throws IOException", "A_clean_title": ["stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "charsequencetranslatori", "char", "sequenc", "translat", "found", "that", "there", "bad", "surrog", "pair", "handl", "charsequencetransl", "char", "sequenc", "translat", "thi", "simpl", "test", "case", "thi", "problem", "ud83dude30", "d83du", "de30", "surrog", "pair", "test", "public", "void", "testescapesurrogatepair", "test", "escap", "surrog", "pair", "throw", "except", "assertequ", "assert", "equal", "ud83dude30", "d83du", "de30", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "ud83dude30", "d83du", "de30", "youll", "get", "except", "as", "shown", "below", "java", "lang", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "string", "index", "out", "rang", "at", "java", "lang", "string", "charat", "char", "at", "string", "java:658", "at", "java", "lang", "charact", "codepointat", "code", "point", "at", "charact", "java:4668", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:95", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "text", "translat", "charsequencetransl", "translat", "char", "sequenc", "translat", "charsequencetransl", "java:59", "char", "sequenc", "translat", "at", "org", "apach", "common", "lang3", "stringescapeutil", "escapecsv", "string", "escap", "util", "escap", "csv", "stringescapeutil", "java:556", "string", "escap", "util", "patch", "attach", "method", "affect", "public", "final", "void", "translat", "charsequ", "char", "sequenc", "input", "writer", "out", "throw", "ioexcept", "io", "except"], "B_title": "Don  t count surrogate pairs as we don  t understand code points at the beginning of a. ", "B_clean_title": ["don", "count", "surrog", "pair", "as", "we", "don", "understand", "code", "point", "at", "begin"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "I had left it harwired to say that it was still failing the tableau test .. ", "B_clean_title": ["had", "left", "it", "harwir", "say", "that", "it", "wa", "still", "fail", "tableau", "test"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed a bug in the linear search algorithm. ", "B_clean_title": ["fix", "bug", "linear", "search", "algorithm"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Added missing comment. ", "B_clean_title": ["ad", "miss", "comment"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for cycles. ", "B_clean_title": ["fix", "cycl"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix 141. ", "B_clean_title": ["fix", "141"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix unused variable. ", "B_clean_title": ["fix", "unus", "variabl"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the for loop. ", "B_clean_title": ["fix", "loop"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "removed a couple incorrect lines. ", "B_clean_title": ["remov", "coupl", "incorrect", "line"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Removed patch for row minimization. ", "B_clean_title": ["remov", "patch", "row", "minim"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "added some debug code. ", "B_clean_title": ["ad", "some", "debug", "code"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "@@ add minRatioPositions . add ( i ). ", "B_clean_title": ["add", "minratioposit", "min", "ratio", "posit", "add"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "I had left it harwired to the minRatioSolver. ", "B_clean_title": ["had", "left", "it", "harwir", "minratiosolv", "min", "ratio", "solver"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add incrementIterationsCounter ( ) to the minRow so it can be used for sorting. ", "B_clean_title": ["add", "incrementiterationscount", "increment", "iter", "counter", "minrow", "min", "row", "so", "it", "use", "sort"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Remove a redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "removed some code that was accidentally left in the last commit. ", "B_clean_title": ["remov", "some", "code", "that", "wa", "accident", "left", "last", "commit"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed missing minRow return. ", "B_clean_title": ["fix", "miss", "minrow", "min", "row", "return"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed a bug in SimplexSolver . java. ", "B_clean_title": ["fix", "bug", "simplexsolv", "simplex", "solver", "java"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "removed a redundant check. ", "B_clean_title": ["remov", "redund", "check"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix the bug in SimplexSolver . java. ", "B_clean_title": ["fix", "bug", "simplexsolv", "simplex", "solver", "java"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Improved the linear search code. ", "B_clean_title": ["improv", "linear", "search", "code"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed data error with Math_28_SimplexSolver_t. ", "B_clean_title": ["fix", "data", "error", "math", "28", "simplexsolv", "simplex", "solver"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add some error data. ", "B_clean_title": ["add", "some", "error", "data"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Added fix from patch. ", "B_clean_title": ["ad", "fix", "patch"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Add missing import. Fix minRatioPositions for tableau min row. ", "B_clean_title": ["add", "miss", "import", "fix", "minratioposit", "min", "ratio", "posit", "tableau", "min", "row"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "added fixed patch. ", "B_clean_title": ["ad", "fix", "patch"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Using lower maxUlps value in linear search. ", "B_clean_title": ["lower", "maxulp", "max", "ulp", "valu", "linear", "search"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fixed the minRatioPositions for tableau. ", "B_clean_title": ["fix", "minratioposit", "min", "ratio", "posit", "tableau"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Remove patch from GenProg_Defects4J_Math_28. added patch for minRow = row. Fix NPE in AbstractLinearOptimizer. ", "B_clean_title": ["remov", "patch", "genprog", "defects4j", "math", "28", "gen", "prog", "ad", "patch", "minrow", "min", "row", "row", "fix", "npe", "abstractlinearoptim", "abstract", "linear", "optim"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Updated patch for linear optimization. Fix a merge conflict in LocalizedFormats . getLocalizedString ( ). Missing patch for E3 ( conflict with prev PR ). Removing a minRatioPositions . add ( i ) for now .. Remove patch for 1 . 6 . 1. Remove a redundant patch. ", "B_clean_title": ["updat", "patch", "linear", "optim", "fix", "merg", "conflict", "localizedformat", "local", "format", "getlocalizedstr", "get", "local", "string", "miss", "patch", "e3", "conflict", "prev", "pr", "remov", "minratioposit", "min", "ratio", "posit", "add", "now", "remov", "patch", "remov", "redund", "patch"]},
{"A_title": "Not expected UnboundedSolutionExceptionSimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables. In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and youll get a massive of unbounded exceptions. First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result. The problem itself is well tested by its authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values. What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem. The problem is formulated as min(1*t + 0*L) (for every r-th subject) s.t. -q(r) + QL >= 0 x(r)t - XL >= 0 L >= 0 where  r = 1..R  L =  l(1) l(2) ... l(R)  (vector of R rows and 1 column) Q - coefficients matrix MxR X - coefficients matrix NxR", "A_clean_title": ["not", "expect", "unboundedsolutionexceptionsimplexsolv", "unbound", "solut", "except", "simplex", "solver", "throw", "unboundedsolutionexcept", "unbound", "solut", "except", "when", "tri", "solv", "minim", "linear", "program", "problem", "number", "except", "thrown", "depend", "number", "variabl", "order", "see", "that", "behavior", "simplexsolv", "simplex", "solver", "first", "tri", "run", "junit", "unit", "test", "set", "final", "variabl", "entiti", "count", "that", "will", "give", "almost", "good", "result", "then", "set", "it", "15", "youll", "get", "massiv", "unbound", "except", "first", "iter", "run", "predefin", "set", "input", "data", "which", "solver", "give", "back", "appropri", "result", "problem", "itself", "well", "test", "by", "it", "author", "mathematician", "who", "believ", "know", "what", "they", "develop", "matlab", "10", "no", "unbound", "solut", "same", "rule", "creatnig", "random", "variabl", "valu", "what", "strang", "me", "depend", "number", "unboundedsolutionexcept", "unbound", "solut", "except", "except", "number", "variabl", "problem", "problem", "formul", "as", "min", "everi", "th", "subject", "ql", "xl", "where", "vector", "row", "column", "coeffici", "matrix", "mxr", "mx", "coeffici", "matrix", "nxr", "nx"], "B_title": "Fix missing StringBuilder in getLocalizedString ( ). Remove patch for 1 . 7 . 5. ", "B_clean_title": ["fix", "miss", "stringbuild", "string", "builder", "getlocalizedstr", "get", "local", "string", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix merge conflict for end . add ( field  newdiff ). ", "B_clean_title": ["fix", "merg", "conflict", "end", "add", "field", "newdiff"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix copy / paste error. ", "B_clean_title": ["fix", "copi", "past", "error"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix merge bug in DurationFormatUtils. ", "B_clean_title": ["fix", "merg", "bug", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix typo. ", "B_clean_title": ["fix", "typo"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fixed bug for calendar systems .. ", "B_clean_title": ["fix", "bug", "calendar", "system"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fixed formatting mistake. ", "B_clean_title": ["fix", "format", "mistak"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in DurationFormatUtils. ", "B_clean_title": ["fix", "bug", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove over - aggressive add in DurationFormatUtils. ", "B_clean_title": ["remov", "over", "aggress", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fixed the merge bug in DurationFormatUtils. ", "B_clean_title": ["fix", "merg", "bug", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in duration format utils. Fix bug in duration format. ", "B_clean_title": ["fix", "bug", "durat", "format", "util", "fix", "bug", "durat", "format"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix merge conflict between end and start. ", "B_clean_title": ["fix", "merg", "conflict", "between", "end", "start"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed two - times add ( field  old ). ", "B_clean_title": ["remov", "patch", "remov", "two", "time", "add", "field", "old"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "patch", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > hour. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "hour", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "was asking for M in the format. fix bug. removed patch. ", "B_clean_title": ["wa", "ask", "format", "fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "revert accidently change. ", "B_clean_title": ["revert", "accid", "chang"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for leap year. Add fix for leap year. removed patch. ", "B_clean_title": ["add", "fix", "leap", "year", "add", "fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old test. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "too", "old", "test", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old pattern. Remove patch for day / week. removed patch. ", "B_clean_title": ["fix", "too", "old", "pattern", "remov", "patch", "day", "week", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix duration format mistake. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "durat", "format", "mistak", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore non - calendar days for now .. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "non", "calendar", "day", "now", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove M from the end of the month string. fixed erroneous changes in duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "end", "month", "string", "fix", "erron", "chang", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > hour. Ignore H = 0 ( fix provided by @ rmb938 ). removed patch. ", "B_clean_title": ["fix", "month", "hour", "ignor", "fix", "provid", "by", "rmb938", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "patch", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict in DurationFormatUtils. remove patch. removed patch. ", "B_clean_title": ["fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. Remove accidential modification. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "remov", "accidenti", "modif"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. remove months = = 0. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "month", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H .. removed patch. ", "B_clean_title": ["ignor", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add months / years back. removed patch. ", "B_clean_title": ["add", "month", "year", "back", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. Remove over - aggressive fix. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "over", "aggress", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "typo", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 1796. fix removed minute and year from end of month / year log. removed patch. ", "B_clean_title": ["fix", "1796", "fix", "remov", "minut", "year", "end", "month", "year", "log", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove loop. removed patch. ", "B_clean_title": ["remov", "loop", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for leap year. removed patch. ", "B_clean_title": ["add", "fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed erroneous test case. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "erron", "test", "case", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. Add missing token. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "add", "miss", "token", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix broken ut. removed fixed minute / hours offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "broken", "ut", "remov", "fix", "minut", "hour", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant patch. Add one year to the end of the month in classic duration format. removed patch. ", "B_clean_title": ["remov", "redund", "patch", "add", "one", "year", "end", "month", "classic", "durat", "format", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo in DurationFormatUtils. ", "B_clean_title": ["fix", "typo", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for calendar year in classic pattern. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "calendar", "year", "classic", "pattern", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "was going to fix the build. removed a redundant call to add ( field  value ). ", "B_clean_title": ["wa", "go", "fix", "build", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > hour. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "hour", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore modifier from end - to - end time. Add end of year fix. removed patch. ", "B_clean_title": ["ignor", "modifi", "end", "end", "time", "add", "end", "year", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. removed patch. ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year in definition time. removed patch. ", "B_clean_title": ["fix", "leap", "year", "definit", "time", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. Add fix for leap year. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "add", "fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove the oversampling of the duration format parser. remove patch. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "oversampl", "durat", "format", "parser", "remov", "patch", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. Add end of year fix. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "add", "end", "year", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. Remove redundant patch. removed patch. ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Put back the duration formatUtils until it is fix .. removed a redundant call to add ( field  value ). ", "B_clean_title": ["put", "back", "durat", "formatutil", "format", "util", "until", "it", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. removed fixed minute offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "remov", "fix", "minut", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove months = = 0. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "month", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed EAP. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "eap", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. fix for month - first. fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "fix", "month", "first", "fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove months = = 0. Remove over - aggressive fix. removed patch. ", "B_clean_title": ["remov", "month", "remov", "over", "aggress", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patch for endDate. ", "B_clean_title": ["remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added fix for lost minute / second delay in duration format. removed patch. ", "B_clean_title": ["ad", "fix", "lost", "minut", "second", "delay", "durat", "format", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H . 264 in DurationFormatUtils. removed patch. ", "B_clean_title": ["ignor", "264", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / m in the same month / year definition. Add one year to the end of the month in classic duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "minut", "same", "month", "year", "definit", "add", "one", "year", "end", "month", "classic", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. Remove fixed patch. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "remov", "fix", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add H = > 60. removed patch. ", "B_clean_title": ["add", "60", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed year ending delay. Remove patch for week ending. removed patch. ", "B_clean_title": ["fix", "year", "end", "delay", "remov", "patch", "week", "end", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove years from the duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "year", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing MMS offset for days / week. remove patch. ", "B_clean_title": ["add", "miss", "mm", "offset", "day", "week", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed syntax error. removed patch. ", "B_clean_title": ["remov", "fix", "syntax", "error", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed patch. ", "B_clean_title": ["fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patched duration format utils. removed unnecessary add ( ) in DurationFormatUtils. ", "B_clean_title": ["remov", "patch", "durat", "format", "util", "remov", "unnecessari", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix the issue of not adding M. fixed typo. ", "B_clean_title": ["fix", "issu", "not", "ad", "fix", "typo"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 773. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "773", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. ", "B_clean_title": ["remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add the month value for the duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "month", "valu", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed unnecessary add ( ). ", "B_clean_title": ["remov", "unnecessari", "add"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed patch. ", "B_clean_title": ["remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove loop. fixed syntax error. removed patch. ", "B_clean_title": ["remov", "loop", "fix", "syntax", "error", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove fixed patch. fix bug. ", "B_clean_title": ["remov", "fix", "patch", "fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. remove patch. removed two - times add ( field  old ). ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "patch", "remov", "two", "time", "add", "field", "old"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix broken patch. removed patch. ", "B_clean_title": ["fix", "broken", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed erroneous test. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "erron", "test", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patched minute / hours. removed patch. ", "B_clean_title": ["remov", "patch", "minut", "hour", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed patch. ", "B_clean_title": ["fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix year overflow in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "year", "overflow", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added fix for # 774. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ad", "fix", "774", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H + H in DurationFormatUtils. Added missing minutes. Add missing minutes and hours to fix. fix merge conflict in DurationFormatUtils. fixed merge conflict in DurationFormatUtils. ", "B_clean_title": ["ignor", "durationformatutil", "durat", "format", "util", "ad", "miss", "minut", "add", "miss", "minut", "hour", "fix", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix the bug of teenager year range .. fix removed patch. removed patch. ", "B_clean_title": ["fix", "bug", "teenag", "year", "rang", "fix", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore patterns with wrong value for month / year. remove patch. removed patch. ", "B_clean_title": ["ignor", "pattern", "wrong", "valu", "month", "year", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - first. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "first", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge issue. fix bug. ", "B_clean_title": ["fix", "merg", "issu", "fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. removed fixed minute / hours delay. removed patch. ", "B_clean_title": ["fix", "week", "end", "remov", "fix", "minut", "hour", "delay", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patch for not having minutes in the same time frame. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "patch", "not", "have", "minut", "same", "time", "frame", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year. removed patch. ", "B_clean_title": ["fix", "leap", "year", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 274. Fix format string for years = 0. fix merge conflict resolution. removed unnecessary add ( ). ", "B_clean_title": ["fix", "274", "fix", "format", "string", "year", "fix", "merg", "conflict", "resolut", "remov", "unnecessari", "add"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 434. ", "B_clean_title": ["fix", "434"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for Persian and Urdu language maps # 2019. Remove patch for week ending. removed patch. ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "2019", "remov", "patch", "week", "end", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix removed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed wrong end date. revert accidently change. ", "B_clean_title": ["fix", "wrong", "end", "date", "revert", "accid", "chang"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed for 1 . 5. removed patch. ", "B_clean_title": ["fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. fix removed minute increments. removed patch. ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "fix", "remov", "minut", "increment", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H + H in DurationFormatUtils. remove loop. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "durationformatutil", "durat", "format", "util", "remov", "loop", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. fixed typo in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "fix", "typo", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed minute / hour offset. removed patch. ", "B_clean_title": ["fix", "minut", "hour", "offset", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. fix for leap year in definition time. remove patch. removed patch. ", "B_clean_title": ["fix", "week", "end", "fix", "leap", "year", "definit", "time", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "week", "end", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. ", "B_clean_title": ["fix", "merg", "conflict", "resolut"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing minutes and hours back. Add end of year fix. removed patch. ", "B_clean_title": ["add", "miss", "minut", "hour", "back", "add", "end", "year", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reduce number of days in first month of year. removed a redundant call to add ( field  value ). ", "B_clean_title": ["reduc", "number", "day", "first", "month", "year", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed a bug in the diff script. ", "B_clean_title": ["fix", "bug", "diff", "script"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixedEndDate = fixedStartDate = fixedEndDate. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fixedendd", "fix", "end", "date", "fixedstartd", "fix", "start", "date", "fixedendd", "fix", "end", "date", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hour delay. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split in ISO 8601 duration format. Add the missing seconds as part of the duration format fix. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "iso", "8601", "durat", "format", "add", "miss", "second", "as", "part", "durat", "format", "fix", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed month ending. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "month", "end", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. was going to fix the build. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "week", "end", "wa", "go", "fix", "build", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "leap", "year", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. Add one year to the end of the month in classic duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "add", "one", "year", "end", "month", "classic", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old pattern. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "too", "old", "pattern", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo in DurationFormatUtils. Remove patch for endDate. ", "B_clean_title": ["fix", "typo", "durationformatutil", "durat", "format", "util", "remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. Remove patch for calendar year. ", "B_clean_title": ["fix", "syntax", "error", "remov", "patch", "calendar", "year"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "revert patch. ", "B_clean_title": ["revert", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. removed extraneous line. ", "B_clean_title": ["remov", "patch", "remov", "extran", "line"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. fix merge conflict in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed too - old pattern. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "too", "old", "pattern", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. remove loop. removed patch. ", "B_clean_title": ["fix", "bug", "remov", "loop", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove fixed minute / second mistake. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "second", "mistak", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. Fix years count. removed patch. ", "B_clean_title": ["fix", "week", "end", "fix", "year", "count", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for Persian and Urdu language maps # 283. removed patch. ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "283", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed typo in DurationFormatUtils. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "typo", "durationformatutil", "durat", "format", "util", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix duration format mistake. Remove fixed patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "durat", "format", "mistak", "remov", "fix", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove the oversampling of the duration format parser. fixed merge conflict in DurationFormatUtils. ", "B_clean_title": ["remov", "oversampl", "durat", "format", "parser", "fix", "merg", "conflict", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove the oversampling of the duration format parser. fix bug. ", "B_clean_title": ["remov", "oversampl", "durat", "format", "parser", "fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix removed minute increments. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "remov", "minut", "increment", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove backwards incompatible change. removed patch. ", "B_clean_title": ["remov", "backward", "incompat", "chang", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore modifier from end - to - end time. removed patch. ", "B_clean_title": ["ignor", "modifi", "end", "end", "time", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. Remove patch for minute / second. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "week", "end", "remov", "patch", "minut", "second", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove patch for endDate. ", "B_clean_title": ["remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant patch. removed patch. ", "B_clean_title": ["remov", "redund", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reduce and correct the duration in the case of month - first. fix bug. removed patch. ", "B_clean_title": ["reduc", "correct", "durat", "case", "month", "first", "fix", "bug", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for leap year. fixed syntax error. removed patch. ", "B_clean_title": ["fix", "leap", "year", "fix", "syntax", "error", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add end of month to fix # 33. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "end", "month", "fix", "33", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for Persian and Urdu language maps # 283. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "persian", "urdu", "languag", "map", "283", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed erroneous test. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "erron", "test", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing patch. removed patch. ", "B_clean_title": ["add", "miss", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore minutes / hours in the end of month value. Remove fixed / unused variable. removed patch. ", "B_clean_title": ["ignor", "minut", "hour", "end", "month", "valu", "remov", "fix", "unus", "variabl", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "bug", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict in DurationFormatUtils. removed patch. ", "B_clean_title": ["fix", "merg", "conflict", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H + H in DurationFormatUtils. removed patch. ", "B_clean_title": ["ignor", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H .. remove patch. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "remov", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove loop. reduce HOUR_OF_DAY by one month. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "loop", "reduc", "hour", "day", "by", "one", "month", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed hours  fix from pull request. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "hour", "fix", "pull", "request", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for patch 1833. fixed syntax error. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "patch", "1833", "fix", "syntax", "error", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore H . 264 in DurationFormatUtils. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["ignor", "264", "durationformatutil", "durat", "format", "util", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. Remove over - aggressive fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "over", "aggress", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. fixed month - > year in configuration. Ignore H = 0 ( fix provided by @ rmb938 ). removed unnecessary add ( ) in DurationFormatUtils. ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "fix", "month", "year", "configur", "ignor", "fix", "provid", "by", "rmb938", "remov", "unnecessari", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed year ending. removed fixed minute / hours offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "year", "end", "remov", "fix", "minut", "hour", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add H = > 60. fix for month - first. removed patch. ", "B_clean_title": ["add", "60", "fix", "month", "first", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed syntax error. Remove patch for endDate. ", "B_clean_title": ["remov", "fix", "syntax", "error", "remov", "patch", "enddat", "end", "date"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix ISO 8601 duration format. removed fixed minute / hours delay. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "iso", "8601", "durat", "format", "remov", "fix", "minut", "hour", "delay", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed test for same day / month. fixed syntax error. fixed legitimization. ", "B_clean_title": ["remov", "test", "same", "day", "month", "fix", "syntax", "error", "fix", "legitim"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove patch. revert patch. ", "B_clean_title": ["remov", "patch", "revert", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant code. fixed syntax error in DurationFormatUtils. removed patch. ", "B_clean_title": ["remov", "redund", "code", "fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add hours / minutes to months number. remove minute = 0 ; patch = 0 ;. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "hour", "minut", "month", "number", "remov", "minut", "patch", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix reverseEach. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "reverseeach", "revers", "each", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix duration format mistake. remove minute = 0 ; patch = 0 ;. fixed legitimization. ", "B_clean_title": ["fix", "durat", "format", "mistak", "remov", "minut", "patch", "fix", "legitim"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix disabled patch for minute / hour. removed patch. ", "B_clean_title": ["fix", "disabl", "patch", "minut", "hour", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - first. fixed syntax error. revert patch. ", "B_clean_title": ["fix", "month", "first", "fix", "syntax", "error", "revert", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove redundant patch. Ignore H . 264 in DurationFormatUtils. removed fixed minute offset. removed patch. ", "B_clean_title": ["remov", "redund", "patch", "ignor", "264", "durationformatutil", "durat", "format", "util", "remov", "fix", "minut", "offset", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Ignore modifier from end - to - end time. fix merge conflict resolution. ", "B_clean_title": ["ignor", "modifi", "end", "end", "time", "fix", "merg", "conflict", "resolut"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix week ending. fixed erroneous legacy change. removed patch. ", "B_clean_title": ["fix", "week", "end", "fix", "erron", "legaci", "chang", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split in ISO 8601 duration format. removed patch. ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "iso", "8601", "durat", "format", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hours offset. removed a redundant call to add ( field  value ). ", "B_clean_title": ["remov", "fix", "minut", "hour", "offset", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reduce HOUR_OF_DAY by one month. removed patch. ", "B_clean_title": ["reduc", "hour", "day", "by", "one", "month", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove M from the end of the month estimates. removed unnecessary add ( ) in DurationFormatUtils. ", "B_clean_title": ["remov", "end", "month", "estim", "remov", "unnecessari", "add", "durationformatutil", "durat", "format", "util"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "removed fixed minute / hours delay. removed patch. ", "B_clean_title": ["remov", "fix", "minut", "hour", "delay", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix for month - > year. Remove useless assignment. removed patch. ", "B_clean_title": ["fix", "month", "year", "remov", "useless", "assign", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for month name calculation. Remove fixed minute / hour offset. removed patch. ", "B_clean_title": ["add", "fix", "month", "name", "calcul", "remov", "fix", "minut", "hour", "offset", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove minute = 0 ; patch = > minute. remove patch. ", "B_clean_title": ["remov", "minut", "patch", "minut", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "remove backwards incompatible change. Add missing minutes and hours back. removed patch. ", "B_clean_title": ["remov", "backward", "incompat", "chang", "add", "miss", "minut", "hour", "back", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix disabled loop. removed patch. ", "B_clean_title": ["fix", "disabl", "loop", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix merge conflict resolution. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "merg", "conflict", "resolut", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "I don  t really see a justification for doing a split sentence. removed a redundant call to add ( field  value ). ", "B_clean_title": ["don", "realli", "see", "justif", "do", "split", "sentenc", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "reverse the changes. ", "B_clean_title": ["revers", "chang"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fixed syntax error in DurationFormatUtils. removed patch. ", "B_clean_title": ["fix", "syntax", "error", "durationformatutil", "durat", "format", "util", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add end of year fix. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "end", "year", "fix", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add missing value. removed a redundant call to add ( field  value ). ", "B_clean_title": ["add", "miss", "valu", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added missing minutes to the duration format test. removed patch. ", "B_clean_title": ["ad", "miss", "minut", "durat", "format", "test", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix disabled month value for ISO 8601 duration format. removed a redundant call to add ( field  value ). ", "B_clean_title": ["fix", "disabl", "month", "valu", "iso", "8601", "durat", "format", "remov", "redund", "call", "add", "field", "valu"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Added fix for lost seconds / minutes in DurationFormatUtils. remove patch. removed patch. ", "B_clean_title": ["ad", "fix", "lost", "second", "minut", "durationformatutil", "durat", "format", "util", "remov", "patch", "remov", "patch"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in fix month / end of month .. ", "B_clean_title": ["fix", "bug", "fix", "month", "end", "month"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix bug. ", "B_clean_title": ["fix", "bug"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for leap year. ", "B_clean_title": ["fix", "leap", "year"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix for bug 6841215 - Fix for Persian and Urdu language maps .. ", "B_clean_title": ["fix", "bug", "6841215", "fix", "persian", "urdu", "languag", "map"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Add fix for bug fix. Updated fix for # 443. ", "B_clean_title": ["add", "fix", "bug", "fix", "updat", "fix", "443"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix empty end fix. ", "B_clean_title": ["fix", "empti", "end", "fix"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove years from the duration format. fix # 434. ", "B_clean_title": ["remov", "year", "durat", "format", "fix", "434"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "fix # 435. ", "B_clean_title": ["fix", "435"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Fix bug in fix_defects4J_Lang_63. ", "B_clean_title": ["fix", "bug", "fix", "defects4j", "lang", "63"]},
{"A_title": "DurationFormatUtils returns wrong resultDurationFormatUtils returns wrong result.  oddly it is only when Date is set to Dec 31 2005 The following code will result in a String of -2 which is way off. Ive tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH 31);         cal.set(Calendar.YEAR 2005);         cal.set(Calendar.HOUR_OF_DAY 0);         cal.set(Calendar.MINUTE 0);         cal.set(Calendar.SECOND 0);         cal.set(Calendar.MILLISECOND 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis() System.currentTimeMillis() MM);         System.out.println(result);", "A_clean_title": ["durationformatutil", "durat", "format", "util", "return", "wrong", "resultdurationformatutil", "result", "durat", "format", "util", "return", "wrong", "result", "oddli", "it", "onli", "when", "date", "set", "dec", "31", "2005", "follow", "code", "will", "result", "string", "which", "way", "off", "ive", "test", "against", "calendar", "cal", "calendar", "getinst", "get", "instanc", "cal", "set", "calendar", "month", "calendar", "decemb", "cal", "set", "calendar", "day", "month", "31", "cal", "set", "calendar", "year", "2005", "cal", "set", "calendar", "hour", "day", "cal", "set", "calendar", "minut", "cal", "set", "calendar", "second", "cal", "set", "calendar", "millisecond", "string", "result", "durationformatutil", "formatperiod", "durat", "format", "util", "format", "period", "cal", "gettimeinmilli", "get", "time", "milli", "system", "currenttimemilli", "current", "time", "milli", "mm", "system", "out", "println", "result"], "B_title": "Remove useless assignment. Fix for bug fix. ", "B_clean_title": ["remov", "useless", "assign", "fix", "bug", "fix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing if (. ", "B_clean_title": ["miss"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing closing paren in BooleanUtils. ", "B_clean_title": ["miss", "close", "paren", "booleanutil", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "@@ commented out previous fix. ", "B_clean_title": ["comment", "out", "previou", "fix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed null check. ", "B_clean_title": ["remov", "null", "check"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "don  t compare y  to  y . don  t compare Y  to  Y  ( fixes # 77 ). ", "B_clean_title": ["don", "compar", "don", "compar", "fix", "77"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed y as separator at the end of StringUtils. ", "B_clean_title": ["remov", "as", "separ", "at", "end", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing if (. ", "B_clean_title": ["miss"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Fixed bug in BooleanUtils where empty string is not the case. ", "B_clean_title": ["fix", "bug", "booleanutil", "boolean", "util", "where", "empti", "string", "not", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing if (. ", "B_clean_title": ["miss"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing one if (. ", "B_clean_title": ["miss", "one"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove backslash which prevents overflow from StringUtils. ", "B_clean_title": ["remov", "backslash", "which", "prevent", "overflow", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Handle case when String is empty or null. ", "B_clean_title": ["handl", "case", "when", "string", "empti", "or", "null"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Handle case when String is empty or null. ", "B_clean_title": ["handl", "case", "when", "string", "empti", "or", "null"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Revert previous patch. ", "B_clean_title": ["revert", "previou", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed an issue with BooleanUtils . toBoolean ( ). Removed unnecessary patch. ", "B_clean_title": ["fix", "issu", "booleanutil", "boolean", "util", "toboolean", "boolean", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add patch for StringUtils. ", "B_clean_title": ["add", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed patch for BooleanUtils . toBoolean ( ) .. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "toboolean", "boolean", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string handling. toLowerCase ( ). ", "B_clean_title": ["lowercas", "string", "handl", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Fixed null string handling. Removed unnecessary patch. ", "B_clean_title": ["fix", "null", "string", "handl", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch for true / false match. toLowerCase ( ). ", "B_clean_title": ["remov", "patch", "true", "fals", "match", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in StringUtils. Removed unnecessary if / else .. ", "B_clean_title": ["ad", "miss", "case", "stringutil", "string", "util", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. Removed unnecessary if / else .. ", "B_clean_title": ["add", "null", "check", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added booleanUtils . equalsIgnoreCase ( ). lowercased string to match actual string. ", "B_clean_title": ["ad", "booleanutil", "boolean", "util", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. toLowerCase ( ) removed previous patch. lowercased string to match patch. ", "B_clean_title": ["add", "null", "check", "tolowercas", "lower", "case", "remov", "previou", "patch", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for strings with spaces in the code. lowercased string to match patch. ", "B_clean_title": ["improv", "perform", "string", "space", "code", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove unnecessary booleanUtils patch. Removed unnecessary patch. ", "B_clean_title": ["remov", "unnecessari", "booleanutil", "boolean", "util", "patch", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patched / removed unnecessary boolean utils class. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "remov", "unnecessari", "boolean", "util", "class", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed null string handling. lowercased string to match actual string. ", "B_clean_title": ["fix", "null", "string", "handl", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "BooleanUtils patch for < = >. Removed patch for  true  and  off  .. ", "B_clean_title": ["booleanutil", "boolean", "util", "patch", "remov", "patch", "true", "off"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Updated toBoolean ( ). Removed unnecessary patch. ", "B_clean_title": ["updat", "toboolean", "boolean", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patched code. toLowerCase ( ). ", "B_clean_title": ["remov", "patch", "code", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. remove null check. toLowerCase ( ). ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "null", "check", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for null strings. removed patch for year in BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["improv", "perform", "null", "string", "remov", "patch", "year", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add case for string comparison. lowercased string to match patch. ", "B_clean_title": ["add", "case", "string", "comparison", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for empty strings. Removed unnecessary if / else .. ", "B_clean_title": ["improv", "perform", "empti", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Fixed a bug in BooleanUtils. Remove over - old boolean utils pattern. Removed unnecessary if / else .. ", "B_clean_title": ["fix", "bug", "booleanutil", "boolean", "util", "remov", "over", "old", "boolean", "util", "pattern", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed StringUtils . equalsIgnoreCase. lowercased string to match actual string. ", "B_clean_title": ["fix", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Updated to match String class .. remove patched boolean utils. ", "B_clean_title": ["updat", "match", "string", "class", "remov", "patch", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for Y = > E. lowercase affix. ", "B_clean_title": ["remov", "patch", "lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for Y = > E. lowercased string to match their definition. ", "B_clean_title": ["remov", "patch", "lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed patch from BooleanUtils. remove patch for BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "remov", "patch", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string comparisons. ", "B_clean_title": ["lowercas", "string", "comparison"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for strings with length > = 647. lowercased string to match actual string. ", "B_clean_title": ["improv", "perform", "string", "length", "647", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove patched code. case insensitive match for  true  to false . ", "B_clean_title": ["remov", "patch", "code", "case", "insensit", "match", "true", "fals"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "match regex. ", "B_clean_title": ["match", "regex"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match their definition. ", "B_clean_title": ["lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Remove patch for year in BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "year", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Optimize equalsIgnoreCase. Removed unnecessary if / else .. ", "B_clean_title": ["optim", "equalsignorecas", "equal", "ignor", "case", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. Removed unnecessary if / else .. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed null string handling. lowercased string to match patch. ", "B_clean_title": ["fix", "null", "string", "handl", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ). ", "B_clean_title": ["tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for true in boolean utils. Removed patch for StringUtils. ", "B_clean_title": ["add", "patch", "true", "boolean", "util", "remov", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve matching of empty strings. lowercased string to match patch. ", "B_clean_title": ["improv", "match", "empti", "string", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for year in BooleanUtils. IgnoreCase string  s value .. ", "B_clean_title": ["remov", "patch", "year", "booleanutil", "boolean", "util", "ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ). ", "B_clean_title": ["tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed StringUtils . equalsIgnoreCase. Removed unnecessary if / else .. ", "B_clean_title": ["fix", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed an obsolete equalsIgnoreCase method. Add an exception check for isEmpty ( String ). Removed unnecessary patch. ", "B_clean_title": ["remov", "obsolet", "equalsignorecas", "equal", "ignor", "case", "method", "add", "except", "check", "isempti", "empti", "string", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for null string handling. toLowerCase ( ). ", "B_clean_title": ["add", "patch", "null", "string", "handl", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed empty string handling. lowercased string handling. ", "B_clean_title": ["remov", "empti", "string", "handl", "lowercas", "string", "handl"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add an empty line check. Remove patched code. Removed patch for StringUtils. ", "B_clean_title": ["add", "empti", "line", "check", "remov", "patch", "code", "remov", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase the y string. Removed unnecessary if / else .. ", "B_clean_title": ["tolowercas", "lower", "case", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add case for string  s equalsIgnoreCase. Removed unnecessary patch. ", "B_clean_title": ["add", "case", "string", "equalsignorecas", "equal", "ignor", "case", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "BooleanUtils now uses empty string literals. lowercased string to match patch. ", "B_clean_title": ["booleanutil", "boolean", "util", "now", "use", "empti", "string", "liter", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "ignore isDigit for boolean equals. ", "B_clean_title": ["ignor", "isdigit", "digit", "boolean", "equal"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added ignore case for  off  and  no  .. Removed unnecessary if / else .. ", "B_clean_title": ["ad", "ignor", "case", "off", "no", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for strings with length > = 647. Modified patch for StringUtils . equalsIgnoreCase. remove patched for last char. ", "B_clean_title": ["improv", "perform", "string", "length", "647", "modifi", "patch", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "remov", "patch", "last", "char"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add an exception check for isEmpty ( String ). lowercased string to match patch. ", "B_clean_title": ["add", "except", "check", "isempti", "empti", "string", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased. Removed unnecessary patch. ", "B_clean_title": ["lowercas", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in StringUtils. Removed unnecessary if / else .. ", "B_clean_title": ["ad", "miss", "case", "stringutil", "string", "util", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. patched BooleanUtils. ", "B_clean_title": ["lowercas", "string", "match", "patch", "patch", "booleanutil", "boolean", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. Remove over - aggressive patching of boolean utils. lowercased string to match actual string. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "over", "aggress", "patch", "boolean", "util", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "IgnoreCase Strings. Removed unnecessary if / else .. ", "B_clean_title": ["ignorecas", "ignor", "case", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercase affix. ", "B_clean_title": ["lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for null string comparison. lowercased string comparisons. lowercased string to match patch. ", "B_clean_title": ["add", "patch", "null", "string", "comparison", "lowercas", "string", "comparison", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add patch for null string handling. lowercased string to match patch. ", "B_clean_title": ["add", "patch", "null", "string", "handl", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added patch for  off  and  no  .. toLowerCase ( ). ", "B_clean_title": ["ad", "patch", "off", "no", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. Removed unnecessary patch. ", "B_clean_title": ["add", "null", "check", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "strtolower the string. Removed unnecessary patch. ", "B_clean_title": ["strtolow", "string", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch from source code. lowercased string to match patch. ", "B_clean_title": ["remov", "patch", "sourc", "code", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Corrected a typo in StringUtils. ", "B_clean_title": ["correct", "typo", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed patch for year in BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["remov", "patch", "year", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string handling. ", "B_clean_title": ["lowercas", "string", "handl"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. Added missing case in StringUtils. lowercased string to match actual string. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "ad", "miss", "case", "stringutil", "string", "util", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "isEmpty ( ) = > false. ", "B_clean_title": ["isempti", "empti", "fals"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in BooleanUtils. Removed unnecessary patch. ", "B_clean_title": ["ad", "miss", "case", "booleanutil", "boolean", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Put back previous patch. Removed unnecessary patch. ", "B_clean_title": ["put", "back", "previou", "patch", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for null string matches  note the patch for more readable strings. Removed unnecessary if / else .. ", "B_clean_title": ["improv", "perform", "null", "string", "match", "note", "patch", "more", "readabl", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Removed patch from BooleanUtils. lowercased. Removed unnecessary patch. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "lowercas", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "patched by accident. removed patch for year in BooleanUtils. Removed patch for  true  and  off  .. ", "B_clean_title": ["patch", "by", "accid", "remov", "patch", "year", "booleanutil", "boolean", "util", "remov", "patch", "true", "off"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "strtolower the string. lowercased string to match patch. ", "B_clean_title": ["strtolow", "string", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add an exception if the String is empty ( I am looking at you Dave ). toLowerCase ( ). ", "B_clean_title": ["add", "except", "string", "empti", "am", "look", "at", "you", "dave", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "modified BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["modifi", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string comparisons. ", "B_clean_title": ["lowercas", "string", "comparison"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ) removed previous patch. Removed unnecessary if / else .. ", "B_clean_title": ["tolowercas", "lower", "case", "remov", "previou", "patch", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add exception if String is empty. ", "B_clean_title": ["add", "except", "string", "empti"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Allow null string input. lowercase affix. ", "B_clean_title": ["allow", "null", "string", "input", "lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string comparisons. Removed unnecessary patch. ", "B_clean_title": ["lowercas", "string", "comparison", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added missing case in StringUtils. Removed unnecessary patch. ", "B_clean_title": ["ad", "miss", "case", "stringutil", "string", "util", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "strtolower the string. toLowerCase ( ). ", "B_clean_title": ["strtolow", "string", "tolowercas", "lower", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. lowercased string to match patch. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add missing case. Removed unnecessary patch. ", "B_clean_title": ["add", "miss", "case", "remov", "unnecessari", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Added patch for  true  in StringUtils. lowercase affix. ", "B_clean_title": ["ad", "patch", "true", "stringutil", "string", "util", "lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. removed patched / removed unnecessary booleanUtils properties. lowercased string to match actual string. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "remov", "patch", "remov", "unnecessari", "booleanutil", "boolean", "util", "properti", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "updated BooleanUtils. lowercased string comparisons. ", "B_clean_title": ["updat", "booleanutil", "boolean", "util", "lowercas", "string", "comparison"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "IgnoreCase string  s value .. ", "B_clean_title": ["ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "toLowerCase ( ) matches any string. ", "B_clean_title": ["tolowercas", "lower", "case", "match", "ani", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. lowercased string to match patch. ", "B_clean_title": ["add", "null", "check", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "IgnoreCase string  s value .. ", "B_clean_title": ["ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed String . equalsIgnoreCase. ", "B_clean_title": ["fix", "string", "equalsignorecas", "equal", "ignor", "case"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed null string handling. lowercased string to match patch. ", "B_clean_title": ["fix", "null", "string", "handl", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "I had left it harwired to true  but it was still possible to check string equality. ", "B_clean_title": ["had", "left", "it", "harwir", "true", "but", "it", "wa", "still", "possibl", "check", "string", "equal"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "removed null check. lowercased string to match actual string. ", "B_clean_title": ["remov", "null", "check", "lowercas", "string", "match", "actual", "string"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "improve performance for null / empty strings. Removed unnecessary if / else .. ", "B_clean_title": ["improv", "perform", "null", "empti", "string", "remov", "unnecessari"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "remove patch for BooleanUtils . equals. lowercased string to match their definition. ", "B_clean_title": ["remov", "patch", "booleanutil", "boolean", "util", "equal", "lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Add case for string  s equalsIgnoreCase. lowercased string to match patch. ", "B_clean_title": ["add", "case", "string", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercase affix. ", "B_clean_title": ["lowercas", "affix"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match patch. ", "B_clean_title": ["lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "lowercased string to match their definition. ", "B_clean_title": ["lowercas", "string", "match", "their", "definit"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "add null check. IgnoreCase string  s value .. ", "B_clean_title": ["add", "null", "check", "ignorecas", "ignor", "case", "string", "valu"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "missing patch for null string match. lowercased string to match patch. ", "B_clean_title": ["miss", "patch", "null", "string", "match", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Allow null string input. Removed patch for StringUtils. ", "B_clean_title": ["allow", "null", "string", "input", "remov", "patch", "stringutil", "string", "util"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "fixed StringUtils . equalsIgnoreCase. lowercased string to match patch. ", "B_clean_title": ["fix", "stringutil", "string", "util", "equalsignorecas", "equal", "ignor", "case", "lowercas", "string", "match", "patch"]},
{"A_title": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsExceptionThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException for example with the test: assertEquals(false BooleanUtils.toBoolean(tru)); The end of case 3 should return false. Patch to follow for source and unit test.", "A_clean_title": ["booleanutil", "toboolean", "boolean", "util", "boolean", "invalid", "drop", "thru", "case", "statement", "caus", "stringindexoutofboundsexceptionth", "string", "index", "out", "bound", "except", "method", "booleanutil", "toboolean", "boolean", "util", "boolean", "ha", "case", "statement", "case", "drop", "through", "case", "thi", "caus", "stringindexoutofboundsexcept", "string", "index", "out", "bound", "except", "exampl", "test", "assertequ", "assert", "equal", "fals", "booleanutil", "toboolean", "boolean", "util", "boolean", "tru", "end", "case", "return", "fals", "patch", "follow", "sourc", "unit", "test"], "B_title": "Corrected a typo in StringUtils. ", "B_clean_title": ["correct", "typo", "stringutil", "string", "util"]},
{"A_title": "Dangerous code in PoissonDistributionImplIn the following excerpt from class PoissonDistributionImpl: PoissonDistributionImpl.java     public PoissonDistributionImpl(double p NormalDistribution z)          super();         setNormal(z);         setMean(p);        (1) Overridable methods are called within the constructor. (2) The reference z is stored and modified within the class. Ive encountered problem (1) in several classes while working on issue 348. In those cases in order to remove potential problems I copied/pasted the body of the setter methods inside the constructor but I think that a more elegant solution would be to remove the setters altogether (i.e. make the classes immutable). Problem (2) can also create unexpected behaviour. Is it really necessary to pass the NormalDistribution object; cant it be always created within the class?", "A_clean_title": ["danger", "code", "poissondistributionimplin", "poisson", "distribut", "impl", "follow", "excerpt", "class", "poissondistributionimpl", "poisson", "distribut", "impl", "poissondistributionimpl", "java", "poisson", "distribut", "impl", "public", "poissondistributionimpl", "poisson", "distribut", "impl", "doubl", "normaldistribut", "normal", "distribut", "super", "setnorm", "set", "normal", "setmean", "set", "mean", "overrid", "method", "are", "call", "within", "constructor", "refer", "store", "modifi", "within", "class", "ive", "encount", "problem", "sever", "class", "while", "work", "issu", "348", "those", "case", "order", "remov", "potenti", "problem", "copi", "past", "bodi", "setter", "method", "insid", "constructor", "but", "think", "that", "more", "eleg", "solut", "would", "remov", "setter", "altogeth", "make", "class", "immut", "problem", "also", "creat", "unexpect", "behaviour", "it", "realli", "necessari", "pass", "normaldistribut", "normal", "distribut", "object", "cant", "it", "alway", "creat", "within", "class"], "B_title": "Fixed a bug in PoissonDistributionImpl .. ", "B_clean_title": ["fix", "bug", "poissondistributionimpl", "poisson", "distribut", "impl"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "Fix an issue with TimeSeries . delete ( ) where the start < end would throw an exception. Fix bug in TimeSeries . clone. ", "B_clean_title": ["fix", "issu", "timeseri", "time", "seri", "delet", "where", "start", "end", "would", "throw", "except", "fix", "bug", "timeseri", "time", "seri", "clone"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "fix a bug in TimeSeries . clone. ", "B_clean_title": ["fix", "bug", "timeseri", "time", "seri", "clone"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "Fix bug in delete ( ). ", "B_clean_title": ["fix", "bug", "delet"]},
{"A_title": "cloning of TimeSeriesIts just a minor bug!  When I clone a TimeSeries which has no items I get an IllegalArgumentException (Requires start <= end). But I dont think the user should be responsible for checking whether the TimeSeries has any items or not.", "A_clean_title": ["clone", "timeseriesit", "time", "seri", "it", "just", "minor", "bug", "when", "clone", "timeseri", "time", "seri", "which", "ha", "no", "item", "get", "illegalargumentexcept", "illeg", "argument", "except", "requir", "start", "end", "but", "dont", "think", "user", "respons", "check", "whether", "timeseri", "time", "seri", "ha", "ani", "item", "or", "not"], "B_title": "Fixed a bug with not throwing the clone exception. ", "B_clean_title": ["fix", "bug", "not", "throw", "clone", "except"]}]